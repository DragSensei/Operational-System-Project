
obj/kern/kernel:     file format elf32-i386


Disassembly of section .text:

f0100000 <start_of_kernel-0xc>:
.long MULTIBOOT_HEADER_FLAGS
.long CHECKSUM

.globl		start_of_kernel
start_of_kernel:
	movw	$0x1234,0x472			# warm boot
f0100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
f0100006:	00 00                	add    %al,(%eax)
f0100008:	fb                   	sti    
f0100009:	4f                   	dec    %edi
f010000a:	52                   	push   %edx
f010000b:	e4 66                	in     $0x66,%al

f010000c <start_of_kernel>:
f010000c:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472
f0100013:	34 12 

	# Establish our own GDT in place of the boot loader's temporary GDT.
	lgdt	RELOC(mygdtdesc)		# load descriptor table
f0100015:	0f 01 15 18 f0 17 00 	lgdtl  0x17f018

	# Immediately reload all segment registers (including CS!)
	# with segment selectors from the new GDT.
	movl	$DATA_SEL, %eax			# Data segment selector
f010001c:	b8 10 00 00 00       	mov    $0x10,%eax
	movw	%ax,%ds				# -> DS: Data Segment
f0100021:	8e d8                	mov    %eax,%ds
	movw	%ax,%es				# -> ES: Extra Segment
f0100023:	8e c0                	mov    %eax,%es
	movw	%ax,%ss				# -> SS: Stack Segment
f0100025:	8e d0                	mov    %eax,%ss
	ljmp	$CODE_SEL,$relocated		# reload CS by jumping
f0100027:	ea 2e 00 10 f0 08 00 	ljmp   $0x8,$0xf010002e

f010002e <relocated>:
relocated:

	# Clear the frame pointer register (EBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movl	$0x0,%ebp			# nuke frame pointer
f010002e:	bd 00 00 00 00       	mov    $0x0,%ebp

    # Leave a few words on the stack for the user trap frame
	#2024: this line is changed since the trapframe is move to the user kernel stack of each process
	#movl	$(ptr_stack_top-SIZEOF_STRUCT_TRAPFRAME),%esp
	movl	$(ptr_stack_top),%esp
f0100033:	bc 00 f0 17 f0       	mov    $0xf017f000,%esp

	# now to C code
	call	FOS_initialize
f0100038:	e8 10 00 00 00       	call   f010004d <FOS_initialize>

f010003d <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
f010003d:	eb fe                	jmp    f010003d <spin>

f010003f <set_uheap_strategy>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;
/*2025*/ //Replaced by setter & getter function
static inline void set_uheap_strategy(uint32 strategy){_UHeapPlacementStrategy = strategy;}
f010003f:	55                   	push   %ebp
f0100040:	89 e5                	mov    %esp,%ebp
f0100042:	8b 45 08             	mov    0x8(%ebp),%eax
f0100045:	a3 e8 6a 85 f0       	mov    %eax,0xf0856ae8
f010004a:	90                   	nop
f010004b:	5d                   	pop    %ebp
f010004c:	c3                   	ret    

f010004d <FOS_initialize>:
//=======================================

//First ever function called in FOS kernel
extern bool __autograde__ ;
void FOS_initialize()
{
f010004d:	55                   	push   %ebp
f010004e:	89 e5                	mov    %esp,%ebp
f0100050:	57                   	push   %edi
f0100051:	56                   	push   %esi
f0100052:	53                   	push   %ebx
f0100053:	81 ec 2c 20 00 00    	sub    $0x202c,%esp
	//cprintf("*	1) Global data (BSS) section...");
	{
		// Before doing anything else,
		// clear the uninitialized global data (BSS) section of our program, from start_of_uninitialized_data_section to end_of_kernel
		// This ensures that all static/global variables start with zero value.
		memset(start_of_uninitialized_data_section, 0, end_of_kernel - start_of_uninitialized_data_section);
f0100059:	ba d0 d6 87 f0       	mov    $0xf087d6d0,%edx
f010005e:	b8 3c 59 81 f0       	mov    $0xf081593c,%eax
f0100063:	29 c2                	sub    %eax,%edx
f0100065:	89 d0                	mov    %edx,%eax
f0100067:	83 ec 04             	sub    $0x4,%esp
f010006a:	50                   	push   %eax
f010006b:	6a 00                	push   $0x0
f010006d:	68 3c 59 81 f0       	push   $0xf081593c
f0100072:	e8 f2 ab 01 00       	call   f011ac69 <memset>
f0100077:	83 c4 10             	add    $0x10,%esp
	//cprintf("[DONE]\n");

	{
		// Initialize the console.
		// Can't call cprintf until after we do this!
		cons_init();
f010007a:	e8 46 19 00 00       	call   f01019c5 <cons_init>
		//print welcome message
		print_welcome_message();
f010007f:	e8 b2 0d 00 00       	call   f0100e36 <print_welcome_message>
	}

	cprintf("\n********************************************************************\n");
f0100084:	83 ec 0c             	sub    $0xc,%esp
f0100087:	68 20 bb 11 f0       	push   $0xf011bb20
f010008c:	e8 cb 1a 00 00       	call   f0101b5c <cprintf>
f0100091:	83 c4 10             	add    $0x10,%esp
	cprintf("* INITIALIZATIONS:\n");
f0100094:	83 ec 0c             	sub    $0xc,%esp
f0100097:	68 67 bb 11 f0       	push   $0xf011bb67
f010009c:	e8 bb 1a 00 00       	call   f0101b5c <cprintf>
f01000a1:	83 c4 10             	add    $0x10,%esp
	cprintf("*=================\n");
f01000a4:	83 ec 0c             	sub    $0xc,%esp
f01000a7:	68 7b bb 11 f0       	push   $0xf011bb7b
f01000ac:	e8 ab 1a 00 00       	call   f0101b5c <cprintf>
f01000b1:	83 c4 10             	add    $0x10,%esp

	cprintf("* 1) CPU...");
f01000b4:	83 ec 0c             	sub    $0xc,%esp
f01000b7:	68 8f bb 11 f0       	push   $0xf011bb8f
f01000bc:	e8 9b 1a 00 00       	call   f0101b5c <cprintf>
f01000c1:	83 c4 10             	add    $0x10,%esp
	{
		//Initialize the Main CPU
		cpu_init(0);
f01000c4:	83 ec 0c             	sub    $0xc,%esp
f01000c7:	6a 00                	push   $0x0
f01000c9:	e8 ac 7e 00 00       	call   f0107f7a <cpu_init>
f01000ce:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("[DONE]\n");
f01000d1:	83 ec 0c             	sub    $0xc,%esp
f01000d4:	68 9b bb 11 f0       	push   $0xf011bb9b
f01000d9:	e8 7e 1a 00 00       	call   f0101b5c <cprintf>
f01000de:	83 c4 10             	add    $0x10,%esp

	cprintf("* 2) MEMORY:\n");
f01000e1:	83 ec 0c             	sub    $0xc,%esp
f01000e4:	68 a3 bb 11 f0       	push   $0xf011bba3
f01000e9:	e8 6e 1a 00 00       	call   f0101b5c <cprintf>
f01000ee:	83 c4 10             	add    $0x10,%esp
	{
		detect_memory();
f01000f1:	e8 ef 87 00 00       	call   f01088e5 <detect_memory>
		initialize_kernel_VM();
f01000f6:	e8 8f 83 00 00       	call   f010848a <initialize_kernel_VM>
		initialize_paging();
f01000fb:	e8 4e 8b 00 00       	call   f0108c4e <initialize_paging>
#if USE_KHEAP
		kheap_init();
f0100100:	e8 75 99 00 00       	call   f0109a7a <kheap_init>
		sharing_init();
f0100105:	e8 aa 97 00 00       	call   f01098b4 <sharing_init>
#endif
		fault_handler_init();
f010010a:	e8 14 f8 00 00       	call   f010f923 <fault_handler_init>
		set_uheap_strategy(UHP_PLACE_CUSTOMFIT);
f010010f:	83 ec 0c             	sub    $0xc,%esp
f0100112:	6a 05                	push   $0x5
f0100114:	e8 26 ff ff ff       	call   f010003f <set_uheap_strategy>
f0100119:	83 c4 10             	add    $0x10,%esp
	}
	//cprintf("* [DONE]\n");

	cprintf("* 3) DISK...");
f010011c:	83 ec 0c             	sub    $0xc,%esp
f010011f:	68 b1 bb 11 f0       	push   $0xf011bbb1
f0100124:	e8 33 1a 00 00       	call   f0101b5c <cprintf>
f0100129:	83 c4 10             	add    $0x10,%esp
	{
		ide_init();
f010012c:	e8 88 b1 01 00       	call   f011b2b9 <ide_init>
	}
	cprintf("[DONE]\n");
f0100131:	83 ec 0c             	sub    $0xc,%esp
f0100134:	68 9b bb 11 f0       	push   $0xf011bb9b
f0100139:	e8 1e 1a 00 00       	call   f0101b5c <cprintf>
f010013e:	83 c4 10             	add    $0x10,%esp

	cprintf("* 4) USER ENVs...");
f0100141:	83 ec 0c             	sub    $0xc,%esp
f0100144:	68 be bb 11 f0       	push   $0xf011bbbe
f0100149:	e8 0e 1a 00 00       	call   f0101b5c <cprintf>
f010014e:	83 c4 10             	add    $0x10,%esp
	{
		env_init();
f0100151:	e8 70 ab 00 00       	call   f010acc6 <env_init>
		ts_init();
f0100156:	e8 61 cd 00 00       	call   f010cebc <ts_init>
	}
	cprintf("[DONE]\n");
f010015b:	83 ec 0c             	sub    $0xc,%esp
f010015e:	68 9b bb 11 f0       	push   $0xf011bb9b
f0100163:	e8 f4 19 00 00       	call   f0101b5c <cprintf>
f0100168:	83 c4 10             	add    $0x10,%esp

	cprintf("* 5) PROGRAMMABLE INTERRUPT CONTROLLER:\n");
f010016b:	83 ec 0c             	sub    $0xc,%esp
f010016e:	68 d0 bb 11 f0       	push   $0xf011bbd0
f0100173:	e8 e4 19 00 00       	call   f0101b5c <cprintf>
f0100178:	83 c4 10             	add    $0x10,%esp
	{
		pic_init();
f010017b:	e8 e6 7a 00 00       	call   f0107c66 <pic_init>
		cprintf("*	PIC is initialized\n");
f0100180:	83 ec 0c             	sub    $0xc,%esp
f0100183:	68 f9 bb 11 f0       	push   $0xf011bbf9
f0100188:	e8 cf 19 00 00       	call   f0101b5c <cprintf>
f010018d:	83 c4 10             	add    $0x10,%esp
		//Enable Clock Interrupt
		irq_clear_mask(0);
f0100190:	83 ec 0c             	sub    $0xc,%esp
f0100193:	6a 00                	push   $0x0
f0100195:	e8 be 7c 00 00       	call   f0107e58 <irq_clear_mask>
f010019a:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ0 (Clock): is Enabled\n");
f010019d:	83 ec 0c             	sub    $0xc,%esp
f01001a0:	68 0f bc 11 f0       	push   $0xf011bc0f
f01001a5:	e8 b2 19 00 00       	call   f0101b5c <cprintf>
f01001aa:	83 c4 10             	add    $0x10,%esp
		//Enable KB Interrupt
		irq_clear_mask(1);
f01001ad:	83 ec 0c             	sub    $0xc,%esp
f01001b0:	6a 01                	push   $0x1
f01001b2:	e8 a1 7c 00 00       	call   f0107e58 <irq_clear_mask>
f01001b7:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ1 (Keyboard): is Enabled\n");
f01001ba:	83 ec 0c             	sub    $0xc,%esp
f01001bd:	68 2c bc 11 f0       	push   $0xf011bc2c
f01001c2:	e8 95 19 00 00       	call   f0101b5c <cprintf>
f01001c7:	83 c4 10             	add    $0x10,%esp
		//Enable COM1 Interrupt
		irq_clear_mask(4);
f01001ca:	83 ec 0c             	sub    $0xc,%esp
f01001cd:	6a 04                	push   $0x4
f01001cf:	e8 84 7c 00 00       	call   f0107e58 <irq_clear_mask>
f01001d4:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ4 (COM1): is Enabled\n");
f01001d7:	83 ec 0c             	sub    $0xc,%esp
f01001da:	68 4b bc 11 f0       	push   $0xf011bc4b
f01001df:	e8 78 19 00 00       	call   f0101b5c <cprintf>
f01001e4:	83 c4 10             	add    $0x10,%esp
		//Enable Primary ATA Hard Disk Interrupt
		irq_clear_mask(14);
f01001e7:	83 ec 0c             	sub    $0xc,%esp
f01001ea:	6a 0e                	push   $0xe
f01001ec:	e8 67 7c 00 00       	call   f0107e58 <irq_clear_mask>
f01001f1:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ14 (Primary ATA Hard Disk): is Enabled\n");
f01001f4:	83 ec 0c             	sub    $0xc,%esp
f01001f7:	68 68 bc 11 f0       	push   $0xf011bc68
f01001fc:	e8 5b 19 00 00       	call   f0101b5c <cprintf>
f0100201:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("* 6) SCHEDULER & MULTI-TASKING:\n");
f0100204:	83 ec 0c             	sub    $0xc,%esp
f0100207:	68 98 bc 11 f0       	push   $0xf011bc98
f010020c:	e8 4b 19 00 00       	call   f0101b5c <cprintf>
f0100211:	83 c4 10             	add    $0x10,%esp
	{
		kclock_init();
f0100214:	e8 40 59 00 00       	call   f0105b59 <kclock_init>
		sched_init() ;
f0100219:	e8 c5 74 00 00       	call   f01076e3 <sched_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 7) ESP to SCHED KERN STACK:\n");
f010021e:	83 ec 0c             	sub    $0xc,%esp
f0100221:	68 bc bc 11 f0       	push   $0xf011bcbc
f0100226:	e8 31 19 00 00       	call   f0101b5c <cprintf>
f010022b:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f010022e:	89 e0                	mov    %esp,%eax
f0100230:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return esp;
f0100233:	8b 45 d8             	mov    -0x28(%ebp),%eax
	{
		//Relocate SP to its corresponding location in the specific stack area below KERN_BASE (SCHD_KERN_STACK_TOP)
		uint32 old_sp = read_esp();
f0100236:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		uint32 sp_offset = (uint32)ptr_stack_top - old_sp ;
f0100239:	b8 00 f0 17 f0       	mov    $0xf017f000,%eax
f010023e:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f0100241:	89 45 e0             	mov    %eax,-0x20(%ebp)
		uint32 new_sp = KERN_STACK_TOP - sp_offset;
f0100244:	b8 00 00 c0 ef       	mov    $0xefc00000,%eax
f0100249:	2b 45 e0             	sub    -0x20(%ebp),%eax
f010024c:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010024f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0100252:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0100255:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0100258:	89 c4                	mov    %eax,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f010025a:	89 e0                	mov    %esp,%eax
f010025c:	89 45 d0             	mov    %eax,-0x30(%ebp)
        return esp;
f010025f:	8b 45 d0             	mov    -0x30(%ebp),%eax
		write_esp(new_sp);
		cprintf("*	old SP = %x - updated SP = %x\n", old_sp, read_esp());
f0100262:	83 ec 04             	sub    $0x4,%esp
f0100265:	50                   	push   %eax
f0100266:	ff 75 e4             	pushl  -0x1c(%ebp)
f0100269:	68 dc bc 11 f0       	push   $0xf011bcdc
f010026e:	e8 e9 18 00 00       	call   f0101b5c <cprintf>
f0100273:	83 c4 10             	add    $0x10,%esp
	}
	//cprintf("* [DONE]\n");
	cprintf("********************************************************************\n");
f0100276:	83 ec 0c             	sub    $0xc,%esp
f0100279:	68 00 bd 11 f0       	push   $0xf011bd00
f010027e:	e8 d9 18 00 00       	call   f0101b5c <cprintf>
f0100283:	83 c4 10             	add    $0x10,%esp

	// start the kernel command prompt.
	while (1==1)
	{
		cprintf("\nWelcome to the FOS kernel command prompt!\n");
f0100286:	83 ec 0c             	sub    $0xc,%esp
f0100289:	68 48 bd 11 f0       	push   $0xf011bd48
f010028e:	e8 c9 18 00 00       	call   f0101b5c <cprintf>
f0100293:	83 c4 10             	add    $0x10,%esp
		cprintf("Type 'help' for a list of commands.\n");
f0100296:	83 ec 0c             	sub    $0xc,%esp
f0100299:	68 74 bd 11 f0       	push   $0xf011bd74
f010029e:	e8 b9 18 00 00       	call   f0101b5c <cprintf>
f01002a3:	83 c4 10             	add    $0x10,%esp
		if (__autograde__)
f01002a6:	a1 20 f0 17 f0       	mov    0xf017f020,%eax
f01002ab:	85 c0                	test   %eax,%eax
f01002ad:	0f 84 7e 0b 00 00    	je     f0100e31 <FOS_initialize+0xde4>
			/*CHECK THE FOLLOWING:
			 * 1) time of each test
			 * 2) "unhandled trap in" message
			 */

			cprintf("\nPROJECT Automatic testing is STARTED...\n") ;
f01002b3:	83 ec 0c             	sub    $0xc,%esp
f01002b6:	68 9c bd 11 f0       	push   $0xf011bd9c
f01002bb:	e8 9c 18 00 00       	call   f0101b5c <cprintf>
f01002c0:	83 c4 10             	add    $0x10,%esp

			//TEST#1: DYNAMIC ALLOCATOR
			{
				char cmd1[BUFLEN] = "tst dynalloc init";
f01002c3:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f01002c9:	bb ec bd 11 f0       	mov    $0xf011bdec,%ebx
f01002ce:	ba 12 00 00 00       	mov    $0x12,%edx
f01002d3:	89 c7                	mov    %eax,%edi
f01002d5:	89 de                	mov    %ebx,%esi
f01002d7:	89 d1                	mov    %edx,%ecx
f01002d9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01002db:	8d 95 e2 ef ff ff    	lea    -0x101e(%ebp),%edx
f01002e1:	b9 ee 03 00 00       	mov    $0x3ee,%ecx
f01002e6:	b0 00                	mov    $0x0,%al
f01002e8:	89 d7                	mov    %edx,%edi
f01002ea:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd2[BUFLEN] = "tst dynalloc alloc";
f01002ec:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f01002f2:	bb ec c1 11 f0       	mov    $0xf011c1ec,%ebx
f01002f7:	ba 13 00 00 00       	mov    $0x13,%edx
f01002fc:	89 c7                	mov    %eax,%edi
f01002fe:	89 de                	mov    %ebx,%esi
f0100300:	89 d1                	mov    %edx,%ecx
f0100302:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100304:	8d 95 e3 f3 ff ff    	lea    -0xc1d(%ebp),%edx
f010030a:	b9 ed 03 00 00       	mov    $0x3ed,%ecx
f010030f:	b0 00                	mov    $0x0,%al
f0100311:	89 d7                	mov    %edx,%edi
f0100313:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd3[BUFLEN] = "tst dynalloc free";
f0100315:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f010031b:	bb ec c5 11 f0       	mov    $0xf011c5ec,%ebx
f0100320:	ba 12 00 00 00       	mov    $0x12,%edx
f0100325:	89 c7                	mov    %eax,%edi
f0100327:	89 de                	mov    %ebx,%esi
f0100329:	89 d1                	mov    %edx,%ecx
f010032b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010032d:	8d 95 e2 f7 ff ff    	lea    -0x81e(%ebp),%edx
f0100333:	b9 ee 03 00 00       	mov    $0x3ee,%ecx
f0100338:	b0 00                	mov    $0x0,%al
f010033a:	89 d7                	mov    %edx,%edi
f010033c:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd4[BUFLEN] = "tst dynalloc realloc";
f010033e:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f0100344:	bb ec c9 11 f0       	mov    $0xf011c9ec,%ebx
f0100349:	ba 15 00 00 00       	mov    $0x15,%edx
f010034e:	89 c7                	mov    %eax,%edi
f0100350:	89 de                	mov    %ebx,%esi
f0100352:	89 d1                	mov    %edx,%ecx
f0100354:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100356:	8d 95 e5 fb ff ff    	lea    -0x41b(%ebp),%edx
f010035c:	b9 eb 03 00 00       	mov    $0x3eb,%ecx
f0100361:	b0 00                	mov    $0x0,%al
f0100363:	89 d7                	mov    %edx,%edi
f0100365:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd4);
			}
			//TEST#2: KERNEL HEAP [PARTIAL GRADING]
			{
				char cmd1[BUFLEN] = "tst kheap CF kmalloc blk";
f0100367:	8d 85 d0 df ff ff    	lea    -0x2030(%ebp),%eax
f010036d:	bb ec cd 11 f0       	mov    $0xf011cdec,%ebx
f0100372:	ba 19 00 00 00       	mov    $0x19,%edx
f0100377:	89 c7                	mov    %eax,%edi
f0100379:	89 de                	mov    %ebx,%esi
f010037b:	89 d1                	mov    %edx,%ecx
f010037d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010037f:	8d 95 e9 df ff ff    	lea    -0x2017(%ebp),%edx
f0100385:	b9 e7 03 00 00       	mov    $0x3e7,%ecx
f010038a:	b0 00                	mov    $0x0,%al
f010038c:	89 d7                	mov    %edx,%edi
f010038e:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd2[BUFLEN] = "tst kheap CF kmalloc page";
f0100390:	8d 85 d0 e3 ff ff    	lea    -0x1c30(%ebp),%eax
f0100396:	bb ec d1 11 f0       	mov    $0xf011d1ec,%ebx
f010039b:	ba 1a 00 00 00       	mov    $0x1a,%edx
f01003a0:	89 c7                	mov    %eax,%edi
f01003a2:	89 de                	mov    %ebx,%esi
f01003a4:	89 d1                	mov    %edx,%ecx
f01003a6:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01003a8:	8d 95 ea e3 ff ff    	lea    -0x1c16(%ebp),%edx
f01003ae:	b9 e6 03 00 00       	mov    $0x3e6,%ecx
f01003b3:	b0 00                	mov    $0x0,%al
f01003b5:	89 d7                	mov    %edx,%edi
f01003b7:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd3[BUFLEN] = "tst kheap CF kmalloc both";
f01003b9:	8d 85 d0 e7 ff ff    	lea    -0x1830(%ebp),%eax
f01003bf:	bb ec d5 11 f0       	mov    $0xf011d5ec,%ebx
f01003c4:	ba 1a 00 00 00       	mov    $0x1a,%edx
f01003c9:	89 c7                	mov    %eax,%edi
f01003cb:	89 de                	mov    %ebx,%esi
f01003cd:	89 d1                	mov    %edx,%ecx
f01003cf:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01003d1:	8d 95 ea e7 ff ff    	lea    -0x1816(%ebp),%edx
f01003d7:	b9 e6 03 00 00       	mov    $0x3e6,%ecx
f01003dc:	b0 00                	mov    $0x0,%al
f01003de:	89 d7                	mov    %edx,%edi
f01003e0:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd4[BUFLEN] = "tst kheap CF kfree blk";
f01003e2:	8d 85 d0 eb ff ff    	lea    -0x1430(%ebp),%eax
f01003e8:	bb ec d9 11 f0       	mov    $0xf011d9ec,%ebx
f01003ed:	ba 17 00 00 00       	mov    $0x17,%edx
f01003f2:	89 c7                	mov    %eax,%edi
f01003f4:	89 de                	mov    %ebx,%esi
f01003f6:	89 d1                	mov    %edx,%ecx
f01003f8:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01003fa:	8d 95 e7 eb ff ff    	lea    -0x1419(%ebp),%edx
f0100400:	b9 e9 03 00 00       	mov    $0x3e9,%ecx
f0100405:	b0 00                	mov    $0x0,%al
f0100407:	89 d7                	mov    %edx,%edi
f0100409:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd5[BUFLEN] = "tst kheap CF kfree page";
f010040b:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f0100411:	bb ec dd 11 f0       	mov    $0xf011ddec,%ebx
f0100416:	ba 06 00 00 00       	mov    $0x6,%edx
f010041b:	89 c7                	mov    %eax,%edi
f010041d:	89 de                	mov    %ebx,%esi
f010041f:	89 d1                	mov    %edx,%ecx
f0100421:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100423:	8d 95 e8 ef ff ff    	lea    -0x1018(%ebp),%edx
f0100429:	b9 fa 00 00 00       	mov    $0xfa,%ecx
f010042e:	b8 00 00 00 00       	mov    $0x0,%eax
f0100433:	89 d7                	mov    %edx,%edi
f0100435:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd6[BUFLEN] = "tst kheap CF kfree both";
f0100437:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f010043d:	bb ec e1 11 f0       	mov    $0xf011e1ec,%ebx
f0100442:	ba 06 00 00 00       	mov    $0x6,%edx
f0100447:	89 c7                	mov    %eax,%edi
f0100449:	89 de                	mov    %ebx,%esi
f010044b:	89 d1                	mov    %edx,%ecx
f010044d:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010044f:	8d 95 e8 f3 ff ff    	lea    -0xc18(%ebp),%edx
f0100455:	b9 fa 00 00 00       	mov    $0xfa,%ecx
f010045a:	b8 00 00 00 00       	mov    $0x0,%eax
f010045f:	89 d7                	mov    %edx,%edi
f0100461:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd7[BUFLEN] = "tst kheap kvirtaddr";
f0100463:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100469:	bb ec e5 11 f0       	mov    $0xf011e5ec,%ebx
f010046e:	ba 05 00 00 00       	mov    $0x5,%edx
f0100473:	89 c7                	mov    %eax,%edi
f0100475:	89 de                	mov    %ebx,%esi
f0100477:	89 d1                	mov    %edx,%ecx
f0100479:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010047b:	8d 95 e4 f7 ff ff    	lea    -0x81c(%ebp),%edx
f0100481:	b9 fb 00 00 00       	mov    $0xfb,%ecx
f0100486:	b8 00 00 00 00       	mov    $0x0,%eax
f010048b:	89 d7                	mov    %edx,%edi
f010048d:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd8[BUFLEN] = "tst kheap kphysaddr";
f010048f:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f0100495:	bb ec e9 11 f0       	mov    $0xf011e9ec,%ebx
f010049a:	ba 05 00 00 00       	mov    $0x5,%edx
f010049f:	89 c7                	mov    %eax,%edi
f01004a1:	89 de                	mov    %ebx,%esi
f01004a3:	89 d1                	mov    %edx,%ecx
f01004a5:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01004a7:	8d 95 e4 fb ff ff    	lea    -0x41c(%ebp),%edx
f01004ad:	b9 fb 00 00 00       	mov    $0xfb,%ecx
f01004b2:	b8 00 00 00 00       	mov    $0x0,%eax
f01004b7:	89 d7                	mov    %edx,%edi
f01004b9:	f3 ab                	rep stos %eax,%es:(%edi)
				//execute_command(cmd8);
			}
			//TEST#3: FAULT HANDLER I [PARTIAL GRADING]
			{
				char cmd1[BUFLEN] = "run tia 15";
f01004bb:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f01004c1:	bb ec ed 11 f0       	mov    $0xf011edec,%ebx
f01004c6:	ba 0b 00 00 00       	mov    $0xb,%edx
f01004cb:	89 c7                	mov    %eax,%edi
f01004cd:	89 de                	mov    %ebx,%esi
f01004cf:	89 d1                	mov    %edx,%ecx
f01004d1:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01004d3:	8d 95 db f7 ff ff    	lea    -0x825(%ebp),%edx
f01004d9:	b9 f5 03 00 00       	mov    $0x3f5,%ecx
f01004de:	b0 00                	mov    $0x0,%al
f01004e0:	89 d7                	mov    %edx,%edi
f01004e2:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd2[BUFLEN] = "run tpp 20";
f01004e4:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f01004ea:	bb ec f1 11 f0       	mov    $0xf011f1ec,%ebx
f01004ef:	ba 0b 00 00 00       	mov    $0xb,%edx
f01004f4:	89 c7                	mov    %eax,%edi
f01004f6:	89 de                	mov    %ebx,%esi
f01004f8:	89 d1                	mov    %edx,%ecx
f01004fa:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01004fc:	8d 95 db fb ff ff    	lea    -0x425(%ebp),%edx
f0100502:	b9 f5 03 00 00       	mov    $0x3f5,%ecx
f0100507:	b0 00                	mov    $0x0,%al
f0100509:	89 d7                	mov    %edx,%edi
f010050b:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd2);
			}
			//TEST: FAULT HANDLER II [OPTIMAL] 	[10 sec]
			{
				char cmd0[BUFLEN] = "optimal";
f010050d:	c7 85 d0 ef ff ff 6f 	movl   $0x6974706f,-0x1030(%ebp)
f0100514:	70 74 69 
f0100517:	c7 85 d4 ef ff ff 6d 	movl   $0x6c616d,-0x102c(%ebp)
f010051e:	61 6c 00 
f0100521:	8d 95 d8 ef ff ff    	lea    -0x1028(%ebp),%edx
f0100527:	b9 fe 00 00 00       	mov    $0xfe,%ecx
f010052c:	b8 00 00 00 00       	mov    $0x0,%eax
f0100531:	89 d7                	mov    %edx,%edi
f0100533:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd1[BUFLEN] = "run toptimal1 11";
f0100535:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f010053b:	bb ec f5 11 f0       	mov    $0xf011f5ec,%ebx
f0100540:	ba 11 00 00 00       	mov    $0x11,%edx
f0100545:	89 c7                	mov    %eax,%edi
f0100547:	89 de                	mov    %ebx,%esi
f0100549:	89 d1                	mov    %edx,%ecx
f010054b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010054d:	8d 95 e1 f3 ff ff    	lea    -0xc1f(%ebp),%edx
f0100553:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f0100558:	b0 00                	mov    $0x0,%al
f010055a:	89 d7                	mov    %edx,%edi
f010055c:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd2[BUFLEN] = "run toptimal2 11";
f010055e:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100564:	bb ec f9 11 f0       	mov    $0xf011f9ec,%ebx
f0100569:	ba 11 00 00 00       	mov    $0x11,%edx
f010056e:	89 c7                	mov    %eax,%edi
f0100570:	89 de                	mov    %ebx,%esi
f0100572:	89 d1                	mov    %edx,%ecx
f0100574:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100576:	8d 95 e1 f7 ff ff    	lea    -0x81f(%ebp),%edx
f010057c:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f0100581:	b0 00                	mov    $0x0,%al
f0100583:	89 d7                	mov    %edx,%edi
f0100585:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd3[BUFLEN] = "run toptimal3 11";
f0100587:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f010058d:	bb ec fd 11 f0       	mov    $0xf011fdec,%ebx
f0100592:	ba 11 00 00 00       	mov    $0x11,%edx
f0100597:	89 c7                	mov    %eax,%edi
f0100599:	89 de                	mov    %ebx,%esi
f010059b:	89 d1                	mov    %edx,%ecx
f010059d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010059f:	8d 95 e1 fb ff ff    	lea    -0x41f(%ebp),%edx
f01005a5:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f01005aa:	b0 00                	mov    $0x0,%al
f01005ac:	89 d7                	mov    %edx,%edi
f01005ae:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd3);
			}
			//TEST: FAULT HANDLER II [CLOCK] 	[10 sec]
			{
				char cmd0[BUFLEN] = "clock";
f01005b0:	c7 85 d0 eb ff ff 63 	movl   $0x636f6c63,-0x1430(%ebp)
f01005b7:	6c 6f 63 
f01005ba:	c7 85 d4 eb ff ff 6b 	movl   $0x6b,-0x142c(%ebp)
f01005c1:	00 00 00 
f01005c4:	8d 95 d8 eb ff ff    	lea    -0x1428(%ebp),%edx
f01005ca:	b9 fe 00 00 00       	mov    $0xfe,%ecx
f01005cf:	b8 00 00 00 00       	mov    $0x0,%eax
f01005d4:	89 d7                	mov    %edx,%edi
f01005d6:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd1[BUFLEN] = "run tpr1 11";
f01005d8:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f01005de:	bb ec 01 12 f0       	mov    $0xf01201ec,%ebx
f01005e3:	ba 03 00 00 00       	mov    $0x3,%edx
f01005e8:	89 c7                	mov    %eax,%edi
f01005ea:	89 de                	mov    %ebx,%esi
f01005ec:	89 d1                	mov    %edx,%ecx
f01005ee:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01005f0:	8d 95 dc ef ff ff    	lea    -0x1024(%ebp),%edx
f01005f6:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f01005fb:	b8 00 00 00 00       	mov    $0x0,%eax
f0100600:	89 d7                	mov    %edx,%edi
f0100602:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd2[BUFLEN] = "run tpr2 6";
f0100604:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f010060a:	bb ec 05 12 f0       	mov    $0xf01205ec,%ebx
f010060f:	ba 0b 00 00 00       	mov    $0xb,%edx
f0100614:	89 c7                	mov    %eax,%edi
f0100616:	89 de                	mov    %ebx,%esi
f0100618:	89 d1                	mov    %edx,%ecx
f010061a:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010061c:	8d 95 db f3 ff ff    	lea    -0xc25(%ebp),%edx
f0100622:	b9 f5 03 00 00       	mov    $0x3f5,%ecx
f0100627:	b0 00                	mov    $0x0,%al
f0100629:	89 d7                	mov    %edx,%edi
f010062b:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd3[BUFLEN] = "run tclock1 11";
f010062d:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100633:	bb ec 09 12 f0       	mov    $0xf01209ec,%ebx
f0100638:	ba 0f 00 00 00       	mov    $0xf,%edx
f010063d:	89 c7                	mov    %eax,%edi
f010063f:	89 de                	mov    %ebx,%esi
f0100641:	89 d1                	mov    %edx,%ecx
f0100643:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100645:	8d 95 df f7 ff ff    	lea    -0x821(%ebp),%edx
f010064b:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0100650:	b0 00                	mov    $0x0,%al
f0100652:	89 d7                	mov    %edx,%edi
f0100654:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd4[BUFLEN] = "run tclock2 11";	//depend on USER HEAP (allocate_user_mem, free_user_mem)
f0100656:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f010065c:	bb ec 0d 12 f0       	mov    $0xf0120dec,%ebx
f0100661:	ba 0f 00 00 00       	mov    $0xf,%edx
f0100666:	89 c7                	mov    %eax,%edi
f0100668:	89 de                	mov    %ebx,%esi
f010066a:	89 d1                	mov    %edx,%ecx
f010066c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010066e:	8d 95 df fb ff ff    	lea    -0x421(%ebp),%edx
f0100674:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0100679:	b0 00                	mov    $0x0,%al
f010067b:	89 d7                	mov    %edx,%edi
f010067d:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd4);
			}
			//TEST: FAULT HANDLER II [MODIFIED CLOCK] 	[10 sec]
			{
				char cmd0[BUFLEN] = "modclock";
f010067f:	8d 85 d0 eb ff ff    	lea    -0x1430(%ebp),%eax
f0100685:	bb ec 11 12 f0       	mov    $0xf01211ec,%ebx
f010068a:	ba 09 00 00 00       	mov    $0x9,%edx
f010068f:	89 c7                	mov    %eax,%edi
f0100691:	89 de                	mov    %ebx,%esi
f0100693:	89 d1                	mov    %edx,%ecx
f0100695:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100697:	8d 95 d9 eb ff ff    	lea    -0x1427(%ebp),%edx
f010069d:	b9 f7 03 00 00       	mov    $0x3f7,%ecx
f01006a2:	b0 00                	mov    $0x0,%al
f01006a4:	89 d7                	mov    %edx,%edi
f01006a6:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd1[BUFLEN] = "run tpr1 11";
f01006a8:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f01006ae:	bb ec 01 12 f0       	mov    $0xf01201ec,%ebx
f01006b3:	ba 03 00 00 00       	mov    $0x3,%edx
f01006b8:	89 c7                	mov    %eax,%edi
f01006ba:	89 de                	mov    %ebx,%esi
f01006bc:	89 d1                	mov    %edx,%ecx
f01006be:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01006c0:	8d 95 dc ef ff ff    	lea    -0x1024(%ebp),%edx
f01006c6:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f01006cb:	b8 00 00 00 00       	mov    $0x0,%eax
f01006d0:	89 d7                	mov    %edx,%edi
f01006d2:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd2[BUFLEN] = "run tpr2 6";
f01006d4:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f01006da:	bb ec 05 12 f0       	mov    $0xf01205ec,%ebx
f01006df:	ba 0b 00 00 00       	mov    $0xb,%edx
f01006e4:	89 c7                	mov    %eax,%edi
f01006e6:	89 de                	mov    %ebx,%esi
f01006e8:	89 d1                	mov    %edx,%ecx
f01006ea:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01006ec:	8d 95 db f3 ff ff    	lea    -0xc25(%ebp),%edx
f01006f2:	b9 f5 03 00 00       	mov    $0x3f5,%ecx
f01006f7:	b0 00                	mov    $0x0,%al
f01006f9:	89 d7                	mov    %edx,%edi
f01006fb:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd3[BUFLEN] = "run tmodclk1 11";
f01006fd:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100703:	bb ec 15 12 f0       	mov    $0xf01215ec,%ebx
f0100708:	ba 04 00 00 00       	mov    $0x4,%edx
f010070d:	89 c7                	mov    %eax,%edi
f010070f:	89 de                	mov    %ebx,%esi
f0100711:	89 d1                	mov    %edx,%ecx
f0100713:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100715:	8d 95 e0 f7 ff ff    	lea    -0x820(%ebp),%edx
f010071b:	b9 fc 00 00 00       	mov    $0xfc,%ecx
f0100720:	b8 00 00 00 00       	mov    $0x0,%eax
f0100725:	89 d7                	mov    %edx,%edi
f0100727:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd4[BUFLEN] = "run tmodclk2 11";	//depend on USER HEAP (allocate_user_mem, free_user_mem)
f0100729:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f010072f:	bb ec 19 12 f0       	mov    $0xf01219ec,%ebx
f0100734:	ba 04 00 00 00       	mov    $0x4,%edx
f0100739:	89 c7                	mov    %eax,%edi
f010073b:	89 de                	mov    %ebx,%esi
f010073d:	89 d1                	mov    %edx,%ecx
f010073f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100741:	8d 95 e0 fb ff ff    	lea    -0x420(%ebp),%edx
f0100747:	b9 fc 00 00 00       	mov    $0xfc,%ecx
f010074c:	b8 00 00 00 00       	mov    $0x0,%eax
f0100751:	89 d7                	mov    %edx,%edi
f0100753:	f3 ab                	rep stos %eax,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd4);
			}
			//TEST: FAULT HANDLER II [LRU] 	[10 sec]
			{
				char cmd0[BUFLEN] = "lru 1";
f0100755:	c7 85 d0 ef ff ff 6c 	movl   $0x2075726c,-0x1030(%ebp)
f010075c:	72 75 20 
f010075f:	c7 85 d4 ef ff ff 31 	movl   $0x31,-0x102c(%ebp)
f0100766:	00 00 00 
f0100769:	8d 95 d8 ef ff ff    	lea    -0x1028(%ebp),%edx
f010076f:	b9 fe 00 00 00       	mov    $0xfe,%ecx
f0100774:	b8 00 00 00 00       	mov    $0x0,%eax
f0100779:	89 d7                	mov    %edx,%edi
f010077b:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd1[BUFLEN] = "run tpr1 11";
f010077d:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f0100783:	bb ec 01 12 f0       	mov    $0xf01201ec,%ebx
f0100788:	ba 03 00 00 00       	mov    $0x3,%edx
f010078d:	89 c7                	mov    %eax,%edi
f010078f:	89 de                	mov    %ebx,%esi
f0100791:	89 d1                	mov    %edx,%ecx
f0100793:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100795:	8d 95 dc f3 ff ff    	lea    -0xc24(%ebp),%edx
f010079b:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f01007a0:	b8 00 00 00 00       	mov    $0x0,%eax
f01007a5:	89 d7                	mov    %edx,%edi
f01007a7:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd2[BUFLEN] = "run tpr2 6";
f01007a9:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f01007af:	bb ec 05 12 f0       	mov    $0xf01205ec,%ebx
f01007b4:	ba 0b 00 00 00       	mov    $0xb,%edx
f01007b9:	89 c7                	mov    %eax,%edi
f01007bb:	89 de                	mov    %ebx,%esi
f01007bd:	89 d1                	mov    %edx,%ecx
f01007bf:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01007c1:	8d 95 db f7 ff ff    	lea    -0x825(%ebp),%edx
f01007c7:	b9 f5 03 00 00       	mov    $0x3f5,%ecx
f01007cc:	b0 00                	mov    $0x0,%al
f01007ce:	89 d7                	mov    %edx,%edi
f01007d0:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd3[BUFLEN] = "run tlru 11";
f01007d2:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f01007d8:	bb ec 1d 12 f0       	mov    $0xf0121dec,%ebx
f01007dd:	ba 03 00 00 00       	mov    $0x3,%edx
f01007e2:	89 c7                	mov    %eax,%edi
f01007e4:	89 de                	mov    %ebx,%esi
f01007e6:	89 d1                	mov    %edx,%ecx
f01007e8:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01007ea:	8d 95 dc fb ff ff    	lea    -0x424(%ebp),%edx
f01007f0:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f01007f5:	b8 00 00 00 00       	mov    $0x0,%eax
f01007fa:	89 d7                	mov    %edx,%edi
f01007fc:	f3 ab                	rep stos %eax,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd3);
			}
			//TEST: USER HEAP	[PARTIAL GRADING]
			{
				char cmd0[BUFLEN] = "uhcustomfit";
f01007fe:	8d 85 d0 e3 ff ff    	lea    -0x1c30(%ebp),%eax
f0100804:	bb ec 21 12 f0       	mov    $0xf01221ec,%ebx
f0100809:	ba 03 00 00 00       	mov    $0x3,%edx
f010080e:	89 c7                	mov    %eax,%edi
f0100810:	89 de                	mov    %ebx,%esi
f0100812:	89 d1                	mov    %edx,%ecx
f0100814:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100816:	8d 95 dc e3 ff ff    	lea    -0x1c24(%ebp),%edx
f010081c:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f0100821:	b8 00 00 00 00       	mov    $0x0,%eax
f0100826:	89 d7                	mov    %edx,%edi
f0100828:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd1[BUFLEN] = "run tm1 3000";
f010082a:	8d 85 d0 e7 ff ff    	lea    -0x1830(%ebp),%eax
f0100830:	bb ec 25 12 f0       	mov    $0xf01225ec,%ebx
f0100835:	ba 0d 00 00 00       	mov    $0xd,%edx
f010083a:	89 c7                	mov    %eax,%edi
f010083c:	89 de                	mov    %ebx,%esi
f010083e:	89 d1                	mov    %edx,%ecx
f0100840:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100842:	8d 95 dd e7 ff ff    	lea    -0x1823(%ebp),%edx
f0100848:	b9 f3 03 00 00       	mov    $0x3f3,%ecx
f010084d:	b0 00                	mov    $0x0,%al
f010084f:	89 d7                	mov    %edx,%edi
f0100851:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd2[BUFLEN] = "run tm2 3000";
f0100853:	8d 85 d0 eb ff ff    	lea    -0x1430(%ebp),%eax
f0100859:	bb ec 29 12 f0       	mov    $0xf01229ec,%ebx
f010085e:	ba 0d 00 00 00       	mov    $0xd,%edx
f0100863:	89 c7                	mov    %eax,%edi
f0100865:	89 de                	mov    %ebx,%esi
f0100867:	89 d1                	mov    %edx,%ecx
f0100869:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010086b:	8d 95 dd eb ff ff    	lea    -0x1423(%ebp),%edx
f0100871:	b9 f3 03 00 00       	mov    $0x3f3,%ecx
f0100876:	b0 00                	mov    $0x0,%al
f0100878:	89 d7                	mov    %edx,%edi
f010087a:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd3[BUFLEN] = "run tf1 3000";
f010087c:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f0100882:	bb ec 2d 12 f0       	mov    $0xf0122dec,%ebx
f0100887:	ba 0d 00 00 00       	mov    $0xd,%edx
f010088c:	89 c7                	mov    %eax,%edi
f010088e:	89 de                	mov    %ebx,%esi
f0100890:	89 d1                	mov    %edx,%ecx
f0100892:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100894:	8d 95 dd ef ff ff    	lea    -0x1023(%ebp),%edx
f010089a:	b9 f3 03 00 00       	mov    $0x3f3,%ecx
f010089f:	b0 00                	mov    $0x0,%al
f01008a1:	89 d7                	mov    %edx,%edi
f01008a3:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd4[BUFLEN] = "run tf2 3000";
f01008a5:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f01008ab:	bb ec 31 12 f0       	mov    $0xf01231ec,%ebx
f01008b0:	ba 0d 00 00 00       	mov    $0xd,%edx
f01008b5:	89 c7                	mov    %eax,%edi
f01008b7:	89 de                	mov    %ebx,%esi
f01008b9:	89 d1                	mov    %edx,%ecx
f01008bb:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01008bd:	8d 95 dd f3 ff ff    	lea    -0xc23(%ebp),%edx
f01008c3:	b9 f3 03 00 00       	mov    $0x3f3,%ecx
f01008c8:	b0 00                	mov    $0x0,%al
f01008ca:	89 d7                	mov    %edx,%edi
f01008cc:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd5[BUFLEN] = "run tcf1 3000";
f01008ce:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f01008d4:	bb ec 35 12 f0       	mov    $0xf01235ec,%ebx
f01008d9:	ba 0e 00 00 00       	mov    $0xe,%edx
f01008de:	89 c7                	mov    %eax,%edi
f01008e0:	89 de                	mov    %ebx,%esi
f01008e2:	89 d1                	mov    %edx,%ecx
f01008e4:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01008e6:	8d 95 de f7 ff ff    	lea    -0x822(%ebp),%edx
f01008ec:	b9 f2 03 00 00       	mov    $0x3f2,%ecx
f01008f1:	b0 00                	mov    $0x0,%al
f01008f3:	89 d7                	mov    %edx,%edi
f01008f5:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd6[BUFLEN] = "run tcf2 10000";
f01008f7:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f01008fd:	bb ec 39 12 f0       	mov    $0xf01239ec,%ebx
f0100902:	ba 0f 00 00 00       	mov    $0xf,%edx
f0100907:	89 c7                	mov    %eax,%edi
f0100909:	89 de                	mov    %ebx,%esi
f010090b:	89 d1                	mov    %edx,%ecx
f010090d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010090f:	8d 95 df fb ff ff    	lea    -0x421(%ebp),%edx
f0100915:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f010091a:	b0 00                	mov    $0x0,%al
f010091c:	89 d7                	mov    %edx,%edi
f010091e:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd6);
			}
			//TEST: SHARED MEMORY	[PARTIAL GRADING]
			{
				char cmd0[BUFLEN] = "uhcustomfit";
f0100920:	8d 85 d0 e7 ff ff    	lea    -0x1830(%ebp),%eax
f0100926:	bb ec 21 12 f0       	mov    $0xf01221ec,%ebx
f010092b:	ba 03 00 00 00       	mov    $0x3,%edx
f0100930:	89 c7                	mov    %eax,%edi
f0100932:	89 de                	mov    %ebx,%esi
f0100934:	89 d1                	mov    %edx,%ecx
f0100936:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100938:	8d 95 dc e7 ff ff    	lea    -0x1824(%ebp),%edx
f010093e:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f0100943:	b8 00 00 00 00       	mov    $0x0,%eax
f0100948:	89 d7                	mov    %edx,%edi
f010094a:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd1[BUFLEN] = "run tshr1 3000";
f010094c:	8d 85 d0 eb ff ff    	lea    -0x1430(%ebp),%eax
f0100952:	bb ec 3d 12 f0       	mov    $0xf0123dec,%ebx
f0100957:	ba 0f 00 00 00       	mov    $0xf,%edx
f010095c:	89 c7                	mov    %eax,%edi
f010095e:	89 de                	mov    %ebx,%esi
f0100960:	89 d1                	mov    %edx,%ecx
f0100962:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100964:	8d 95 df eb ff ff    	lea    -0x1421(%ebp),%edx
f010096a:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f010096f:	b0 00                	mov    $0x0,%al
f0100971:	89 d7                	mov    %edx,%edi
f0100973:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd2[BUFLEN] = "run tshr2 3000";
f0100975:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f010097b:	bb ec 41 12 f0       	mov    $0xf01241ec,%ebx
f0100980:	ba 0f 00 00 00       	mov    $0xf,%edx
f0100985:	89 c7                	mov    %eax,%edi
f0100987:	89 de                	mov    %ebx,%esi
f0100989:	89 d1                	mov    %edx,%ecx
f010098b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010098d:	8d 95 df ef ff ff    	lea    -0x1021(%ebp),%edx
f0100993:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0100998:	b0 00                	mov    $0x0,%al
f010099a:	89 d7                	mov    %edx,%edi
f010099c:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd3[BUFLEN] = "run tshr3 3000";
f010099e:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f01009a4:	bb ec 45 12 f0       	mov    $0xf01245ec,%ebx
f01009a9:	ba 0f 00 00 00       	mov    $0xf,%edx
f01009ae:	89 c7                	mov    %eax,%edi
f01009b0:	89 de                	mov    %ebx,%esi
f01009b2:	89 d1                	mov    %edx,%ecx
f01009b4:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01009b6:	8d 95 df f3 ff ff    	lea    -0xc21(%ebp),%edx
f01009bc:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f01009c1:	b0 00                	mov    $0x0,%al
f01009c3:	89 d7                	mov    %edx,%edi
f01009c5:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd4[BUFLEN] = "run tcf3 3000";	//depend on USER HEAP (malloc, free)
f01009c7:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f01009cd:	bb ec 49 12 f0       	mov    $0xf01249ec,%ebx
f01009d2:	ba 0e 00 00 00       	mov    $0xe,%edx
f01009d7:	89 c7                	mov    %eax,%edi
f01009d9:	89 de                	mov    %ebx,%esi
f01009db:	89 d1                	mov    %edx,%ecx
f01009dd:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01009df:	8d 95 de f7 ff ff    	lea    -0x822(%ebp),%edx
f01009e5:	b9 f2 03 00 00       	mov    $0x3f2,%ecx
f01009ea:	b0 00                	mov    $0x0,%al
f01009ec:	89 d7                	mov    %edx,%edi
f01009ee:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd5[BUFLEN] = "run tst_protection 5000"; //[0/1 GRADING] [time limit: 3 mins]
f01009f0:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f01009f6:	bb ec 4d 12 f0       	mov    $0xf0124dec,%ebx
f01009fb:	ba 06 00 00 00       	mov    $0x6,%edx
f0100a00:	89 c7                	mov    %eax,%edi
f0100a02:	89 de                	mov    %ebx,%esi
f0100a04:	89 d1                	mov    %edx,%ecx
f0100a06:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100a08:	8d 95 e8 fb ff ff    	lea    -0x418(%ebp),%edx
f0100a0e:	b9 fa 00 00 00       	mov    $0xfa,%ecx
f0100a13:	b8 00 00 00 00       	mov    $0x0,%eax
f0100a18:	89 d7                	mov    %edx,%edi
f0100a1a:	f3 ab                	rep stos %eax,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd5);
			}
			//TEST: PRIORITY RR SCHEDULER
			{
				char cmd01[BUFLEN] = "schedPRIRR 10 40 1000";
f0100a1c:	8d 85 d0 eb ff ff    	lea    -0x1430(%ebp),%eax
f0100a22:	bb ec 51 12 f0       	mov    $0xf01251ec,%ebx
f0100a27:	ba 16 00 00 00       	mov    $0x16,%edx
f0100a2c:	89 c7                	mov    %eax,%edi
f0100a2e:	89 de                	mov    %ebx,%esi
f0100a30:	89 d1                	mov    %edx,%ecx
f0100a32:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100a34:	8d 95 e6 eb ff ff    	lea    -0x141a(%ebp),%edx
f0100a3a:	b9 ea 03 00 00       	mov    $0x3ea,%ecx
f0100a3f:	b0 00                	mov    $0x0,%al
f0100a41:	89 d7                	mov    %edx,%edi
f0100a43:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd03[BUFLEN] = "schedPRIRR 10 40 20";
f0100a45:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f0100a4b:	bb ec 55 12 f0       	mov    $0xf01255ec,%ebx
f0100a50:	ba 05 00 00 00       	mov    $0x5,%edx
f0100a55:	89 c7                	mov    %eax,%edi
f0100a57:	89 de                	mov    %ebx,%esi
f0100a59:	89 d1                	mov    %edx,%ecx
f0100a5b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100a5d:	8d 95 e4 ef ff ff    	lea    -0x101c(%ebp),%edx
f0100a63:	b9 fb 00 00 00       	mov    $0xfb,%ecx
f0100a68:	b8 00 00 00 00       	mov    $0x0,%eax
f0100a6d:	89 d7                	mov    %edx,%edi
f0100a6f:	f3 ab                	rep stos %eax,%es:(%edi)
				//execute_command(cmd03);
				char cmdU1_1[BUFLEN] = "tst priorityRR 0";	//52 sec
f0100a71:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f0100a77:	bb ec 59 12 f0       	mov    $0xf01259ec,%ebx
f0100a7c:	ba 11 00 00 00       	mov    $0x11,%edx
f0100a81:	89 c7                	mov    %eax,%edi
f0100a83:	89 de                	mov    %ebx,%esi
f0100a85:	89 d1                	mov    %edx,%ecx
f0100a87:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100a89:	8d 95 e1 f3 ff ff    	lea    -0xc1f(%ebp),%edx
f0100a8f:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f0100a94:	b0 00                	mov    $0x0,%al
f0100a96:	89 d7                	mov    %edx,%edi
f0100a98:	f3 aa                	rep stos %al,%es:(%edi)
				char cmdU2_1[BUFLEN] = "tst priorityRR 1";	//58 sec
f0100a9a:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100aa0:	bb ec 5d 12 f0       	mov    $0xf0125dec,%ebx
f0100aa5:	ba 11 00 00 00       	mov    $0x11,%edx
f0100aaa:	89 c7                	mov    %eax,%edi
f0100aac:	89 de                	mov    %ebx,%esi
f0100aae:	89 d1                	mov    %edx,%ecx
f0100ab0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100ab2:	8d 95 e1 f7 ff ff    	lea    -0x81f(%ebp),%edx
f0100ab8:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f0100abd:	b0 00                	mov    $0x0,%al
f0100abf:	89 d7                	mov    %edx,%edi
f0100ac1:	f3 aa                	rep stos %al,%es:(%edi)
				char cmdU3_1[BUFLEN] = "tst priorityRR 2";	//90 sec
f0100ac3:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f0100ac9:	bb ec 61 12 f0       	mov    $0xf01261ec,%ebx
f0100ace:	ba 11 00 00 00       	mov    $0x11,%edx
f0100ad3:	89 c7                	mov    %eax,%edi
f0100ad5:	89 de                	mov    %ebx,%esi
f0100ad7:	89 d1                	mov    %edx,%ecx
f0100ad9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100adb:	8d 95 e1 fb ff ff    	lea    -0x41f(%ebp),%edx
f0100ae1:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f0100ae6:	b0 00                	mov    $0x0,%al
f0100ae8:	89 d7                	mov    %edx,%edi
f0100aea:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmdU3_1);
			}
			//TEST: PROTECTION
			{
				char cmd1[BUFLEN] = "run tst_chan_all 20";
f0100aec:	8d 85 d0 eb ff ff    	lea    -0x1430(%ebp),%eax
f0100af2:	bb ec 65 12 f0       	mov    $0xf01265ec,%ebx
f0100af7:	ba 05 00 00 00       	mov    $0x5,%edx
f0100afc:	89 c7                	mov    %eax,%edi
f0100afe:	89 de                	mov    %ebx,%esi
f0100b00:	89 d1                	mov    %edx,%ecx
f0100b02:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100b04:	8d 95 e4 eb ff ff    	lea    -0x141c(%ebp),%edx
f0100b0a:	b9 fb 00 00 00       	mov    $0xfb,%ecx
f0100b0f:	b8 00 00 00 00       	mov    $0x0,%eax
f0100b14:	89 d7                	mov    %edx,%edi
f0100b16:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd2[BUFLEN] = "run tst_chan_one 20";
f0100b18:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f0100b1e:	bb ec 69 12 f0       	mov    $0xf01269ec,%ebx
f0100b23:	ba 05 00 00 00       	mov    $0x5,%edx
f0100b28:	89 c7                	mov    %eax,%edi
f0100b2a:	89 de                	mov    %ebx,%esi
f0100b2c:	89 d1                	mov    %edx,%ecx
f0100b2e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100b30:	8d 95 e4 ef ff ff    	lea    -0x101c(%ebp),%edx
f0100b36:	b9 fb 00 00 00       	mov    $0xfb,%ecx
f0100b3b:	b8 00 00 00 00       	mov    $0x0,%eax
f0100b40:	89 d7                	mov    %edx,%edi
f0100b42:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd3[BUFLEN] = "run tst_sleeplock 20";
f0100b44:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f0100b4a:	bb ec 6d 12 f0       	mov    $0xf0126dec,%ebx
f0100b4f:	ba 15 00 00 00       	mov    $0x15,%edx
f0100b54:	89 c7                	mov    %eax,%edi
f0100b56:	89 de                	mov    %ebx,%esi
f0100b58:	89 d1                	mov    %edx,%ecx
f0100b5a:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100b5c:	8d 95 e5 f3 ff ff    	lea    -0xc1b(%ebp),%edx
f0100b62:	b9 eb 03 00 00       	mov    $0x3eb,%ecx
f0100b67:	b0 00                	mov    $0x0,%al
f0100b69:	89 d7                	mov    %edx,%edi
f0100b6b:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd4[BUFLEN] = "run tst_ksem1 500";	//5 sec
f0100b6d:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100b73:	bb ec 71 12 f0       	mov    $0xf01271ec,%ebx
f0100b78:	ba 12 00 00 00       	mov    $0x12,%edx
f0100b7d:	89 c7                	mov    %eax,%edi
f0100b7f:	89 de                	mov    %ebx,%esi
f0100b81:	89 d1                	mov    %edx,%ecx
f0100b83:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100b85:	8d 95 e2 f7 ff ff    	lea    -0x81e(%ebp),%edx
f0100b8b:	b9 ee 03 00 00       	mov    $0x3ee,%ecx
f0100b90:	b0 00                	mov    $0x0,%al
f0100b92:	89 d7                	mov    %edx,%edi
f0100b94:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd5[BUFLEN] = "run tst_ksem2 500";	//20 sec
f0100b96:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f0100b9c:	bb ec 75 12 f0       	mov    $0xf01275ec,%ebx
f0100ba1:	ba 12 00 00 00       	mov    $0x12,%edx
f0100ba6:	89 c7                	mov    %eax,%edi
f0100ba8:	89 de                	mov    %ebx,%esi
f0100baa:	89 d1                	mov    %edx,%ecx
f0100bac:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100bae:	8d 95 e2 fb ff ff    	lea    -0x41e(%ebp),%edx
f0100bb4:	b9 ee 03 00 00       	mov    $0x3ee,%ecx
f0100bb9:	b0 00                	mov    $0x0,%al
f0100bbb:	89 d7                	mov    %edx,%edi
f0100bbd:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd5);
			}
			//TEST#X: BONUS - DA: BLOCK IF NO BLOCK
			{
				char cmd1[BUFLEN] = "run tst_da_block 500";
f0100bbf:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f0100bc5:	bb ec 79 12 f0       	mov    $0xf01279ec,%ebx
f0100bca:	ba 15 00 00 00       	mov    $0x15,%edx
f0100bcf:	89 c7                	mov    %eax,%edi
f0100bd1:	89 de                	mov    %ebx,%esi
f0100bd3:	89 d1                	mov    %edx,%ecx
f0100bd5:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100bd7:	8d 95 e5 fb ff ff    	lea    -0x41b(%ebp),%edx
f0100bdd:	b9 eb 03 00 00       	mov    $0x3eb,%ecx
f0100be2:	b0 00                	mov    $0x0,%al
f0100be4:	89 d7                	mov    %edx,%edi
f0100be6:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd1);
			}
			//TEST#X: BONUS - KREALLOC
			{
				char cmd0[BUFLEN] = "khcustomfit";
f0100be8:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f0100bee:	bb ec 7d 12 f0       	mov    $0xf0127dec,%ebx
f0100bf3:	ba 03 00 00 00       	mov    $0x3,%edx
f0100bf8:	89 c7                	mov    %eax,%edi
f0100bfa:	89 de                	mov    %ebx,%esi
f0100bfc:	89 d1                	mov    %edx,%ecx
f0100bfe:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100c00:	8d 95 dc ef ff ff    	lea    -0x1024(%ebp),%edx
f0100c06:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f0100c0b:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c10:	89 d7                	mov    %edx,%edi
f0100c12:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd1[BUFLEN] = "tst kheap CF krealloc 1";
f0100c14:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f0100c1a:	bb ec 81 12 f0       	mov    $0xf01281ec,%ebx
f0100c1f:	ba 06 00 00 00       	mov    $0x6,%edx
f0100c24:	89 c7                	mov    %eax,%edi
f0100c26:	89 de                	mov    %ebx,%esi
f0100c28:	89 d1                	mov    %edx,%ecx
f0100c2a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100c2c:	8d 95 e8 f3 ff ff    	lea    -0xc18(%ebp),%edx
f0100c32:	b9 fa 00 00 00       	mov    $0xfa,%ecx
f0100c37:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c3c:	89 d7                	mov    %edx,%edi
f0100c3e:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd2[BUFLEN] = "tst kheap CF krealloc 2";
f0100c40:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100c46:	bb ec 85 12 f0       	mov    $0xf01285ec,%ebx
f0100c4b:	ba 06 00 00 00       	mov    $0x6,%edx
f0100c50:	89 c7                	mov    %eax,%edi
f0100c52:	89 de                	mov    %ebx,%esi
f0100c54:	89 d1                	mov    %edx,%ecx
f0100c56:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100c58:	8d 95 e8 f7 ff ff    	lea    -0x818(%ebp),%edx
f0100c5e:	b9 fa 00 00 00       	mov    $0xfa,%ecx
f0100c63:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c68:	89 d7                	mov    %edx,%edi
f0100c6a:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd3[BUFLEN] = "tst kheap CF krealloc 3";
f0100c6c:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f0100c72:	bb ec 89 12 f0       	mov    $0xf01289ec,%ebx
f0100c77:	ba 06 00 00 00       	mov    $0x6,%edx
f0100c7c:	89 c7                	mov    %eax,%edi
f0100c7e:	89 de                	mov    %ebx,%esi
f0100c80:	89 d1                	mov    %edx,%ecx
f0100c82:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100c84:	8d 95 e8 fb ff ff    	lea    -0x418(%ebp),%edx
f0100c8a:	b9 fa 00 00 00       	mov    $0xfa,%ecx
f0100c8f:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c94:	89 d7                	mov    %edx,%edi
f0100c96:	f3 ab                	rep stos %eax,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd1);
			}
			//TEST#X: BONUS - FAST PAGE ALLOCATOR
			{
				char cmd0[BUFLEN] = "khcustomfit";
f0100c98:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100c9e:	bb ec 7d 12 f0       	mov    $0xf0127dec,%ebx
f0100ca3:	ba 03 00 00 00       	mov    $0x3,%edx
f0100ca8:	89 c7                	mov    %eax,%edi
f0100caa:	89 de                	mov    %ebx,%esi
f0100cac:	89 d1                	mov    %edx,%ecx
f0100cae:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100cb0:	8d 95 dc f7 ff ff    	lea    -0x824(%ebp),%edx
f0100cb6:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f0100cbb:	b8 00 00 00 00       	mov    $0x0,%eax
f0100cc0:	89 d7                	mov    %edx,%edi
f0100cc2:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd1[BUFLEN] = "tst kheap CF fast"; //[0/1 GRADING] [time limit: 10 secs]
f0100cc4:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f0100cca:	bb ec 8d 12 f0       	mov    $0xf0128dec,%ebx
f0100ccf:	ba 12 00 00 00       	mov    $0x12,%edx
f0100cd4:	89 c7                	mov    %eax,%edi
f0100cd6:	89 de                	mov    %ebx,%esi
f0100cd8:	89 d1                	mov    %edx,%ecx
f0100cda:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100cdc:	8d 95 e2 fb ff ff    	lea    -0x41e(%ebp),%edx
f0100ce2:	b9 ee 03 00 00       	mov    $0x3ee,%ecx
f0100ce7:	b0 00                	mov    $0x0,%al
f0100ce9:	89 d7                	mov    %edx,%edi
f0100ceb:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd1);
			}
			//TEST#X: BONUS - EXIT
			{
				char cmd0[BUFLEN] = "fifo";
f0100ced:	c7 85 d0 e3 ff ff 66 	movl   $0x6f666966,-0x1c30(%ebp)
f0100cf4:	69 66 6f 
f0100cf7:	c7 85 d4 e3 ff ff 00 	movl   $0x0,-0x1c2c(%ebp)
f0100cfe:	00 00 00 
f0100d01:	8d 95 d8 e3 ff ff    	lea    -0x1c28(%ebp),%edx
f0100d07:	b9 fe 00 00 00       	mov    $0xfe,%ecx
f0100d0c:	b8 00 00 00 00       	mov    $0x0,%eax
f0100d11:	89 d7                	mov    %edx,%edi
f0100d13:	f3 ab                	rep stos %eax,%es:(%edi)
				//Scenario 1: without using dynamic allocation/de-allocation [PLACEMENT]
				char cmd1[BUFLEN] = "run tef1 100";
f0100d15:	8d 85 d0 e7 ff ff    	lea    -0x1830(%ebp),%eax
f0100d1b:	bb ec 91 12 f0       	mov    $0xf01291ec,%ebx
f0100d20:	ba 0d 00 00 00       	mov    $0xd,%edx
f0100d25:	89 c7                	mov    %eax,%edi
f0100d27:	89 de                	mov    %ebx,%esi
f0100d29:	89 d1                	mov    %edx,%ecx
f0100d2b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100d2d:	8d 95 dd e7 ff ff    	lea    -0x1823(%ebp),%edx
f0100d33:	b9 f3 03 00 00       	mov    $0x3f3,%ecx
f0100d38:	b0 00                	mov    $0x0,%al
f0100d3a:	89 d7                	mov    %edx,%edi
f0100d3c:	f3 aa                	rep stos %al,%es:(%edi)
				//Scenario 2: using dynamic allocation and free [REPLACEMENT]
				char cmd2[BUFLEN] = "run tef2 20";
f0100d3e:	8d 85 d0 eb ff ff    	lea    -0x1430(%ebp),%eax
f0100d44:	bb ec 95 12 f0       	mov    $0xf01295ec,%ebx
f0100d49:	ba 03 00 00 00       	mov    $0x3,%edx
f0100d4e:	89 c7                	mov    %eax,%edi
f0100d50:	89 de                	mov    %ebx,%esi
f0100d52:	89 d1                	mov    %edx,%ecx
f0100d54:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100d56:	8d 95 dc eb ff ff    	lea    -0x1424(%ebp),%edx
f0100d5c:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f0100d61:	b8 00 00 00 00       	mov    $0x0,%eax
f0100d66:	89 d7                	mov    %edx,%edi
f0100d68:	f3 ab                	rep stos %eax,%es:(%edi)
				//Scenario3: using dynamic allocation and free [process kill itself] [REPLACEMENT]
				char cmd3[BUFLEN] = "run tef3 20";
f0100d6a:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f0100d70:	bb ec 99 12 f0       	mov    $0xf01299ec,%ebx
f0100d75:	ba 03 00 00 00       	mov    $0x3,%edx
f0100d7a:	89 c7                	mov    %eax,%edi
f0100d7c:	89 de                	mov    %ebx,%esi
f0100d7e:	89 d1                	mov    %edx,%ecx
f0100d80:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100d82:	8d 95 dc ef ff ff    	lea    -0x1024(%ebp),%edx
f0100d88:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f0100d8d:	b8 00 00 00 00       	mov    $0x0,%eax
f0100d92:	89 d7                	mov    %edx,%edi
f0100d94:	f3 ab                	rep stos %eax,%es:(%edi)
				//Scenario 4: using create & get of shared variables [REPLACEMENT]
				char cmd4[BUFLEN] = "run tef4 10";
f0100d96:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f0100d9c:	bb ec 9d 12 f0       	mov    $0xf0129dec,%ebx
f0100da1:	ba 03 00 00 00       	mov    $0x3,%edx
f0100da6:	89 c7                	mov    %eax,%edi
f0100da8:	89 de                	mov    %ebx,%esi
f0100daa:	89 d1                	mov    %edx,%ecx
f0100dac:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100dae:	8d 95 dc f3 ff ff    	lea    -0xc24(%ebp),%edx
f0100db4:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f0100db9:	b8 00 00 00 00       	mov    $0x0,%eax
f0100dbe:	89 d7                	mov    %edx,%edi
f0100dc0:	f3 ab                	rep stos %eax,%es:(%edi)
				//Scenario 5: using create, get and free shared variables by the created environment itself before calling env_free [PLACEMENT]
				char cmd5[BUFLEN] = "run tef5_2 3000";
f0100dc2:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100dc8:	bb ec a1 12 f0       	mov    $0xf012a1ec,%ebx
f0100dcd:	ba 04 00 00 00       	mov    $0x4,%edx
f0100dd2:	89 c7                	mov    %eax,%edi
f0100dd4:	89 de                	mov    %ebx,%esi
f0100dd6:	89 d1                	mov    %edx,%ecx
f0100dd8:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100dda:	8d 95 e0 f7 ff ff    	lea    -0x820(%ebp),%edx
f0100de0:	b9 fc 00 00 00       	mov    $0xfc,%ecx
f0100de5:	b8 00 00 00 00       	mov    $0x0,%eax
f0100dea:	89 d7                	mov    %edx,%edi
f0100dec:	f3 ab                	rep stos %eax,%es:(%edi)
				//Scenario 6: using shared variables and semaphores together [PLACEMENT]
				char cmd6[BUFLEN] = "run tef6 3000";
f0100dee:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f0100df4:	bb ec a5 12 f0       	mov    $0xf012a5ec,%ebx
f0100df9:	ba 0e 00 00 00       	mov    $0xe,%edx
f0100dfe:	89 c7                	mov    %eax,%edi
f0100e00:	89 de                	mov    %ebx,%esi
f0100e02:	89 d1                	mov    %edx,%ecx
f0100e04:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100e06:	8d 95 de fb ff ff    	lea    -0x422(%ebp),%edx
f0100e0c:	b9 f2 03 00 00       	mov    $0x3f2,%ecx
f0100e11:	b0 00                	mov    $0x0,%al
f0100e13:	89 d7                	mov    %edx,%edi
f0100e15:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd5);

			}

			cprintf("PROJECT Automatic testing is ENDED\n") ;
f0100e17:	83 ec 0c             	sub    $0xc,%esp
f0100e1a:	68 c8 bd 11 f0       	push   $0xf011bdc8
f0100e1f:	e8 38 0d 00 00       	call   f0101b5c <cprintf>
f0100e24:	83 c4 10             	add    $0x10,%esp
			__autograde__ = 0;
f0100e27:	c7 05 20 f0 17 f0 00 	movl   $0x0,0xf017f020
f0100e2e:	00 00 00 
		}
		get_into_prompt();
f0100e31:	e8 ac 0e 00 00       	call   f0101ce2 <get_into_prompt>

f0100e36 <print_welcome_message>:
	}
}


void print_welcome_message()
{
f0100e36:	55                   	push   %ebp
f0100e37:	89 e5                	mov    %esp,%ebp
f0100e39:	83 ec 08             	sub    $0x8,%esp
    cprintf("\n\n\n");
f0100e3c:	83 ec 0c             	sub    $0xc,%esp
f0100e3f:	68 ec a9 12 f0       	push   $0xf012a9ec
f0100e44:	e8 13 0d 00 00       	call   f0101b5c <cprintf>
f0100e49:	83 c4 10             	add    $0x10,%esp
    cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f0100e4c:	83 ec 0c             	sub    $0xc,%esp
f0100e4f:	68 f0 a9 12 f0       	push   $0xf012a9f0
f0100e54:	e8 03 0d 00 00       	call   f0101b5c <cprintf>
f0100e59:	83 c4 10             	add    $0x10,%esp
    cprintf("\t\t!!                                                             !!\n");
f0100e5c:	83 ec 0c             	sub    $0xc,%esp
f0100e5f:	68 38 aa 12 f0       	push   $0xf012aa38
f0100e64:	e8 f3 0c 00 00       	call   f0101b5c <cprintf>
f0100e69:	83 c4 10             	add    $0x10,%esp
    cprintf("\t\t!!                   !! FCIS says HELLO !!                     !!\n");
f0100e6c:	83 ec 0c             	sub    $0xc,%esp
f0100e6f:	68 80 aa 12 f0       	push   $0xf012aa80
f0100e74:	e8 e3 0c 00 00       	call   f0101b5c <cprintf>
f0100e79:	83 c4 10             	add    $0x10,%esp
    cprintf("\t\t!!                                                             !!\n");
f0100e7c:	83 ec 0c             	sub    $0xc,%esp
f0100e7f:	68 38 aa 12 f0       	push   $0xf012aa38
f0100e84:	e8 d3 0c 00 00       	call   f0101b5c <cprintf>
f0100e89:	83 c4 10             	add    $0x10,%esp
    cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f0100e8c:	83 ec 0c             	sub    $0xc,%esp
f0100e8f:	68 f0 a9 12 f0       	push   $0xf012a9f0
f0100e94:	e8 c3 0c 00 00       	call   f0101b5c <cprintf>
f0100e99:	83 c4 10             	add    $0x10,%esp
    cprintf("\n\n\n\n");
f0100e9c:	83 ec 0c             	sub    $0xc,%esp
f0100e9f:	68 c5 aa 12 f0       	push   $0xf012aac5
f0100ea4:	e8 b3 0c 00 00       	call   f0101b5c <cprintf>
f0100ea9:	83 c4 10             	add    $0x10,%esp
}
f0100eac:	90                   	nop
f0100ead:	c9                   	leave  
f0100eae:	c3                   	ret    

f0100eaf <_panic>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv and schedule the next environment.
 */
void _panic(const char *file, int line, const char *fmt,...)
{
f0100eaf:	55                   	push   %ebp
f0100eb0:	89 e5                	mov    %esp,%ebp
f0100eb2:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f0100eb5:	e8 5e ab 00 00       	call   f010ba18 <get_cpu_proc>
f0100eba:	89 45 f4             	mov    %eax,-0xc(%ebp)

	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f0100ebd:	8b 45 10             	mov    0x10(%ebp),%eax
f0100ec0:	a3 40 59 81 f0       	mov    %eax,0xf0815940

	va_start(ap, fmt);
f0100ec5:	8d 45 10             	lea    0x10(%ebp),%eax
f0100ec8:	83 c0 04             	add    $0x4,%eax
f0100ecb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cprintf_colored(TEXT_PANIC_CLR, "\nkernel [EVAL_FINAL]panic at %s:%d: ", file, line);
f0100ece:	ff 75 0c             	pushl  0xc(%ebp)
f0100ed1:	ff 75 08             	pushl  0x8(%ebp)
f0100ed4:	68 cc aa 12 f0       	push   $0xf012aacc
f0100ed9:	6a 74                	push   $0x74
f0100edb:	e8 ac 0c 00 00       	call   f0101b8c <cprintf_colored>
f0100ee0:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f0100ee3:	8b 45 10             	mov    0x10(%ebp),%eax
f0100ee6:	83 ec 08             	sub    $0x8,%esp
f0100ee9:	ff 75 f0             	pushl  -0x10(%ebp)
f0100eec:	50                   	push   %eax
f0100eed:	e8 41 0c 00 00       	call   f0101b33 <vcprintf>
f0100ef2:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100ef5:	83 ec 0c             	sub    $0xc,%esp
f0100ef8:	68 f1 aa 12 f0       	push   $0xf012aaf1
f0100efd:	e8 5a 0c 00 00       	call   f0101b5c <cprintf>
f0100f02:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100f05:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100f09:	74 10                	je     f0100f1b <_panic+0x6c>
f0100f0b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100f0e:	8b 40 18             	mov    0x18(%eax),%eax
f0100f11:	83 f8 02             	cmp    $0x2,%eax
f0100f14:	75 05                	jne    f0100f1b <_panic+0x6c>
	{
		//cprintf("\n>>>>>>>>>>> exiting the cur env<<<<<<<<<<<<\n");
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f0100f16:	e8 bb aa 00 00       	call   f010b9d6 <env_exit>

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100f1b:	89 e0                	mov    %esp,%eax
f0100f1d:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f0100f20:	8b 45 e8             	mov    -0x18(%ebp),%eax
	}
	//else //2024: panic from Kernel and no current running env
	{
		char* esp = (char*)read_esp();
f0100f23:	89 45 ec             	mov    %eax,-0x14(%ebp)
		cprintf("esp = %x\n", esp);
f0100f26:	83 ec 08             	sub    $0x8,%esp
f0100f29:	ff 75 ec             	pushl  -0x14(%ebp)
f0100f2c:	68 f3 aa 12 f0       	push   $0xf012aaf3
f0100f31:	e8 26 0c 00 00       	call   f0101b5c <cprintf>
f0100f36:	83 c4 10             	add    $0x10,%esp
		//			//2024: make sure that the SP points to the kernel stack (either the one above KERN_BASE or below it)
		//			assert((esp < ptr_stack_top && esp >= ptr_stack_bottom) ||
		//					(esp < (char*)SCHD_KERN_STACK_TOP && esp >= (char*)SCHD_KERN_STACK_TOP - KERNEL_STACK_SIZE)) ;

		get_into_prompt();
f0100f39:	e8 a4 0d 00 00       	call   f0101ce2 <get_into_prompt>

f0100f3e <_panic_all>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit all env's and then enters the kernel command prompt.
 */
void _panic_all(const char *file, int line, const char *fmt,...)
{
f0100f3e:	55                   	push   %ebp
f0100f3f:	89 e5                	mov    %esp,%ebp
f0100f41:	83 ec 28             	sub    $0x28,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f0100f44:	8b 45 10             	mov    0x10(%ebp),%eax
f0100f47:	a3 40 59 81 f0       	mov    %eax,0xf0815940

	va_start(ap, fmt);
f0100f4c:	8d 45 10             	lea    0x10(%ebp),%eax
f0100f4f:	83 c0 04             	add    $0x4,%eax
f0100f52:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf_colored(TEXT_PANIC_CLR, "\nkernel panic at %s:%d: ", file, line);
f0100f55:	ff 75 0c             	pushl  0xc(%ebp)
f0100f58:	ff 75 08             	pushl  0x8(%ebp)
f0100f5b:	68 fd aa 12 f0       	push   $0xf012aafd
f0100f60:	6a 74                	push   $0x74
f0100f62:	e8 25 0c 00 00       	call   f0101b8c <cprintf_colored>
f0100f67:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f0100f6a:	8b 45 10             	mov    0x10(%ebp),%eax
f0100f6d:	83 ec 08             	sub    $0x8,%esp
f0100f70:	ff 75 f4             	pushl  -0xc(%ebp)
f0100f73:	50                   	push   %eax
f0100f74:	e8 ba 0b 00 00       	call   f0101b33 <vcprintf>
f0100f79:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100f7c:	83 ec 0c             	sub    $0xc,%esp
f0100f7f:	68 f1 aa 12 f0       	push   $0xf012aaf1
f0100f84:	e8 d3 0b 00 00       	call   f0101b5c <cprintf>
f0100f89:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the command prompt */
	pushcli();
f0100f8c:	e8 9f 70 00 00       	call   f0108030 <pushcli>
	struct cpu *c = mycpu();
f0100f91:	e8 da 6f 00 00       	call   f0107f70 <mycpu>
f0100f96:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int sched_stat = c->scheduler_status;
f0100f99:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0100f9c:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f0100fa2:	89 45 ec             	mov    %eax,-0x14(%ebp)
	popcli();
f0100fa5:	e8 d8 70 00 00       	call   f0108082 <popcli>
	/*2022*///Check if the scheduler is successfully initialized or not
	if (sched_stat != SCH_UNINITIALIZED)
f0100faa:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
f0100fae:	74 23                	je     f0100fd3 <_panic_all+0x95>
	{
		//exit all ready env's
		sched_exit_all_ready_envs();
f0100fb0:	e8 a1 64 00 00       	call   f0107456 <sched_exit_all_ready_envs>
		struct Env* cur_env = get_cpu_proc();
f0100fb5:	e8 5e aa 00 00       	call   f010ba18 <get_cpu_proc>
f0100fba:	89 45 e8             	mov    %eax,-0x18(%ebp)
		if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100fbd:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0100fc1:	74 10                	je     f0100fd3 <_panic_all+0x95>
f0100fc3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100fc6:	8b 40 18             	mov    0x18(%eax),%eax
f0100fc9:	83 f8 02             	cmp    $0x2,%eax
f0100fcc:	75 05                	jne    f0100fd3 <_panic_all+0x95>
		{
			//cprintf("exit curenv...........\n");
			//Place the running env into the exit queue then switch to the scheduler
			env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f0100fce:	e8 03 aa 00 00       	call   f010b9d6 <env_exit>

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100fd3:	89 e0                	mov    %esp,%eax
f0100fd5:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return esp;
f0100fd8:	8b 45 e0             	mov    -0x20(%ebp),%eax
		//		fos_scheduler();
	}
	//else //2024: panic from Kernel and no current running env
	{
		//2024: make sure that the SP points to the kernel stack (either the one above KERN_BASE or below it)
		char* esp = (char*)read_esp();
f0100fdb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//		assert((esp < ptr_stack_top && esp >= ptr_stack_bottom) ||
		//				(esp < (char*)SCHD_KERN_STACK_TOP && esp >= (char*)SCHD_KERN_STACK_TOP - KERNEL_STACK_SIZE)) ;

		get_into_prompt();
f0100fde:	e8 ff 0c 00 00       	call   f0101ce2 <get_into_prompt>

f0100fe3 <_panic_into_prompt>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv (if any) and break into the command prompt.
 */
void _panic_into_prompt(const char *file, int line, const char *fmt,...)
{
f0100fe3:	55                   	push   %ebp
f0100fe4:	89 e5                	mov    %esp,%ebp
f0100fe6:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f0100fe9:	8b 45 10             	mov    0x10(%ebp),%eax
f0100fec:	a3 40 59 81 f0       	mov    %eax,0xf0815940

	va_start(ap, fmt);
f0100ff1:	8d 45 10             	lea    0x10(%ebp),%eax
f0100ff4:	83 c0 04             	add    $0x4,%eax
f0100ff7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf_colored(TEXT_PANIC_CLR,"\nkernel panic at %s:%d: ", file, line);
f0100ffa:	ff 75 0c             	pushl  0xc(%ebp)
f0100ffd:	ff 75 08             	pushl  0x8(%ebp)
f0101000:	68 fd aa 12 f0       	push   $0xf012aafd
f0101005:	6a 74                	push   $0x74
f0101007:	e8 80 0b 00 00       	call   f0101b8c <cprintf_colored>
f010100c:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f010100f:	8b 45 10             	mov    0x10(%ebp),%eax
f0101012:	83 ec 08             	sub    $0x8,%esp
f0101015:	ff 75 f4             	pushl  -0xc(%ebp)
f0101018:	50                   	push   %eax
f0101019:	e8 15 0b 00 00       	call   f0101b33 <vcprintf>
f010101e:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0101021:	83 ec 0c             	sub    $0xc,%esp
f0101024:	68 f1 aa 12 f0       	push   $0xf012aaf1
f0101029:	e8 2e 0b 00 00       	call   f0101b5c <cprintf>
f010102e:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	//	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	struct Env* cur_env = get_cpu_proc();
f0101031:	e8 e2 a9 00 00       	call   f010ba18 <get_cpu_proc>
f0101036:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0101039:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010103d:	74 10                	je     f010104f <_panic_into_prompt+0x6c>
f010103f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101042:	8b 40 18             	mov    0x18(%eax),%eax
f0101045:	83 f8 02             	cmp    $0x2,%eax
f0101048:	75 05                	jne    f010104f <_panic_into_prompt+0x6c>
	{
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f010104a:	e8 87 a9 00 00       	call   f010b9d6 <env_exit>
	}

	get_into_prompt();
f010104f:	e8 8e 0c 00 00       	call   f0101ce2 <get_into_prompt>

f0101054 <_warn>:

}

/* like panic, but don't enters the kernel command prompt*/
void _warn(const char *file, int line, const char *fmt,...)
{
f0101054:	55                   	push   %ebp
f0101055:	89 e5                	mov    %esp,%ebp
f0101057:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f010105a:	8d 45 10             	lea    0x10(%ebp),%eax
f010105d:	83 c0 04             	add    $0x4,%eax
f0101060:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf_colored(TEXT_WARN_CLR, "\nkernel warning at %s:%d: ", file, line);
f0101063:	ff 75 0c             	pushl  0xc(%ebp)
f0101066:	ff 75 08             	pushl  0x8(%ebp)
f0101069:	68 16 ab 12 f0       	push   $0xf012ab16
f010106e:	6a 7e                	push   $0x7e
f0101070:	e8 17 0b 00 00       	call   f0101b8c <cprintf_colored>
f0101075:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f0101078:	8b 45 10             	mov    0x10(%ebp),%eax
f010107b:	83 ec 08             	sub    $0x8,%esp
f010107e:	ff 75 f4             	pushl  -0xc(%ebp)
f0101081:	50                   	push   %eax
f0101082:	e8 ac 0a 00 00       	call   f0101b33 <vcprintf>
f0101087:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f010108a:	83 ec 0c             	sub    $0xc,%esp
f010108d:	68 f1 aa 12 f0       	push   $0xf012aaf1
f0101092:	e8 c5 0a 00 00       	call   f0101b5c <cprintf>
f0101097:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f010109a:	90                   	nop
f010109b:	c9                   	leave  
f010109c:	c3                   	ret    

f010109d <serial_proc_data>:

static bool serial_exists;

int
serial_proc_data(void)
{
f010109d:	55                   	push   %ebp
f010109e:	89 e5                	mov    %esp,%ebp
f01010a0:	83 ec 10             	sub    $0x10,%esp
f01010a3:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01010aa:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01010ad:	89 c2                	mov    %eax,%edx
f01010af:	ec                   	in     (%dx),%al
f01010b0:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f01010b3:	8a 45 f7             	mov    -0x9(%ebp),%al
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
f01010b6:	0f b6 c0             	movzbl %al,%eax
f01010b9:	83 e0 01             	and    $0x1,%eax
f01010bc:	85 c0                	test   %eax,%eax
f01010be:	75 07                	jne    f01010c7 <serial_proc_data+0x2a>
		return -1;
f01010c0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01010c5:	eb 16                	jmp    f01010dd <serial_proc_data+0x40>
f01010c7:	c7 45 fc f8 03 00 00 	movl   $0x3f8,-0x4(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01010ce:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01010d1:	89 c2                	mov    %eax,%edx
f01010d3:	ec                   	in     (%dx),%al
f01010d4:	88 45 f6             	mov    %al,-0xa(%ebp)
	return data;
f01010d7:	8a 45 f6             	mov    -0xa(%ebp),%al
	return inb(COM1+COM_RX);
f01010da:	0f b6 c0             	movzbl %al,%eax
}
f01010dd:	c9                   	leave  
f01010de:	c3                   	ret    

f01010df <serial_intr>:

void
serial_intr(void)
{
f01010df:	55                   	push   %ebp
f01010e0:	89 e5                	mov    %esp,%ebp
f01010e2:	83 ec 08             	sub    $0x8,%esp
	if (serial_exists)
f01010e5:	a1 64 59 81 f0       	mov    0xf0815964,%eax
f01010ea:	85 c0                	test   %eax,%eax
f01010ec:	74 10                	je     f01010fe <serial_intr+0x1f>
		cons_intr(serial_proc_data);
f01010ee:	83 ec 0c             	sub    $0xc,%esp
f01010f1:	68 9d 10 10 f0       	push   $0xf010109d
f01010f6:	e8 ae 07 00 00       	call   f01018a9 <cons_intr>
f01010fb:	83 c4 10             	add    $0x10,%esp
}
f01010fe:	90                   	nop
f01010ff:	c9                   	leave  
f0101100:	c3                   	ret    

f0101101 <serial_interrupt_handler>:

void serial_interrupt_handler(struct Trapframe* tf)
{
f0101101:	55                   	push   %ebp
f0101102:	89 e5                	mov    %esp,%ebp
f0101104:	83 ec 08             	sub    $0x8,%esp
	cprintf("\nserial interrupt\n");
f0101107:	83 ec 0c             	sub    $0xc,%esp
f010110a:	68 34 ab 12 f0       	push   $0xf012ab34
f010110f:	e8 48 0a 00 00       	call   f0101b5c <cprintf>
f0101114:	83 c4 10             	add    $0x10,%esp
	serial_intr();
f0101117:	e8 c3 ff ff ff       	call   f01010df <serial_intr>
}
f010111c:	90                   	nop
f010111d:	c9                   	leave  
f010111e:	c3                   	ret    

f010111f <serial_init>:

void
serial_init(void)
{
f010111f:	55                   	push   %ebp
f0101120:	89 e5                	mov    %esp,%ebp
f0101122:	83 ec 48             	sub    $0x48,%esp
f0101125:	c7 45 f4 fa 03 00 00 	movl   $0x3fa,-0xc(%ebp)
f010112c:	c6 45 c6 00          	movb   $0x0,-0x3a(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0101130:	8a 45 c6             	mov    -0x3a(%ebp),%al
f0101133:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0101136:	ee                   	out    %al,(%dx)
f0101137:	c7 45 f0 fb 03 00 00 	movl   $0x3fb,-0x10(%ebp)
f010113e:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
f0101142:	8a 45 c7             	mov    -0x39(%ebp),%al
f0101145:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101148:	ee                   	out    %al,(%dx)
f0101149:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%ebp)
f0101150:	c6 45 c8 0c          	movb   $0xc,-0x38(%ebp)
f0101154:	8a 45 c8             	mov    -0x38(%ebp),%al
f0101157:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010115a:	ee                   	out    %al,(%dx)
f010115b:	c7 45 e8 f9 03 00 00 	movl   $0x3f9,-0x18(%ebp)
f0101162:	c6 45 c9 00          	movb   $0x0,-0x37(%ebp)
f0101166:	8a 45 c9             	mov    -0x37(%ebp),%al
f0101169:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010116c:	ee                   	out    %al,(%dx)
f010116d:	c7 45 e4 fb 03 00 00 	movl   $0x3fb,-0x1c(%ebp)
f0101174:	c6 45 ca 03          	movb   $0x3,-0x36(%ebp)
f0101178:	8a 45 ca             	mov    -0x36(%ebp),%al
f010117b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010117e:	ee                   	out    %al,(%dx)
f010117f:	c7 45 e0 fc 03 00 00 	movl   $0x3fc,-0x20(%ebp)
f0101186:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
f010118a:	8a 45 cb             	mov    -0x35(%ebp),%al
f010118d:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0101190:	ee                   	out    %al,(%dx)
f0101191:	c7 45 dc f9 03 00 00 	movl   $0x3f9,-0x24(%ebp)
f0101198:	c6 45 cc 01          	movb   $0x1,-0x34(%ebp)
f010119c:	8a 45 cc             	mov    -0x34(%ebp),%al
f010119f:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01011a2:	ee                   	out    %al,(%dx)
f01011a3:	c7 45 d8 fd 03 00 00 	movl   $0x3fd,-0x28(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01011aa:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01011ad:	89 c2                	mov    %eax,%edx
f01011af:	ec                   	in     (%dx),%al
f01011b0:	88 45 cd             	mov    %al,-0x33(%ebp)
	return data;
f01011b3:	8a 45 cd             	mov    -0x33(%ebp),%al
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
f01011b6:	3c ff                	cmp    $0xff,%al
f01011b8:	0f 95 c0             	setne  %al
f01011bb:	0f b6 c0             	movzbl %al,%eax
f01011be:	a3 64 59 81 f0       	mov    %eax,0xf0815964
f01011c3:	c7 45 d4 fa 03 00 00 	movl   $0x3fa,-0x2c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01011ca:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01011cd:	89 c2                	mov    %eax,%edx
f01011cf:	ec                   	in     (%dx),%al
f01011d0:	88 45 ce             	mov    %al,-0x32(%ebp)
f01011d3:	c7 45 d0 f8 03 00 00 	movl   $0x3f8,-0x30(%ebp)
f01011da:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01011dd:	89 c2                	mov    %eax,%edx
f01011df:	ec                   	in     (%dx),%al
f01011e0:	88 45 cf             	mov    %al,-0x31(%ebp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	irq_install_handler(4, &serial_interrupt_handler);
f01011e3:	83 ec 08             	sub    $0x8,%esp
f01011e6:	68 01 11 10 f0       	push   $0xf0101101
f01011eb:	6a 04                	push   $0x4
f01011ed:	e8 ce cf 00 00       	call   f010e1c0 <irq_install_handler>
f01011f2:	83 c4 10             	add    $0x10,%esp

}
f01011f5:	90                   	nop
f01011f6:	c9                   	leave  
f01011f7:	c3                   	ret    

f01011f8 <delay>:
// page.

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
f01011f8:	55                   	push   %ebp
f01011f9:	89 e5                	mov    %esp,%ebp
f01011fb:	83 ec 20             	sub    $0x20,%esp
f01011fe:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%ebp)
f0101205:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0101208:	89 c2                	mov    %eax,%edx
f010120a:	ec                   	in     (%dx),%al
f010120b:	88 45 ec             	mov    %al,-0x14(%ebp)
f010120e:	c7 45 f8 84 00 00 00 	movl   $0x84,-0x8(%ebp)
f0101215:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0101218:	89 c2                	mov    %eax,%edx
f010121a:	ec                   	in     (%dx),%al
f010121b:	88 45 ed             	mov    %al,-0x13(%ebp)
f010121e:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%ebp)
f0101225:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101228:	89 c2                	mov    %eax,%edx
f010122a:	ec                   	in     (%dx),%al
f010122b:	88 45 ee             	mov    %al,-0x12(%ebp)
f010122e:	c7 45 f0 84 00 00 00 	movl   $0x84,-0x10(%ebp)
f0101235:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101238:	89 c2                	mov    %eax,%edx
f010123a:	ec                   	in     (%dx),%al
f010123b:	88 45 ef             	mov    %al,-0x11(%ebp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
f010123e:	90                   	nop
f010123f:	c9                   	leave  
f0101240:	c3                   	ret    

f0101241 <lpt_putc>:

static void
lpt_putc(int c)
{
f0101241:	55                   	push   %ebp
f0101242:	89 e5                	mov    %esp,%ebp
f0101244:	83 ec 20             	sub    $0x20,%esp
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f0101247:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f010124e:	eb 08                	jmp    f0101258 <lpt_putc+0x17>
		delay();
f0101250:	e8 a3 ff ff ff       	call   f01011f8 <delay>
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f0101255:	ff 45 fc             	incl   -0x4(%ebp)
f0101258:	c7 45 ec 79 03 00 00 	movl   $0x379,-0x14(%ebp)
f010125f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101262:	89 c2                	mov    %eax,%edx
f0101264:	ec                   	in     (%dx),%al
f0101265:	88 45 eb             	mov    %al,-0x15(%ebp)
	return data;
f0101268:	8a 45 eb             	mov    -0x15(%ebp),%al
f010126b:	84 c0                	test   %al,%al
f010126d:	78 09                	js     f0101278 <lpt_putc+0x37>
f010126f:	81 7d fc ef 0a 00 00 	cmpl   $0xaef,-0x4(%ebp)
f0101276:	7e d8                	jle    f0101250 <lpt_putc+0xf>
		delay();
	outb(0x378+0, c);
f0101278:	8b 45 08             	mov    0x8(%ebp),%eax
f010127b:	0f b6 c0             	movzbl %al,%eax
f010127e:	c7 45 f4 78 03 00 00 	movl   $0x378,-0xc(%ebp)
f0101285:	88 45 e8             	mov    %al,-0x18(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0101288:	8a 45 e8             	mov    -0x18(%ebp),%al
f010128b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010128e:	ee                   	out    %al,(%dx)
f010128f:	c7 45 f0 7a 03 00 00 	movl   $0x37a,-0x10(%ebp)
f0101296:	c6 45 e9 0d          	movb   $0xd,-0x17(%ebp)
f010129a:	8a 45 e9             	mov    -0x17(%ebp),%al
f010129d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01012a0:	ee                   	out    %al,(%dx)
f01012a1:	c7 45 f8 7a 03 00 00 	movl   $0x37a,-0x8(%ebp)
f01012a8:	c6 45 ea 08          	movb   $0x8,-0x16(%ebp)
f01012ac:	8a 45 ea             	mov    -0x16(%ebp),%al
f01012af:	8b 55 f8             	mov    -0x8(%ebp),%edx
f01012b2:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
f01012b3:	90                   	nop
f01012b4:	c9                   	leave  
f01012b5:	c3                   	ret    

f01012b6 <cga_init>:
static uint16 *crt_buf;
static uint16 crt_pos;

void
cga_init(void)
{
f01012b6:	55                   	push   %ebp
f01012b7:	89 e5                	mov    %esp,%ebp
f01012b9:	83 ec 20             	sub    $0x20,%esp
	volatile uint16 *cp;
	uint16 was;
	unsigned pos;

	cp = (uint16*) (KERNEL_BASE + CGA_BUF);
f01012bc:	c7 45 fc 00 80 0b f0 	movl   $0xf00b8000,-0x4(%ebp)
	was = *cp;
f01012c3:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01012c6:	66 8b 00             	mov    (%eax),%ax
f01012c9:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
	*cp = (uint16) 0xA55A;
f01012cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01012d0:	66 c7 00 5a a5       	movw   $0xa55a,(%eax)
	if (*cp != 0xA55A) {
f01012d5:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01012d8:	66 8b 00             	mov    (%eax),%ax
f01012db:	66 3d 5a a5          	cmp    $0xa55a,%ax
f01012df:	74 13                	je     f01012f4 <cga_init+0x3e>
		cp = (uint16*) (KERNEL_BASE + MONO_BUF);
f01012e1:	c7 45 fc 00 00 0b f0 	movl   $0xf00b0000,-0x4(%ebp)
		addr_6845 = MONO_BASE;
f01012e8:	c7 05 68 59 81 f0 b4 	movl   $0x3b4,0xf0815968
f01012ef:	03 00 00 
f01012f2:	eb 14                	jmp    f0101308 <cga_init+0x52>
	} else {
		*cp = was;
f01012f4:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01012f7:	66 8b 45 fa          	mov    -0x6(%ebp),%ax
f01012fb:	66 89 02             	mov    %ax,(%edx)
		addr_6845 = CGA_BASE;
f01012fe:	c7 05 68 59 81 f0 d4 	movl   $0x3d4,0xf0815968
f0101305:	03 00 00 
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
f0101308:	a1 68 59 81 f0       	mov    0xf0815968,%eax
f010130d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0101310:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
f0101314:	8a 45 e0             	mov    -0x20(%ebp),%al
f0101317:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010131a:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
f010131b:	a1 68 59 81 f0       	mov    0xf0815968,%eax
f0101320:	40                   	inc    %eax
f0101321:	89 45 ec             	mov    %eax,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0101324:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101327:	89 c2                	mov    %eax,%edx
f0101329:	ec                   	in     (%dx),%al
f010132a:	88 45 e1             	mov    %al,-0x1f(%ebp)
	return data;
f010132d:	8a 45 e1             	mov    -0x1f(%ebp),%al
f0101330:	0f b6 c0             	movzbl %al,%eax
f0101333:	c1 e0 08             	shl    $0x8,%eax
f0101336:	89 45 f0             	mov    %eax,-0x10(%ebp)
	outb(addr_6845, 15);
f0101339:	a1 68 59 81 f0       	mov    0xf0815968,%eax
f010133e:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0101341:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0101345:	8a 45 e2             	mov    -0x1e(%ebp),%al
f0101348:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010134b:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
f010134c:	a1 68 59 81 f0       	mov    0xf0815968,%eax
f0101351:	40                   	inc    %eax
f0101352:	89 45 e4             	mov    %eax,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0101355:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101358:	89 c2                	mov    %eax,%edx
f010135a:	ec                   	in     (%dx),%al
f010135b:	88 45 e3             	mov    %al,-0x1d(%ebp)
	return data;
f010135e:	8a 45 e3             	mov    -0x1d(%ebp),%al
f0101361:	0f b6 c0             	movzbl %al,%eax
f0101364:	09 45 f0             	or     %eax,-0x10(%ebp)

	crt_buf = (uint16*) cp;
f0101367:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010136a:	a3 6c 59 81 f0       	mov    %eax,0xf081596c
	crt_pos = pos;
f010136f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101372:	66 a3 70 59 81 f0    	mov    %ax,0xf0815970
}
f0101378:	90                   	nop
f0101379:	c9                   	leave  
f010137a:	c3                   	ret    

f010137b <cga_putc>:

//2016: Preliminary backward and forward cursor movement was added to FOS
// 		Thanks to student Abdullah Mohammad Ma3en, 3rd year, and TA Ghada Hamed.
void
cga_putc(int c)
{
f010137b:	55                   	push   %ebp
f010137c:	89 e5                	mov    %esp,%ebp
f010137e:	53                   	push   %ebx
f010137f:	83 ec 24             	sub    $0x24,%esp
	// if no attribute given, then use the text color
	if (!(c & ~0xFF))
f0101382:	8b 45 08             	mov    0x8(%ebp),%eax
f0101385:	b0 00                	mov    $0x0,%al
f0101387:	85 c0                	test   %eax,%eax
f0101389:	75 18                	jne    f01013a3 <cga_putc+0x28>
	{
		c |= current_text_color == 0? 0x700 : current_text_color;
f010138b:	a1 f0 6a 85 f0       	mov    0xf0856af0,%eax
f0101390:	85 c0                	test   %eax,%eax
f0101392:	74 07                	je     f010139b <cga_putc+0x20>
f0101394:	a1 f0 6a 85 f0       	mov    0xf0856af0,%eax
f0101399:	eb 05                	jmp    f01013a0 <cga_putc+0x25>
f010139b:	b8 00 07 00 00       	mov    $0x700,%eax
f01013a0:	09 45 08             	or     %eax,0x8(%ebp)
		//c |= 0x700; /*black and white*/
	}
	switch (c & 0xff) {
f01013a3:	8b 45 08             	mov    0x8(%ebp),%eax
f01013a6:	0f b6 c0             	movzbl %al,%eax
f01013a9:	83 f8 0a             	cmp    $0xa,%eax
f01013ac:	74 77                	je     f0101425 <cga_putc+0xaa>
f01013ae:	83 f8 0a             	cmp    $0xa,%eax
f01013b1:	7f 13                	jg     f01013c6 <cga_putc+0x4b>
f01013b3:	83 f8 08             	cmp    $0x8,%eax
f01013b6:	74 2e                	je     f01013e6 <cga_putc+0x6b>
f01013b8:	83 f8 09             	cmp    $0x9,%eax
f01013bb:	0f 84 a8 00 00 00    	je     f0101469 <cga_putc+0xee>
f01013c1:	e9 22 01 00 00       	jmp    f01014e8 <cga_putc+0x16d>
f01013c6:	3d e4 00 00 00       	cmp    $0xe4,%eax
f01013cb:	0f 84 de 00 00 00    	je     f01014af <cga_putc+0x134>
f01013d1:	3d e5 00 00 00       	cmp    $0xe5,%eax
f01013d6:	0f 84 f1 00 00 00    	je     f01014cd <cga_putc+0x152>
f01013dc:	83 f8 0d             	cmp    $0xd,%eax
f01013df:	74 5d                	je     f010143e <cga_putc+0xc3>
f01013e1:	e9 02 01 00 00       	jmp    f01014e8 <cga_putc+0x16d>
	case '\b':
		if (crt_pos > 0) {
f01013e6:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f01013ec:	66 85 c0             	test   %ax,%ax
f01013ef:	0f 84 4f 01 00 00    	je     f0101544 <cga_putc+0x1c9>
			crt_pos--;
f01013f5:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f01013fb:	48                   	dec    %eax
f01013fc:	66 a3 70 59 81 f0    	mov    %ax,0xf0815970
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
f0101402:	8b 15 6c 59 81 f0    	mov    0xf081596c,%edx
f0101408:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f010140e:	0f b7 c0             	movzwl %ax,%eax
f0101411:	01 c0                	add    %eax,%eax
f0101413:	01 c2                	add    %eax,%edx
f0101415:	8b 45 08             	mov    0x8(%ebp),%eax
f0101418:	b0 00                	mov    $0x0,%al
f010141a:	83 c8 20             	or     $0x20,%eax
f010141d:	66 89 02             	mov    %ax,(%edx)
		}
		break;
f0101420:	e9 1f 01 00 00       	jmp    f0101544 <cga_putc+0x1c9>
	case '\n':
		crt_pos += CRT_COLS;
f0101425:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f010142b:	83 c0 50             	add    $0x50,%eax
f010142e:	66 a3 70 59 81 f0    	mov    %ax,0xf0815970
		text_length = 0;
f0101434:	c7 05 60 59 81 f0 00 	movl   $0x0,0xf0815960
f010143b:	00 00 00 
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
f010143e:	66 8b 0d 70 59 81 f0 	mov    0xf0815970,%cx
f0101445:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f010144b:	bb 50 00 00 00       	mov    $0x50,%ebx
f0101450:	ba 00 00 00 00       	mov    $0x0,%edx
f0101455:	66 f7 f3             	div    %bx
f0101458:	89 d0                	mov    %edx,%eax
f010145a:	29 c1                	sub    %eax,%ecx
f010145c:	89 c8                	mov    %ecx,%eax
f010145e:	66 a3 70 59 81 f0    	mov    %ax,0xf0815970
		break;
f0101464:	e9 e5 00 00 00       	jmp    f010154e <cga_putc+0x1d3>
	case '\t':
		cons_putc(' ');
f0101469:	83 ec 0c             	sub    $0xc,%esp
f010146c:	6a 20                	push   $0x20
f010146e:	e8 30 05 00 00       	call   f01019a3 <cons_putc>
f0101473:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f0101476:	83 ec 0c             	sub    $0xc,%esp
f0101479:	6a 20                	push   $0x20
f010147b:	e8 23 05 00 00       	call   f01019a3 <cons_putc>
f0101480:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f0101483:	83 ec 0c             	sub    $0xc,%esp
f0101486:	6a 20                	push   $0x20
f0101488:	e8 16 05 00 00       	call   f01019a3 <cons_putc>
f010148d:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f0101490:	83 ec 0c             	sub    $0xc,%esp
f0101493:	6a 20                	push   $0x20
f0101495:	e8 09 05 00 00       	call   f01019a3 <cons_putc>
f010149a:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f010149d:	83 ec 0c             	sub    $0xc,%esp
f01014a0:	6a 20                	push   $0x20
f01014a2:	e8 fc 04 00 00       	call   f01019a3 <cons_putc>
f01014a7:	83 c4 10             	add    $0x10,%esp
		break;
f01014aa:	e9 9f 00 00 00       	jmp    f010154e <cga_putc+0x1d3>
	case KEY_LF:
		if(crt_pos>0)
f01014af:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f01014b5:	66 85 c0             	test   %ax,%ax
f01014b8:	0f 84 89 00 00 00    	je     f0101547 <cga_putc+0x1cc>
			crt_pos--;
f01014be:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f01014c4:	48                   	dec    %eax
f01014c5:	66 a3 70 59 81 f0    	mov    %ax,0xf0815970
		break;
f01014cb:	eb 7a                	jmp    f0101547 <cga_putc+0x1cc>
	case KEY_RT:
		if (crt_pos < CRT_SIZE)
f01014cd:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f01014d3:	66 3d cf 07          	cmp    $0x7cf,%ax
f01014d7:	77 71                	ja     f010154a <cga_putc+0x1cf>
			crt_pos++;
f01014d9:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f01014df:	40                   	inc    %eax
f01014e0:	66 a3 70 59 81 f0    	mov    %ax,0xf0815970
		break;
f01014e6:	eb 62                	jmp    f010154a <cga_putc+0x1cf>
	default: {
		if (c != KEY_LF && c != KEY_RT) {
f01014e8:	81 7d 08 e4 00 00 00 	cmpl   $0xe4,0x8(%ebp)
f01014ef:	74 5c                	je     f010154d <cga_putc+0x1d2>
f01014f1:	81 7d 08 e5 00 00 00 	cmpl   $0xe5,0x8(%ebp)
f01014f8:	74 53                	je     f010154d <cga_putc+0x1d2>
			crt_buf[crt_pos++] = c;		/* write the character */
f01014fa:	8b 0d 6c 59 81 f0    	mov    0xf081596c,%ecx
f0101500:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f0101506:	8d 50 01             	lea    0x1(%eax),%edx
f0101509:	66 89 15 70 59 81 f0 	mov    %dx,0xf0815970
f0101510:	0f b7 c0             	movzwl %ax,%eax
f0101513:	01 c0                	add    %eax,%eax
f0101515:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0101518:	8b 45 08             	mov    0x8(%ebp),%eax
f010151b:	66 89 02             	mov    %ax,(%edx)
			if (crt_pos > 1920 + text_length)
f010151e:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f0101524:	0f b7 c0             	movzwl %ax,%eax
f0101527:	8b 15 60 59 81 f0    	mov    0xf0815960,%edx
f010152d:	81 c2 80 07 00 00    	add    $0x780,%edx
f0101533:	39 d0                	cmp    %edx,%eax
f0101535:	7e 16                	jle    f010154d <cga_putc+0x1d2>
				text_length++;
f0101537:	a1 60 59 81 f0       	mov    0xf0815960,%eax
f010153c:	40                   	inc    %eax
f010153d:	a3 60 59 81 f0       	mov    %eax,0xf0815960
		}
		break;
f0101542:	eb 09                	jmp    f010154d <cga_putc+0x1d2>
	case '\b':
		if (crt_pos > 0) {
			crt_pos--;
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
		}
		break;
f0101544:	90                   	nop
f0101545:	eb 07                	jmp    f010154e <cga_putc+0x1d3>
		cons_putc(' ');
		break;
	case KEY_LF:
		if(crt_pos>0)
			crt_pos--;
		break;
f0101547:	90                   	nop
f0101548:	eb 04                	jmp    f010154e <cga_putc+0x1d3>
	case KEY_RT:
		if (crt_pos < CRT_SIZE)
			crt_pos++;
		break;
f010154a:	90                   	nop
f010154b:	eb 01                	jmp    f010154e <cga_putc+0x1d3>
		if (c != KEY_LF && c != KEY_RT) {
			crt_buf[crt_pos++] = c;		/* write the character */
			if (crt_pos > 1920 + text_length)
				text_length++;
		}
		break;
f010154d:	90                   	nop
	}
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
f010154e:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f0101554:	66 3d cf 07          	cmp    $0x7cf,%ax
f0101558:	76 58                	jbe    f01015b2 <cga_putc+0x237>
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
f010155a:	a1 6c 59 81 f0       	mov    0xf081596c,%eax
f010155f:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
f0101565:	a1 6c 59 81 f0       	mov    0xf081596c,%eax
f010156a:	83 ec 04             	sub    $0x4,%esp
f010156d:	68 00 0f 00 00       	push   $0xf00
f0101572:	52                   	push   %edx
f0101573:	50                   	push   %eax
f0101574:	e8 93 97 01 00       	call   f011ad0c <memcpy>
f0101579:	83 c4 10             	add    $0x10,%esp
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f010157c:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
f0101583:	eb 15                	jmp    f010159a <cga_putc+0x21f>
			crt_buf[i] = 0x0700 | ' ';
f0101585:	8b 15 6c 59 81 f0    	mov    0xf081596c,%edx
f010158b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010158e:	01 c0                	add    %eax,%eax
f0101590:	01 d0                	add    %edx,%eax
f0101592:	66 c7 00 20 07       	movw   $0x720,(%eax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f0101597:	ff 45 f4             	incl   -0xc(%ebp)
f010159a:	81 7d f4 cf 07 00 00 	cmpl   $0x7cf,-0xc(%ebp)
f01015a1:	7e e2                	jle    f0101585 <cga_putc+0x20a>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
f01015a3:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f01015a9:	83 e8 50             	sub    $0x50,%eax
f01015ac:	66 a3 70 59 81 f0    	mov    %ax,0xf0815970
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
f01015b2:	a1 68 59 81 f0       	mov    0xf0815968,%eax
f01015b7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01015ba:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01015be:	8a 45 e0             	mov    -0x20(%ebp),%al
f01015c1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01015c4:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
f01015c5:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f01015cb:	66 c1 e8 08          	shr    $0x8,%ax
f01015cf:	0f b6 c0             	movzbl %al,%eax
f01015d2:	8b 15 68 59 81 f0    	mov    0xf0815968,%edx
f01015d8:	42                   	inc    %edx
f01015d9:	89 55 ec             	mov    %edx,-0x14(%ebp)
f01015dc:	88 45 e1             	mov    %al,-0x1f(%ebp)
f01015df:	8a 45 e1             	mov    -0x1f(%ebp),%al
f01015e2:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01015e5:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
f01015e6:	a1 68 59 81 f0       	mov    0xf0815968,%eax
f01015eb:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01015ee:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
f01015f2:	8a 45 e2             	mov    -0x1e(%ebp),%al
f01015f5:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01015f8:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
f01015f9:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f01015ff:	0f b6 c0             	movzbl %al,%eax
f0101602:	8b 15 68 59 81 f0    	mov    0xf0815968,%edx
f0101608:	42                   	inc    %edx
f0101609:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f010160c:	88 45 e3             	mov    %al,-0x1d(%ebp)
f010160f:	8a 45 e3             	mov    -0x1d(%ebp),%al
f0101612:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0101615:	ee                   	out    %al,(%dx)
}
f0101616:	90                   	nop
f0101617:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010161a:	c9                   	leave  
f010161b:	c3                   	ret    

f010161c <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
f010161c:	55                   	push   %ebp
f010161d:	89 e5                	mov    %esp,%ebp
f010161f:	83 ec 28             	sub    $0x28,%esp
f0101622:	c7 45 dc 64 00 00 00 	movl   $0x64,-0x24(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0101629:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010162c:	89 c2                	mov    %eax,%edx
f010162e:	ec                   	in     (%dx),%al
f010162f:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0101632:	8a 45 db             	mov    -0x25(%ebp),%al
	int c;
	uint8 data;
	static uint32 shift;

	if ((inb(KBSTATP) & KBS_DIB) == 0)
f0101635:	0f b6 c0             	movzbl %al,%eax
f0101638:	83 e0 01             	and    $0x1,%eax
f010163b:	85 c0                	test   %eax,%eax
f010163d:	75 0a                	jne    f0101649 <kbd_proc_data+0x2d>
		return -1;
f010163f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0101644:	e9 2a 02 00 00       	jmp    f0101873 <kbd_proc_data+0x257>
f0101649:	c7 45 e4 60 00 00 00 	movl   $0x60,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0101650:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101653:	89 c2                	mov    %eax,%edx
f0101655:	ec                   	in     (%dx),%al
f0101656:	88 45 da             	mov    %al,-0x26(%ebp)
	return data;
f0101659:	8a 45 da             	mov    -0x26(%ebp),%al

	data = inb(KBDATAP);
f010165c:	88 45 f3             	mov    %al,-0xd(%ebp)

	if (data == 0xE0) {
f010165f:	80 7d f3 e0          	cmpb   $0xe0,-0xd(%ebp)
f0101663:	75 17                	jne    f010167c <kbd_proc_data+0x60>
		// E0 escape character
		shift |= E0ESC;
f0101665:	a1 88 5b 81 f0       	mov    0xf0815b88,%eax
f010166a:	83 c8 40             	or     $0x40,%eax
f010166d:	a3 88 5b 81 f0       	mov    %eax,0xf0815b88
		return 0;
f0101672:	b8 00 00 00 00       	mov    $0x0,%eax
f0101677:	e9 f7 01 00 00       	jmp    f0101873 <kbd_proc_data+0x257>
	} else if (data & 0x80) {
f010167c:	8a 45 f3             	mov    -0xd(%ebp),%al
f010167f:	84 c0                	test   %al,%al
f0101681:	79 44                	jns    f01016c7 <kbd_proc_data+0xab>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
f0101683:	a1 88 5b 81 f0       	mov    0xf0815b88,%eax
f0101688:	83 e0 40             	and    $0x40,%eax
f010168b:	85 c0                	test   %eax,%eax
f010168d:	75 08                	jne    f0101697 <kbd_proc_data+0x7b>
f010168f:	8a 45 f3             	mov    -0xd(%ebp),%al
f0101692:	83 e0 7f             	and    $0x7f,%eax
f0101695:	eb 03                	jmp    f010169a <kbd_proc_data+0x7e>
f0101697:	8a 45 f3             	mov    -0xd(%ebp),%al
f010169a:	88 45 f3             	mov    %al,-0xd(%ebp)
		shift &= ~(shiftcode[data] | E0ESC);
f010169d:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f01016a1:	8a 80 40 f0 17 f0    	mov    -0xfe80fc0(%eax),%al
f01016a7:	83 c8 40             	or     $0x40,%eax
f01016aa:	0f b6 c0             	movzbl %al,%eax
f01016ad:	f7 d0                	not    %eax
f01016af:	89 c2                	mov    %eax,%edx
f01016b1:	a1 88 5b 81 f0       	mov    0xf0815b88,%eax
f01016b6:	21 d0                	and    %edx,%eax
f01016b8:	a3 88 5b 81 f0       	mov    %eax,0xf0815b88
		return 0;
f01016bd:	b8 00 00 00 00       	mov    $0x0,%eax
f01016c2:	e9 ac 01 00 00       	jmp    f0101873 <kbd_proc_data+0x257>
	} else if (shift & E0ESC) {
f01016c7:	a1 88 5b 81 f0       	mov    0xf0815b88,%eax
f01016cc:	83 e0 40             	and    $0x40,%eax
f01016cf:	85 c0                	test   %eax,%eax
f01016d1:	74 11                	je     f01016e4 <kbd_proc_data+0xc8>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
f01016d3:	80 4d f3 80          	orb    $0x80,-0xd(%ebp)
		shift &= ~E0ESC;
f01016d7:	a1 88 5b 81 f0       	mov    0xf0815b88,%eax
f01016dc:	83 e0 bf             	and    $0xffffffbf,%eax
f01016df:	a3 88 5b 81 f0       	mov    %eax,0xf0815b88
	}

	shift |= shiftcode[data];
f01016e4:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f01016e8:	8a 80 40 f0 17 f0    	mov    -0xfe80fc0(%eax),%al
f01016ee:	0f b6 d0             	movzbl %al,%edx
f01016f1:	a1 88 5b 81 f0       	mov    0xf0815b88,%eax
f01016f6:	09 d0                	or     %edx,%eax
f01016f8:	a3 88 5b 81 f0       	mov    %eax,0xf0815b88
	shift ^= togglecode[data];
f01016fd:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0101701:	8a 80 40 f1 17 f0    	mov    -0xfe80ec0(%eax),%al
f0101707:	0f b6 d0             	movzbl %al,%edx
f010170a:	a1 88 5b 81 f0       	mov    0xf0815b88,%eax
f010170f:	31 d0                	xor    %edx,%eax
f0101711:	a3 88 5b 81 f0       	mov    %eax,0xf0815b88

	c = charcode[shift & (CTL | SHIFT)][data];
f0101716:	a1 88 5b 81 f0       	mov    0xf0815b88,%eax
f010171b:	83 e0 03             	and    $0x3,%eax
f010171e:	8b 14 85 40 f5 17 f0 	mov    -0xfe80ac0(,%eax,4),%edx
f0101725:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0101729:	01 d0                	add    %edx,%eax
f010172b:	8a 00                	mov    (%eax),%al
f010172d:	0f b6 c0             	movzbl %al,%eax
f0101730:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (c == KEY_DEL) {
f0101733:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f010173a:	0f 85 9c 00 00 00    	jne    f01017dc <kbd_proc_data+0x1c0>
		if (text_length > 0) {
f0101740:	a1 60 59 81 f0       	mov    0xf0815960,%eax
f0101745:	85 c0                	test   %eax,%eax
f0101747:	0f 8e 85 00 00 00    	jle    f01017d2 <kbd_proc_data+0x1b6>
			if (crt_pos == 1920 + text_length)
f010174d:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f0101753:	0f b7 c0             	movzwl %ax,%eax
f0101756:	8b 15 60 59 81 f0    	mov    0xf0815960,%edx
f010175c:	81 c2 80 07 00 00    	add    $0x780,%edx
f0101762:	39 d0                	cmp    %edx,%eax
f0101764:	75 0a                	jne    f0101770 <kbd_proc_data+0x154>
				return 0;
f0101766:	b8 00 00 00 00       	mov    $0x0,%eax
f010176b:	e9 03 01 00 00       	jmp    f0101873 <kbd_proc_data+0x257>
			else {
				text_length--;
f0101770:	a1 60 59 81 f0       	mov    0xf0815960,%eax
f0101775:	48                   	dec    %eax
f0101776:	a3 60 59 81 f0       	mov    %eax,0xf0815960
				int crt_pos_Length = crt_pos - 1925;
f010177b:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f0101781:	0f b7 c0             	movzwl %ax,%eax
f0101784:	2d 85 07 00 00       	sub    $0x785,%eax
f0101789:	89 45 ec             	mov    %eax,-0x14(%ebp)
				for (int i = crt_pos; crt_pos_Length <= text_length;
f010178c:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f0101792:	0f b7 c0             	movzwl %ax,%eax
f0101795:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0101798:	eb 26                	jmp    f01017c0 <kbd_proc_data+0x1a4>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
f010179a:	8b 15 6c 59 81 f0    	mov    0xf081596c,%edx
f01017a0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01017a3:	01 c0                	add    %eax,%eax
f01017a5:	01 c2                	add    %eax,%edx
f01017a7:	a1 6c 59 81 f0       	mov    0xf081596c,%eax
f01017ac:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f01017af:	41                   	inc    %ecx
f01017b0:	01 c9                	add    %ecx,%ecx
f01017b2:	01 c8                	add    %ecx,%eax
f01017b4:	66 8b 00             	mov    (%eax),%ax
f01017b7:	66 89 02             	mov    %ax,(%edx)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
						++i, crt_pos_Length++) {
f01017ba:	ff 45 e8             	incl   -0x18(%ebp)
f01017bd:	ff 45 ec             	incl   -0x14(%ebp)
			if (crt_pos == 1920 + text_length)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
f01017c0:	a1 60 59 81 f0       	mov    0xf0815960,%eax
f01017c5:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f01017c8:	7e d0                	jle    f010179a <kbd_proc_data+0x17e>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
				}
				return c;
f01017ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01017cd:	e9 a1 00 00 00       	jmp    f0101873 <kbd_proc_data+0x257>
			}
		}
		return 0;
f01017d2:	b8 00 00 00 00       	mov    $0x0,%eax
f01017d7:	e9 97 00 00 00       	jmp    f0101873 <kbd_proc_data+0x257>
	}
	if (shift & CAPSLOCK) {
f01017dc:	a1 88 5b 81 f0       	mov    0xf0815b88,%eax
f01017e1:	83 e0 08             	and    $0x8,%eax
f01017e4:	85 c0                	test   %eax,%eax
f01017e6:	74 22                	je     f010180a <kbd_proc_data+0x1ee>
		if ('a' <= c && c <= 'z')
f01017e8:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
f01017ec:	7e 0c                	jle    f01017fa <kbd_proc_data+0x1de>
f01017ee:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
f01017f2:	7f 06                	jg     f01017fa <kbd_proc_data+0x1de>
			c += 'A' - 'a';
f01017f4:	83 6d f4 20          	subl   $0x20,-0xc(%ebp)
f01017f8:	eb 10                	jmp    f010180a <kbd_proc_data+0x1ee>
		else if ('A' <= c && c <= 'Z')
f01017fa:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
f01017fe:	7e 0a                	jle    f010180a <kbd_proc_data+0x1ee>
f0101800:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
f0101804:	7f 04                	jg     f010180a <kbd_proc_data+0x1ee>
			c += 'a' - 'A';
f0101806:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
	}

	// Process special keys
	if ((int) shift == NUMLOCK && c >= '0' && c <= '9')
f010180a:	a1 88 5b 81 f0       	mov    0xf0815b88,%eax
f010180f:	83 f8 10             	cmp    $0x10,%eax
f0101812:	75 13                	jne    f0101827 <kbd_proc_data+0x20b>
f0101814:	83 7d f4 2f          	cmpl   $0x2f,-0xc(%ebp)
f0101818:	7e 0d                	jle    f0101827 <kbd_proc_data+0x20b>
f010181a:	83 7d f4 39          	cmpl   $0x39,-0xc(%ebp)
f010181e:	7f 07                	jg     f0101827 <kbd_proc_data+0x20b>
		return 0;
f0101820:	b8 00 00 00 00       	mov    $0x0,%eax
f0101825:	eb 4c                	jmp    f0101873 <kbd_proc_data+0x257>
	if (c == 255)
f0101827:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f010182e:	75 07                	jne    f0101837 <kbd_proc_data+0x21b>
		return 0;
f0101830:	b8 00 00 00 00       	mov    $0x0,%eax
f0101835:	eb 3c                	jmp    f0101873 <kbd_proc_data+0x257>
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
f0101837:	a1 88 5b 81 f0       	mov    0xf0815b88,%eax
f010183c:	f7 d0                	not    %eax
f010183e:	83 e0 06             	and    $0x6,%eax
f0101841:	85 c0                	test   %eax,%eax
f0101843:	75 2b                	jne    f0101870 <kbd_proc_data+0x254>
f0101845:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f010184c:	75 22                	jne    f0101870 <kbd_proc_data+0x254>
		cprintf("Rebooting!\n");
f010184e:	83 ec 0c             	sub    $0xc,%esp
f0101851:	68 47 ab 12 f0       	push   $0xf012ab47
f0101856:	e8 01 03 00 00       	call   f0101b5c <cprintf>
f010185b:	83 c4 10             	add    $0x10,%esp
f010185e:	c7 45 e0 92 00 00 00 	movl   $0x92,-0x20(%ebp)
f0101865:	c6 45 d9 03          	movb   $0x3,-0x27(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0101869:	8a 45 d9             	mov    -0x27(%ebp),%al
f010186c:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010186f:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}

	return c;
f0101870:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0101873:	c9                   	leave  
f0101874:	c3                   	ret    

f0101875 <kbd_intr>:

void
kbd_intr(void)
{
f0101875:	55                   	push   %ebp
f0101876:	89 e5                	mov    %esp,%ebp
f0101878:	83 ec 08             	sub    $0x8,%esp
	cons_intr(kbd_proc_data);
f010187b:	83 ec 0c             	sub    $0xc,%esp
f010187e:	68 1c 16 10 f0       	push   $0xf010161c
f0101883:	e8 21 00 00 00       	call   f01018a9 <cons_intr>
f0101888:	83 c4 10             	add    $0x10,%esp
}
f010188b:	90                   	nop
f010188c:	c9                   	leave  
f010188d:	c3                   	ret    

f010188e <kbd_init>:

void
kbd_init(void)
{
f010188e:	55                   	push   %ebp
f010188f:	89 e5                	mov    %esp,%ebp
f0101891:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(1, &keyboard_interrupt_handler);
f0101894:	83 ec 08             	sub    $0x8,%esp
f0101897:	68 73 1a 10 f0       	push   $0xf0101a73
f010189c:	6a 01                	push   $0x1
f010189e:	e8 1d c9 00 00       	call   f010e1c0 <irq_install_handler>
f01018a3:	83 c4 10             	add    $0x10,%esp
	}
	else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&KBDsem, 0, "keyboard semaphore");
	}
}
f01018a6:	90                   	nop
f01018a7:	c9                   	leave  
f01018a8:	c3                   	ret    

f01018a9 <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
void
cons_intr(int (*proc)(void))
{
f01018a9:	55                   	push   %ebp
f01018aa:	89 e5                	mov    %esp,%ebp
f01018ac:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = (*proc)()) != -1) {
f01018af:	eb 35                	jmp    f01018e6 <cons_intr+0x3d>
		if (c == 0)
f01018b1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01018b5:	75 02                	jne    f01018b9 <cons_intr+0x10>
			continue;
f01018b7:	eb 2d                	jmp    f01018e6 <cons_intr+0x3d>
		cons.buf[cons.wpos++] = c;
f01018b9:	a1 84 5b 81 f0       	mov    0xf0815b84,%eax
f01018be:	8d 50 01             	lea    0x1(%eax),%edx
f01018c1:	89 15 84 5b 81 f0    	mov    %edx,0xf0815b84
f01018c7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01018ca:	88 90 80 59 81 f0    	mov    %dl,-0xf7ea680(%eax)
		if (cons.wpos == CONSBUFSIZE)
f01018d0:	a1 84 5b 81 f0       	mov    0xf0815b84,%eax
f01018d5:	3d 00 02 00 00       	cmp    $0x200,%eax
f01018da:	75 0a                	jne    f01018e6 <cons_intr+0x3d>
			cons.wpos = 0;
f01018dc:	c7 05 84 5b 81 f0 00 	movl   $0x0,0xf0815b84
f01018e3:	00 00 00 
void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
f01018e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01018e9:	ff d0                	call   *%eax
f01018eb:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01018ee:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
f01018f2:	75 bd                	jne    f01018b1 <cons_intr+0x8>
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;

		//cprintf("\nCHAR %d is written into cons.buf\n", c);
	}
}
f01018f4:	90                   	nop
f01018f5:	c9                   	leave  
f01018f6:	c3                   	ret    

f01018f7 <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
f01018f7:	55                   	push   %ebp
f01018f8:	89 e5                	mov    %esp,%ebp
f01018fa:	83 ec 18             	sub    $0x18,%esp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
f01018fd:	e8 dd f7 ff ff       	call   f01010df <serial_intr>
	kbd_intr();
f0101902:	e8 6e ff ff ff       	call   f0101875 <kbd_intr>

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
f0101907:	8b 15 80 5b 81 f0    	mov    0xf0815b80,%edx
f010190d:	a1 84 5b 81 f0       	mov    0xf0815b84,%eax
f0101912:	39 c2                	cmp    %eax,%edx
f0101914:	74 35                	je     f010194b <cons_getc+0x54>
		c = cons.buf[cons.rpos++];
f0101916:	a1 80 5b 81 f0       	mov    0xf0815b80,%eax
f010191b:	8d 50 01             	lea    0x1(%eax),%edx
f010191e:	89 15 80 5b 81 f0    	mov    %edx,0xf0815b80
f0101924:	8a 80 80 59 81 f0    	mov    -0xf7ea680(%eax),%al
f010192a:	0f b6 c0             	movzbl %al,%eax
f010192d:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0101930:	a1 80 5b 81 f0       	mov    0xf0815b80,%eax
f0101935:	3d 00 02 00 00       	cmp    $0x200,%eax
f010193a:	75 0a                	jne    f0101946 <cons_getc+0x4f>
			cons.rpos = 0;
f010193c:	c7 05 80 5b 81 f0 00 	movl   $0x0,0xf0815b80
f0101943:	00 00 00 
		return c;
f0101946:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101949:	eb 05                	jmp    f0101950 <cons_getc+0x59>
	}
	return 0;
f010194b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0101950:	c9                   	leave  
f0101951:	c3                   	ret    

f0101952 <cons_getc2>:

//// return the next input character from the console buffer, or 0 if none
int
cons_getc2(void)
{
f0101952:	55                   	push   %ebp
f0101953:	89 e5                	mov    %esp,%ebp
f0101955:	83 ec 10             	sub    $0x10,%esp
	int c;
	// grab the next character from the input buffer (if any).
	if (cons.rpos != cons.wpos) {
f0101958:	8b 15 80 5b 81 f0    	mov    0xf0815b80,%edx
f010195e:	a1 84 5b 81 f0       	mov    0xf0815b84,%eax
f0101963:	39 c2                	cmp    %eax,%edx
f0101965:	74 35                	je     f010199c <cons_getc2+0x4a>
		c = cons.buf[cons.rpos++];
f0101967:	a1 80 5b 81 f0       	mov    0xf0815b80,%eax
f010196c:	8d 50 01             	lea    0x1(%eax),%edx
f010196f:	89 15 80 5b 81 f0    	mov    %edx,0xf0815b80
f0101975:	8a 80 80 59 81 f0    	mov    -0xf7ea680(%eax),%al
f010197b:	0f b6 c0             	movzbl %al,%eax
f010197e:	89 45 fc             	mov    %eax,-0x4(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0101981:	a1 80 5b 81 f0       	mov    0xf0815b80,%eax
f0101986:	3d 00 02 00 00       	cmp    $0x200,%eax
f010198b:	75 0a                	jne    f0101997 <cons_getc2+0x45>
			cons.rpos = 0;
f010198d:	c7 05 80 5b 81 f0 00 	movl   $0x0,0xf0815b80
f0101994:	00 00 00 
		return c;
f0101997:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010199a:	eb 05                	jmp    f01019a1 <cons_getc2+0x4f>
	}
	return 0;
f010199c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01019a1:	c9                   	leave  
f01019a2:	c3                   	ret    

f01019a3 <cons_putc>:

// output a character to the console
void
cons_putc(int c)
{
f01019a3:	55                   	push   %ebp
f01019a4:	89 e5                	mov    %esp,%ebp
f01019a6:	83 ec 08             	sub    $0x8,%esp
	lpt_putc(c);
f01019a9:	ff 75 08             	pushl  0x8(%ebp)
f01019ac:	e8 90 f8 ff ff       	call   f0101241 <lpt_putc>
f01019b1:	83 c4 04             	add    $0x4,%esp
	cga_putc(c);
f01019b4:	83 ec 0c             	sub    $0xc,%esp
f01019b7:	ff 75 08             	pushl  0x8(%ebp)
f01019ba:	e8 bc f9 ff ff       	call   f010137b <cga_putc>
f01019bf:	83 c4 10             	add    $0x10,%esp
}
f01019c2:	90                   	nop
f01019c3:	c9                   	leave  
f01019c4:	c3                   	ret    

f01019c5 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
f01019c5:	55                   	push   %ebp
f01019c6:	89 e5                	mov    %esp,%ebp
f01019c8:	83 ec 08             	sub    $0x8,%esp
	cga_init();
f01019cb:	e8 e6 f8 ff ff       	call   f01012b6 <cga_init>
	kbd_init();
f01019d0:	e8 b9 fe ff ff       	call   f010188e <kbd_init>
	serial_init();
f01019d5:	e8 45 f7 ff ff       	call   f010111f <serial_init>

	if (!serial_exists)
f01019da:	a1 64 59 81 f0       	mov    0xf0815964,%eax
f01019df:	85 c0                	test   %eax,%eax
f01019e1:	75 10                	jne    f01019f3 <cons_init+0x2e>
		cprintf("Serial port does not exist!\n");
f01019e3:	83 ec 0c             	sub    $0xc,%esp
f01019e6:	68 53 ab 12 f0       	push   $0xf012ab53
f01019eb:	e8 6c 01 00 00       	call   f0101b5c <cprintf>
f01019f0:	83 c4 10             	add    $0x10,%esp
	}
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&conssem, 1, "console semaphore");
	}
}
f01019f3:	90                   	nop
f01019f4:	c9                   	leave  
f01019f5:	c3                   	ret    

f01019f6 <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf from KERNEL side

void
cputchar(int c)
{
f01019f6:	55                   	push   %ebp
f01019f7:	89 e5                	mov    %esp,%ebp
f01019f9:	83 ec 08             	sub    $0x8,%esp
	cons_putc(c);
f01019fc:	83 ec 0c             	sub    $0xc,%esp
f01019ff:	ff 75 08             	pushl  0x8(%ebp)
f0101a02:	e8 9c ff ff ff       	call   f01019a3 <cons_putc>
f0101a07:	83 c4 10             	add    $0x10,%esp
}
f0101a0a:	90                   	nop
f0101a0b:	c9                   	leave  
f0101a0c:	c3                   	ret    

f0101a0d <getchar>:

int
getchar(void)
{
f0101a0d:	55                   	push   %ebp
f0101a0e:	89 e5                	mov    %esp,%ebp
f0101a10:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = cons_getc()) == 0)
f0101a13:	e8 df fe ff ff       	call   f01018f7 <cons_getc>
f0101a18:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0101a1b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0101a1f:	74 f2                	je     f0101a13 <getchar+0x6>
		/* do nothing */;
	return c;
f0101a21:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0101a24:	c9                   	leave  
f0101a25:	c3                   	ret    

f0101a26 <iscons>:

int
iscons(int fdnum)
{
f0101a26:	55                   	push   %ebp
f0101a27:	89 e5                	mov    %esp,%ebp
	// used by readline
	return 1;
f0101a29:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0101a2e:	5d                   	pop    %ebp
f0101a2f:	c3                   	ret    

f0101a30 <clear_screen_buffer>:

// *************** This clear screen feature is implemented by *************
// ********* Abd-Alrahman Zedan From Team Frozen-Bytes - FCIS'24-25 ********
void
clear_screen_buffer(void)
{
f0101a30:	55                   	push   %ebp
f0101a31:	89 e5                	mov    %esp,%ebp
f0101a33:	83 ec 10             	sub    $0x10,%esp
	// accessing the screen buffer in the memory
	uint32 *crt_buf = (uint32*)(KERNEL_BASE + CGA_BUF);
f0101a36:	c7 45 f8 00 80 0b f0 	movl   $0xf00b8000,-0x8(%ebp)
	// setting the screen buffer content to spaces with black background
	for (int i = 0; i < CRT_SIZE; i++)
f0101a3d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0101a44:	eb 18                	jmp    f0101a5e <clear_screen_buffer+0x2e>
		crt_buf[i] = 0x0700 | ' ';
f0101a46:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0101a49:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0101a50:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0101a53:	01 d0                	add    %edx,%eax
f0101a55:	c7 00 20 07 00 00    	movl   $0x720,(%eax)
clear_screen_buffer(void)
{
	// accessing the screen buffer in the memory
	uint32 *crt_buf = (uint32*)(KERNEL_BASE + CGA_BUF);
	// setting the screen buffer content to spaces with black background
	for (int i = 0; i < CRT_SIZE; i++)
f0101a5b:	ff 45 fc             	incl   -0x4(%ebp)
f0101a5e:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%ebp)
f0101a65:	7e df                	jle    f0101a46 <clear_screen_buffer+0x16>
		crt_buf[i] = 0x0700 | ' ';
	crt_pos = 0; // reset_cursor_position
f0101a67:	66 c7 05 70 59 81 f0 	movw   $0x0,0xf0815970
f0101a6e:	00 00 
}
f0101a70:	90                   	nop
f0101a71:	c9                   	leave  
f0101a72:	c3                   	ret    

f0101a73 <keyboard_interrupt_handler>:

/*Keyboard Interrupt Service Routine */
void keyboard_interrupt_handler()
{
f0101a73:	55                   	push   %ebp
f0101a74:	89 e5                	mov    %esp,%ebp
f0101a76:	83 ec 08             	sub    $0x8,%esp
	//	char scanCode = inb(0x60) & 0x7F; //What key is pressed
	//	char press = inb(0x60) & 0x80; //Press down, or released
	//
	//	cprintf("Scan code: %d, Press: %d\n", scanCode, press);
	//cprintf("char is pressed\n");
	kbd_intr();
f0101a79:	e8 f7 fd ff ff       	call   f0101875 <kbd_intr>
		else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
		{
			signal_ksemaphore(&KBDsem);
		}
	}
}
f0101a7e:	90                   	nop
f0101a7f:	c9                   	leave  
f0101a80:	c3                   	ret    

f0101a81 <cons_lock>:

void cons_lock(void)
{
f0101a81:	55                   	push   %ebp
f0101a82:	89 e5                	mov    %esp,%ebp
f0101a84:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0101a87:	e8 8f 41 00 00       	call   f0105c1b <kclock_stop>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0101a8c:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0101a8d:	e8 86 9f 00 00       	call   f010ba18 <get_cpu_proc>
f0101a92:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0101a95:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0101a99:	75 17                	jne    f0101ab2 <cons_lock+0x31>
		{
			panic("cons_lock: no running process to block");
f0101a9b:	83 ec 04             	sub    $0x4,%esp
f0101a9e:	68 70 ab 12 f0       	push   $0xf012ab70
f0101aa3:	68 3b 02 00 00       	push   $0x23b
f0101aa8:	68 97 ab 12 f0       	push   $0xf012ab97
f0101aad:	e8 fd f3 ff ff       	call   f0100eaf <_panic>
		}
		p->env_tf->tf_eflags &= ~FL_IF ;
f0101ab2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101ab5:	8b 00                	mov    (%eax),%eax
f0101ab7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0101aba:	8b 12                	mov    (%edx),%edx
f0101abc:	8b 52 38             	mov    0x38(%edx),%edx
f0101abf:	80 e6 fd             	and    $0xfd,%dh
f0101ac2:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		wait_ksemaphore(&conssem);
	}

}
f0101ac5:	90                   	nop
f0101ac6:	c9                   	leave  
f0101ac7:	c3                   	ret    

f0101ac8 <cons_unlock>:

void cons_unlock(void)
{
f0101ac8:	55                   	push   %ebp
f0101ac9:	89 e5                	mov    %esp,%ebp
f0101acb:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0101ace:	e8 48 41 00 00       	call   f0105c1b <kclock_stop>
f0101ad3:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0101ad4:	e8 3f 9f 00 00       	call   f010ba18 <get_cpu_proc>
f0101ad9:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0101adc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0101ae0:	75 17                	jne    f0101af9 <cons_unlock+0x31>
		{
			panic("cons_unlock: no running process to block");
f0101ae2:	83 ec 04             	sub    $0x4,%esp
f0101ae5:	68 ac ab 12 f0       	push   $0xf012abac
f0101aea:	68 54 02 00 00       	push   $0x254
f0101aef:	68 97 ab 12 f0       	push   $0xf012ab97
f0101af4:	e8 b6 f3 ff ff       	call   f0100eaf <_panic>
		}
		p->env_tf->tf_eflags |= FL_IF ;
f0101af9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101afc:	8b 00                	mov    (%eax),%eax
f0101afe:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0101b01:	8b 12                	mov    (%edx),%edx
f0101b03:	8b 52 38             	mov    0x38(%edx),%edx
f0101b06:	80 ce 02             	or     $0x2,%dh
f0101b09:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		signal_ksemaphore(&conssem);
	}

}
f0101b0c:	90                   	nop
f0101b0d:	c9                   	leave  
f0101b0e:	c3                   	ret    

f0101b0f <putch>:
#include <kern/cons/console.h>


static void
putch(int ch, int *cnt)
{
f0101b0f:	55                   	push   %ebp
f0101b10:	89 e5                	mov    %esp,%ebp
f0101b12:	83 ec 08             	sub    $0x8,%esp
	cputchar(ch);
f0101b15:	83 ec 0c             	sub    $0xc,%esp
f0101b18:	ff 75 08             	pushl  0x8(%ebp)
f0101b1b:	e8 d6 fe ff ff       	call   f01019f6 <cputchar>
f0101b20:	83 c4 10             	add    $0x10,%esp
	(*cnt)++;
f0101b23:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b26:	8b 00                	mov    (%eax),%eax
f0101b28:	8d 50 01             	lea    0x1(%eax),%edx
f0101b2b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b2e:	89 10                	mov    %edx,(%eax)
}
f0101b30:	90                   	nop
f0101b31:	c9                   	leave  
f0101b32:	c3                   	ret    

f0101b33 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
f0101b33:	55                   	push   %ebp
f0101b34:	89 e5                	mov    %esp,%ebp
f0101b36:	83 ec 18             	sub    $0x18,%esp
	int cnt = 0;
f0101b39:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	vprintfmt((void*)putch, &cnt, fmt, ap);
f0101b40:	ff 75 0c             	pushl  0xc(%ebp)
f0101b43:	ff 75 08             	pushl  0x8(%ebp)
f0101b46:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0101b49:	50                   	push   %eax
f0101b4a:	68 0f 1b 10 f0       	push   $0xf0101b0f
f0101b4f:	e8 65 88 01 00       	call   f011a3b9 <vprintfmt>
f0101b54:	83 c4 10             	add    $0x10,%esp
	return cnt;
f0101b57:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0101b5a:	c9                   	leave  
f0101b5b:	c3                   	ret    

f0101b5c <cprintf>:

int
cprintf(const char *fmt, ...)
{
f0101b5c:	55                   	push   %ebp
f0101b5d:	89 e5                	mov    %esp,%ebp
f0101b5f:	83 ec 18             	sub    $0x18,%esp
	int cnt;
	pushcli();	//disable interrupts
f0101b62:	e8 c9 64 00 00       	call   f0108030 <pushcli>
	{
		va_list ap;

		va_start(ap, fmt);
f0101b67:	8d 45 0c             	lea    0xc(%ebp),%eax
f0101b6a:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cnt = vcprintf(fmt, ap);
f0101b6d:	8b 45 08             	mov    0x8(%ebp),%eax
f0101b70:	83 ec 08             	sub    $0x8,%esp
f0101b73:	ff 75 f4             	pushl  -0xc(%ebp)
f0101b76:	50                   	push   %eax
f0101b77:	e8 b7 ff ff ff       	call   f0101b33 <vcprintf>
f0101b7c:	83 c4 10             	add    $0x10,%esp
f0101b7f:	89 45 f0             	mov    %eax,-0x10(%ebp)
		va_end(ap);
	}
	popcli();	//enable interrupts
f0101b82:	e8 fb 64 00 00       	call   f0108082 <popcli>

	return cnt;
f0101b87:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0101b8a:	c9                   	leave  
f0101b8b:	c3                   	ret    

f0101b8c <cprintf_colored>:

// *************** This text coloring feature is implemented by *************
// ********** Abd-Alrahman Zedan From Team Frozen-Bytes - FCIS'24-25 ********
int
cprintf_colored(int textClr, const char *fmt, ...)
{
f0101b8c:	55                   	push   %ebp
f0101b8d:	89 e5                	mov    %esp,%ebp
f0101b8f:	83 ec 18             	sub    $0x18,%esp
	current_text_color = (textClr << 8) ;
f0101b92:	8b 45 08             	mov    0x8(%ebp),%eax
f0101b95:	c1 e0 08             	shl    $0x8,%eax
f0101b98:	a3 f0 6a 85 f0       	mov    %eax,0xf0856af0
	int cnt;
	pushcli();	//disable interrupts
f0101b9d:	e8 8e 64 00 00       	call   f0108030 <pushcli>
	{
		va_list ap;

		va_start(ap, fmt);
f0101ba2:	8d 45 0c             	lea    0xc(%ebp),%eax
f0101ba5:	83 c0 04             	add    $0x4,%eax
f0101ba8:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cnt = vcprintf(fmt, ap);
f0101bab:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101bae:	83 ec 08             	sub    $0x8,%esp
f0101bb1:	ff 75 f4             	pushl  -0xc(%ebp)
f0101bb4:	50                   	push   %eax
f0101bb5:	e8 79 ff ff ff       	call   f0101b33 <vcprintf>
f0101bba:	83 c4 10             	add    $0x10,%esp
f0101bbd:	89 45 f0             	mov    %eax,-0x10(%ebp)
		va_end(ap);
	}
	popcli();	//enable interrupts
f0101bc0:	e8 bd 64 00 00       	call   f0108082 <popcli>
	current_text_color = TEXT_DEFAULT_CLR; //restore default text color
f0101bc5:	c7 05 f0 6a 85 f0 00 	movl   $0x700,0xf0856af0
f0101bcc:	07 00 00 

	return cnt;
f0101bcf:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0101bd2:	c9                   	leave  
f0101bd3:	c3                   	ret    

f0101bd4 <run_command_prompt>:
#include "commands.h"

extern bool __autograde__ ;
extern void command_prompt_readline(const char *prompt, char* buf);
void run_command_prompt()
{
f0101bd4:	55                   	push   %ebp
f0101bd5:	89 e5                	mov    %esp,%ebp
f0101bd7:	57                   	push   %edi
f0101bd8:	56                   	push   %esi
f0101bd9:	53                   	push   %ebx
f0101bda:	81 ec 0c 10 00 00    	sub    $0x100c,%esp
	if (__autograde__)
f0101be0:	a1 20 f0 17 f0       	mov    0xf017f020,%eax
f0101be5:	85 c0                	test   %eax,%eax
f0101be7:	0f 84 85 00 00 00    	je     f0101c72 <run_command_prompt+0x9e>
	{
		char cmdU1_2[BUFLEN] = "tst priorityRR 0";	//
f0101bed:	8d 85 e8 ef ff ff    	lea    -0x1018(%ebp),%eax
f0101bf3:	bb de ab 12 f0       	mov    $0xf012abde,%ebx
f0101bf8:	ba 11 00 00 00       	mov    $0x11,%edx
f0101bfd:	89 c7                	mov    %eax,%edi
f0101bff:	89 de                	mov    %ebx,%esi
f0101c01:	89 d1                	mov    %edx,%ecx
f0101c03:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101c05:	8d 95 f9 ef ff ff    	lea    -0x1007(%ebp),%edx
f0101c0b:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f0101c10:	b0 00                	mov    $0x0,%al
f0101c12:	89 d7                	mov    %edx,%edi
f0101c14:	f3 aa                	rep stos %al,%es:(%edi)
		char cmdU2_2[BUFLEN] = "tst priorityRR 1";	//
f0101c16:	8d 85 e8 f3 ff ff    	lea    -0xc18(%ebp),%eax
f0101c1c:	bb de af 12 f0       	mov    $0xf012afde,%ebx
f0101c21:	ba 11 00 00 00       	mov    $0x11,%edx
f0101c26:	89 c7                	mov    %eax,%edi
f0101c28:	89 de                	mov    %ebx,%esi
f0101c2a:	89 d1                	mov    %edx,%ecx
f0101c2c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101c2e:	8d 95 f9 f3 ff ff    	lea    -0xc07(%ebp),%edx
f0101c34:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f0101c39:	b0 00                	mov    $0x0,%al
f0101c3b:	89 d7                	mov    %edx,%edi
f0101c3d:	f3 aa                	rep stos %al,%es:(%edi)
		char cmdU3_2[BUFLEN] = "tst priorityRR 2";	//
f0101c3f:	8d 85 e8 f7 ff ff    	lea    -0x818(%ebp),%eax
f0101c45:	bb de b3 12 f0       	mov    $0xf012b3de,%ebx
f0101c4a:	ba 11 00 00 00       	mov    $0x11,%edx
f0101c4f:	89 c7                	mov    %eax,%edi
f0101c51:	89 de                	mov    %ebx,%esi
f0101c53:	89 d1                	mov    %edx,%ecx
f0101c55:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101c57:	8d 95 f9 f7 ff ff    	lea    -0x807(%ebp),%edx
f0101c5d:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f0101c62:	b0 00                	mov    $0x0,%al
f0101c64:	89 d7                	mov    %edx,%edi
f0101c66:	f3 aa                	rep stos %al,%es:(%edi)
//		execute_command(cmdU3_2);
		__autograde__ = 0;
f0101c68:	c7 05 20 f0 17 f0 00 	movl   $0x0,0xf017f020
f0101c6f:	00 00 00 
	}
	/*2024*/
	LIST_INIT(&foundCommands);
f0101c72:	c7 05 6c 6d 85 f0 00 	movl   $0x0,0xf0856d6c
f0101c79:	00 00 00 
f0101c7c:	c7 05 70 6d 85 f0 00 	movl   $0x0,0xf0856d70
f0101c83:	00 00 00 
f0101c86:	c7 05 78 6d 85 f0 00 	movl   $0x0,0xf0856d78
f0101c8d:	00 00 00 
		//readline("FOS> ", command_line);

		// ********** This DosKey supported readline function is a combined implementation from **********
		// ********** 		Mohamed Raafat & Mohamed Yousry, 3rd year students, FCIS, 2017		**********
		// ********** 				Combined, edited and modified by TA\Ghada Hamed				**********
		memset(command_line, 0, sizeof(command_line));
f0101c90:	83 ec 04             	sub    $0x4,%esp
f0101c93:	68 00 04 00 00       	push   $0x400
f0101c98:	6a 00                	push   $0x0
f0101c9a:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101ca0:	50                   	push   %eax
f0101ca1:	e8 c3 8f 01 00       	call   f011ac69 <memset>
f0101ca6:	83 c4 10             	add    $0x10,%esp
		command_prompt_readline("FOS> ", command_line);
f0101ca9:	83 ec 08             	sub    $0x8,%esp
f0101cac:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101cb2:	50                   	push   %eax
f0101cb3:	68 d8 ab 12 f0       	push   $0xf012abd8
f0101cb8:	e8 42 06 00 00       	call   f01022ff <command_prompt_readline>
f0101cbd:	83 c4 10             	add    $0x10,%esp

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
f0101cc0:	83 ec 0c             	sub    $0xc,%esp
f0101cc3:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101cc9:	50                   	push   %eax
f0101cca:	e8 4c 01 00 00       	call   f0101e1b <execute_command>
f0101ccf:	83 c4 10             	add    $0x10,%esp
f0101cd2:	85 c0                	test   %eax,%eax
f0101cd4:	78 02                	js     f0101cd8 <run_command_prompt+0x104>
				break;
	}
f0101cd6:	eb b8                	jmp    f0101c90 <run_command_prompt+0xbc>
		command_prompt_readline("FOS> ", command_line);

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
				break;
f0101cd8:	90                   	nop
	}
}
f0101cd9:	90                   	nop
f0101cda:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101cdd:	5b                   	pop    %ebx
f0101cde:	5e                   	pop    %esi
f0101cdf:	5f                   	pop    %edi
f0101ce0:	5d                   	pop    %ebp
f0101ce1:	c3                   	ret    

f0101ce2 <get_into_prompt>:
 * They're placed globally (instead of locally) to avoid clearing them while they're in use [el7 :)]
 */
int m;
char *p ;
void get_into_prompt()
{
f0101ce2:	55                   	push   %ebp
f0101ce3:	89 e5                	mov    %esp,%ebp
f0101ce5:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0101ce8:	9c                   	pushf  
f0101ce9:	58                   	pop    %eax
f0101cea:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f0101ced:	8b 45 d8             	mov    -0x28(%ebp),%eax
	while (1)
	{
		//disable interrupt if it's already enabled
		if (read_eflags() & FL_IF)
f0101cf0:	25 00 02 00 00       	and    $0x200,%eax
f0101cf5:	85 c0                	test   %eax,%eax
f0101cf7:	74 01                	je     f0101cfa <get_into_prompt+0x18>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0101cf9:	fa                   	cli    
			cli();

		//Switch to the kernel virtual memory
		switchkvm();
f0101cfa:	e8 9f 9f 00 00       	call   f010bc9e <switchkvm>

		//Reset current CPU
		struct cpu *c = mycpu();
f0101cff:	e8 6c 62 00 00       	call   f0107f70 <mycpu>
f0101d04:	89 45 f0             	mov    %eax,-0x10(%ebp)
		c->ncli = 0;
f0101d07:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101d0a:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f0101d11:	00 00 00 
		c->intena = 0;
f0101d14:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101d17:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
f0101d1e:	00 00 00 
		c->scheduler = NULL;
f0101d21:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101d24:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		c->scheduler_status = SCH_STOPPED ;
f0101d2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101d2e:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0101d35:	00 00 00 
		c->proc = NULL;
f0101d38:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101d3b:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0101d42:	00 00 00 

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0101d45:	89 e0                	mov    %esp,%eax
f0101d47:	89 45 dc             	mov    %eax,-0x24(%ebp)
        return esp;
f0101d4a:	8b 45 dc             	mov    -0x24(%ebp),%eax

		//Read current ESP
		uint32 cur_esp = read_esp();
f0101d4d:	89 45 e8             	mov    %eax,-0x18(%ebp)

//		//Make sure it's in the correct stack (i.e. KERN STACK below KERN_BASE)
//		assert(cur_esp < SCHD_KERN_STACK_TOP && cur_esp >= SCHD_KERN_STACK_TOP - KERNEL_STACK_SIZE);

		//Reset ESP to the beginning of the SCHED KERNEL STACK of this CPU before getting into the cmd prmpt
		uint32 cpuStackTop = (uint32)c->stack + KERNEL_STACK_SIZE;
f0101d50:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101d53:	8b 40 08             	mov    0x8(%eax),%eax
f0101d56:	05 00 80 00 00       	add    $0x8000,%eax
f0101d5b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		uint32 cpuStackBottom = (uint32)c->stack + PAGE_SIZE/*GUARD Page*/;
f0101d5e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101d61:	8b 40 08             	mov    0x8(%eax),%eax
f0101d64:	05 00 10 00 00       	add    $0x1000,%eax
f0101d69:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0101d6c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101d6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0101d72:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101d75:	89 c4                	mov    %eax,%esp
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101d77:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101d7a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0101d7d:	73 44                	jae    f0101dc3 <get_into_prompt+0xe1>
f0101d7f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101d82:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0101d85:	72 3c                	jb     f0101dc3 <get_into_prompt+0xe1>
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
f0101d87:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101d8a:	a3 74 6e 85 f0       	mov    %eax,0xf0856e74
			m = cpuStackTop - cur_esp;
f0101d8f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101d92:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0101d95:	a3 78 6e 85 f0       	mov    %eax,0xf0856e78
			while (--m >= 0)
f0101d9a:	eb 11                	jmp    f0101dad <get_into_prompt+0xcb>
				*p++ = 0;
f0101d9c:	a1 74 6e 85 f0       	mov    0xf0856e74,%eax
f0101da1:	8d 50 01             	lea    0x1(%eax),%edx
f0101da4:	89 15 74 6e 85 f0    	mov    %edx,0xf0856e74
f0101daa:	c6 00 00             	movb   $0x0,(%eax)
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
			m = cpuStackTop - cur_esp;
			while (--m >= 0)
f0101dad:	a1 78 6e 85 f0       	mov    0xf0856e78,%eax
f0101db2:	48                   	dec    %eax
f0101db3:	a3 78 6e 85 f0       	mov    %eax,0xf0856e78
f0101db8:	a1 78 6e 85 f0       	mov    0xf0856e78,%eax
f0101dbd:	85 c0                	test   %eax,%eax
f0101dbf:	79 db                	jns    f0101d9c <get_into_prompt+0xba>
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101dc1:	eb 3a                	jmp    f0101dfd <get_into_prompt+0x11b>
				*p++ = 0;
		}
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
f0101dc3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0101dc6:	a3 74 6e 85 f0       	mov    %eax,0xf0856e74
			m = cpuStackTop - cpuStackBottom;
f0101dcb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101dce:	2b 45 e0             	sub    -0x20(%ebp),%eax
f0101dd1:	a3 78 6e 85 f0       	mov    %eax,0xf0856e78
			while (--m >= 0)
f0101dd6:	eb 11                	jmp    f0101de9 <get_into_prompt+0x107>
				*p++ = 0;
f0101dd8:	a1 74 6e 85 f0       	mov    0xf0856e74,%eax
f0101ddd:	8d 50 01             	lea    0x1(%eax),%edx
f0101de0:	89 15 74 6e 85 f0    	mov    %edx,0xf0856e74
f0101de6:	c6 00 00             	movb   $0x0,(%eax)
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
			m = cpuStackTop - cpuStackBottom;
			while (--m >= 0)
f0101de9:	a1 78 6e 85 f0       	mov    0xf0856e78,%eax
f0101dee:	48                   	dec    %eax
f0101def:	a3 78 6e 85 f0       	mov    %eax,0xf0856e78
f0101df4:	a1 78 6e 85 f0       	mov    0xf0856e78,%eax
f0101df9:	85 c0                	test   %eax,%eax
f0101dfb:	79 db                	jns    f0101dd8 <get_into_prompt+0xf6>
f0101dfd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
}

static __inline void
write_ebp(uint32 ebp)
{
	__asm __volatile("movl %0,%%ebp" : : "r" (ebp) );
f0101e04:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101e07:	89 c5                	mov    %eax,%ebp

		//Reset EBP to ZERO so that when calling the run_command_prompt() it pushes ZERO into the stack
		write_ebp(0);

		//Get into the prompt (should NOT return)
		run_command_prompt(NULL);
f0101e09:	83 ec 0c             	sub    $0xc,%esp
f0101e0c:	6a 00                	push   $0x0
f0101e0e:	e8 c1 fd ff ff       	call   f0101bd4 <run_command_prompt>
f0101e13:	83 c4 10             	add    $0x10,%esp
	}
f0101e16:	e9 cd fe ff ff       	jmp    f0101ce8 <get_into_prompt+0x6>

f0101e1b <execute_command>:
#define WHITESPACE "\t\r\n "

//Function to parse any command and execute it
//(simply by calling its corresponding function)
int execute_command(char *command_string)
{
f0101e1b:	55                   	push   %ebp
f0101e1c:	89 e5                	mov    %esp,%ebp
f0101e1e:	83 ec 78             	sub    $0x78,%esp
	int number_of_arguments;
	//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
	char *arguments[MAX_ARGUMENTS];


	strsplit(command_string, WHITESPACE, arguments, &number_of_arguments) ;
f0101e21:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0101e24:	50                   	push   %eax
f0101e25:	8d 45 90             	lea    -0x70(%ebp),%eax
f0101e28:	50                   	push   %eax
f0101e29:	68 de b7 12 f0       	push   $0xf012b7de
f0101e2e:	ff 75 08             	pushl  0x8(%ebp)
f0101e31:	e8 09 93 01 00       	call   f011b13f <strsplit>
f0101e36:	83 c4 10             	add    $0x10,%esp
	if (number_of_arguments == 0)
f0101e39:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101e3c:	85 c0                	test   %eax,%eax
f0101e3e:	75 0a                	jne    f0101e4a <execute_command+0x2f>
		return 0;
f0101e40:	b8 00 00 00 00       	mov    $0x0,%eax
f0101e45:	e9 a4 02 00 00       	jmp    f01020ee <execute_command+0x2d3>

	int ret = process_command(number_of_arguments, arguments);
f0101e4a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101e4d:	83 ec 08             	sub    $0x8,%esp
f0101e50:	8d 55 90             	lea    -0x70(%ebp),%edx
f0101e53:	52                   	push   %edx
f0101e54:	50                   	push   %eax
f0101e55:	e8 96 02 00 00       	call   f01020f0 <process_command>
f0101e5a:	83 c4 10             	add    $0x10,%esp
f0101e5d:	89 45 e0             	mov    %eax,-0x20(%ebp)

	if (ret == CMD_INVALID)
f0101e60:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f0101e64:	75 19                	jne    f0101e7f <execute_command+0x64>
	{
		cprintf("Unknown command '%s'\n", arguments[0]);
f0101e66:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101e69:	83 ec 08             	sub    $0x8,%esp
f0101e6c:	50                   	push   %eax
f0101e6d:	68 e3 b7 12 f0       	push   $0xf012b7e3
f0101e72:	e8 e5 fc ff ff       	call   f0101b5c <cprintf>
f0101e77:	83 c4 10             	add    $0x10,%esp
f0101e7a:	e9 6a 02 00 00       	jmp    f01020e9 <execute_command+0x2ce>
	}
	else if (ret == CMD_INV_NUM_ARGS)
f0101e7f:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0101e83:	75 4f                	jne    f0101ed4 <execute_command+0xb9>
	{
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101e85:	a1 78 6d 85 f0       	mov    0xf0856d78,%eax
f0101e8a:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (numOfFoundCmds != 1)
f0101e8d:	83 7d d8 01          	cmpl   $0x1,-0x28(%ebp)
f0101e91:	74 17                	je     f0101eaa <execute_command+0x8f>
		{
			panic("command is found but the list is either empty or contains more than one command!");
f0101e93:	83 ec 04             	sub    $0x4,%esp
f0101e96:	68 fc b7 12 f0       	push   $0xf012b7fc
f0101e9b:	68 90 00 00 00       	push   $0x90
f0101ea0:	68 4d b8 12 f0       	push   $0xf012b84d
f0101ea5:	e8 05 f0 ff ff       	call   f0100eaf <_panic>
		}
		struct Command * cmd = LIST_FIRST(&foundCommands);
f0101eaa:	a1 6c 6d 85 f0       	mov    0xf0856d6c,%eax
f0101eaf:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		cprintf("%s: invalid number of args.\nDescription: %s\n", cmd->name, cmd->description);
f0101eb2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101eb5:	8b 50 04             	mov    0x4(%eax),%edx
f0101eb8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101ebb:	8b 00                	mov    (%eax),%eax
f0101ebd:	83 ec 04             	sub    $0x4,%esp
f0101ec0:	52                   	push   %edx
f0101ec1:	50                   	push   %eax
f0101ec2:	68 68 b8 12 f0       	push   $0xf012b868
f0101ec7:	e8 90 fc ff ff       	call   f0101b5c <cprintf>
f0101ecc:	83 c4 10             	add    $0x10,%esp
f0101ecf:	e9 15 02 00 00       	jmp    f01020e9 <execute_command+0x2ce>
	}
	else if (ret == CMD_MATCHED)
f0101ed4:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0101ed8:	0f 85 e6 01 00 00    	jne    f01020c4 <execute_command+0x2a9>
	{
		int i = 1;
f0101ede:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101ee5:	a1 78 6d 85 f0       	mov    0xf0856d78,%eax
f0101eea:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (numOfFoundCmds == 0)
f0101eed:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0101ef1:	75 17                	jne    f0101f0a <execute_command+0xef>
		{
			panic("command is matched but the list is empty!");
f0101ef3:	83 ec 04             	sub    $0x4,%esp
f0101ef6:	68 98 b8 12 f0       	push   $0xf012b898
f0101efb:	68 9b 00 00 00       	push   $0x9b
f0101f00:	68 4d b8 12 f0       	push   $0xf012b84d
f0101f05:	e8 a5 ef ff ff       	call   f0100eaf <_panic>
		}
		struct Command * cmd = NULL;
f0101f0a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(cmd, &foundCommands)
f0101f11:	a1 6c 6d 85 f0       	mov    0xf0856d6c,%eax
f0101f16:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0101f19:	eb 28                	jmp    f0101f43 <execute_command+0x128>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
f0101f1b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101f1e:	8b 10                	mov    (%eax),%edx
f0101f20:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101f23:	8d 48 01             	lea    0x1(%eax),%ecx
f0101f26:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0101f29:	83 ec 04             	sub    $0x4,%esp
f0101f2c:	52                   	push   %edx
f0101f2d:	50                   	push   %eax
f0101f2e:	68 c2 b8 12 f0       	push   $0xf012b8c2
f0101f33:	e8 24 fc ff ff       	call   f0101b5c <cprintf>
f0101f38:	83 c4 10             	add    $0x10,%esp
		if (numOfFoundCmds == 0)
		{
			panic("command is matched but the list is empty!");
		}
		struct Command * cmd = NULL;
		LIST_FOREACH(cmd, &foundCommands)
f0101f3b:	a1 74 6d 85 f0       	mov    0xf0856d74,%eax
f0101f40:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0101f43:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0101f47:	74 08                	je     f0101f51 <execute_command+0x136>
f0101f49:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101f4c:	8b 40 10             	mov    0x10(%eax),%eax
f0101f4f:	eb 05                	jmp    f0101f56 <execute_command+0x13b>
f0101f51:	b8 00 00 00 00       	mov    $0x0,%eax
f0101f56:	a3 74 6d 85 f0       	mov    %eax,0xf0856d74
f0101f5b:	a1 74 6d 85 f0       	mov    0xf0856d74,%eax
f0101f60:	85 c0                	test   %eax,%eax
f0101f62:	75 b7                	jne    f0101f1b <execute_command+0x100>
f0101f64:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0101f68:	75 b1                	jne    f0101f1b <execute_command+0x100>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
f0101f6a:	83 ec 08             	sub    $0x8,%esp
f0101f6d:	ff 75 dc             	pushl  -0x24(%ebp)
f0101f70:	68 cc b8 12 f0       	push   $0xf012b8cc
f0101f75:	e8 e2 fb ff ff       	call   f0101b5c <cprintf>
f0101f7a:	83 c4 10             	add    $0x10,%esp
		char Chose = getchar();
f0101f7d:	e8 8b fa ff ff       	call   f0101a0d <getchar>
f0101f82:	88 45 ef             	mov    %al,-0x11(%ebp)
		cputchar(Chose);
f0101f85:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0101f89:	83 ec 0c             	sub    $0xc,%esp
f0101f8c:	50                   	push   %eax
f0101f8d:	e8 64 fa ff ff       	call   f01019f6 <cputchar>
f0101f92:	83 c4 10             	add    $0x10,%esp
		int selection = 0;
f0101f95:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		while (Chose >= '0' && Chose <= '9')
f0101f9c:	eb 40                	jmp    f0101fde <execute_command+0x1c3>
		{
			selection = selection*10 + (Chose - '0') ;
f0101f9e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0101fa1:	89 d0                	mov    %edx,%eax
f0101fa3:	c1 e0 02             	shl    $0x2,%eax
f0101fa6:	01 d0                	add    %edx,%eax
f0101fa8:	01 c0                	add    %eax,%eax
f0101faa:	89 c2                	mov    %eax,%edx
f0101fac:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0101fb0:	83 e8 30             	sub    $0x30,%eax
f0101fb3:	01 d0                	add    %edx,%eax
f0101fb5:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if (selection < 1 || selection > numOfFoundCmds)
f0101fb8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0101fbc:	7e 2c                	jle    f0101fea <execute_command+0x1cf>
f0101fbe:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101fc1:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0101fc4:	7f 24                	jg     f0101fea <execute_command+0x1cf>
				break;

			Chose = getchar();
f0101fc6:	e8 42 fa ff ff       	call   f0101a0d <getchar>
f0101fcb:	88 45 ef             	mov    %al,-0x11(%ebp)
			cputchar(Chose);
f0101fce:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0101fd2:	83 ec 0c             	sub    $0xc,%esp
f0101fd5:	50                   	push   %eax
f0101fd6:	e8 1b fa ff ff       	call   f01019f6 <cputchar>
f0101fdb:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
		char Chose = getchar();
		cputchar(Chose);
		int selection = 0;
		while (Chose >= '0' && Chose <= '9')
f0101fde:	80 7d ef 2f          	cmpb   $0x2f,-0x11(%ebp)
f0101fe2:	7e 06                	jle    f0101fea <execute_command+0x1cf>
f0101fe4:	80 7d ef 39          	cmpb   $0x39,-0x11(%ebp)
f0101fe8:	7e b4                	jle    f0101f9e <execute_command+0x183>
				break;

			Chose = getchar();
			cputchar(Chose);
		}
		cputchar('\n');
f0101fea:	83 ec 0c             	sub    $0xc,%esp
f0101fed:	6a 0a                	push   $0xa
f0101fef:	e8 02 fa ff ff       	call   f01019f6 <cputchar>
f0101ff4:	83 c4 10             	add    $0x10,%esp
		if (selection >= 1 && selection <= numOfFoundCmds)
f0101ff7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0101ffb:	0f 8e e8 00 00 00    	jle    f01020e9 <execute_command+0x2ce>
f0102001:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102004:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0102007:	0f 8f dc 00 00 00    	jg     f01020e9 <execute_command+0x2ce>
		{
			int c = 1;
f010200d:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
			LIST_FOREACH(cmd, &foundCommands)
f0102014:	a1 6c 6d 85 f0       	mov    0xf0856d6c,%eax
f0102019:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010201c:	eb 75                	jmp    f0102093 <execute_command+0x278>
			{
				if (c++ == selection)
f010201e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102021:	8d 50 01             	lea    0x1(%eax),%edx
f0102024:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0102027:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010202a:	75 5f                	jne    f010208b <execute_command+0x270>
				{
					if (cmd->num_of_args == 0)
f010202c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010202f:	8b 40 0c             	mov    0xc(%eax),%eax
f0102032:	85 c0                	test   %eax,%eax
f0102034:	75 31                	jne    f0102067 <execute_command+0x24c>
					{
						cprintf("FOS> %s\n", cmd->name);
f0102036:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102039:	8b 00                	mov    (%eax),%eax
f010203b:	83 ec 08             	sub    $0x8,%esp
f010203e:	50                   	push   %eax
f010203f:	68 2f b9 12 f0       	push   $0xf012b92f
f0102044:	e8 13 fb ff ff       	call   f0101b5c <cprintf>
f0102049:	83 c4 10             	add    $0x10,%esp
						return cmd->function_to_execute(number_of_arguments, arguments);
f010204c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010204f:	8b 40 08             	mov    0x8(%eax),%eax
f0102052:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0102055:	83 ec 08             	sub    $0x8,%esp
f0102058:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f010205b:	51                   	push   %ecx
f010205c:	52                   	push   %edx
f010205d:	ff d0                	call   *%eax
f010205f:	83 c4 10             	add    $0x10,%esp
f0102062:	e9 87 00 00 00       	jmp    f01020ee <execute_command+0x2d3>
					}
					else
					{
						cprintf("%s: %s\n", cmd->name, cmd->description);
f0102067:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010206a:	8b 50 04             	mov    0x4(%eax),%edx
f010206d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102070:	8b 00                	mov    (%eax),%eax
f0102072:	83 ec 04             	sub    $0x4,%esp
f0102075:	52                   	push   %edx
f0102076:	50                   	push   %eax
f0102077:	68 38 b9 12 f0       	push   $0xf012b938
f010207c:	e8 db fa ff ff       	call   f0101b5c <cprintf>
f0102081:	83 c4 10             	add    $0x10,%esp
						return 0;
f0102084:	b8 00 00 00 00       	mov    $0x0,%eax
f0102089:	eb 63                	jmp    f01020ee <execute_command+0x2d3>
		}
		cputchar('\n');
		if (selection >= 1 && selection <= numOfFoundCmds)
		{
			int c = 1;
			LIST_FOREACH(cmd, &foundCommands)
f010208b:	a1 74 6d 85 f0       	mov    0xf0856d74,%eax
f0102090:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102093:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102097:	74 08                	je     f01020a1 <execute_command+0x286>
f0102099:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010209c:	8b 40 10             	mov    0x10(%eax),%eax
f010209f:	eb 05                	jmp    f01020a6 <execute_command+0x28b>
f01020a1:	b8 00 00 00 00       	mov    $0x0,%eax
f01020a6:	a3 74 6d 85 f0       	mov    %eax,0xf0856d74
f01020ab:	a1 74 6d 85 f0       	mov    0xf0856d74,%eax
f01020b0:	85 c0                	test   %eax,%eax
f01020b2:	0f 85 66 ff ff ff    	jne    f010201e <execute_command+0x203>
f01020b8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01020bc:	0f 85 5c ff ff ff    	jne    f010201e <execute_command+0x203>
f01020c2:	eb 25                	jmp    f01020e9 <execute_command+0x2ce>
			}
		}
	}
	else
	{
		return commands[ret].function_to_execute(number_of_arguments, arguments);
f01020c4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01020c7:	89 d0                	mov    %edx,%eax
f01020c9:	01 c0                	add    %eax,%eax
f01020cb:	01 d0                	add    %edx,%eax
f01020cd:	c1 e0 03             	shl    $0x3,%eax
f01020d0:	05 68 f5 17 f0       	add    $0xf017f568,%eax
f01020d5:	8b 00                	mov    (%eax),%eax
f01020d7:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01020da:	83 ec 08             	sub    $0x8,%esp
f01020dd:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f01020e0:	51                   	push   %ecx
f01020e1:	52                   	push   %edx
f01020e2:	ff d0                	call   *%eax
f01020e4:	83 c4 10             	add    $0x10,%esp
f01020e7:	eb 05                	jmp    f01020ee <execute_command+0x2d3>
	}
	return 0;
f01020e9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01020ee:	c9                   	leave  
f01020ef:	c3                   	ret    

f01020f0 <process_command>:


int process_command(int number_of_arguments, char** arguments)
{
f01020f0:	55                   	push   %ebp
f01020f1:	89 e5                	mov    %esp,%ebp
f01020f3:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01020f6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01020fd:	eb 31                	jmp    f0102130 <process_command+0x40>
	{
		if (strcmp(arguments[0], commands[i].name) == 0)
f01020ff:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102102:	89 d0                	mov    %edx,%eax
f0102104:	01 c0                	add    %eax,%eax
f0102106:	01 d0                	add    %edx,%eax
f0102108:	c1 e0 03             	shl    $0x3,%eax
f010210b:	05 60 f5 17 f0       	add    $0xf017f560,%eax
f0102110:	8b 10                	mov    (%eax),%edx
f0102112:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102115:	8b 00                	mov    (%eax),%eax
f0102117:	83 ec 08             	sub    $0x8,%esp
f010211a:	52                   	push   %edx
f010211b:	50                   	push   %eax
f010211c:	e8 66 8a 01 00       	call   f011ab87 <strcmp>
f0102121:	83 c4 10             	add    $0x10,%esp
f0102124:	85 c0                	test   %eax,%eax
f0102126:	75 05                	jne    f010212d <process_command+0x3d>
		{
			return i;
f0102128:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010212b:	eb 14                	jmp    f0102141 <process_command+0x51>
}


int process_command(int number_of_arguments, char** arguments)
{
	for (int i = 0; i < NUM_OF_COMMANDS; i++)
f010212d:	ff 45 f4             	incl   -0xc(%ebp)
f0102130:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102133:	a1 a8 fb 17 f0       	mov    0xf017fba8,%eax
f0102138:	39 c2                	cmp    %eax,%edx
f010213a:	72 c3                	jb     f01020ff <process_command+0xf>
		if (strcmp(arguments[0], commands[i].name) == 0)
		{
			return i;
		}
	}
	return CMD_INVALID;
f010213c:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
f0102141:	c9                   	leave  
f0102142:	c3                   	ret    

f0102143 <clearandwritecommand>:
#define HISTORY_MAX 19
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty_buf[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
f0102143:	55                   	push   %ebp
f0102144:	89 e5                	mov    %esp,%ebp
f0102146:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < *i; j++) {
f0102149:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102150:	eb 10                	jmp    f0102162 <clearandwritecommand+0x1f>
		cputchar('\b');
f0102152:	83 ec 0c             	sub    $0xc,%esp
f0102155:	6a 08                	push   $0x8
f0102157:	e8 9a f8 ff ff       	call   f01019f6 <cputchar>
f010215c:	83 c4 10             	add    $0x10,%esp
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty_buf[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
	for (int j = 0; j < *i; j++) {
f010215f:	ff 45 f4             	incl   -0xc(%ebp)
f0102162:	8b 45 08             	mov    0x8(%ebp),%eax
f0102165:	8b 00                	mov    (%eax),%eax
f0102167:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010216a:	7f e6                	jg     f0102152 <clearandwritecommand+0xf>
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
f010216c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010216f:	c1 e0 0a             	shl    $0xa,%eax
f0102172:	05 80 fe 86 f0       	add    $0xf086fe80,%eax
f0102177:	83 ec 0c             	sub    $0xc,%esp
f010217a:	50                   	push   %eax
f010217b:	e8 fb 88 01 00       	call   f011aa7b <strlen>
f0102180:	83 c4 10             	add    $0x10,%esp
f0102183:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty_buf, BUFLEN);
f0102186:	83 ec 04             	sub    $0x4,%esp
f0102189:	68 00 04 00 00       	push   $0x400
f010218e:	68 80 4e 87 f0       	push   $0xf0874e80
f0102193:	ff 75 10             	pushl  0x10(%ebp)
f0102196:	e8 71 8b 01 00       	call   f011ad0c <memcpy>
f010219b:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f010219e:	8b 45 08             	mov    0x8(%ebp),%eax
f01021a1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01021a7:	eb 52                	jmp    f01021fb <clearandwritecommand+0xb8>
		cputchar(command_history[commandidx][*i]);
f01021a9:	8b 45 08             	mov    0x8(%ebp),%eax
f01021ac:	8b 00                	mov    (%eax),%eax
f01021ae:	8b 55 0c             	mov    0xc(%ebp),%edx
f01021b1:	c1 e2 0a             	shl    $0xa,%edx
f01021b4:	01 d0                	add    %edx,%eax
f01021b6:	05 80 fe 86 f0       	add    $0xf086fe80,%eax
f01021bb:	8a 00                	mov    (%eax),%al
f01021bd:	0f be c0             	movsbl %al,%eax
f01021c0:	83 ec 0c             	sub    $0xc,%esp
f01021c3:	50                   	push   %eax
f01021c4:	e8 2d f8 ff ff       	call   f01019f6 <cputchar>
f01021c9:	83 c4 10             	add    $0x10,%esp
		buf[*i] = command_history[commandidx][*i];
f01021cc:	8b 45 08             	mov    0x8(%ebp),%eax
f01021cf:	8b 00                	mov    (%eax),%eax
f01021d1:	89 c2                	mov    %eax,%edx
f01021d3:	8b 45 10             	mov    0x10(%ebp),%eax
f01021d6:	01 c2                	add    %eax,%edx
f01021d8:	8b 45 08             	mov    0x8(%ebp),%eax
f01021db:	8b 00                	mov    (%eax),%eax
f01021dd:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f01021e0:	c1 e1 0a             	shl    $0xa,%ecx
f01021e3:	01 c8                	add    %ecx,%eax
f01021e5:	05 80 fe 86 f0       	add    $0xf086fe80,%eax
f01021ea:	8a 00                	mov    (%eax),%al
f01021ec:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < *i; j++) {
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
	memcpy(buf, empty_buf, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f01021ee:	8b 45 08             	mov    0x8(%ebp),%eax
f01021f1:	8b 00                	mov    (%eax),%eax
f01021f3:	8d 50 01             	lea    0x1(%eax),%edx
f01021f6:	8b 45 08             	mov    0x8(%ebp),%eax
f01021f9:	89 10                	mov    %edx,(%eax)
f01021fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01021fe:	8b 00                	mov    (%eax),%eax
f0102200:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0102203:	7c a4                	jl     f01021a9 <clearandwritecommand+0x66>
		cputchar(command_history[commandidx][*i]);
		buf[*i] = command_history[commandidx][*i];
	}
	*last_index = len;
f0102205:	8b 45 14             	mov    0x14(%ebp),%eax
f0102208:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010220b:	89 10                	mov    %edx,(%eax)
}
f010220d:	90                   	nop
f010220e:	c9                   	leave  
f010220f:	c3                   	ret    

f0102210 <RoundAutoCompleteCommandWithTheSamePrefix>:

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
f0102210:	55                   	push   %ebp
f0102211:	89 e5                	mov    %esp,%ebp
f0102213:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < old_buf_len; j++) {
f0102216:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010221d:	eb 10                	jmp    f010222f <RoundAutoCompleteCommandWithTheSamePrefix+0x1f>
		cputchar('\b');
f010221f:	83 ec 0c             	sub    $0xc,%esp
f0102222:	6a 08                	push   $0x8
f0102224:	e8 cd f7 ff ff       	call   f01019f6 <cputchar>
f0102229:	83 c4 10             	add    $0x10,%esp
	*last_index = len;
}

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
	for (int j = 0; j < old_buf_len; j++) {
f010222c:	ff 45 f4             	incl   -0xc(%ebp)
f010222f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102232:	3b 45 08             	cmp    0x8(%ebp),%eax
f0102235:	7c e8                	jl     f010221f <RoundAutoCompleteCommandWithTheSamePrefix+0xf>
		cputchar('\b');
	}
	int len = strlen(prefix_element);
f0102237:	83 ec 0c             	sub    $0xc,%esp
f010223a:	ff 75 0c             	pushl  0xc(%ebp)
f010223d:	e8 39 88 01 00       	call   f011aa7b <strlen>
f0102242:	83 c4 10             	add    $0x10,%esp
f0102245:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty_buf, BUFLEN);
f0102248:	83 ec 04             	sub    $0x4,%esp
f010224b:	68 00 04 00 00       	push   $0x400
f0102250:	68 80 4e 87 f0       	push   $0xf0874e80
f0102255:	ff 75 10             	pushl  0x10(%ebp)
f0102258:	e8 af 8a 01 00       	call   f011ad0c <memcpy>
f010225d:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f0102260:	8b 45 14             	mov    0x14(%ebp),%eax
f0102263:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0102269:	eb 46                	jmp    f01022b1 <RoundAutoCompleteCommandWithTheSamePrefix+0xa1>
		cputchar(prefix_element[*i]);
f010226b:	8b 45 14             	mov    0x14(%ebp),%eax
f010226e:	8b 00                	mov    (%eax),%eax
f0102270:	89 c2                	mov    %eax,%edx
f0102272:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102275:	01 d0                	add    %edx,%eax
f0102277:	8a 00                	mov    (%eax),%al
f0102279:	0f be c0             	movsbl %al,%eax
f010227c:	83 ec 0c             	sub    $0xc,%esp
f010227f:	50                   	push   %eax
f0102280:	e8 71 f7 ff ff       	call   f01019f6 <cputchar>
f0102285:	83 c4 10             	add    $0x10,%esp
		buf[*i] = prefix_element[*i];
f0102288:	8b 45 14             	mov    0x14(%ebp),%eax
f010228b:	8b 00                	mov    (%eax),%eax
f010228d:	89 c2                	mov    %eax,%edx
f010228f:	8b 45 10             	mov    0x10(%ebp),%eax
f0102292:	01 c2                	add    %eax,%edx
f0102294:	8b 45 14             	mov    0x14(%ebp),%eax
f0102297:	8b 00                	mov    (%eax),%eax
f0102299:	89 c1                	mov    %eax,%ecx
f010229b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010229e:	01 c8                	add    %ecx,%eax
f01022a0:	8a 00                	mov    (%eax),%al
f01022a2:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < old_buf_len; j++) {
		cputchar('\b');
	}
	int len = strlen(prefix_element);
	memcpy(buf, empty_buf, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f01022a4:	8b 45 14             	mov    0x14(%ebp),%eax
f01022a7:	8b 00                	mov    (%eax),%eax
f01022a9:	8d 50 01             	lea    0x1(%eax),%edx
f01022ac:	8b 45 14             	mov    0x14(%ebp),%eax
f01022af:	89 10                	mov    %edx,(%eax)
f01022b1:	8b 45 14             	mov    0x14(%ebp),%eax
f01022b4:	8b 00                	mov    (%eax),%eax
f01022b6:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01022b9:	7c b0                	jl     f010226b <RoundAutoCompleteCommandWithTheSamePrefix+0x5b>
		cputchar(prefix_element[*i]);
		buf[*i] = prefix_element[*i];
	}
	*last_index = len;
f01022bb:	8b 45 18             	mov    0x18(%ebp),%eax
f01022be:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01022c1:	89 10                	mov    %edx,(%eax)
}
f01022c3:	90                   	nop
f01022c4:	c9                   	leave  
f01022c5:	c3                   	ret    

f01022c6 <clear_prefix_list>:

char PrefixList[100][1024];
void clear_prefix_list()
{
f01022c6:	55                   	push   %ebp
f01022c7:	89 e5                	mov    %esp,%ebp
f01022c9:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < 100; ++i) {
f01022cc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01022d3:	eb 21                	jmp    f01022f6 <clear_prefix_list+0x30>
		memset(PrefixList[i], 0, 1024);}
f01022d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01022d8:	c1 e0 0a             	shl    $0xa,%eax
f01022db:	05 80 6e 85 f0       	add    $0xf0856e80,%eax
f01022e0:	83 ec 04             	sub    $0x4,%esp
f01022e3:	68 00 04 00 00       	push   $0x400
f01022e8:	6a 00                	push   $0x0
f01022ea:	50                   	push   %eax
f01022eb:	e8 79 89 01 00       	call   f011ac69 <memset>
f01022f0:	83 c4 10             	add    $0x10,%esp
}

char PrefixList[100][1024];
void clear_prefix_list()
{
	for (int i = 0; i < 100; ++i) {
f01022f3:	ff 45 f4             	incl   -0xc(%ebp)
f01022f6:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
f01022fa:	7e d9                	jle    f01022d5 <clear_prefix_list+0xf>
		memset(PrefixList[i], 0, 1024);}
}
f01022fc:	90                   	nop
f01022fd:	c9                   	leave  
f01022fe:	c3                   	ret    

f01022ff <command_prompt_readline>:

//Array of tests
extern struct Test tests[] ;
extern uint32 NUM_OF_TESTS;

void command_prompt_readline(const char *prompt, char* buf) {
f01022ff:	55                   	push   %ebp
f0102300:	89 e5                	mov    %esp,%ebp
f0102302:	57                   	push   %edi
f0102303:	53                   	push   %ebx
f0102304:	81 ec d0 08 00 00    	sub    $0x8d0,%esp
	int i, c, echoing, lastIndex;
	if (prompt != NULL)
f010230a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010230e:	74 13                	je     f0102323 <command_prompt_readline+0x24>
		cprintf("%s", prompt);
f0102310:	83 ec 08             	sub    $0x8,%esp
f0102313:	ff 75 08             	pushl  0x8(%ebp)
f0102316:	68 40 b9 12 f0       	push   $0xf012b940
f010231b:	e8 3c f8 ff ff       	call   f0101b5c <cprintf>
f0102320:	83 c4 10             	add    $0x10,%esp

	int commandidx = last_command_idx + 1;
f0102323:	a1 50 f5 17 f0       	mov    0xf017f550,%eax
f0102328:	40                   	inc    %eax
f0102329:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int prefix_list_idx = lastIndex = i = 0;
f010232c:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f0102333:	00 00 00 
f0102336:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f010233c:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0102342:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0102348:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int prefix_list_size, last_c;
	echoing = iscons(0);
f010234b:	83 ec 0c             	sub    $0xc,%esp
f010234e:	6a 00                	push   $0x0
f0102350:	e8 d1 f6 ff ff       	call   f0101a26 <iscons>
f0102355:	83 c4 10             	add    $0x10,%esp
f0102358:	89 45 98             	mov    %eax,-0x68(%ebp)
	bool is_run_cmd = 0;
f010235b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool is_tst_cmd = 0;
f0102362:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

	while (1) {
		c = getchar();
f0102369:	e8 9f f6 ff ff       	call   f0101a0d <getchar>
f010236e:	89 45 94             	mov    %eax,-0x6c(%ebp)
		if (i > lastIndex)
f0102371:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f0102377:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f010237d:	39 c2                	cmp    %eax,%edx
f010237f:	7e 0c                	jle    f010238d <command_prompt_readline+0x8e>
			lastIndex = i;
f0102381:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102387:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		if (c < 0) {
f010238d:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
f0102391:	79 22                	jns    f01023b5 <command_prompt_readline+0xb6>

			if (c != -E_EOF)
f0102393:	83 7d 94 07          	cmpl   $0x7,-0x6c(%ebp)
f0102397:	0f 84 94 0a 00 00    	je     f0102e31 <command_prompt_readline+0xb32>
				cprintf("read error: %e\n", c);
f010239d:	83 ec 08             	sub    $0x8,%esp
f01023a0:	ff 75 94             	pushl  -0x6c(%ebp)
f01023a3:	68 43 b9 12 f0       	push   $0xf012b943
f01023a8:	e8 af f7 ff ff       	call   f0101b5c <cprintf>
f01023ad:	83 c4 10             	add    $0x10,%esp
			return;
f01023b0:	e9 7c 0a 00 00       	jmp    f0102e31 <command_prompt_readline+0xb32>
		} else if (c == 226) { // Up arrow
f01023b5:	81 7d 94 e2 00 00 00 	cmpl   $0xe2,-0x6c(%ebp)
f01023bc:	75 2a                	jne    f01023e8 <command_prompt_readline+0xe9>
			if (commandidx)
f01023be:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01023c2:	74 03                	je     f01023c7 <command_prompt_readline+0xc8>
				commandidx--;
f01023c4:	ff 4d f4             	decl   -0xc(%ebp)
			clearandwritecommand(&i, commandidx, buf, &lastIndex);
f01023c7:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f01023cd:	50                   	push   %eax
f01023ce:	ff 75 0c             	pushl  0xc(%ebp)
f01023d1:	ff 75 f4             	pushl  -0xc(%ebp)
f01023d4:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f01023da:	50                   	push   %eax
f01023db:	e8 63 fd ff ff       	call   f0102143 <clearandwritecommand>
f01023e0:	83 c4 10             	add    $0x10,%esp
f01023e3:	e9 32 0a 00 00       	jmp    f0102e1a <command_prompt_readline+0xb1b>
		} else if (c == 227) { // Down arrow
f01023e8:	81 7d 94 e3 00 00 00 	cmpl   $0xe3,-0x6c(%ebp)
f01023ef:	75 3b                	jne    f010242c <command_prompt_readline+0x12d>
			if (commandidx < last_command_idx)
f01023f1:	a1 50 f5 17 f0       	mov    0xf017f550,%eax
f01023f6:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f01023f9:	7d 03                	jge    f01023fe <command_prompt_readline+0xff>
				commandidx++;
f01023fb:	ff 45 f4             	incl   -0xc(%ebp)
			if (last_command_idx >= 0)
f01023fe:	a1 50 f5 17 f0       	mov    0xf017f550,%eax
f0102403:	85 c0                	test   %eax,%eax
f0102405:	0f 88 0f 0a 00 00    	js     f0102e1a <command_prompt_readline+0xb1b>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
f010240b:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0102411:	50                   	push   %eax
f0102412:	ff 75 0c             	pushl  0xc(%ebp)
f0102415:	ff 75 f4             	pushl  -0xc(%ebp)
f0102418:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f010241e:	50                   	push   %eax
f010241f:	e8 1f fd ff ff       	call   f0102143 <clearandwritecommand>
f0102424:	83 c4 10             	add    $0x10,%esp
f0102427:	e9 ee 09 00 00       	jmp    f0102e1a <command_prompt_readline+0xb1b>
		} else if (c == 9) { // Tab button
f010242c:	83 7d 94 09          	cmpl   $0x9,-0x6c(%ebp)
f0102430:	0f 85 6d 07 00 00    	jne    f0102ba3 <command_prompt_readline+0x8a4>
			if (last_c != 9) {
f0102436:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
f010243a:	0f 84 fc 06 00 00    	je     f0102b3c <command_prompt_readline+0x83d>
				clear_prefix_list(PrefixList, 100);
f0102440:	83 ec 08             	sub    $0x8,%esp
f0102443:	6a 64                	push   $0x64
f0102445:	68 80 6e 85 f0       	push   $0xf0856e80
f010244a:	e8 77 fe ff ff       	call   f01022c6 <clear_prefix_list>
f010244f:	83 c4 10             	add    $0x10,%esp
				if (strlen(buf) == 0 || last_c == 255)
f0102452:	83 ec 0c             	sub    $0xc,%esp
f0102455:	ff 75 0c             	pushl  0xc(%ebp)
f0102458:	e8 1e 86 01 00       	call   f011aa7b <strlen>
f010245d:	83 c4 10             	add    $0x10,%esp
f0102460:	85 c0                	test   %eax,%eax
f0102462:	0f 84 bd 09 00 00    	je     f0102e25 <command_prompt_readline+0xb26>
f0102468:	81 7d e8 ff 00 00 00 	cmpl   $0xff,-0x18(%ebp)
f010246f:	0f 84 b0 09 00 00    	je     f0102e25 <command_prompt_readline+0xb26>
					continue;
				char *arguments[MAX_ARGUMENTS];
				int number_of_arguments = prefix_list_size = 0;
f0102475:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f010247c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010247f:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
				char temp_buf[1024];
				strcpy(temp_buf, buf);
f0102485:	83 ec 08             	sub    $0x8,%esp
f0102488:	ff 75 0c             	pushl  0xc(%ebp)
f010248b:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0102491:	50                   	push   %eax
f0102492:	e8 33 86 01 00       	call   f011aaca <strcpy>
f0102497:	83 c4 10             	add    $0x10,%esp
				int bufLength = strlen(buf);
f010249a:	83 ec 0c             	sub    $0xc,%esp
f010249d:	ff 75 0c             	pushl  0xc(%ebp)
f01024a0:	e8 d6 85 01 00       	call   f011aa7b <strlen>
f01024a5:	83 c4 10             	add    $0x10,%esp
f01024a8:	89 45 90             	mov    %eax,-0x70(%ebp)
				if (buf[bufLength - 1] == ' ')
f01024ab:	8b 45 90             	mov    -0x70(%ebp),%eax
f01024ae:	8d 50 ff             	lea    -0x1(%eax),%edx
f01024b1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01024b4:	01 d0                	add    %edx,%eax
f01024b6:	8a 00                	mov    (%eax),%al
f01024b8:	3c 20                	cmp    $0x20,%al
f01024ba:	0f 84 6b 09 00 00    	je     f0102e2b <command_prompt_readline+0xb2c>
					continue;
				strsplit(temp_buf, WHITESPACE, arguments, &number_of_arguments);
f01024c0:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f01024c6:	50                   	push   %eax
f01024c7:	8d 85 30 f7 ff ff    	lea    -0x8d0(%ebp),%eax
f01024cd:	50                   	push   %eax
f01024ce:	68 53 b9 12 f0       	push   $0xf012b953
f01024d3:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01024d9:	50                   	push   %eax
f01024da:	e8 60 8c 01 00       	call   f011b13f <strsplit>
f01024df:	83 c4 10             	add    $0x10,%esp
				int it_str = 0;
f01024e2:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if (number_of_arguments > 1) {
f01024e9:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01024ef:	83 f8 01             	cmp    $0x1,%eax
f01024f2:	0f 8e 28 01 00 00    	jle    f0102620 <command_prompt_readline+0x321>
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
f01024f8:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01024fe:	83 ec 08             	sub    $0x8,%esp
f0102501:	68 58 b9 12 f0       	push   $0xf012b958
f0102506:	50                   	push   %eax
f0102507:	e8 7b 86 01 00       	call   f011ab87 <strcmp>
f010250c:	83 c4 10             	add    $0x10,%esp
f010250f:	85 c0                	test   %eax,%eax
f0102511:	74 3c                	je     f010254f <command_prompt_readline+0x250>
f0102513:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0102519:	83 ec 08             	sub    $0x8,%esp
f010251c:	68 5c b9 12 f0       	push   $0xf012b95c
f0102521:	50                   	push   %eax
f0102522:	e8 60 86 01 00       	call   f011ab87 <strcmp>
f0102527:	83 c4 10             	add    $0x10,%esp
f010252a:	85 c0                	test   %eax,%eax
f010252c:	74 21                	je     f010254f <command_prompt_readline+0x250>
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
f010252e:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0102534:	83 ec 08             	sub    $0x8,%esp
f0102537:	68 61 b9 12 f0       	push   $0xf012b961
f010253c:	50                   	push   %eax
f010253d:	e8 45 86 01 00       	call   f011ab87 <strcmp>
f0102542:	83 c4 10             	add    $0x10,%esp
f0102545:	85 c0                	test   %eax,%eax
f0102547:	74 06                	je     f010254f <command_prompt_readline+0x250>
						continue;
f0102549:	90                   	nop
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f010254a:	e9 d6 08 00 00       	jmp    f0102e25 <command_prompt_readline+0xb26>
				int it_str = 0;
				if (number_of_arguments > 1) {
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
						continue;
					if ((strcmp(arguments[0], "tst") == 0))
f010254f:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0102555:	83 ec 08             	sub    $0x8,%esp
f0102558:	68 61 b9 12 f0       	push   $0xf012b961
f010255d:	50                   	push   %eax
f010255e:	e8 24 86 01 00       	call   f011ab87 <strcmp>
f0102563:	83 c4 10             	add    $0x10,%esp
f0102566:	85 c0                	test   %eax,%eax
f0102568:	75 09                	jne    f0102573 <command_prompt_readline+0x274>
					{
						is_tst_cmd = 1;
f010256a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
f0102571:	eb 07                	jmp    f010257a <command_prompt_readline+0x27b>
					}
					else
					{
						is_run_cmd = 1;
f0102573:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
					}
					char temp[1024] = "";
f010257a:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f0102581:	00 00 00 
f0102584:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f010258a:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010258f:	b8 00 00 00 00       	mov    $0x0,%eax
f0102594:	89 d7                	mov    %edx,%edi
f0102596:	f3 ab                	rep stos %eax,%es:(%edi)
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
f0102598:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010259e:	48                   	dec    %eax
f010259f:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f01025a6:	83 ec 0c             	sub    $0xc,%esp
f01025a9:	50                   	push   %eax
f01025aa:	e8 cc 84 01 00       	call   f011aa7b <strlen>
f01025af:	83 c4 10             	add    $0x10,%esp
f01025b2:	8b 55 90             	mov    -0x70(%ebp),%edx
f01025b5:	29 c2                	sub    %eax,%edx
f01025b7:	89 d0                	mov    %edx,%eax
f01025b9:	89 45 8c             	mov    %eax,-0x74(%ebp)
					for (int var = 0; var < TotalLen; ++var) {
f01025bc:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f01025c3:	eb 1d                	jmp    f01025e2 <command_prompt_readline+0x2e3>
						temp[it_str++] = buf[var];
f01025c5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01025c8:	8d 50 01             	lea    0x1(%eax),%edx
f01025cb:	89 55 dc             	mov    %edx,-0x24(%ebp)
f01025ce:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f01025d1:	8b 55 0c             	mov    0xc(%ebp),%edx
f01025d4:	01 ca                	add    %ecx,%edx
f01025d6:	8a 12                	mov    (%edx),%dl
f01025d8:	88 94 05 70 fb ff ff 	mov    %dl,-0x490(%ebp,%eax,1)
					{
						is_run_cmd = 1;
					}
					char temp[1024] = "";
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
					for (int var = 0; var < TotalLen; ++var) {
f01025df:	ff 45 d8             	incl   -0x28(%ebp)
f01025e2:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01025e5:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f01025e8:	7c db                	jl     f01025c5 <command_prompt_readline+0x2c6>
						temp[it_str++] = buf[var];
					}
					strcpy(buf, temp);   //buf contains all arguments except the last one
f01025ea:	83 ec 08             	sub    $0x8,%esp
f01025ed:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01025f3:	50                   	push   %eax
f01025f4:	ff 75 0c             	pushl  0xc(%ebp)
f01025f7:	e8 ce 84 01 00       	call   f011aaca <strcpy>
f01025fc:	83 c4 10             	add    $0x10,%esp
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
f01025ff:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0102605:	48                   	dec    %eax
f0102606:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f010260d:	83 ec 08             	sub    $0x8,%esp
f0102610:	50                   	push   %eax
f0102611:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0102617:	50                   	push   %eax
f0102618:	e8 ad 84 01 00       	call   f011aaca <strcpy>
f010261d:	83 c4 10             	add    $0x10,%esp
				}
				int it_prefix_list = 0;
f0102620:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
				if(number_of_arguments == 1)
f0102627:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010262d:	83 f8 01             	cmp    $0x1,%eax
f0102630:	0f 85 30 01 00 00    	jne    f0102766 <command_prompt_readline+0x467>
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f0102636:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f010263d:	e9 0f 01 00 00       	jmp    f0102751 <command_prompt_readline+0x452>
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
f0102642:	83 ec 0c             	sub    $0xc,%esp
f0102645:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f010264b:	50                   	push   %eax
f010264c:	e8 2a 84 01 00       	call   f011aa7b <strlen>
f0102651:	83 c4 10             	add    $0x10,%esp
f0102654:	89 c1                	mov    %eax,%ecx
f0102656:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0102659:	89 d0                	mov    %edx,%eax
f010265b:	01 c0                	add    %eax,%eax
f010265d:	01 d0                	add    %edx,%eax
f010265f:	c1 e0 03             	shl    $0x3,%eax
f0102662:	05 60 f5 17 f0       	add    $0xf017f560,%eax
f0102667:	8b 00                	mov    (%eax),%eax
f0102669:	83 ec 04             	sub    $0x4,%esp
f010266c:	51                   	push   %ecx
f010266d:	50                   	push   %eax
f010266e:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0102674:	50                   	push   %eax
f0102675:	e8 45 85 01 00       	call   f011abbf <strncmp>
f010267a:	83 c4 10             	add    $0x10,%esp
f010267d:	89 45 88             	mov    %eax,-0x78(%ebp)
						if (x == 0) {
f0102680:	83 7d 88 00          	cmpl   $0x0,-0x78(%ebp)
f0102684:	0f 85 c4 00 00 00    	jne    f010274e <command_prompt_readline+0x44f>
							it_str = -1;
f010268a:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
							char string[1024] = "";
f0102691:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f0102698:	00 00 00 
f010269b:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01026a1:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01026a6:	b8 00 00 00 00       	mov    $0x0,%eax
f01026ab:	89 d7                	mov    %edx,%edi
f01026ad:	f3 ab                	rep stos %eax,%es:(%edi)
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f01026af:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f01026b6:	eb 2d                	jmp    f01026e5 <command_prompt_readline+0x3e6>
								string[++it_str] = commands[var].name[var3];
f01026b8:	ff 45 dc             	incl   -0x24(%ebp)
f01026bb:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01026be:	89 d0                	mov    %edx,%eax
f01026c0:	01 c0                	add    %eax,%eax
f01026c2:	01 d0                	add    %edx,%eax
f01026c4:	c1 e0 03             	shl    $0x3,%eax
f01026c7:	05 60 f5 17 f0       	add    $0xf017f560,%eax
f01026cc:	8b 10                	mov    (%eax),%edx
f01026ce:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01026d1:	01 d0                	add    %edx,%eax
f01026d3:	8a 00                	mov    (%eax),%al
f01026d5:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f01026db:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01026de:	01 ca                	add    %ecx,%edx
f01026e0:	88 02                	mov    %al,(%edx)
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
						if (x == 0) {
							it_str = -1;
							char string[1024] = "";
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f01026e2:	ff 45 cc             	incl   -0x34(%ebp)
f01026e5:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01026e8:	89 d0                	mov    %edx,%eax
f01026ea:	01 c0                	add    %eax,%eax
f01026ec:	01 d0                	add    %edx,%eax
f01026ee:	c1 e0 03             	shl    $0x3,%eax
f01026f1:	05 60 f5 17 f0       	add    $0xf017f560,%eax
f01026f6:	8b 00                	mov    (%eax),%eax
f01026f8:	83 ec 0c             	sub    $0xc,%esp
f01026fb:	50                   	push   %eax
f01026fc:	e8 7a 83 01 00       	call   f011aa7b <strlen>
f0102701:	83 c4 10             	add    $0x10,%esp
f0102704:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f0102707:	7f af                	jg     f01026b8 <command_prompt_readline+0x3b9>
								string[++it_str] = commands[var].name[var3];
							}
							memset(PrefixList[it_prefix_list], 0, 1024);
f0102709:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010270c:	c1 e0 0a             	shl    $0xa,%eax
f010270f:	05 80 6e 85 f0       	add    $0xf0856e80,%eax
f0102714:	83 ec 04             	sub    $0x4,%esp
f0102717:	68 00 04 00 00       	push   $0x400
f010271c:	6a 00                	push   $0x0
f010271e:	50                   	push   %eax
f010271f:	e8 45 85 01 00       	call   f011ac69 <memset>
f0102724:	83 c4 10             	add    $0x10,%esp
							strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0102727:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010272a:	40                   	inc    %eax
f010272b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010272e:	c1 e2 0a             	shl    $0xa,%edx
f0102731:	81 c2 80 6e 85 f0    	add    $0xf0856e80,%edx
f0102737:	83 ec 04             	sub    $0x4,%esp
f010273a:	50                   	push   %eax
f010273b:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f0102741:	50                   	push   %eax
f0102742:	52                   	push   %edx
f0102743:	e8 b0 83 01 00       	call   f011aaf8 <strncpy>
f0102748:	83 c4 10             	add    $0x10,%esp
							it_prefix_list++;
f010274b:	ff 45 d4             	incl   -0x2c(%ebp)
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
				}
				int it_prefix_list = 0;
				if(number_of_arguments == 1)
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f010274e:	ff 45 d0             	incl   -0x30(%ebp)
f0102751:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0102754:	a1 a8 fb 17 f0       	mov    0xf017fba8,%eax
f0102759:	39 c2                	cmp    %eax,%edx
f010275b:	0f 82 e1 fe ff ff    	jb     f0102642 <command_prompt_readline+0x343>
f0102761:	e9 fe 02 00 00       	jmp    f0102a64 <command_prompt_readline+0x765>
						}
					}
				}
				else
				{
					if(is_run_cmd)
f0102766:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010276a:	0f 84 7b 01 00 00    	je     f01028eb <command_prompt_readline+0x5ec>
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f0102770:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f0102777:	e9 5c 01 00 00       	jmp    f01028d8 <command_prompt_readline+0x5d9>
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
f010277c:	83 ec 0c             	sub    $0xc,%esp
f010277f:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0102785:	50                   	push   %eax
f0102786:	e8 f0 82 01 00       	call   f011aa7b <strlen>
f010278b:	83 c4 10             	add    $0x10,%esp
f010278e:	89 c1                	mov    %eax,%ecx
f0102790:	8b 1d 9c 00 18 f0    	mov    0xf018009c,%ebx
f0102796:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0102799:	89 d0                	mov    %edx,%eax
f010279b:	01 c0                	add    %eax,%eax
f010279d:	01 d0                	add    %edx,%eax
f010279f:	c1 e0 02             	shl    $0x2,%eax
f01027a2:	01 d8                	add    %ebx,%eax
f01027a4:	8b 00                	mov    (%eax),%eax
f01027a6:	83 ec 04             	sub    $0x4,%esp
f01027a9:	51                   	push   %ecx
f01027aa:	50                   	push   %eax
f01027ab:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01027b1:	50                   	push   %eax
f01027b2:	e8 08 84 01 00       	call   f011abbf <strncmp>
f01027b7:	83 c4 10             	add    $0x10,%esp
f01027ba:	89 45 84             	mov    %eax,-0x7c(%ebp)
							if (x == 0) {
f01027bd:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
f01027c1:	0f 85 0e 01 00 00    	jne    f01028d5 <command_prompt_readline+0x5d6>
								it_str = -1;
f01027c7:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f01027ce:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01027d5:	00 00 00 
f01027d8:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01027de:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01027e3:	b8 00 00 00 00       	mov    $0x0,%eax
f01027e8:	89 d7                	mov    %edx,%edi
f01027ea:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f01027ec:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01027f2:	83 f8 01             	cmp    $0x1,%eax
f01027f5:	7e 39                	jle    f0102830 <command_prompt_readline+0x531>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f01027f7:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f01027fe:	eb 1d                	jmp    f010281d <command_prompt_readline+0x51e>
										string[++it_str] = buf[var2];
f0102800:	ff 45 dc             	incl   -0x24(%ebp)
f0102803:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0102806:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102809:	01 d0                	add    %edx,%eax
f010280b:	8a 00                	mov    (%eax),%al
f010280d:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0102813:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0102816:	01 ca                	add    %ecx,%edx
f0102818:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f010281a:	ff 45 c4             	incl   -0x3c(%ebp)
f010281d:	83 ec 0c             	sub    $0xc,%esp
f0102820:	ff 75 0c             	pushl  0xc(%ebp)
f0102823:	e8 53 82 01 00       	call   f011aa7b <strlen>
f0102828:	83 c4 10             	add    $0x10,%esp
f010282b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f010282e:	7f d0                	jg     f0102800 <command_prompt_readline+0x501>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f0102830:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
f0102837:	eb 30                	jmp    f0102869 <command_prompt_readline+0x56a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
f0102839:	ff 45 dc             	incl   -0x24(%ebp)
f010283c:	8b 0d 9c 00 18 f0    	mov    0xf018009c,%ecx
f0102842:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0102845:	89 d0                	mov    %edx,%eax
f0102847:	01 c0                	add    %eax,%eax
f0102849:	01 d0                	add    %edx,%eax
f010284b:	c1 e0 02             	shl    $0x2,%eax
f010284e:	01 c8                	add    %ecx,%eax
f0102850:	8b 10                	mov    (%eax),%edx
f0102852:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0102855:	01 d0                	add    %edx,%eax
f0102857:	8a 00                	mov    (%eax),%al
f0102859:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010285f:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0102862:	01 ca                	add    %ecx,%edx
f0102864:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f0102866:	ff 45 c0             	incl   -0x40(%ebp)
f0102869:	8b 0d 9c 00 18 f0    	mov    0xf018009c,%ecx
f010286f:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0102872:	89 d0                	mov    %edx,%eax
f0102874:	01 c0                	add    %eax,%eax
f0102876:	01 d0                	add    %edx,%eax
f0102878:	c1 e0 02             	shl    $0x2,%eax
f010287b:	01 c8                	add    %ecx,%eax
f010287d:	8b 00                	mov    (%eax),%eax
f010287f:	83 ec 0c             	sub    $0xc,%esp
f0102882:	50                   	push   %eax
f0102883:	e8 f3 81 01 00       	call   f011aa7b <strlen>
f0102888:	83 c4 10             	add    $0x10,%esp
f010288b:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f010288e:	7f a9                	jg     f0102839 <command_prompt_readline+0x53a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0102890:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102893:	c1 e0 0a             	shl    $0xa,%eax
f0102896:	05 80 6e 85 f0       	add    $0xf0856e80,%eax
f010289b:	83 ec 04             	sub    $0x4,%esp
f010289e:	68 00 04 00 00       	push   $0x400
f01028a3:	6a 00                	push   $0x0
f01028a5:	50                   	push   %eax
f01028a6:	e8 be 83 01 00       	call   f011ac69 <memset>
f01028ab:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f01028ae:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01028b1:	40                   	inc    %eax
f01028b2:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01028b5:	c1 e2 0a             	shl    $0xa,%edx
f01028b8:	81 c2 80 6e 85 f0    	add    $0xf0856e80,%edx
f01028be:	83 ec 04             	sub    $0x4,%esp
f01028c1:	50                   	push   %eax
f01028c2:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01028c8:	50                   	push   %eax
f01028c9:	52                   	push   %edx
f01028ca:	e8 29 82 01 00       	call   f011aaf8 <strncpy>
f01028cf:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f01028d2:	ff 45 d4             	incl   -0x2c(%ebp)
				}
				else
				{
					if(is_run_cmd)
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f01028d5:	ff 45 c8             	incl   -0x38(%ebp)
f01028d8:	a1 a0 00 18 f0       	mov    0xf01800a0,%eax
f01028dd:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f01028e0:	0f 8c 96 fe ff ff    	jl     f010277c <command_prompt_readline+0x47d>
f01028e6:	e9 79 01 00 00       	jmp    f0102a64 <command_prompt_readline+0x765>
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
								it_prefix_list++;
							}
						}
					}
					else if(is_tst_cmd)
f01028eb:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01028ef:	0f 84 6f 01 00 00    	je     f0102a64 <command_prompt_readline+0x765>
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f01028f5:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f01028fc:	e9 53 01 00 00       	jmp    f0102a54 <command_prompt_readline+0x755>
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
f0102901:	83 ec 0c             	sub    $0xc,%esp
f0102904:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f010290a:	50                   	push   %eax
f010290b:	e8 6b 81 01 00       	call   f011aa7b <strlen>
f0102910:	83 c4 10             	add    $0x10,%esp
f0102913:	89 c1                	mov    %eax,%ecx
f0102915:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0102918:	89 d0                	mov    %edx,%eax
f010291a:	01 c0                	add    %eax,%eax
f010291c:	01 d0                	add    %edx,%eax
f010291e:	c1 e0 02             	shl    $0x2,%eax
f0102921:	05 c0 00 18 f0       	add    $0xf01800c0,%eax
f0102926:	8b 00                	mov    (%eax),%eax
f0102928:	83 ec 04             	sub    $0x4,%esp
f010292b:	51                   	push   %ecx
f010292c:	50                   	push   %eax
f010292d:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0102933:	50                   	push   %eax
f0102934:	e8 86 82 01 00       	call   f011abbf <strncmp>
f0102939:	83 c4 10             	add    $0x10,%esp
f010293c:	89 45 80             	mov    %eax,-0x80(%ebp)
							if (x == 0) {
f010293f:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f0102943:	0f 85 08 01 00 00    	jne    f0102a51 <command_prompt_readline+0x752>
								it_str = -1;
f0102949:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f0102950:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f0102957:	00 00 00 
f010295a:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0102960:	b9 ff 00 00 00       	mov    $0xff,%ecx
f0102965:	b8 00 00 00 00       	mov    $0x0,%eax
f010296a:	89 d7                	mov    %edx,%edi
f010296c:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f010296e:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0102974:	83 f8 01             	cmp    $0x1,%eax
f0102977:	7e 39                	jle    f01029b2 <command_prompt_readline+0x6b3>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0102979:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
f0102980:	eb 1d                	jmp    f010299f <command_prompt_readline+0x6a0>
										string[++it_str] = buf[var2];
f0102982:	ff 45 dc             	incl   -0x24(%ebp)
f0102985:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0102988:	8b 45 0c             	mov    0xc(%ebp),%eax
f010298b:	01 d0                	add    %edx,%eax
f010298d:	8a 00                	mov    (%eax),%al
f010298f:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0102995:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0102998:	01 ca                	add    %ecx,%edx
f010299a:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f010299c:	ff 45 b8             	incl   -0x48(%ebp)
f010299f:	83 ec 0c             	sub    $0xc,%esp
f01029a2:	ff 75 0c             	pushl  0xc(%ebp)
f01029a5:	e8 d1 80 01 00       	call   f011aa7b <strlen>
f01029aa:	83 c4 10             	add    $0x10,%esp
f01029ad:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f01029b0:	7f d0                	jg     f0102982 <command_prompt_readline+0x683>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f01029b2:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
f01029b9:	eb 2d                	jmp    f01029e8 <command_prompt_readline+0x6e9>
									string[++it_str] = tests[var].name[var3];
f01029bb:	ff 45 dc             	incl   -0x24(%ebp)
f01029be:	8b 55 bc             	mov    -0x44(%ebp),%edx
f01029c1:	89 d0                	mov    %edx,%eax
f01029c3:	01 c0                	add    %eax,%eax
f01029c5:	01 d0                	add    %edx,%eax
f01029c7:	c1 e0 02             	shl    $0x2,%eax
f01029ca:	05 c0 00 18 f0       	add    $0xf01800c0,%eax
f01029cf:	8b 10                	mov    (%eax),%edx
f01029d1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01029d4:	01 d0                	add    %edx,%eax
f01029d6:	8a 00                	mov    (%eax),%al
f01029d8:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f01029de:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01029e1:	01 ca                	add    %ecx,%edx
f01029e3:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f01029e5:	ff 45 b4             	incl   -0x4c(%ebp)
f01029e8:	8b 55 bc             	mov    -0x44(%ebp),%edx
f01029eb:	89 d0                	mov    %edx,%eax
f01029ed:	01 c0                	add    %eax,%eax
f01029ef:	01 d0                	add    %edx,%eax
f01029f1:	c1 e0 02             	shl    $0x2,%eax
f01029f4:	05 c0 00 18 f0       	add    $0xf01800c0,%eax
f01029f9:	8b 00                	mov    (%eax),%eax
f01029fb:	83 ec 0c             	sub    $0xc,%esp
f01029fe:	50                   	push   %eax
f01029ff:	e8 77 80 01 00       	call   f011aa7b <strlen>
f0102a04:	83 c4 10             	add    $0x10,%esp
f0102a07:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0102a0a:	7f af                	jg     f01029bb <command_prompt_readline+0x6bc>
									string[++it_str] = tests[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0102a0c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102a0f:	c1 e0 0a             	shl    $0xa,%eax
f0102a12:	05 80 6e 85 f0       	add    $0xf0856e80,%eax
f0102a17:	83 ec 04             	sub    $0x4,%esp
f0102a1a:	68 00 04 00 00       	push   $0x400
f0102a1f:	6a 00                	push   $0x0
f0102a21:	50                   	push   %eax
f0102a22:	e8 42 82 01 00       	call   f011ac69 <memset>
f0102a27:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0102a2a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102a2d:	40                   	inc    %eax
f0102a2e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0102a31:	c1 e2 0a             	shl    $0xa,%edx
f0102a34:	81 c2 80 6e 85 f0    	add    $0xf0856e80,%edx
f0102a3a:	83 ec 04             	sub    $0x4,%esp
f0102a3d:	50                   	push   %eax
f0102a3e:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f0102a44:	50                   	push   %eax
f0102a45:	52                   	push   %edx
f0102a46:	e8 ad 80 01 00       	call   f011aaf8 <strncpy>
f0102a4b:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f0102a4e:	ff 45 d4             	incl   -0x2c(%ebp)
							}
						}
					}
					else if(is_tst_cmd)
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f0102a51:	ff 45 bc             	incl   -0x44(%ebp)
f0102a54:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0102a57:	a1 80 01 18 f0       	mov    0xf0180180,%eax
f0102a5c:	39 c2                	cmp    %eax,%edx
f0102a5e:	0f 82 9d fe ff ff    	jb     f0102901 <command_prompt_readline+0x602>
								it_prefix_list++;
							}
						}
					}
				}
				prefix_list_size = it_prefix_list;
f0102a64:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102a67:	89 45 ec             	mov    %eax,-0x14(%ebp)
				if (it_prefix_list) {
f0102a6a:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0102a6e:	0f 84 a6 03 00 00    	je     f0102e1a <command_prompt_readline+0xb1b>
					prefix_list_idx = it_str = 0;
f0102a74:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0102a7b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102a7e:	89 45 f0             	mov    %eax,-0x10(%ebp)
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f0102a81:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
f0102a88:	eb 1f                	jmp    f0102aa9 <command_prompt_readline+0x7aa>
						buf[it_str++] = PrefixList[0][var2];}
f0102a8a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102a8d:	8d 50 01             	lea    0x1(%eax),%edx
f0102a90:	89 55 dc             	mov    %edx,-0x24(%ebp)
f0102a93:	89 c2                	mov    %eax,%edx
f0102a95:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102a98:	01 c2                	add    %eax,%edx
f0102a9a:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0102a9d:	05 80 6e 85 f0       	add    $0xf0856e80,%eax
f0102aa2:	8a 00                	mov    (%eax),%al
f0102aa4:	88 02                	mov    %al,(%edx)
					}
				}
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f0102aa6:	ff 45 b0             	incl   -0x50(%ebp)
f0102aa9:	83 ec 0c             	sub    $0xc,%esp
f0102aac:	68 80 6e 85 f0       	push   $0xf0856e80
f0102ab1:	e8 c5 7f 01 00       	call   f011aa7b <strlen>
f0102ab6:	83 c4 10             	add    $0x10,%esp
f0102ab9:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0102abc:	7f cc                	jg     f0102a8a <command_prompt_readline+0x78b>
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f0102abe:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
f0102ac5:	eb 10                	jmp    f0102ad7 <command_prompt_readline+0x7d8>
						cputchar('\b');}
f0102ac7:	83 ec 0c             	sub    $0xc,%esp
f0102aca:	6a 08                	push   $0x8
f0102acc:	e8 25 ef ff ff       	call   f01019f6 <cputchar>
f0102ad1:	83 c4 10             	add    $0x10,%esp
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f0102ad4:	ff 45 ac             	incl   -0x54(%ebp)
f0102ad7:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0102ada:	3b 45 90             	cmp    -0x70(%ebp),%eax
f0102add:	7c e8                	jl     f0102ac7 <command_prompt_readline+0x7c8>
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0102adf:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
f0102ae6:	eb 1c                	jmp    f0102b04 <command_prompt_readline+0x805>
						cputchar(buf[j]);}
f0102ae8:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0102aeb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102aee:	01 d0                	add    %edx,%eax
f0102af0:	8a 00                	mov    (%eax),%al
f0102af2:	0f be c0             	movsbl %al,%eax
f0102af5:	83 ec 0c             	sub    $0xc,%esp
f0102af8:	50                   	push   %eax
f0102af9:	e8 f8 ee ff ff       	call   f01019f6 <cputchar>
f0102afe:	83 c4 10             	add    $0x10,%esp
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0102b01:	ff 45 a8             	incl   -0x58(%ebp)
f0102b04:	83 ec 0c             	sub    $0xc,%esp
f0102b07:	ff 75 0c             	pushl  0xc(%ebp)
f0102b0a:	e8 6c 7f 01 00       	call   f011aa7b <strlen>
f0102b0f:	83 c4 10             	add    $0x10,%esp
f0102b12:	3b 45 a8             	cmp    -0x58(%ebp),%eax
f0102b15:	7f d1                	jg     f0102ae8 <command_prompt_readline+0x7e9>
						cputchar(buf[j]);}
					i = lastIndex = strlen(buf);
f0102b17:	83 ec 0c             	sub    $0xc,%esp
f0102b1a:	ff 75 0c             	pushl  0xc(%ebp)
f0102b1d:	e8 59 7f 01 00       	call   f011aa7b <strlen>
f0102b22:	83 c4 10             	add    $0x10,%esp
f0102b25:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0102b2b:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0102b31:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0102b37:	e9 de 02 00 00       	jmp    f0102e1a <command_prompt_readline+0xb1b>
				}
			}
			else {
				if (prefix_list_size > 0) {	int prev = prefix_list_idx;
f0102b3c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0102b40:	0f 8e d4 02 00 00    	jle    f0102e1a <command_prompt_readline+0xb1b>
f0102b46:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102b49:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
				prefix_list_idx = (prefix_list_idx + 1) % prefix_list_size;
f0102b4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102b52:	40                   	inc    %eax
f0102b53:	99                   	cltd   
f0102b54:	f7 7d ec             	idivl  -0x14(%ebp)
f0102b57:	89 55 f0             	mov    %edx,-0x10(%ebp)
				RoundAutoCompleteCommandWithTheSamePrefix(strlen(PrefixList[prev]), PrefixList[prefix_list_idx], buf, &i, &lastIndex);
f0102b5a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102b5d:	c1 e0 0a             	shl    $0xa,%eax
f0102b60:	8d 98 80 6e 85 f0    	lea    -0xf7a9180(%eax),%ebx
f0102b66:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f0102b6c:	c1 e0 0a             	shl    $0xa,%eax
f0102b6f:	05 80 6e 85 f0       	add    $0xf0856e80,%eax
f0102b74:	83 ec 0c             	sub    $0xc,%esp
f0102b77:	50                   	push   %eax
f0102b78:	e8 fe 7e 01 00       	call   f011aa7b <strlen>
f0102b7d:	83 c4 10             	add    $0x10,%esp
f0102b80:	83 ec 0c             	sub    $0xc,%esp
f0102b83:	8d 95 74 ff ff ff    	lea    -0x8c(%ebp),%edx
f0102b89:	52                   	push   %edx
f0102b8a:	8d 95 78 ff ff ff    	lea    -0x88(%ebp),%edx
f0102b90:	52                   	push   %edx
f0102b91:	ff 75 0c             	pushl  0xc(%ebp)
f0102b94:	53                   	push   %ebx
f0102b95:	50                   	push   %eax
f0102b96:	e8 75 f6 ff ff       	call   f0102210 <RoundAutoCompleteCommandWithTheSamePrefix>
f0102b9b:	83 c4 20             	add    $0x20,%esp
f0102b9e:	e9 77 02 00 00       	jmp    f0102e1a <command_prompt_readline+0xb1b>
				}
			}
		}

		else if (c == 228) { // left arrow
f0102ba3:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0102baa:	75 2e                	jne    f0102bda <command_prompt_readline+0x8db>
			if (i > 0) {
f0102bac:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102bb2:	85 c0                	test   %eax,%eax
f0102bb4:	0f 8e 60 02 00 00    	jle    f0102e1a <command_prompt_readline+0xb1b>
				i--;
f0102bba:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102bc0:	48                   	dec    %eax
f0102bc1:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0102bc7:	83 ec 0c             	sub    $0xc,%esp
f0102bca:	ff 75 94             	pushl  -0x6c(%ebp)
f0102bcd:	e8 24 ee ff ff       	call   f01019f6 <cputchar>
f0102bd2:	83 c4 10             	add    $0x10,%esp
f0102bd5:	e9 40 02 00 00       	jmp    f0102e1a <command_prompt_readline+0xb1b>
			}
		} else if (c == 229) { // right arrow
f0102bda:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0102be1:	75 34                	jne    f0102c17 <command_prompt_readline+0x918>
			if (i < lastIndex) {
f0102be3:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f0102be9:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0102bef:	39 c2                	cmp    %eax,%edx
f0102bf1:	0f 8d 23 02 00 00    	jge    f0102e1a <command_prompt_readline+0xb1b>
				i++;
f0102bf7:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102bfd:	40                   	inc    %eax
f0102bfe:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0102c04:	83 ec 0c             	sub    $0xc,%esp
f0102c07:	ff 75 94             	pushl  -0x6c(%ebp)
f0102c0a:	e8 e7 ed ff ff       	call   f01019f6 <cputchar>
f0102c0f:	83 c4 10             	add    $0x10,%esp
f0102c12:	e9 03 02 00 00       	jmp    f0102e1a <command_prompt_readline+0xb1b>
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
f0102c17:	81 7d 94 e9 00 00 00 	cmpl   $0xe9,-0x6c(%ebp)
f0102c1e:	75 4c                	jne    f0102c6c <command_prompt_readline+0x96d>
f0102c20:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102c26:	85 c0                	test   %eax,%eax
f0102c28:	7e 42                	jle    f0102c6c <command_prompt_readline+0x96d>
			for (int var = i; var <= lastIndex; ++var) {
f0102c2a:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102c30:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0102c33:	eb 1a                	jmp    f0102c4f <command_prompt_readline+0x950>
				buf[var] = buf[var + 1];
f0102c35:	8b 55 a4             	mov    -0x5c(%ebp),%edx
f0102c38:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102c3b:	01 c2                	add    %eax,%edx
f0102c3d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0102c40:	8d 48 01             	lea    0x1(%eax),%ecx
f0102c43:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102c46:	01 c8                	add    %ecx,%eax
f0102c48:	8a 00                	mov    (%eax),%al
f0102c4a:	88 02                	mov    %al,(%edx)
				i++;
				cputchar(c);
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
			for (int var = i; var <= lastIndex; ++var) {
f0102c4c:	ff 45 a4             	incl   -0x5c(%ebp)
f0102c4f:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0102c55:	39 45 a4             	cmp    %eax,-0x5c(%ebp)
f0102c58:	7e db                	jle    f0102c35 <command_prompt_readline+0x936>
				buf[var] = buf[var + 1];
			}
			lastIndex--;
f0102c5a:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0102c60:	48                   	dec    %eax
f0102c61:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0102c67:	e9 ae 01 00 00       	jmp    f0102e1a <command_prompt_readline+0xb1b>
		}
		else if (c >= ' ' && i < BUFLEN - 1 && c != 229 && c != 228) {
f0102c6c:	83 7d 94 1f          	cmpl   $0x1f,-0x6c(%ebp)
f0102c70:	7e 60                	jle    f0102cd2 <command_prompt_readline+0x9d3>
f0102c72:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102c78:	3d fe 03 00 00       	cmp    $0x3fe,%eax
f0102c7d:	7f 53                	jg     f0102cd2 <command_prompt_readline+0x9d3>
f0102c7f:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0102c86:	74 4a                	je     f0102cd2 <command_prompt_readline+0x9d3>
f0102c88:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0102c8f:	74 41                	je     f0102cd2 <command_prompt_readline+0x9d3>
			if (echoing)
f0102c91:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0102c95:	74 0e                	je     f0102ca5 <command_prompt_readline+0x9a6>
				cputchar(c);
f0102c97:	83 ec 0c             	sub    $0xc,%esp
f0102c9a:	ff 75 94             	pushl  -0x6c(%ebp)
f0102c9d:	e8 54 ed ff ff       	call   f01019f6 <cputchar>
f0102ca2:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f0102ca5:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102cab:	8d 50 01             	lea    0x1(%eax),%edx
f0102cae:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
f0102cb4:	89 c2                	mov    %eax,%edx
f0102cb6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102cb9:	01 d0                	add    %edx,%eax
f0102cbb:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0102cbe:	88 10                	mov    %dl,(%eax)
			lastIndex++;
f0102cc0:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0102cc6:	40                   	inc    %eax
f0102cc7:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0102ccd:	e9 48 01 00 00       	jmp    f0102e1a <command_prompt_readline+0xb1b>
		} else if (c == '\b' && i > 0) {
f0102cd2:	83 7d 94 08          	cmpl   $0x8,-0x6c(%ebp)
f0102cd6:	75 60                	jne    f0102d38 <command_prompt_readline+0xa39>
f0102cd8:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102cde:	85 c0                	test   %eax,%eax
f0102ce0:	7e 56                	jle    f0102d38 <command_prompt_readline+0xa39>

			if (echoing)
f0102ce2:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0102ce6:	74 0e                	je     f0102cf6 <command_prompt_readline+0x9f7>
				cputchar(c);
f0102ce8:	83 ec 0c             	sub    $0xc,%esp
f0102ceb:	ff 75 94             	pushl  -0x6c(%ebp)
f0102cee:	e8 03 ed ff ff       	call   f01019f6 <cputchar>
f0102cf3:	83 c4 10             	add    $0x10,%esp
			for (int var = i; var <= i; ++var) {
f0102cf6:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102cfc:	89 45 a0             	mov    %eax,-0x60(%ebp)
f0102cff:	eb 1a                	jmp    f0102d1b <command_prompt_readline+0xa1c>
				buf[var - 1] = buf[var];
f0102d01:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0102d04:	8d 50 ff             	lea    -0x1(%eax),%edx
f0102d07:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d0a:	01 c2                	add    %eax,%edx
f0102d0c:	8b 4d a0             	mov    -0x60(%ebp),%ecx
f0102d0f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d12:	01 c8                	add    %ecx,%eax
f0102d14:	8a 00                	mov    (%eax),%al
f0102d16:	88 02                	mov    %al,(%edx)
			lastIndex++;
		} else if (c == '\b' && i > 0) {

			if (echoing)
				cputchar(c);
			for (int var = i; var <= i; ++var) {
f0102d18:	ff 45 a0             	incl   -0x60(%ebp)
f0102d1b:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102d21:	39 45 a0             	cmp    %eax,-0x60(%ebp)
f0102d24:	7e db                	jle    f0102d01 <command_prompt_readline+0xa02>
				buf[var - 1] = buf[var];
			}
			i--;
f0102d26:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102d2c:	48                   	dec    %eax
f0102d2d:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0102d33:	e9 e2 00 00 00       	jmp    f0102e1a <command_prompt_readline+0xb1b>
		} else if (c == '\n' || c == '\r') {
f0102d38:	83 7d 94 0a          	cmpl   $0xa,-0x6c(%ebp)
f0102d3c:	74 0a                	je     f0102d48 <command_prompt_readline+0xa49>
f0102d3e:	83 7d 94 0d          	cmpl   $0xd,-0x6c(%ebp)
f0102d42:	0f 85 d2 00 00 00    	jne    f0102e1a <command_prompt_readline+0xb1b>

			if (echoing)
f0102d48:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0102d4c:	74 0e                	je     f0102d5c <command_prompt_readline+0xa5d>
				cputchar(c);
f0102d4e:	83 ec 0c             	sub    $0xc,%esp
f0102d51:	ff 75 94             	pushl  -0x6c(%ebp)
f0102d54:	e8 9d ec ff ff       	call   f01019f6 <cputchar>
f0102d59:	83 c4 10             	add    $0x10,%esp

			buf[lastIndex] = 0;
f0102d5c:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0102d62:	89 c2                	mov    %eax,%edx
f0102d64:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d67:	01 d0                	add    %edx,%eax
f0102d69:	c6 00 00             	movb   $0x0,(%eax)
			if (last_command_idx == HISTORY_MAX) {
f0102d6c:	a1 50 f5 17 f0       	mov    0xf017f550,%eax
f0102d71:	83 f8 13             	cmp    $0x13,%eax
f0102d74:	75 56                	jne    f0102dcc <command_prompt_readline+0xacd>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0102d76:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%ebp)
f0102d7d:	eb 2d                	jmp    f0102dac <command_prompt_readline+0xaad>
					memcpy(command_history[idx], command_history[idx + 1],
f0102d7f:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0102d82:	40                   	inc    %eax
f0102d83:	c1 e0 0a             	shl    $0xa,%eax
f0102d86:	8d 90 80 fe 86 f0    	lea    -0xf790180(%eax),%edx
f0102d8c:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0102d8f:	c1 e0 0a             	shl    $0xa,%eax
f0102d92:	05 80 fe 86 f0       	add    $0xf086fe80,%eax
f0102d97:	83 ec 04             	sub    $0x4,%esp
f0102d9a:	68 00 04 00 00       	push   $0x400
f0102d9f:	52                   	push   %edx
f0102da0:	50                   	push   %eax
f0102da1:	e8 66 7f 01 00       	call   f011ad0c <memcpy>
f0102da6:	83 c4 10             	add    $0x10,%esp
			if (echoing)
				cputchar(c);

			buf[lastIndex] = 0;
			if (last_command_idx == HISTORY_MAX) {
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0102da9:	ff 45 9c             	incl   -0x64(%ebp)
f0102dac:	83 7d 9c 12          	cmpl   $0x12,-0x64(%ebp)
f0102db0:	7e cd                	jle    f0102d7f <command_prompt_readline+0xa80>
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
f0102db2:	83 ec 04             	sub    $0x4,%esp
f0102db5:	68 00 04 00 00       	push   $0x400
f0102dba:	ff 75 0c             	pushl  0xc(%ebp)
f0102dbd:	68 80 4a 87 f0       	push   $0xf0874a80
f0102dc2:	e8 45 7f 01 00       	call   f011ad0c <memcpy>
f0102dc7:	83 c4 10             	add    $0x10,%esp
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0102dca:	eb 68                	jmp    f0102e34 <command_prompt_readline+0xb35>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
f0102dcc:	a1 50 f5 17 f0       	mov    0xf017f550,%eax
f0102dd1:	c1 e0 0a             	shl    $0xa,%eax
f0102dd4:	05 80 fe 86 f0       	add    $0xf086fe80,%eax
f0102dd9:	83 ec 08             	sub    $0x8,%esp
f0102ddc:	ff 75 0c             	pushl  0xc(%ebp)
f0102ddf:	50                   	push   %eax
f0102de0:	e8 a2 7d 01 00       	call   f011ab87 <strcmp>
f0102de5:	83 c4 10             	add    $0x10,%esp
f0102de8:	85 c0                	test   %eax,%eax
f0102dea:	74 48                	je     f0102e34 <command_prompt_readline+0xb35>
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
f0102dec:	a1 50 f5 17 f0       	mov    0xf017f550,%eax
f0102df1:	40                   	inc    %eax
f0102df2:	a3 50 f5 17 f0       	mov    %eax,0xf017f550
f0102df7:	a1 50 f5 17 f0       	mov    0xf017f550,%eax
f0102dfc:	c1 e0 0a             	shl    $0xa,%eax
f0102dff:	05 80 fe 86 f0       	add    $0xf086fe80,%eax
f0102e04:	83 ec 04             	sub    $0x4,%esp
f0102e07:	68 00 04 00 00       	push   $0x400
f0102e0c:	ff 75 0c             	pushl  0xc(%ebp)
f0102e0f:	50                   	push   %eax
f0102e10:	e8 f7 7e 01 00       	call   f011ad0c <memcpy>
f0102e15:	83 c4 10             	add    $0x10,%esp
			}
			return;
f0102e18:	eb 1a                	jmp    f0102e34 <command_prompt_readline+0xb35>

		}
		last_c = c;
f0102e1a:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0102e1d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0102e20:	e9 44 f5 ff ff       	jmp    f0102369 <command_prompt_readline+0x6a>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f0102e25:	90                   	nop
f0102e26:	e9 3e f5 ff ff       	jmp    f0102369 <command_prompt_readline+0x6a>
				int number_of_arguments = prefix_list_size = 0;
				char temp_buf[1024];
				strcpy(temp_buf, buf);
				int bufLength = strlen(buf);
				if (buf[bufLength - 1] == ' ')
					continue;
f0102e2b:	90                   	nop
			}
			return;

		}
		last_c = c;
	}
f0102e2c:	e9 38 f5 ff ff       	jmp    f0102369 <command_prompt_readline+0x6a>
			lastIndex = i;
		if (c < 0) {

			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			return;
f0102e31:	90                   	nop
f0102e32:	eb 01                	jmp    f0102e35 <command_prompt_readline+0xb36>
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0102e34:	90                   	nop

		}
		last_c = c;
	}
}
f0102e35:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0102e38:	5b                   	pop    %ebx
f0102e39:	5f                   	pop    %edi
f0102e3a:	5d                   	pop    %ebp
f0102e3b:	c3                   	ret    

f0102e3c <set_kheap_strategy>:
uint32 kheapPageAllocStart ;
uint32 kheapPageAllocBreak ;
uint32 kheapPlacementStrategy;

/*2025*/ //Replaced by setter & getter function
static inline void set_kheap_strategy(uint32 strategy){kheapPlacementStrategy = strategy;}
f0102e3c:	55                   	push   %ebp
f0102e3d:	89 e5                	mov    %esp,%ebp
f0102e3f:	8b 45 08             	mov    0x8(%ebp),%eax
f0102e42:	a3 c4 69 85 f0       	mov    %eax,0xf08569c4
f0102e47:	90                   	nop
f0102e48:	5d                   	pop    %ebp
f0102e49:	c3                   	ret    

f0102e4a <get_kheap_strategy>:
static inline uint32 get_kheap_strategy(){return kheapPlacementStrategy ;}
f0102e4a:	55                   	push   %ebp
f0102e4b:	89 e5                	mov    %esp,%ebp
f0102e4d:	a1 c4 69 85 f0       	mov    0xf08569c4,%eax
f0102e52:	5d                   	pop    %ebp
f0102e53:	c3                   	ret    

f0102e54 <set_uheap_strategy>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;
/*2025*/ //Replaced by setter & getter function
static inline void set_uheap_strategy(uint32 strategy){_UHeapPlacementStrategy = strategy;}
f0102e54:	55                   	push   %ebp
f0102e55:	89 e5                	mov    %esp,%ebp
f0102e57:	8b 45 08             	mov    0x8(%ebp),%eax
f0102e5a:	a3 e8 6a 85 f0       	mov    %eax,0xf0856ae8
f0102e5f:	90                   	nop
f0102e60:	5d                   	pop    %ebp
f0102e61:	c3                   	ret    

f0102e62 <get_uheap_strategy>:
static inline uint32 get_uheap_strategy(){return _UHeapPlacementStrategy ;}
f0102e62:	55                   	push   %ebp
f0102e63:	89 e5                	mov    %esp,%ebp
f0102e65:	a1 e8 6a 85 f0       	mov    0xf0856ae8,%eax
f0102e6a:	5d                   	pop    %ebp
f0102e6b:	c3                   	ret    

f0102e6c <to_frame_info>:
{
	return to_frame_number(ptr_frame_info) << PGSHIFT;
}

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0102e6c:	55                   	push   %ebp
f0102e6d:	89 e5                	mov    %esp,%ebp
f0102e6f:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0102e72:	8b 45 08             	mov    0x8(%ebp),%eax
f0102e75:	c1 e8 0c             	shr    $0xc,%eax
f0102e78:	89 c2                	mov    %eax,%edx
f0102e7a:	a1 b8 e9 83 f0       	mov    0xf083e9b8,%eax
f0102e7f:	39 c2                	cmp    %eax,%edx
f0102e81:	72 14                	jb     f0102e97 <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f0102e83:	83 ec 04             	sub    $0x4,%esp
f0102e86:	68 68 b9 12 f0       	push   $0xf012b968
f0102e8b:	6a 4e                	push   $0x4e
f0102e8d:	68 90 b9 12 f0       	push   $0xf012b990
f0102e92:	e8 18 e0 ff ff       	call   f0100eaf <_panic>
	return &frames_info[PPN(physical_address)];
f0102e97:	8b 15 08 6b 85 f0    	mov    0xf0856b08,%edx
f0102e9d:	8b 45 08             	mov    0x8(%ebp),%eax
f0102ea0:	c1 e8 0c             	shr    $0xc,%eax
f0102ea3:	89 c1                	mov    %eax,%ecx
f0102ea5:	89 c8                	mov    %ecx,%eax
f0102ea7:	c1 e0 02             	shl    $0x2,%eax
f0102eaa:	01 c8                	add    %ecx,%eax
f0102eac:	c1 e0 02             	shl    $0x2,%eax
f0102eaf:	01 d0                	add    %edx,%eax
}
f0102eb1:	c9                   	leave  
f0102eb2:	c3                   	ret    

f0102eb3 <command_help>:

/***** Implementations of basic kernel command prompt commands *****/

//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{
f0102eb3:	55                   	push   %ebp
f0102eb4:	89 e5                	mov    %esp,%ebp
f0102eb6:	53                   	push   %ebx
f0102eb7:	83 ec 14             	sub    $0x14,%esp

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0102eba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102ec1:	eb 3b                	jmp    f0102efe <command_help+0x4b>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);
f0102ec3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102ec6:	89 d0                	mov    %edx,%eax
f0102ec8:	01 c0                	add    %eax,%eax
f0102eca:	01 d0                	add    %edx,%eax
f0102ecc:	c1 e0 03             	shl    $0x3,%eax
f0102ecf:	05 64 f5 17 f0       	add    $0xf017f564,%eax
f0102ed4:	8b 10                	mov    (%eax),%edx
f0102ed6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102ed9:	89 c8                	mov    %ecx,%eax
f0102edb:	01 c0                	add    %eax,%eax
f0102edd:	01 c8                	add    %ecx,%eax
f0102edf:	c1 e0 03             	shl    $0x3,%eax
f0102ee2:	05 60 f5 17 f0       	add    $0xf017f560,%eax
f0102ee7:	8b 00                	mov    (%eax),%eax
f0102ee9:	83 ec 04             	sub    $0x4,%esp
f0102eec:	52                   	push   %edx
f0102eed:	50                   	push   %eax
f0102eee:	68 cb c8 12 f0       	push   $0xf012c8cb
f0102ef3:	e8 64 ec ff ff       	call   f0101b5c <cprintf>
f0102ef8:	83 c4 10             	add    $0x10,%esp
//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0102efb:	ff 45 f4             	incl   -0xc(%ebp)
f0102efe:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102f01:	a1 a8 fb 17 f0       	mov    0xf017fba8,%eax
f0102f06:	39 c2                	cmp    %eax,%edx
f0102f08:	72 b9                	jb     f0102ec3 <command_help+0x10>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");
f0102f0a:	83 ec 0c             	sub    $0xc,%esp
f0102f0d:	68 d4 c8 12 f0       	push   $0xf012c8d4
f0102f12:	e8 45 ec ff ff       	call   f0101b5c <cprintf>
f0102f17:	83 c4 10             	add    $0x10,%esp

	for (i = 0; i < NUM_USER_PROGS; i++)
f0102f1a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102f21:	eb 42                	jmp    f0102f65 <command_help+0xb2>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
f0102f23:	8b 0d 9c 00 18 f0    	mov    0xf018009c,%ecx
f0102f29:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102f2c:	89 d0                	mov    %edx,%eax
f0102f2e:	01 c0                	add    %eax,%eax
f0102f30:	01 d0                	add    %edx,%eax
f0102f32:	c1 e0 02             	shl    $0x2,%eax
f0102f35:	01 c8                	add    %ecx,%eax
f0102f37:	8b 50 04             	mov    0x4(%eax),%edx
f0102f3a:	8b 1d 9c 00 18 f0    	mov    0xf018009c,%ebx
f0102f40:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102f43:	89 c8                	mov    %ecx,%eax
f0102f45:	01 c0                	add    %eax,%eax
f0102f47:	01 c8                	add    %ecx,%eax
f0102f49:	c1 e0 02             	shl    $0x2,%eax
f0102f4c:	01 d8                	add    %ebx,%eax
f0102f4e:	8b 00                	mov    (%eax),%eax
f0102f50:	83 ec 04             	sub    $0x4,%esp
f0102f53:	52                   	push   %edx
f0102f54:	50                   	push   %eax
f0102f55:	68 e9 c8 12 f0       	push   $0xf012c8e9
f0102f5a:	e8 fd eb ff ff       	call   f0101b5c <cprintf>
f0102f5f:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < NUM_OF_COMMANDS; i++)
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");

	for (i = 0; i < NUM_USER_PROGS; i++)
f0102f62:	ff 45 f4             	incl   -0xc(%ebp)
f0102f65:	a1 a0 00 18 f0       	mov    0xf01800a0,%eax
f0102f6a:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0102f6d:	7c b4                	jl     f0102f23 <command_help+0x70>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
	return 0;
f0102f6f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102f74:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0102f77:	c9                   	leave  
f0102f78:	c3                   	ret    

f0102f79 <command_kernel_info>:

//print information about kernel addresses and kernel size
int command_kernel_info(int number_of_arguments, char **arguments )
{
f0102f79:	55                   	push   %ebp
f0102f7a:	89 e5                	mov    %esp,%ebp
f0102f7c:	83 ec 08             	sub    $0x8,%esp
	extern char start_of_kernel[], end_of_kernel_code_section[], start_of_uninitialized_data_section[], end_of_kernel[];

	cprintf("Special kernel symbols:\n");
f0102f7f:	83 ec 0c             	sub    $0xc,%esp
f0102f82:	68 05 c9 12 f0       	push   $0xf012c905
f0102f87:	e8 d0 eb ff ff       	call   f0101b5c <cprintf>
f0102f8c:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
f0102f8f:	b8 0c 00 10 00       	mov    $0x10000c,%eax
f0102f94:	83 ec 04             	sub    $0x4,%esp
f0102f97:	50                   	push   %eax
f0102f98:	68 0c 00 10 f0       	push   $0xf010000c
f0102f9d:	68 20 c9 12 f0       	push   $0xf012c920
f0102fa2:	e8 b5 eb ff ff       	call   f0101b5c <cprintf>
f0102fa7:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
f0102faa:	b8 15 bb 11 00       	mov    $0x11bb15,%eax
f0102faf:	83 ec 04             	sub    $0x4,%esp
f0102fb2:	50                   	push   %eax
f0102fb3:	68 15 bb 11 f0       	push   $0xf011bb15
f0102fb8:	68 5c c9 12 f0       	push   $0xf012c95c
f0102fbd:	e8 9a eb ff ff       	call   f0101b5c <cprintf>
f0102fc2:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
f0102fc5:	b8 3c 59 81 00       	mov    $0x81593c,%eax
f0102fca:	83 ec 04             	sub    $0x4,%esp
f0102fcd:	50                   	push   %eax
f0102fce:	68 3c 59 81 f0       	push   $0xf081593c
f0102fd3:	68 98 c9 12 f0       	push   $0xf012c998
f0102fd8:	e8 7f eb ff ff       	call   f0101b5c <cprintf>
f0102fdd:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
f0102fe0:	b8 d0 d6 87 00       	mov    $0x87d6d0,%eax
f0102fe5:	83 ec 04             	sub    $0x4,%esp
f0102fe8:	50                   	push   %eax
f0102fe9:	68 d0 d6 87 f0       	push   $0xf087d6d0
f0102fee:	68 e0 c9 12 f0       	push   $0xf012c9e0
f0102ff3:	e8 64 eb ff ff       	call   f0101b5c <cprintf>
f0102ff8:	83 c4 10             	add    $0x10,%esp
	cprintf("Kernel executable memory footprint: %d KB\n",
			(end_of_kernel-start_of_kernel+1023)/1024);
f0102ffb:	b8 d0 d6 87 f0       	mov    $0xf087d6d0,%eax
f0103000:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
f0103006:	b8 0c 00 10 f0       	mov    $0xf010000c,%eax
f010300b:	29 c2                	sub    %eax,%edx
f010300d:	89 d0                	mov    %edx,%eax
	cprintf("Special kernel symbols:\n");
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
	cprintf("Kernel executable memory footprint: %d KB\n",
f010300f:	85 c0                	test   %eax,%eax
f0103011:	79 05                	jns    f0103018 <command_kernel_info+0x9f>
f0103013:	05 ff 03 00 00       	add    $0x3ff,%eax
f0103018:	c1 f8 0a             	sar    $0xa,%eax
f010301b:	83 ec 08             	sub    $0x8,%esp
f010301e:	50                   	push   %eax
f010301f:	68 1c ca 12 f0       	push   $0xf012ca1c
f0103024:	e8 33 eb ff ff       	call   f0101b5c <cprintf>
f0103029:	83 c4 10             	add    $0x10,%esp
			(end_of_kernel-start_of_kernel+1023)/1024);
	return 0;
f010302c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103031:	c9                   	leave  
f0103032:	c3                   	ret    

f0103033 <command_writemem_k>:
//*****************************************************************************************//
//===========================================================================
//Lab2.Examples
//=============
int command_writemem_k(int number_of_arguments, char **arguments)
{
f0103033:	55                   	push   %ebp
f0103034:	89 e5                	mov    %esp,%ebp
f0103036:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB2 Example: corresponding command name is "wm"

	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0103039:	8b 45 0c             	mov    0xc(%ebp),%eax
f010303c:	83 c0 04             	add    $0x4,%eax
f010303f:	8b 00                	mov    (%eax),%eax
f0103041:	83 ec 04             	sub    $0x4,%esp
f0103044:	6a 10                	push   $0x10
f0103046:	6a 00                	push   $0x0
f0103048:	50                   	push   %eax
f0103049:	e8 3c 7e 01 00       	call   f011ae8a <strtol>
f010304e:	83 c4 10             	add    $0x10,%esp
f0103051:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0103056:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int stringLen = strlen(arguments[2]);
f0103059:	8b 45 0c             	mov    0xc(%ebp),%eax
f010305c:	83 c0 08             	add    $0x8,%eax
f010305f:	8b 00                	mov    (%eax),%eax
f0103061:	83 ec 0c             	sub    $0xc,%esp
f0103064:	50                   	push   %eax
f0103065:	e8 11 7a 01 00       	call   f011aa7b <strlen>
f010306a:	83 c4 10             	add    $0x10,%esp
f010306d:	89 45 ec             	mov    %eax,-0x14(%ebp)

	for(int i=0;i < stringLen; i++)
f0103070:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0103077:	eb 1c                	jmp    f0103095 <command_writemem_k+0x62>
	{
		*address = arguments[2][i];
f0103079:	8b 45 0c             	mov    0xc(%ebp),%eax
f010307c:	83 c0 08             	add    $0x8,%eax
f010307f:	8b 10                	mov    (%eax),%edx
f0103081:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103084:	01 d0                	add    %edx,%eax
f0103086:	8a 00                	mov    (%eax),%al
f0103088:	88 c2                	mov    %al,%dl
f010308a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010308d:	88 10                	mov    %dl,(%eax)
		address++;
f010308f:	ff 45 f4             	incl   -0xc(%ebp)
	//TODO: LAB2 Example: corresponding command name is "wm"

	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
	int stringLen = strlen(arguments[2]);

	for(int i=0;i < stringLen; i++)
f0103092:	ff 45 f0             	incl   -0x10(%ebp)
f0103095:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103098:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010309b:	7c dc                	jl     f0103079 <command_writemem_k+0x46>
	{
		*address = arguments[2][i];
		address++;
	}
	return 0;
f010309d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01030a2:	c9                   	leave  
f01030a3:	c3                   	ret    

f01030a4 <command_readmem_k>:

int command_readmem_k(int number_of_arguments, char **arguments)
{
f01030a4:	55                   	push   %ebp
f01030a5:	89 e5                	mov    %esp,%ebp
f01030a7:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB2 Example: corresponding command name is "rm"

	unsigned int address = strtol(arguments[1], NULL, 16);
f01030aa:	8b 45 0c             	mov    0xc(%ebp),%eax
f01030ad:	83 c0 04             	add    $0x4,%eax
f01030b0:	8b 00                	mov    (%eax),%eax
f01030b2:	83 ec 04             	sub    $0x4,%esp
f01030b5:	6a 10                	push   $0x10
f01030b7:	6a 00                	push   $0x0
f01030b9:	50                   	push   %eax
f01030ba:	e8 cb 7d 01 00       	call   f011ae8a <strtol>
f01030bf:	83 c4 10             	add    $0x10,%esp
f01030c2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	unsigned char *ptr = (unsigned char *)(address + KERNEL_BASE) ;
f01030c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01030c8:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01030cd:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//Read value at the given address
	cprintf("value at virtual address %x = %c\n", ptr, *ptr);
f01030d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01030d3:	8a 00                	mov    (%eax),%al
f01030d5:	0f b6 c0             	movzbl %al,%eax
f01030d8:	83 ec 04             	sub    $0x4,%esp
f01030db:	50                   	push   %eax
f01030dc:	ff 75 f0             	pushl  -0x10(%ebp)
f01030df:	68 48 ca 12 f0       	push   $0xf012ca48
f01030e4:	e8 73 ea ff ff       	call   f0101b5c <cprintf>
f01030e9:	83 c4 10             	add    $0x10,%esp
	return 0;
f01030ec:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01030f1:	c9                   	leave  
f01030f2:	c3                   	ret    

f01030f3 <command_get_page_table>:

//===========================================================================
//Lab3.Examples
//=============
int command_get_page_table(int number_of_arguments, char **arguments)
{
f01030f3:	55                   	push   %ebp
f01030f4:	89 e5                	mov    %esp,%ebp
f01030f6:	83 ec 08             	sub    $0x8,%esp
	//TODO: LAB3 Example#1,2: fill this function. corresponding command name is "gpt"
	//Comment the following line
	panic("Function is not implemented yet!");
f01030f9:	83 ec 04             	sub    $0x4,%esp
f01030fc:	68 6c ca 12 f0       	push   $0xf012ca6c
f0103101:	68 cd 00 00 00       	push   $0xcd
f0103106:	68 8d ca 12 f0       	push   $0xf012ca8d
f010310b:	e8 9f dd ff ff       	call   f0100eaf <_panic>

f0103110 <command_kernel_base_info>:

	return 0;
}

int command_kernel_base_info(int number_of_arguments, char **arguments)
{
f0103110:	55                   	push   %ebp
f0103111:	89 e5                	mov    %esp,%ebp
f0103113:	83 ec 08             	sub    $0x8,%esp
	//TODO: LAB3 Example#3: fill this function. corresponding command name is "ikb"
	//Comment the following line
	panic("Function is not implemented yet!");
f0103116:	83 ec 04             	sub    $0x4,%esp
f0103119:	68 6c ca 12 f0       	push   $0xf012ca6c
f010311e:	68 d6 00 00 00       	push   $0xd6
f0103123:	68 8d ca 12 f0       	push   $0xf012ca8d
f0103128:	e8 82 dd ff ff       	call   f0100eaf <_panic>

f010312d <command_del_kernel_base>:

	return 0;
}

int command_del_kernel_base(int number_of_arguments, char **arguments)
{
f010312d:	55                   	push   %ebp
f010312e:	89 e5                	mov    %esp,%ebp
f0103130:	83 ec 08             	sub    $0x8,%esp
	//TODO: LAB3 Example#4: fill this function. corresponding command name is "dkb"
	//Comment the following line
	panic("Function is not implemented yet!");
f0103133:	83 ec 04             	sub    $0x4,%esp
f0103136:	68 6c ca 12 f0       	push   $0xf012ca6c
f010313b:	68 df 00 00 00       	push   $0xdf
f0103140:	68 8d ca 12 f0       	push   $0xf012ca8d
f0103145:	e8 65 dd ff ff       	call   f0100eaf <_panic>

f010314a <command_share_page>:

	return 0;
}

int command_share_page(int number_of_arguments, char **arguments)
{
f010314a:	55                   	push   %ebp
f010314b:	89 e5                	mov    %esp,%ebp
f010314d:	83 ec 08             	sub    $0x8,%esp
	//TODO: LAB3 Example#5: fill this function. corresponding command name is "shr"
	//Comment the following line
	panic("Function is not implemented yet!");
f0103150:	83 ec 04             	sub    $0x4,%esp
f0103153:	68 6c ca 12 f0       	push   $0xf012ca6c
f0103158:	68 e8 00 00 00       	push   $0xe8
f010315d:	68 8d ca 12 f0       	push   $0xf012ca8d
f0103162:	e8 48 dd ff ff       	call   f0100eaf <_panic>

f0103167 <command_nr>:
//===========================================================================
//Lab4.Examples
//==============
//[1] Number of references on the given physical address
int command_nr(int number_of_arguments, char **arguments)
{
f0103167:	55                   	push   %ebp
f0103168:	89 e5                	mov    %esp,%ebp
f010316a:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB4 Example#1: corresponding command name is "nr"

	uint32 pa  = strtol(arguments[1], NULL, 16);
f010316d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103170:	83 c0 04             	add    $0x4,%eax
f0103173:	8b 00                	mov    (%eax),%eax
f0103175:	83 ec 04             	sub    $0x4,%esp
f0103178:	6a 10                	push   $0x10
f010317a:	6a 00                	push   $0x0
f010317c:	50                   	push   %eax
f010317d:	e8 08 7d 01 00       	call   f011ae8a <strtol>
f0103182:	83 c4 10             	add    $0x10,%esp
f0103185:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int num_of_ref = num_of_references(pa);
f0103188:	83 ec 0c             	sub    $0xc,%esp
f010318b:	ff 75 f4             	pushl  -0xc(%ebp)
f010318e:	e8 99 6b 00 00       	call   f0109d2c <num_of_references>
f0103193:	83 c4 10             	add    $0x10,%esp
f0103196:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cprintf("Num of ref's @ pa %x = %d\n", pa, num_of_ref);
f0103199:	83 ec 04             	sub    $0x4,%esp
f010319c:	ff 75 f0             	pushl  -0x10(%ebp)
f010319f:	ff 75 f4             	pushl  -0xc(%ebp)
f01031a2:	68 a1 ca 12 f0       	push   $0xf012caa1
f01031a7:	e8 b0 e9 ff ff       	call   f0101b5c <cprintf>
f01031ac:	83 c4 10             	add    $0x10,%esp
	return 0;
f01031af:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01031b4:	c9                   	leave  
f01031b5:	c3                   	ret    

f01031b6 <command_ap>:

//[2] Allocate Page
int command_ap(int number_of_arguments, char **arguments)
{
f01031b6:	55                   	push   %ebp
f01031b7:	89 e5                	mov    %esp,%ebp
f01031b9:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB4 Example#2: corresponding command name is "ap"

	uint32 va = strtol(arguments[1], NULL, 16);
f01031bc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01031bf:	83 c0 04             	add    $0x4,%eax
f01031c2:	8b 00                	mov    (%eax),%eax
f01031c4:	83 ec 04             	sub    $0x4,%esp
f01031c7:	6a 10                	push   $0x10
f01031c9:	6a 00                	push   $0x0
f01031cb:	50                   	push   %eax
f01031cc:	e8 b9 7c 01 00       	call   f011ae8a <strtol>
f01031d1:	83 c4 10             	add    $0x10,%esp
f01031d4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	bool set_to_zero = 0;
f01031d7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (number_of_arguments == 3)
f01031de:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01031e2:	75 15                	jne    f01031f9 <command_ap+0x43>
	{
		if (arguments[2][0] == '0')
f01031e4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01031e7:	83 c0 08             	add    $0x8,%eax
f01031ea:	8b 00                	mov    (%eax),%eax
f01031ec:	8a 00                	mov    (%eax),%al
f01031ee:	3c 30                	cmp    $0x30,%al
f01031f0:	75 07                	jne    f01031f9 <command_ap+0x43>
			set_to_zero = 1;
f01031f2:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	int ret = alloc_page(ptr_page_directory, va, PERM_USER | PERM_WRITEABLE, set_to_zero);
f01031f9:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01031fe:	ff 75 f4             	pushl  -0xc(%ebp)
f0103201:	6a 06                	push   $0x6
f0103203:	ff 75 f0             	pushl  -0x10(%ebp)
f0103206:	50                   	push   %eax
f0103207:	e8 42 6b 00 00       	call   f0109d4e <alloc_page>
f010320c:	83 c4 10             	add    $0x10,%esp
f010320f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (ret == 1)
f0103212:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
f0103216:	75 15                	jne    f010322d <command_ap+0x77>
	{
		cprintf("Page @ va %x already exists!\n", va);
f0103218:	83 ec 08             	sub    $0x8,%esp
f010321b:	ff 75 f0             	pushl  -0x10(%ebp)
f010321e:	68 bc ca 12 f0       	push   $0xf012cabc
f0103223:	e8 34 e9 ff ff       	call   f0101b5c <cprintf>
f0103228:	83 c4 10             	add    $0x10,%esp
f010322b:	eb 41                	jmp    f010326e <command_ap+0xb8>
	}
	else if (ret == E_NO_MEM)
f010322d:	83 7d ec fc          	cmpl   $0xfffffffc,-0x14(%ebp)
f0103231:	75 12                	jne    f0103245 <command_ap+0x8f>
	{
		cprintf("No enough memory!\n");
f0103233:	83 ec 0c             	sub    $0xc,%esp
f0103236:	68 da ca 12 f0       	push   $0xf012cada
f010323b:	e8 1c e9 ff ff       	call   f0101b5c <cprintf>
f0103240:	83 c4 10             	add    $0x10,%esp
f0103243:	eb 29                	jmp    f010326e <command_ap+0xb8>
	}
	else
	{
		cprintf("New page is allocated @ va %x\n", va);
f0103245:	83 ec 08             	sub    $0x8,%esp
f0103248:	ff 75 f0             	pushl  -0x10(%ebp)
f010324b:	68 f0 ca 12 f0       	push   $0xf012caf0
f0103250:	e8 07 e9 ff ff       	call   f0101b5c <cprintf>
f0103255:	83 c4 10             	add    $0x10,%esp
		if (set_to_zero)
f0103258:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010325c:	74 10                	je     f010326e <command_ap+0xb8>
			cprintf("and initialized by ZERO\n");
f010325e:	83 ec 0c             	sub    $0xc,%esp
f0103261:	68 0f cb 12 f0       	push   $0xf012cb0f
f0103266:	e8 f1 e8 ff ff       	call   f0101b5c <cprintf>
f010326b:	83 c4 10             	add    $0x10,%esp
	}
	return 0 ;
f010326e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103273:	c9                   	leave  
f0103274:	c3                   	ret    

f0103275 <command_fp>:

//[3] Free Page: Un-map a single page at the given virtual address in the user space
int command_fp(int number_of_arguments, char **arguments)
{
f0103275:	55                   	push   %ebp
f0103276:	89 e5                	mov    %esp,%ebp
f0103278:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB4 Example#3: corresponding command name is "fp"

	uint32 va = strtol(arguments[1], NULL, 16);
f010327b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010327e:	83 c0 04             	add    $0x4,%eax
f0103281:	8b 00                	mov    (%eax),%eax
f0103283:	83 ec 04             	sub    $0x4,%esp
f0103286:	6a 10                	push   $0x10
f0103288:	6a 00                	push   $0x0
f010328a:	50                   	push   %eax
f010328b:	e8 fa 7b 01 00       	call   f011ae8a <strtol>
f0103290:	83 c4 10             	add    $0x10,%esp
f0103293:	89 45 f4             	mov    %eax,-0xc(%ebp)
	unmap_frame(ptr_page_directory, va);
f0103296:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f010329b:	83 ec 08             	sub    $0x8,%esp
f010329e:	ff 75 f4             	pushl  -0xc(%ebp)
f01032a1:	50                   	push   %eax
f01032a2:	e8 a8 63 00 00       	call   f010964f <unmap_frame>
f01032a7:	83 c4 10             	add    $0x10,%esp

	return 0;
f01032aa:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01032af:	c9                   	leave  
f01032b0:	c3                   	ret    

f01032b1 <command_cfp>:
//===========================================================================
//Lab4.Hands-on
//==============
//Count Free Pages in Range
int command_cfp(int number_of_arguments, char **arguments)
{
f01032b1:	55                   	push   %ebp
f01032b2:	89 e5                	mov    %esp,%ebp
f01032b4:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB4 Hands-on: corresponding command name is "cfp"

	uint32* dir_ptr = clone_kern_dir();
f01032b7:	e8 d8 6e 01 00       	call   f011a194 <clone_kern_dir>
f01032bc:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uint32 va1 = strtol(arguments[1], NULL, 16);
f01032bf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01032c2:	83 c0 04             	add    $0x4,%eax
f01032c5:	8b 00                	mov    (%eax),%eax
f01032c7:	83 ec 04             	sub    $0x4,%esp
f01032ca:	6a 10                	push   $0x10
f01032cc:	6a 00                	push   $0x0
f01032ce:	50                   	push   %eax
f01032cf:	e8 b6 7b 01 00       	call   f011ae8a <strtol>
f01032d4:	83 c4 10             	add    $0x10,%esp
f01032d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 va2 = strtol(arguments[2], NULL, 16);
f01032da:	8b 45 0c             	mov    0xc(%ebp),%eax
f01032dd:	83 c0 08             	add    $0x8,%eax
f01032e0:	8b 00                	mov    (%eax),%eax
f01032e2:	83 ec 04             	sub    $0x4,%esp
f01032e5:	6a 10                	push   $0x10
f01032e7:	6a 00                	push   $0x0
f01032e9:	50                   	push   %eax
f01032ea:	e8 9b 7b 01 00       	call   f011ae8a <strtol>
f01032ef:	83 c4 10             	add    $0x10,%esp
f01032f2:	89 45 ec             	mov    %eax,-0x14(%ebp)

	uint32 num_of_free = calculate_free_space(dir_ptr, va1, va2);
f01032f5:	83 ec 04             	sub    $0x4,%esp
f01032f8:	ff 75 ec             	pushl  -0x14(%ebp)
f01032fb:	ff 75 f0             	pushl  -0x10(%ebp)
f01032fe:	ff 75 f4             	pushl  -0xc(%ebp)
f0103301:	e8 e1 78 00 00       	call   f010abe7 <calculate_free_space>
f0103306:	83 c4 10             	add    $0x10,%esp
f0103309:	89 45 e8             	mov    %eax,-0x18(%ebp)

	cprintf("Num of free pages in va range [%x, %x) = %d\n", va1, va2, num_of_free);
f010330c:	ff 75 e8             	pushl  -0x18(%ebp)
f010330f:	ff 75 ec             	pushl  -0x14(%ebp)
f0103312:	ff 75 f0             	pushl  -0x10(%ebp)
f0103315:	68 28 cb 12 f0       	push   $0xf012cb28
f010331a:	e8 3d e8 ff ff       	call   f0101b5c <cprintf>
f010331f:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103322:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103327:	c9                   	leave  
f0103328:	c3                   	ret    

f0103329 <command_asp>:

//===========================================================================
//Lab5.Hands.On
//=============
int command_asp(int number_of_arguments, char **arguments)
{
f0103329:	55                   	push   %ebp
f010332a:	89 e5                	mov    %esp,%ebp
f010332c:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB5 Hands-on: corresponding command name is "asp"

	uint32* dir_ptr = clone_kern_dir();
f010332f:	e8 60 6e 01 00       	call   f011a194 <clone_kern_dir>
f0103334:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 va1 = strtol(arguments[1], NULL, 16);
f0103337:	8b 45 0c             	mov    0xc(%ebp),%eax
f010333a:	83 c0 04             	add    $0x4,%eax
f010333d:	8b 00                	mov    (%eax),%eax
f010333f:	83 ec 04             	sub    $0x4,%esp
f0103342:	6a 10                	push   $0x10
f0103344:	6a 00                	push   $0x0
f0103346:	50                   	push   %eax
f0103347:	e8 3e 7b 01 00       	call   f011ae8a <strtol>
f010334c:	83 c4 10             	add    $0x10,%esp
f010334f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 va2 = strtol(arguments[2], NULL, 16);
f0103352:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103355:	83 c0 08             	add    $0x8,%eax
f0103358:	8b 00                	mov    (%eax),%eax
f010335a:	83 ec 04             	sub    $0x4,%esp
f010335d:	6a 10                	push   $0x10
f010335f:	6a 00                	push   $0x0
f0103361:	50                   	push   %eax
f0103362:	e8 23 7b 01 00       	call   f011ae8a <strtol>
f0103367:	83 c4 10             	add    $0x10,%esp
f010336a:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int ret = alloc_shared_page(dir_ptr, va1, dir_ptr, va2, PERM_USER | PERM_WRITEABLE);
f010336d:	83 ec 0c             	sub    $0xc,%esp
f0103370:	6a 06                	push   $0x6
f0103372:	ff 75 ec             	pushl  -0x14(%ebp)
f0103375:	ff 75 f4             	pushl  -0xc(%ebp)
f0103378:	ff 75 f0             	pushl  -0x10(%ebp)
f010337b:	ff 75 f4             	pushl  -0xc(%ebp)
f010337e:	e8 6e 6a 00 00       	call   f0109df1 <alloc_shared_page>
f0103383:	83 c4 20             	add    $0x20,%esp
f0103386:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret == E_NO_MEM)
f0103389:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f010338d:	75 10                	jne    f010339f <command_asp+0x76>
	{
		cprintf("No enough memory!\n");
f010338f:	83 ec 0c             	sub    $0xc,%esp
f0103392:	68 da ca 12 f0       	push   $0xf012cada
f0103397:	e8 c0 e7 ff ff       	call   f0101b5c <cprintf>
f010339c:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f010339f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01033a4:	c9                   	leave  
f01033a5:	c3                   	ret    

f01033a6 <command_shmp>:

int command_shmp(int number_of_arguments, char **arguments)
{
f01033a6:	55                   	push   %ebp
f01033a7:	89 e5                	mov    %esp,%ebp
f01033a9:	83 ec 08             	sub    $0x8,%esp
	//TODO: LAB5 Hands-on: fill this function. corresponding command name is "sm"
	//Comment the following line
	panic("Function is not implemented yet!");
f01033ac:	83 ec 04             	sub    $0x4,%esp
f01033af:	68 6c ca 12 f0       	push   $0xf012ca6c
f01033b4:	68 4d 01 00 00       	push   $0x14d
f01033b9:	68 8d ca 12 f0       	push   $0xf012ca8d
f01033be:	e8 ec da ff ff       	call   f0100eaf <_panic>

f01033c3 <command_scp>:

	return 0 ;
}

int command_scp(int number_of_arguments, char **arguments)
{
f01033c3:	55                   	push   %ebp
f01033c4:	89 e5                	mov    %esp,%ebp
f01033c6:	83 ec 08             	sub    $0x8,%esp
	//TODO: LAB5 Hands-on: fill this function. corresponding command name is "sp"
	//Comment the following line
	panic("Function is not implemented yet!");
f01033c9:	83 ec 04             	sub    $0x4,%esp
f01033cc:	68 6c ca 12 f0       	push   $0xf012ca6c
f01033d1:	68 56 01 00 00       	push   $0x156
f01033d6:	68 8d ca 12 f0       	push   $0xf012ca8d
f01033db:	e8 cf da ff ff       	call   f0100eaf <_panic>

f01033e0 <command_shrr>:

	return 0 ;
}

int command_shrr(int number_of_arguments, char **arguments)
{
f01033e0:	55                   	push   %ebp
f01033e1:	89 e5                	mov    %esp,%ebp
f01033e3:	83 ec 08             	sub    $0x8,%esp
	//TODO: LAB5 Hands-on: fill this function. corresponding command name is "sr"
	//Comment the following line
	panic("Function is not implemented yet!");
f01033e6:	83 ec 04             	sub    $0x4,%esp
f01033e9:	68 6c ca 12 f0       	push   $0xf012ca6c
f01033ee:	68 5f 01 00 00       	push   $0x15f
f01033f3:	68 8d ca 12 f0       	push   $0xf012ca8d
f01033f8:	e8 b2 da ff ff       	call   f0100eaf <_panic>

f01033fd <command_v2p>:

	return 0;
}

int command_v2p(int number_of_arguments, char **arguments)
{
f01033fd:	55                   	push   %ebp
f01033fe:	89 e5                	mov    %esp,%ebp
f0103400:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB5 Hands-on: corresponding command name is "v2p"

	uint32 va = strtol(arguments[1], NULL, 16);
f0103403:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103406:	83 c0 04             	add    $0x4,%eax
f0103409:	8b 00                	mov    (%eax),%eax
f010340b:	83 ec 04             	sub    $0x4,%esp
f010340e:	6a 10                	push   $0x10
f0103410:	6a 00                	push   $0x0
f0103412:	50                   	push   %eax
f0103413:	e8 72 7a 01 00       	call   f011ae8a <strtol>
f0103418:	83 c4 10             	add    $0x10,%esp
f010341b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 pa = virtual_to_physical(ptr_page_directory, va);
f010341e:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0103423:	83 ec 08             	sub    $0x8,%esp
f0103426:	ff 75 f4             	pushl  -0xc(%ebp)
f0103429:	50                   	push   %eax
f010342a:	e8 c9 68 00 00       	call   f0109cf8 <virtual_to_physical>
f010342f:	83 c4 10             	add    $0x10,%esp
f0103432:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (pa == -1)
f0103435:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
f0103439:	75 12                	jne    f010344d <command_v2p+0x50>
		cprintf("NOT FOUND\n");
f010343b:	83 ec 0c             	sub    $0xc,%esp
f010343e:	68 55 cb 12 f0       	push   $0xf012cb55
f0103443:	e8 14 e7 ff ff       	call   f0101b5c <cprintf>
f0103448:	83 c4 10             	add    $0x10,%esp
f010344b:	eb 16                	jmp    f0103463 <command_v2p+0x66>
	else
		cprintf("PA of VA %x = %x\n", va, pa);
f010344d:	83 ec 04             	sub    $0x4,%esp
f0103450:	ff 75 f0             	pushl  -0x10(%ebp)
f0103453:	ff 75 f4             	pushl  -0xc(%ebp)
f0103456:	68 60 cb 12 f0       	push   $0xf012cb60
f010345b:	e8 fc e6 ff ff       	call   f0101b5c <cprintf>
f0103460:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103463:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103468:	c9                   	leave  
f0103469:	c3                   	ret    

f010346a <command_p2v>:

int command_p2v(int number_of_arguments, char **arguments)
{
f010346a:	55                   	push   %ebp
f010346b:	89 e5                	mov    %esp,%ebp
f010346d:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB5 Hands-on: corresponding command name is "p2v"

	uint32 pa = strtol(arguments[1], NULL, 16);
f0103470:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103473:	83 c0 04             	add    $0x4,%eax
f0103476:	8b 00                	mov    (%eax),%eax
f0103478:	83 ec 04             	sub    $0x4,%esp
f010347b:	6a 10                	push   $0x10
f010347d:	6a 00                	push   $0x0
f010347f:	50                   	push   %eax
f0103480:	e8 05 7a 01 00       	call   f011ae8a <strtol>
f0103485:	83 c4 10             	add    $0x10,%esp
f0103488:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 va = physical_to_virtual(ptr_page_directory, pa);
f010348b:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0103490:	83 ec 08             	sub    $0x8,%esp
f0103493:	ff 75 f4             	pushl  -0xc(%ebp)
f0103496:	50                   	push   %eax
f0103497:	e8 76 68 00 00       	call   f0109d12 <physical_to_virtual>
f010349c:	83 c4 10             	add    $0x10,%esp
f010349f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (va == 0xFFFFFFFF)
f01034a2:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
f01034a6:	75 12                	jne    f01034ba <command_p2v+0x50>
		cprintf("NOT FOUND\n");
f01034a8:	83 ec 0c             	sub    $0xc,%esp
f01034ab:	68 55 cb 12 f0       	push   $0xf012cb55
f01034b0:	e8 a7 e6 ff ff       	call   f0101b5c <cprintf>
f01034b5:	83 c4 10             	add    $0x10,%esp
f01034b8:	eb 16                	jmp    f01034d0 <command_p2v+0x66>
	else
		cprintf("VA of PA %x = %x\n", pa, va);
f01034ba:	83 ec 04             	sub    $0x4,%esp
f01034bd:	ff 75 f0             	pushl  -0x10(%ebp)
f01034c0:	ff 75 f4             	pushl  -0xc(%ebp)
f01034c3:	68 72 cb 12 f0       	push   $0xf012cb72
f01034c8:	e8 8f e6 ff ff       	call   f0101b5c <cprintf>
f01034cd:	83 c4 10             	add    $0x10,%esp
	return 0;
f01034d0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01034d5:	c9                   	leave  
f01034d6:	c3                   	ret    

f01034d7 <command_ft>:

//===========================================================================
//Lab6.Examples
//=============
int command_ft(int number_of_arguments, char **arguments)
{
f01034d7:	55                   	push   %ebp
f01034d8:	89 e5                	mov    %esp,%ebp
f01034da:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB6 Example: corresponding command name is "ft"

	uint32 va = strtol(arguments[1], NULL, 16);
f01034dd:	8b 45 0c             	mov    0xc(%ebp),%eax
f01034e0:	83 c0 04             	add    $0x4,%eax
f01034e3:	8b 00                	mov    (%eax),%eax
f01034e5:	83 ec 04             	sub    $0x4,%esp
f01034e8:	6a 10                	push   $0x10
f01034ea:	6a 00                	push   $0x0
f01034ec:	50                   	push   %eax
f01034ed:	e8 98 79 01 00       	call   f011ae8a <strtol>
f01034f2:	83 c4 10             	add    $0x10,%esp
f01034f5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	del_page_table(ptr_page_directory, va);
f01034f8:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01034fd:	83 ec 08             	sub    $0x8,%esp
f0103500:	ff 75 f4             	pushl  -0xc(%ebp)
f0103503:	50                   	push   %eax
f0103504:	e8 05 69 00 00       	call   f0109e0e <del_page_table>
f0103509:	83 c4 10             	add    $0x10,%esp

	return 0;
f010350c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103511:	c9                   	leave  
f0103512:	c3                   	ret    

f0103513 <command_writeusermem>:

//*****************************************************************************************//
//***************************** UTILITY/TESING COMMANDS ***********************************//
//*****************************************************************************************//
int command_writeusermem(int number_of_arguments, char **arguments)
{
f0103513:	55                   	push   %ebp
f0103514:	89 e5                	mov    %esp,%ebp
f0103516:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 3)
f0103519:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f010351d:	75 37                	jne    f0103556 <command_writeusermem+0x43>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f010351f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103522:	83 c0 04             	add    $0x4,%eax
f0103525:	8b 00                	mov    (%eax),%eax
f0103527:	83 ec 04             	sub    $0x4,%esp
f010352a:	6a 10                	push   $0x10
f010352c:	6a 00                	push   $0x0
f010352e:	50                   	push   %eax
f010352f:	e8 56 79 01 00       	call   f011ae8a <strtol>
f0103534:	83 c4 10             	add    $0x10,%esp
f0103537:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address) ;
f010353a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010353d:	89 45 d8             	mov    %eax,-0x28(%ebp)

		*ptr = arguments[2][0];
f0103540:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103543:	83 c0 08             	add    $0x8,%eax
f0103546:	8b 00                	mov    (%eax),%eax
f0103548:	8a 00                	mov    (%eax),%al
f010354a:	88 c2                	mov    %al,%dl
f010354c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010354f:	88 10                	mov    %dl,(%eax)
f0103551:	e9 b9 00 00 00       	jmp    f010360f <command_writeusermem+0xfc>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 4)
f0103556:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f010355a:	0f 85 9f 00 00 00    	jne    f01035ff <command_writeusermem+0xec>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f0103560:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103563:	83 c0 04             	add    $0x4,%eax
f0103566:	8b 00                	mov    (%eax),%eax
f0103568:	83 ec 04             	sub    $0x4,%esp
f010356b:	6a 0a                	push   $0xa
f010356d:	6a 00                	push   $0x0
f010356f:	50                   	push   %eax
f0103570:	e8 15 79 01 00       	call   f011ae8a <strtol>
f0103575:	83 c4 10             	add    $0x10,%esp
f0103578:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f010357b:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f0103582:	83 ec 04             	sub    $0x4,%esp
f0103585:	6a 00                	push   $0x0
f0103587:	8d 45 d0             	lea    -0x30(%ebp),%eax
f010358a:	50                   	push   %eax
f010358b:	ff 75 f4             	pushl  -0xc(%ebp)
f010358e:	e8 d5 84 00 00       	call   f010ba68 <envid2env>
f0103593:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f0103596:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103599:	83 c0 08             	add    $0x8,%eax
f010359c:	8b 00                	mov    (%eax),%eax
f010359e:	83 ec 04             	sub    $0x4,%esp
f01035a1:	6a 10                	push   $0x10
f01035a3:	6a 00                	push   $0x0
f01035a5:	50                   	push   %eax
f01035a6:	e8 df 78 01 00       	call   f011ae8a <strtol>
f01035ab:	83 c4 10             	add    $0x10,%esp
f01035ae:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f01035b1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01035b4:	85 c0                	test   %eax,%eax
f01035b6:	75 07                	jne    f01035bf <command_writeusermem+0xac>
f01035b8:	b8 00 00 00 00       	mov    $0x0,%eax
f01035bd:	eb 55                	jmp    f0103614 <command_writeusermem+0x101>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f01035bf:	0f 20 d8             	mov    %cr3,%eax
f01035c2:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f01035c5:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f01035c8:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32) (env->env_cr3));
f01035cb:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01035ce:	8b 40 68             	mov    0x68(%eax),%eax
f01035d1:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01035d4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01035d7:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f01035da:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01035dd:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		*ptr = arguments[3][0];
f01035e0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01035e3:	83 c0 0c             	add    $0xc,%eax
f01035e6:	8b 00                	mov    (%eax),%eax
f01035e8:	8a 00                	mov    (%eax),%al
f01035ea:	88 c2                	mov    %al,%dl
f01035ec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01035ef:	88 10                	mov    %dl,(%eax)
f01035f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01035f4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01035f7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01035fa:	0f 22 d8             	mov    %eax,%cr3
f01035fd:	eb 10                	jmp    f010360f <command_writeusermem+0xfc>
		lcr3(oldDir);
	}
	else
	{
		cprintf("wum command: invalid number of arguments\n") ;
f01035ff:	83 ec 0c             	sub    $0xc,%esp
f0103602:	68 84 cb 12 f0       	push   $0xf012cb84
f0103607:	e8 50 e5 ff ff       	call   f0101b5c <cprintf>
f010360c:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f010360f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103614:	c9                   	leave  
f0103615:	c3                   	ret    

f0103616 <command_readusermem>:


int command_readusermem(int number_of_arguments, char **arguments)
{
f0103616:	55                   	push   %ebp
f0103617:	89 e5                	mov    %esp,%ebp
f0103619:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 2)
f010361c:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0103620:	75 42                	jne    f0103664 <command_readusermem+0x4e>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f0103622:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103625:	83 c0 04             	add    $0x4,%eax
f0103628:	8b 00                	mov    (%eax),%eax
f010362a:	83 ec 04             	sub    $0x4,%esp
f010362d:	6a 10                	push   $0x10
f010362f:	6a 00                	push   $0x0
f0103631:	50                   	push   %eax
f0103632:	e8 53 78 01 00       	call   f011ae8a <strtol>
f0103637:	83 c4 10             	add    $0x10,%esp
f010363a:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address ) ;
f010363d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0103640:	89 45 d8             	mov    %eax,-0x28(%ebp)

		cprintf("value at address %x = %c\n", ptr, *ptr);
f0103643:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0103646:	8a 00                	mov    (%eax),%al
f0103648:	0f b6 c0             	movzbl %al,%eax
f010364b:	83 ec 04             	sub    $0x4,%esp
f010364e:	50                   	push   %eax
f010364f:	ff 75 d8             	pushl  -0x28(%ebp)
f0103652:	68 ae cb 12 f0       	push   $0xf012cbae
f0103657:	e8 00 e5 ff ff       	call   f0101b5c <cprintf>
f010365c:	83 c4 10             	add    $0x10,%esp
f010365f:	e9 c4 00 00 00       	jmp    f0103728 <command_readusermem+0x112>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 3)
f0103664:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0103668:	0f 85 aa 00 00 00    	jne    f0103718 <command_readusermem+0x102>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f010366e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103671:	83 c0 04             	add    $0x4,%eax
f0103674:	8b 00                	mov    (%eax),%eax
f0103676:	83 ec 04             	sub    $0x4,%esp
f0103679:	6a 0a                	push   $0xa
f010367b:	6a 00                	push   $0x0
f010367d:	50                   	push   %eax
f010367e:	e8 07 78 01 00       	call   f011ae8a <strtol>
f0103683:	83 c4 10             	add    $0x10,%esp
f0103686:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f0103689:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f0103690:	83 ec 04             	sub    $0x4,%esp
f0103693:	6a 00                	push   $0x0
f0103695:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0103698:	50                   	push   %eax
f0103699:	ff 75 f4             	pushl  -0xc(%ebp)
f010369c:	e8 c7 83 00 00       	call   f010ba68 <envid2env>
f01036a1:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f01036a4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01036a7:	83 c0 08             	add    $0x8,%eax
f01036aa:	8b 00                	mov    (%eax),%eax
f01036ac:	83 ec 04             	sub    $0x4,%esp
f01036af:	6a 10                	push   $0x10
f01036b1:	6a 00                	push   $0x0
f01036b3:	50                   	push   %eax
f01036b4:	e8 d1 77 01 00       	call   f011ae8a <strtol>
f01036b9:	83 c4 10             	add    $0x10,%esp
f01036bc:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f01036bf:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01036c2:	85 c0                	test   %eax,%eax
f01036c4:	75 07                	jne    f01036cd <command_readusermem+0xb7>
f01036c6:	b8 00 00 00 00       	mov    $0x0,%eax
f01036cb:	eb 60                	jmp    f010372d <command_readusermem+0x117>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f01036cd:	0f 20 d8             	mov    %cr3,%eax
f01036d0:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f01036d3:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f01036d6:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32)( env->env_cr3));
f01036d9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01036dc:	8b 40 68             	mov    0x68(%eax),%eax
f01036df:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01036e2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01036e5:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f01036e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01036eb:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		cprintf("value at address %x = %c\n", address, *ptr);
f01036ee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01036f1:	8a 00                	mov    (%eax),%al
f01036f3:	0f b6 c0             	movzbl %al,%eax
f01036f6:	83 ec 04             	sub    $0x4,%esp
f01036f9:	50                   	push   %eax
f01036fa:	ff 75 f0             	pushl  -0x10(%ebp)
f01036fd:	68 ae cb 12 f0       	push   $0xf012cbae
f0103702:	e8 55 e4 ff ff       	call   f0101b5c <cprintf>
f0103707:	83 c4 10             	add    $0x10,%esp
f010370a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010370d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0103710:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0103713:	0f 22 d8             	mov    %eax,%cr3
f0103716:	eb 10                	jmp    f0103728 <command_readusermem+0x112>

		lcr3(oldDir);
	}
	else
	{
		cprintf("rum command: invalid number of arguments\n") ;
f0103718:	83 ec 0c             	sub    $0xc,%esp
f010371b:	68 c8 cb 12 f0       	push   $0xf012cbc8
f0103720:	e8 37 e4 ff ff       	call   f0101b5c <cprintf>
f0103725:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103728:	b8 00 00 00 00       	mov    $0x0,%eax

}
f010372d:	c9                   	leave  
f010372e:	c3                   	ret    

f010372f <command_readuserblock>:


int command_readuserblock(int number_of_arguments, char **arguments)
{
f010372f:	55                   	push   %ebp
f0103730:	89 e5                	mov    %esp,%ebp
f0103732:	83 ec 38             	sub    $0x38,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0103735:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103738:	83 c0 04             	add    $0x4,%eax
f010373b:	8b 00                	mov    (%eax),%eax
f010373d:	83 ec 04             	sub    $0x4,%esp
f0103740:	6a 0a                	push   $0xa
f0103742:	6a 00                	push   $0x0
f0103744:	50                   	push   %eax
f0103745:	e8 40 77 01 00       	call   f011ae8a <strtol>
f010374a:	83 c4 10             	add    $0x10,%esp
f010374d:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Env* env = NULL;
f0103750:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	envid2env(envId, &env, 0 );
f0103757:	83 ec 04             	sub    $0x4,%esp
f010375a:	6a 00                	push   $0x0
f010375c:	8d 45 d0             	lea    -0x30(%ebp),%eax
f010375f:	50                   	push   %eax
f0103760:	ff 75 ec             	pushl  -0x14(%ebp)
f0103763:	e8 00 83 00 00       	call   f010ba68 <envid2env>
f0103768:	83 c4 10             	add    $0x10,%esp

	int address = strtol(arguments[2], NULL, 16);
f010376b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010376e:	83 c0 08             	add    $0x8,%eax
f0103771:	8b 00                	mov    (%eax),%eax
f0103773:	83 ec 04             	sub    $0x4,%esp
f0103776:	6a 10                	push   $0x10
f0103778:	6a 00                	push   $0x0
f010377a:	50                   	push   %eax
f010377b:	e8 0a 77 01 00       	call   f011ae8a <strtol>
f0103780:	83 c4 10             	add    $0x10,%esp
f0103783:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int nBytes = strtol(arguments[3], NULL, 10);
f0103786:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103789:	83 c0 0c             	add    $0xc,%eax
f010378c:	8b 00                	mov    (%eax),%eax
f010378e:	83 ec 04             	sub    $0x4,%esp
f0103791:	6a 0a                	push   $0xa
f0103793:	6a 00                	push   $0x0
f0103795:	50                   	push   %eax
f0103796:	e8 ef 76 01 00       	call   f011ae8a <strtol>
f010379b:	83 c4 10             	add    $0x10,%esp
f010379e:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	unsigned char *ptr = (unsigned char *)(address) ;
f01037a1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01037a4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//Write the given Character

	if(env == NULL) return 0;
f01037a7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01037aa:	85 c0                	test   %eax,%eax
f01037ac:	75 07                	jne    f01037b5 <command_readuserblock+0x86>
f01037ae:	b8 00 00 00 00       	mov    $0x0,%eax
f01037b3:	eb 65                	jmp    f010381a <command_readuserblock+0xeb>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f01037b5:	0f 20 d8             	mov    %cr3,%eax
f01037b8:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f01037bb:	8b 45 d8             	mov    -0x28(%ebp),%eax

	uint32 oldDir = rcr3();
f01037be:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));
f01037c1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01037c4:	8b 40 68             	mov    0x68(%eax),%eax
f01037c7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01037ca:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01037cd:	0f 22 d8             	mov    %eax,%cr3

	int i;
	for(i = 0;i<nBytes; i++)
f01037d0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01037d7:	eb 28                	jmp    f0103801 <command_readuserblock+0xd2>
	{
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
f01037d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01037dc:	8a 00                	mov    (%eax),%al
f01037de:	0f b6 d0             	movzbl %al,%edx
f01037e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01037e4:	8a 00                	mov    (%eax),%al
f01037e6:	0f b6 c0             	movzbl %al,%eax
f01037e9:	52                   	push   %edx
f01037ea:	50                   	push   %eax
f01037eb:	ff 75 f4             	pushl  -0xc(%ebp)
f01037ee:	68 f2 cb 12 f0       	push   $0xf012cbf2
f01037f3:	e8 64 e3 ff ff       	call   f0101b5c <cprintf>
f01037f8:	83 c4 10             	add    $0x10,%esp
		ptr++;
f01037fb:	ff 45 f4             	incl   -0xc(%ebp)
	uint32 oldDir = rcr3();
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));

	int i;
	for(i = 0;i<nBytes; i++)
f01037fe:	ff 45 f0             	incl   -0x10(%ebp)
f0103801:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103804:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0103807:	7c d0                	jl     f01037d9 <command_readuserblock+0xaa>
f0103809:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010380c:	89 45 e0             	mov    %eax,-0x20(%ebp)
f010380f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0103812:	0f 22 d8             	mov    %eax,%cr3
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
		ptr++;
	}
	lcr3(oldDir);

	return 0;
f0103815:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010381a:	c9                   	leave  
f010381b:	c3                   	ret    

f010381c <command_remove_table>:

int command_remove_table(int number_of_arguments, char **arguments)
{
f010381c:	55                   	push   %ebp
f010381d:	89 e5                	mov    %esp,%ebp
f010381f:	83 ec 28             	sub    $0x28,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0103822:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103825:	83 c0 04             	add    $0x4,%eax
f0103828:	8b 00                	mov    (%eax),%eax
f010382a:	83 ec 04             	sub    $0x4,%esp
f010382d:	6a 0a                	push   $0xa
f010382f:	6a 00                	push   $0x0
f0103831:	50                   	push   %eax
f0103832:	e8 53 76 01 00       	call   f011ae8a <strtol>
f0103837:	83 c4 10             	add    $0x10,%esp
f010383a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct Env* env = NULL;
f010383d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	envid2env(envId, &env, 0 );
f0103844:	83 ec 04             	sub    $0x4,%esp
f0103847:	6a 00                	push   $0x0
f0103849:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010384c:	50                   	push   %eax
f010384d:	ff 75 f4             	pushl  -0xc(%ebp)
f0103850:	e8 13 82 00 00       	call   f010ba68 <envid2env>
f0103855:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0103858:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010385b:	85 c0                	test   %eax,%eax
f010385d:	75 0a                	jne    f0103869 <command_remove_table+0x4d>
f010385f:	b8 00 00 00 00       	mov    $0x0,%eax
f0103864:	e9 c7 00 00 00       	jmp    f0103930 <command_remove_table+0x114>

	uint32 address = strtol(arguments[2], NULL, 16);
f0103869:	8b 45 0c             	mov    0xc(%ebp),%eax
f010386c:	83 c0 08             	add    $0x8,%eax
f010386f:	8b 00                	mov    (%eax),%eax
f0103871:	83 ec 04             	sub    $0x4,%esp
f0103874:	6a 10                	push   $0x10
f0103876:	6a 00                	push   $0x0
f0103878:	50                   	push   %eax
f0103879:	e8 0c 76 01 00       	call   f011ae8a <strtol>
f010387e:	83 c4 10             	add    $0x10,%esp
f0103881:	89 45 f0             	mov    %eax,-0x10(%ebp)
	unsigned char *va = (unsigned char *)(address) ;
f0103884:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103887:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 table_pa = env->env_page_directory[PDX(address)] & 0xFFFFF000;
f010388a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010388d:	8b 40 64             	mov    0x64(%eax),%eax
f0103890:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103893:	c1 ea 16             	shr    $0x16,%edx
f0103896:	c1 e2 02             	shl    $0x2,%edx
f0103899:	01 d0                	add    %edx,%eax
f010389b:	8b 00                	mov    (%eax),%eax
f010389d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01038a2:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//remove the table
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(va))
f01038a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01038a8:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f01038ad:	77 1c                	ja     f01038cb <command_remove_table+0xaf>
	{
		kfree((void*)kheap_virtual_address(table_pa));
f01038af:	83 ec 0c             	sub    $0xc,%esp
f01038b2:	ff 75 e8             	pushl  -0x18(%ebp)
f01038b5:	e8 b0 62 00 00       	call   f0109b6a <kheap_virtual_address>
f01038ba:	83 c4 10             	add    $0x10,%esp
f01038bd:	83 ec 0c             	sub    $0xc,%esp
f01038c0:	50                   	push   %eax
f01038c1:	e8 8a 62 00 00       	call   f0109b50 <kfree>
f01038c6:	83 c4 10             	add    $0x10,%esp
f01038c9:	eb 28                	jmp    f01038f3 <command_remove_table+0xd7>
	}
	else
	{
		// get the physical address and FrameInfo of the page table
		struct FrameInfo *table_FrameInfo = to_frame_info(table_pa);
f01038cb:	83 ec 0c             	sub    $0xc,%esp
f01038ce:	ff 75 e8             	pushl  -0x18(%ebp)
f01038d1:	e8 96 f5 ff ff       	call   f0102e6c <to_frame_info>
f01038d6:	83 c4 10             	add    $0x10,%esp
f01038d9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		// set references of the table frame to 0 then free it by adding
		// to the free frame list
		table_FrameInfo->references = 0;
f01038dc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01038df:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		free_frame(table_FrameInfo);
f01038e5:	83 ec 0c             	sub    $0xc,%esp
f01038e8:	ff 75 e4             	pushl  -0x1c(%ebp)
f01038eb:	e8 7a 58 00 00       	call   f010916a <free_frame>
f01038f0:	83 c4 10             	add    $0x10,%esp
	}

	// set the corresponding entry in the directory to 0
	uint32 dir_index = PDX(va);
f01038f3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01038f6:	c1 e8 16             	shr    $0x16,%eax
f01038f9:	89 45 e0             	mov    %eax,-0x20(%ebp)
	env->env_page_directory[dir_index] &= (~PERM_PRESENT);
f01038fc:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01038ff:	8b 40 64             	mov    0x64(%eax),%eax
f0103902:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0103905:	c1 e2 02             	shl    $0x2,%edx
f0103908:	01 c2                	add    %eax,%edx
f010390a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010390d:	8b 40 64             	mov    0x64(%eax),%eax
f0103910:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f0103913:	c1 e1 02             	shl    $0x2,%ecx
f0103916:	01 c8                	add    %ecx,%eax
f0103918:	8b 00                	mov    (%eax),%eax
f010391a:	83 e0 fe             	and    $0xfffffffe,%eax
f010391d:	89 02                	mov    %eax,(%edx)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010391f:	0f 20 d8             	mov    %cr3,%eax
f0103922:	89 45 dc             	mov    %eax,-0x24(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0103925:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0103928:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
	return 0;
f010392b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103930:	c9                   	leave  
f0103931:	c3                   	ret    

f0103932 <command_allocuserpage>:

int command_allocuserpage(int number_of_arguments, char **arguments)
{
f0103932:	55                   	push   %ebp
f0103933:	89 e5                	mov    %esp,%ebp
f0103935:	83 ec 28             	sub    $0x28,%esp
	if (number_of_arguments < 3 || number_of_arguments > 4)
f0103938:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010393c:	7e 06                	jle    f0103944 <command_allocuserpage+0x12>
f010393e:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0103942:	7e 1a                	jle    f010395e <command_allocuserpage+0x2c>
	{
		cprintf("aup command: invalid number of arguments\n") ;
f0103944:	83 ec 0c             	sub    $0xc,%esp
f0103947:	68 04 cc 12 f0       	push   $0xf012cc04
f010394c:	e8 0b e2 ff ff       	call   f0101b5c <cprintf>
f0103951:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103954:	b8 00 00 00 00       	mov    $0x0,%eax
f0103959:	e9 46 01 00 00       	jmp    f0103aa4 <command_allocuserpage+0x172>
	}
	int32 envId = strtol(arguments[1],NULL, 10);
f010395e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103961:	83 c0 04             	add    $0x4,%eax
f0103964:	8b 00                	mov    (%eax),%eax
f0103966:	83 ec 04             	sub    $0x4,%esp
f0103969:	6a 0a                	push   $0xa
f010396b:	6a 00                	push   $0x0
f010396d:	50                   	push   %eax
f010396e:	e8 17 75 01 00       	call   f011ae8a <strtol>
f0103973:	83 c4 10             	add    $0x10,%esp
f0103976:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Env* env = NULL;
f0103979:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	envid2env(envId, &env, 0 );
f0103980:	83 ec 04             	sub    $0x4,%esp
f0103983:	6a 00                	push   $0x0
f0103985:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0103988:	50                   	push   %eax
f0103989:	ff 75 f0             	pushl  -0x10(%ebp)
f010398c:	e8 d7 80 00 00       	call   f010ba68 <envid2env>
f0103991:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0103994:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103997:	85 c0                	test   %eax,%eax
f0103999:	75 0a                	jne    f01039a5 <command_allocuserpage+0x73>
f010399b:	b8 00 00 00 00       	mov    $0x0,%eax
f01039a0:	e9 ff 00 00 00       	jmp    f0103aa4 <command_allocuserpage+0x172>

	uint32 va = strtol(arguments[2], NULL, 16);
f01039a5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01039a8:	83 c0 08             	add    $0x8,%eax
f01039ab:	8b 00                	mov    (%eax),%eax
f01039ad:	83 ec 04             	sub    $0x4,%esp
f01039b0:	6a 10                	push   $0x10
f01039b2:	6a 00                	push   $0x0
f01039b4:	50                   	push   %eax
f01039b5:	e8 d0 74 01 00       	call   f011ae8a <strtol>
f01039ba:	83 c4 10             	add    $0x10,%esp
f01039bd:	89 45 ec             	mov    %eax,-0x14(%ebp)

	// Allocate a single frame from the free frame list
	struct FrameInfo * ptr_FrameInfo ;
	int ret = allocate_frame(&ptr_FrameInfo);
f01039c0:	83 ec 0c             	sub    $0xc,%esp
f01039c3:	8d 45 e0             	lea    -0x20(%ebp),%eax
f01039c6:	50                   	push   %eax
f01039c7:	e8 76 56 00 00       	call   f0109042 <allocate_frame>
f01039cc:	83 c4 10             	add    $0x10,%esp
f01039cf:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret == E_NO_MEM)
f01039d2:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f01039d6:	75 1a                	jne    f01039f2 <command_allocuserpage+0xc0>
	{
		cprintf("ERROR: no enough memory\n");
f01039d8:	83 ec 0c             	sub    $0xc,%esp
f01039db:	68 2e cc 12 f0       	push   $0xf012cc2e
f01039e0:	e8 77 e1 ff ff       	call   f0101b5c <cprintf>
f01039e5:	83 c4 10             	add    $0x10,%esp
		return 0;
f01039e8:	b8 00 00 00 00       	mov    $0x0,%eax
f01039ed:	e9 b2 00 00 00       	jmp    f0103aa4 <command_allocuserpage+0x172>
	}

	if (number_of_arguments == 3)
f01039f2:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01039f6:	75 1d                	jne    f0103a15 <command_allocuserpage+0xe3>
	{
		// Map this frame to the given user virtual address with PERM_WRITEABLE
		map_frame(env->env_page_directory, ptr_FrameInfo, va, PERM_WRITEABLE | PERM_USER);
f01039f8:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01039fb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01039fe:	8b 40 64             	mov    0x64(%eax),%eax
f0103a01:	6a 06                	push   $0x6
f0103a03:	ff 75 ec             	pushl  -0x14(%ebp)
f0103a06:	52                   	push   %edx
f0103a07:	50                   	push   %eax
f0103a08:	e8 d6 5a 00 00       	call   f01094e3 <map_frame>
f0103a0d:	83 c4 10             	add    $0x10,%esp
f0103a10:	e9 8a 00 00 00       	jmp    f0103a9f <command_allocuserpage+0x16d>
	}
	else if (number_of_arguments == 4)
f0103a15:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0103a19:	0f 85 80 00 00 00    	jne    f0103a9f <command_allocuserpage+0x16d>
	{
		// Map this frame to the given user virtual address with the given permission
		uint32 rw ;
		if (arguments[3][0] == 'r' || arguments[3][0] == 'R')
f0103a1f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103a22:	83 c0 0c             	add    $0xc,%eax
f0103a25:	8b 00                	mov    (%eax),%eax
f0103a27:	8a 00                	mov    (%eax),%al
f0103a29:	3c 72                	cmp    $0x72,%al
f0103a2b:	74 0e                	je     f0103a3b <command_allocuserpage+0x109>
f0103a2d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103a30:	83 c0 0c             	add    $0xc,%eax
f0103a33:	8b 00                	mov    (%eax),%eax
f0103a35:	8a 00                	mov    (%eax),%al
f0103a37:	3c 52                	cmp    $0x52,%al
f0103a39:	75 09                	jne    f0103a44 <command_allocuserpage+0x112>
			rw = 0 ;
f0103a3b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0103a42:	eb 3c                	jmp    f0103a80 <command_allocuserpage+0x14e>
		else if (arguments[3][0] == 'w' || arguments[3][0] == 'W')
f0103a44:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103a47:	83 c0 0c             	add    $0xc,%eax
f0103a4a:	8b 00                	mov    (%eax),%eax
f0103a4c:	8a 00                	mov    (%eax),%al
f0103a4e:	3c 77                	cmp    $0x77,%al
f0103a50:	74 0e                	je     f0103a60 <command_allocuserpage+0x12e>
f0103a52:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103a55:	83 c0 0c             	add    $0xc,%eax
f0103a58:	8b 00                	mov    (%eax),%eax
f0103a5a:	8a 00                	mov    (%eax),%al
f0103a5c:	3c 57                	cmp    $0x57,%al
f0103a5e:	75 09                	jne    f0103a69 <command_allocuserpage+0x137>
			rw = PERM_WRITEABLE ;
f0103a60:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0103a67:	eb 17                	jmp    f0103a80 <command_allocuserpage+0x14e>
		else
		{
			cprintf("aup command: wrong permission (r/w)... will continue as writable\n") ;
f0103a69:	83 ec 0c             	sub    $0xc,%esp
f0103a6c:	68 48 cc 12 f0       	push   $0xf012cc48
f0103a71:	e8 e6 e0 ff ff       	call   f0101b5c <cprintf>
f0103a76:	83 c4 10             	add    $0x10,%esp
			rw = PERM_WRITEABLE ;
f0103a79:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
		}

		map_frame(env->env_page_directory, ptr_FrameInfo, va, rw | PERM_USER);
f0103a80:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103a83:	83 c8 04             	or     $0x4,%eax
f0103a86:	89 c1                	mov    %eax,%ecx
f0103a88:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0103a8b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103a8e:	8b 40 64             	mov    0x64(%eax),%eax
f0103a91:	51                   	push   %ecx
f0103a92:	ff 75 ec             	pushl  -0x14(%ebp)
f0103a95:	52                   	push   %edx
f0103a96:	50                   	push   %eax
f0103a97:	e8 47 5a 00 00       	call   f01094e3 <map_frame>
f0103a9c:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103a9f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103aa4:	c9                   	leave  
f0103aa5:	c3                   	ret    

f0103aa6 <command_meminfo>:
//*****************************************************************************************//
//***************************** PROJECT HELPERS COMMAND ***********************************//
//*****************************************************************************************//

int command_meminfo(int number_of_arguments, char **arguments)
{
f0103aa6:	55                   	push   %ebp
f0103aa7:	89 e5                	mov    %esp,%ebp
f0103aa9:	56                   	push   %esi
f0103aaa:	53                   	push   %ebx
f0103aab:	83 ec 10             	sub    $0x10,%esp
	struct freeFramesCounters counters =calculate_available_frames();
f0103aae:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0103ab1:	83 ec 0c             	sub    $0xc,%esp
f0103ab4:	50                   	push   %eax
f0103ab5:	e8 17 5d 00 00       	call   f01097d1 <calculate_available_frames>
f0103aba:	83 c4 0c             	add    $0xc,%esp
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0103abd:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0103ac0:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103ac3:	8b 45 ec             	mov    -0x14(%ebp),%eax
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);
f0103ac6:	8b 75 ec             	mov    -0x14(%ebp),%esi
f0103ac9:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0103acc:	01 de                	add    %ebx,%esi
f0103ace:	8b 5d f4             	mov    -0xc(%ebp),%ebx
//*****************************************************************************************//

int command_meminfo(int number_of_arguments, char **arguments)
{
	struct freeFramesCounters counters =calculate_available_frames();
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0103ad1:	01 f3                	add    %esi,%ebx
f0103ad3:	83 ec 0c             	sub    $0xc,%esp
f0103ad6:	51                   	push   %ecx
f0103ad7:	52                   	push   %edx
f0103ad8:	50                   	push   %eax
f0103ad9:	53                   	push   %ebx
f0103ada:	68 8c cc 12 f0       	push   $0xf012cc8c
f0103adf:	e8 78 e0 ff ff       	call   f0101b5c <cprintf>
f0103ae4:	83 c4 20             	add    $0x20,%esp
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);

	cprintf("Num of calls for kheap_virtual_address [in last run] = %d\n", numOfKheapVACalls);
f0103ae7:	a1 30 6c 85 f0       	mov    0xf0856c30,%eax
f0103aec:	83 ec 08             	sub    $0x8,%esp
f0103aef:	50                   	push   %eax
f0103af0:	68 e4 cc 12 f0       	push   $0xf012cce4
f0103af5:	e8 62 e0 ff ff       	call   f0101b5c <cprintf>
f0103afa:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103afd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103b02:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0103b05:	5b                   	pop    %ebx
f0103b06:	5e                   	pop    %esi
f0103b07:	5d                   	pop    %ebp
f0103b08:	c3                   	ret    

f0103b09 <CreateEnv>:

//2020
struct Env * CreateEnv(int number_of_arguments, char **arguments)
{
f0103b09:	55                   	push   %ebp
f0103b0a:	89 e5                	mov    %esp,%ebp
f0103b0c:	83 ec 28             	sub    $0x28,%esp
	struct Env* env;
	uint32 pageWSSize = __PWS_MAX_SIZE;		//arg#3 default
f0103b0f:	c7 45 f4 88 13 00 00 	movl   $0x1388,-0xc(%ebp)
	uint32 LRUSecondListSize = 0;			//arg#4 default
f0103b16:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 percent_WS_pages_to_remove = 0;	//arg#5 default
f0103b1d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int BSDSchedNiceVal = -100;				//arg#5 default
f0103b24:	c7 45 ec 9c ff ff ff 	movl   $0xffffff9c,-0x14(%ebp)
	int PRIRRSchedPriority = 0;				//arg#5 default
f0103b2b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

#if USE_KHEAP
	{
		switch (number_of_arguments)
f0103b32:	8b 45 08             	mov    0x8(%ebp),%eax
f0103b35:	83 f8 04             	cmp    $0x4,%eax
f0103b38:	0f 84 c3 00 00 00    	je     f0103c01 <CreateEnv+0xf8>
f0103b3e:	83 f8 05             	cmp    $0x5,%eax
f0103b41:	74 0e                	je     f0103b51 <CreateEnv+0x48>
f0103b43:	83 f8 03             	cmp    $0x3,%eax
f0103b46:	0f 84 4a 01 00 00    	je     f0103c96 <CreateEnv+0x18d>
f0103b4c:	e9 8d 01 00 00       	jmp    f0103cde <CreateEnv+0x1d5>
		{
		case 5:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103b51:	83 ec 0c             	sub    $0xc,%esp
f0103b54:	6a 02                	push   $0x2
f0103b56:	e8 c8 bc 00 00       	call   f010f823 <isPageReplacmentAlgorithmLRU>
f0103b5b:	83 c4 10             	add    $0x10,%esp
f0103b5e:	85 c0                	test   %eax,%eax
f0103b60:	75 1a                	jne    f0103b7c <CreateEnv+0x73>
			{
				cprintf("ERROR: Current Replacement is NOT LRU LISTS, invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<BSD_Sched_Nice>]\naborting...\n");
f0103b62:	83 ec 0c             	sub    $0xc,%esp
f0103b65:	68 20 cd 12 f0       	push   $0xf012cd20
f0103b6a:	e8 ed df ff ff       	call   f0101b5c <cprintf>
f0103b6f:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0103b72:	b8 00 00 00 00       	mov    $0x0,%eax
f0103b77:	e9 7b 02 00 00       	jmp    f0103df7 <CreateEnv+0x2ee>
			}
			//percent_WS_pages_to_remove = strtol(arguments[4], NULL, 10);
			if (isSchedMethodBSD())
f0103b7c:	e8 3c 3b 00 00       	call   f01076bd <isSchedMethodBSD>
f0103b81:	85 c0                	test   %eax,%eax
f0103b83:	74 1d                	je     f0103ba2 <CreateEnv+0x99>
				BSDSchedNiceVal = strtol(arguments[4], NULL, 10);
f0103b85:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103b88:	83 c0 10             	add    $0x10,%eax
f0103b8b:	8b 00                	mov    (%eax),%eax
f0103b8d:	83 ec 04             	sub    $0x4,%esp
f0103b90:	6a 0a                	push   $0xa
f0103b92:	6a 00                	push   $0x0
f0103b94:	50                   	push   %eax
f0103b95:	e8 f0 72 01 00       	call   f011ae8a <strtol>
f0103b9a:	83 c4 10             	add    $0x10,%esp
f0103b9d:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0103ba0:	eb 24                	jmp    f0103bc6 <CreateEnv+0xbd>
			else if (isSchedMethodPRIRR())
f0103ba2:	e8 29 3b 00 00       	call   f01076d0 <isSchedMethodPRIRR>
f0103ba7:	85 c0                	test   %eax,%eax
f0103ba9:	74 1b                	je     f0103bc6 <CreateEnv+0xbd>
				PRIRRSchedPriority = strtol(arguments[4], NULL, 10);
f0103bab:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103bae:	83 c0 10             	add    $0x10,%eax
f0103bb1:	8b 00                	mov    (%eax),%eax
f0103bb3:	83 ec 04             	sub    $0x4,%esp
f0103bb6:	6a 0a                	push   $0xa
f0103bb8:	6a 00                	push   $0x0
f0103bba:	50                   	push   %eax
f0103bbb:	e8 ca 72 01 00       	call   f011ae8a <strtol>
f0103bc0:	83 c4 10             	add    $0x10,%esp
f0103bc3:	89 45 e8             	mov    %eax,-0x18(%ebp)

			LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0103bc6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103bc9:	83 c0 0c             	add    $0xc,%eax
f0103bcc:	8b 00                	mov    (%eax),%eax
f0103bce:	83 ec 04             	sub    $0x4,%esp
f0103bd1:	6a 0a                	push   $0xa
f0103bd3:	6a 00                	push   $0x0
f0103bd5:	50                   	push   %eax
f0103bd6:	e8 af 72 01 00       	call   f011ae8a <strtol>
f0103bdb:	83 c4 10             	add    $0x10,%esp
f0103bde:	89 45 f0             	mov    %eax,-0x10(%ebp)
			pageWSSize = strtol(arguments[2], NULL, 10);
f0103be1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103be4:	83 c0 08             	add    $0x8,%eax
f0103be7:	8b 00                	mov    (%eax),%eax
f0103be9:	83 ec 04             	sub    $0x4,%esp
f0103bec:	6a 0a                	push   $0xa
f0103bee:	6a 00                	push   $0x0
f0103bf0:	50                   	push   %eax
f0103bf1:	e8 94 72 01 00       	call   f011ae8a <strtol>
f0103bf6:	83 c4 10             	add    $0x10,%esp
f0103bf9:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0103bfc:	e9 f7 00 00 00       	jmp    f0103cf8 <CreateEnv+0x1ef>
		case 4:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103c01:	83 ec 0c             	sub    $0xc,%esp
f0103c04:	6a 02                	push   $0x2
f0103c06:	e8 18 bc 00 00       	call   f010f823 <isPageReplacmentAlgorithmLRU>
f0103c0b:	83 c4 10             	add    $0x10,%esp
f0103c0e:	85 c0                	test   %eax,%eax
f0103c10:	75 4c                	jne    f0103c5e <CreateEnv+0x155>
			{
				//percent_WS_pages_to_remove = strtol(arguments[3], NULL, 10);
				if (isSchedMethodBSD())
f0103c12:	e8 a6 3a 00 00       	call   f01076bd <isSchedMethodBSD>
f0103c17:	85 c0                	test   %eax,%eax
f0103c19:	74 1d                	je     f0103c38 <CreateEnv+0x12f>
					BSDSchedNiceVal = strtol(arguments[3], NULL, 10);
f0103c1b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103c1e:	83 c0 0c             	add    $0xc,%eax
f0103c21:	8b 00                	mov    (%eax),%eax
f0103c23:	83 ec 04             	sub    $0x4,%esp
f0103c26:	6a 0a                	push   $0xa
f0103c28:	6a 00                	push   $0x0
f0103c2a:	50                   	push   %eax
f0103c2b:	e8 5a 72 01 00       	call   f011ae8a <strtol>
f0103c30:	83 c4 10             	add    $0x10,%esp
f0103c33:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0103c36:	eb 41                	jmp    f0103c79 <CreateEnv+0x170>
				else if (isSchedMethodPRIRR())
f0103c38:	e8 93 3a 00 00       	call   f01076d0 <isSchedMethodPRIRR>
f0103c3d:	85 c0                	test   %eax,%eax
f0103c3f:	74 38                	je     f0103c79 <CreateEnv+0x170>
					PRIRRSchedPriority = strtol(arguments[3], NULL, 10);			}
f0103c41:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103c44:	83 c0 0c             	add    $0xc,%eax
f0103c47:	8b 00                	mov    (%eax),%eax
f0103c49:	83 ec 04             	sub    $0x4,%esp
f0103c4c:	6a 0a                	push   $0xa
f0103c4e:	6a 00                	push   $0x0
f0103c50:	50                   	push   %eax
f0103c51:	e8 34 72 01 00       	call   f011ae8a <strtol>
f0103c56:	83 c4 10             	add    $0x10,%esp
f0103c59:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0103c5c:	eb 1b                	jmp    f0103c79 <CreateEnv+0x170>
			else
			{
				LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0103c5e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103c61:	83 c0 0c             	add    $0xc,%eax
f0103c64:	8b 00                	mov    (%eax),%eax
f0103c66:	83 ec 04             	sub    $0x4,%esp
f0103c69:	6a 0a                	push   $0xa
f0103c6b:	6a 00                	push   $0x0
f0103c6d:	50                   	push   %eax
f0103c6e:	e8 17 72 01 00       	call   f011ae8a <strtol>
f0103c73:	83 c4 10             	add    $0x10,%esp
f0103c76:	89 45 f0             	mov    %eax,-0x10(%ebp)
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f0103c79:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103c7c:	83 c0 08             	add    $0x8,%eax
f0103c7f:	8b 00                	mov    (%eax),%eax
f0103c81:	83 ec 04             	sub    $0x4,%esp
f0103c84:	6a 0a                	push   $0xa
f0103c86:	6a 00                	push   $0x0
f0103c88:	50                   	push   %eax
f0103c89:	e8 fc 71 01 00       	call   f011ae8a <strtol>
f0103c8e:	83 c4 10             	add    $0x10,%esp
f0103c91:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0103c94:	eb 62                	jmp    f0103cf8 <CreateEnv+0x1ef>
		case 3:
			if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103c96:	83 ec 0c             	sub    $0xc,%esp
f0103c99:	6a 02                	push   $0x2
f0103c9b:	e8 83 bb 00 00       	call   f010f823 <isPageReplacmentAlgorithmLRU>
f0103ca0:	83 c4 10             	add    $0x10,%esp
f0103ca3:	85 c0                	test   %eax,%eax
f0103ca5:	74 1a                	je     f0103cc1 <CreateEnv+0x1b8>
			{
				cprintf("ERROR: Current Replacement is LRU LISTS, Please specify a working set size in the 3rd arg and LRU second list size in the 4th arg, aborting.\n");
f0103ca7:	83 ec 0c             	sub    $0xc,%esp
f0103caa:	68 cc cd 12 f0       	push   $0xf012cdcc
f0103caf:	e8 a8 de ff ff       	call   f0101b5c <cprintf>
f0103cb4:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0103cb7:	b8 00 00 00 00       	mov    $0x0,%eax
f0103cbc:	e9 36 01 00 00       	jmp    f0103df7 <CreateEnv+0x2ee>
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f0103cc1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103cc4:	83 c0 08             	add    $0x8,%eax
f0103cc7:	8b 00                	mov    (%eax),%eax
f0103cc9:	83 ec 04             	sub    $0x4,%esp
f0103ccc:	6a 0a                	push   $0xa
f0103cce:	6a 00                	push   $0x0
f0103cd0:	50                   	push   %eax
f0103cd1:	e8 b4 71 01 00       	call   f011ae8a <strtol>
f0103cd6:	83 c4 10             	add    $0x10,%esp
f0103cd9:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0103cdc:	eb 1a                	jmp    f0103cf8 <CreateEnv+0x1ef>
		default:
			cprintf("ERROR: invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<DYN_LOC_SCOPE_percent_WS_to_remove>]\naborting...\n");
f0103cde:	83 ec 0c             	sub    $0xc,%esp
f0103ce1:	68 5c ce 12 f0       	push   $0xf012ce5c
f0103ce6:	e8 71 de ff ff       	call   f0101b5c <cprintf>
f0103ceb:	83 c4 10             	add    $0x10,%esp
			return NULL;
f0103cee:	b8 00 00 00 00       	mov    $0x0,%eax
f0103cf3:	e9 ff 00 00 00       	jmp    f0103df7 <CreateEnv+0x2ee>
		{
			cprintf("ERROR: size of WS must be less than or equal to %d... aborting", __PWS_MAX_SIZE);
			return NULL;
		}
#endif
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103cf8:	83 ec 0c             	sub    $0xc,%esp
f0103cfb:	6a 02                	push   $0x2
f0103cfd:	e8 21 bb 00 00       	call   f010f823 <isPageReplacmentAlgorithmLRU>
f0103d02:	83 c4 10             	add    $0x10,%esp
f0103d05:	85 c0                	test   %eax,%eax
f0103d07:	74 23                	je     f0103d2c <CreateEnv+0x223>
		{
			if (LRUSecondListSize > pageWSSize - 1)
f0103d09:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103d0c:	48                   	dec    %eax
f0103d0d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0103d10:	73 1a                	jae    f0103d2c <CreateEnv+0x223>
			{
				cprintf("ERROR: size of LRU second list can't equal/exceed the size of the page WS... aborting\n");
f0103d12:	83 ec 0c             	sub    $0xc,%esp
f0103d15:	68 f4 ce 12 f0       	push   $0xf012cef4
f0103d1a:	e8 3d de ff ff       	call   f0101b5c <cprintf>
f0103d1f:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0103d22:	b8 00 00 00 00       	mov    $0x0,%eax
f0103d27:	e9 cb 00 00 00       	jmp    f0103df7 <CreateEnv+0x2ee>
			}
		}
		assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f0103d2c:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0103d30:	76 19                	jbe    f0103d4b <CreateEnv+0x242>
f0103d32:	68 4c cf 12 f0       	push   $0xf012cf4c
f0103d37:	68 91 cf 12 f0       	push   $0xf012cf91
f0103d3c:	68 a5 02 00 00       	push   $0x2a5
f0103d41:	68 8d ca 12 f0       	push   $0xf012ca8d
f0103d46:	e8 64 d1 ff ff       	call   f0100eaf <_panic>
		{
			LRUSecondListSize = __LRU_SNDLST_SIZE;
		}
	}
#endif
	assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f0103d4b:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0103d4f:	76 19                	jbe    f0103d6a <CreateEnv+0x261>
f0103d51:	68 4c cf 12 f0       	push   $0xf012cf4c
f0103d56:	68 91 cf 12 f0       	push   $0xf012cf91
f0103d5b:	68 c3 02 00 00       	push   $0x2c3
f0103d60:	68 8d ca 12 f0       	push   $0xf012ca8d
f0103d65:	e8 45 d1 ff ff       	call   f0100eaf <_panic>
	env = env_create(arguments[1], pageWSSize, LRUSecondListSize, percent_WS_pages_to_remove);
f0103d6a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103d6d:	83 c0 04             	add    $0x4,%eax
f0103d70:	8b 00                	mov    (%eax),%eax
f0103d72:	ff 75 e4             	pushl  -0x1c(%ebp)
f0103d75:	ff 75 f0             	pushl  -0x10(%ebp)
f0103d78:	ff 75 f4             	pushl  -0xc(%ebp)
f0103d7b:	50                   	push   %eax
f0103d7c:	e8 e0 70 00 00       	call   f010ae61 <env_create>
f0103d81:	83 c4 10             	add    $0x10,%esp
f0103d84:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (BSDSchedNiceVal != -100)
f0103d87:	83 7d ec 9c          	cmpl   $0xffffff9c,-0x14(%ebp)
f0103d8b:	74 49                	je     f0103dd6 <CreateEnv+0x2cd>
	{
		cprintf("nice value = %d\n", BSDSchedNiceVal);
f0103d8d:	83 ec 08             	sub    $0x8,%esp
f0103d90:	ff 75 ec             	pushl  -0x14(%ebp)
f0103d93:	68 a6 cf 12 f0       	push   $0xf012cfa6
f0103d98:	e8 bf dd ff ff       	call   f0101b5c <cprintf>
f0103d9d:	83 c4 10             	add    $0x10,%esp
		assert(BSDSchedNiceVal >= -20 && BSDSchedNiceVal <= 20);
f0103da0:	83 7d ec ec          	cmpl   $0xffffffec,-0x14(%ebp)
f0103da4:	7c 06                	jl     f0103dac <CreateEnv+0x2a3>
f0103da6:	83 7d ec 14          	cmpl   $0x14,-0x14(%ebp)
f0103daa:	7e 19                	jle    f0103dc5 <CreateEnv+0x2bc>
f0103dac:	68 b8 cf 12 f0       	push   $0xf012cfb8
f0103db1:	68 91 cf 12 f0       	push   $0xf012cf91
f0103db6:	68 c8 02 00 00       	push   $0x2c8
f0103dbb:	68 8d ca 12 f0       	push   $0xf012ca8d
f0103dc0:	e8 ea d0 ff ff       	call   f0100eaf <_panic>
		env_set_nice(env, BSDSchedNiceVal);
f0103dc5:	83 ec 08             	sub    $0x8,%esp
f0103dc8:	ff 75 ec             	pushl  -0x14(%ebp)
f0103dcb:	ff 75 e0             	pushl  -0x20(%ebp)
f0103dce:	e8 34 38 00 00       	call   f0107607 <env_set_nice>
f0103dd3:	83 c4 10             	add    $0x10,%esp
	}
	if (isSchedMethodPRIRR())
f0103dd6:	e8 f5 38 00 00       	call   f01076d0 <isSchedMethodPRIRR>
f0103ddb:	85 c0                	test   %eax,%eax
f0103ddd:	74 15                	je     f0103df4 <CreateEnv+0x2eb>
		env_set_priority(env->env_id, PRIRRSchedPriority);
f0103ddf:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0103de2:	8b 40 10             	mov    0x10(%eax),%eax
f0103de5:	83 ec 08             	sub    $0x8,%esp
f0103de8:	ff 75 e8             	pushl  -0x18(%ebp)
f0103deb:	50                   	push   %eax
f0103dec:	e8 6d 38 00 00       	call   f010765e <env_set_priority>
f0103df1:	83 c4 10             	add    $0x10,%esp

	return env;
f0103df4:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f0103df7:	c9                   	leave  
f0103df8:	c3                   	ret    

f0103df9 <command_run_program>:

int command_run_program(int number_of_arguments, char **arguments)
{
f0103df9:	55                   	push   %ebp
f0103dfa:	89 e5                	mov    %esp,%ebp
f0103dfc:	83 ec 18             	sub    $0x18,%esp
	//[1] Create and initialize a new environment for the program to be run
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f0103dff:	83 ec 08             	sub    $0x8,%esp
f0103e02:	ff 75 0c             	pushl  0xc(%ebp)
f0103e05:	ff 75 08             	pushl  0x8(%ebp)
f0103e08:	e8 fc fc ff ff       	call   f0103b09 <CreateEnv>
f0103e0d:	83 c4 10             	add    $0x10,%esp
f0103e10:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(env == NULL) return 0;
f0103e13:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0103e17:	75 07                	jne    f0103e20 <command_run_program+0x27>
f0103e19:	b8 00 00 00 00       	mov    $0x0,%eax
f0103e1e:	eb 46                	jmp    f0103e66 <command_run_program+0x6d>
	cprintf("\nEnvironment Id= %d\n",env->env_id);
f0103e20:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103e23:	8b 40 10             	mov    0x10(%eax),%eax
f0103e26:	83 ec 08             	sub    $0x8,%esp
f0103e29:	50                   	push   %eax
f0103e2a:	68 e8 cf 12 f0       	push   $0xf012cfe8
f0103e2f:	e8 28 dd ff ff       	call   f0101b5c <cprintf>
f0103e34:	83 c4 10             	add    $0x10,%esp

	//[2] Place it in the NEW queue
	sched_new_env(env);
f0103e37:	83 ec 0c             	sub    $0xc,%esp
f0103e3a:	ff 75 f4             	pushl  -0xc(%ebp)
f0103e3d:	e8 47 28 00 00       	call   f0106689 <sched_new_env>
f0103e42:	83 c4 10             	add    $0x10,%esp

	numOfKheapVACalls = 0;
f0103e45:	c7 05 30 6c 85 f0 00 	movl   $0x0,0xf0856c30
f0103e4c:	00 00 00 

	//[3] Run the created environment by adding it to the "ready" queue then invoke the scheduler to execute it
	sched_run_env(env->env_id);
f0103e4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103e52:	8b 40 10             	mov    0x10(%eax),%eax
f0103e55:	83 ec 0c             	sub    $0xc,%esp
f0103e58:	50                   	push   %eax
f0103e59:	e8 81 28 00 00       	call   f01066df <sched_run_env>
f0103e5e:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103e61:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103e66:	c9                   	leave  
f0103e67:	c3                   	ret    

f0103e68 <command_kill_program>:

int command_kill_program(int number_of_arguments, char **arguments)
{
f0103e68:	55                   	push   %ebp
f0103e69:	89 e5                	mov    %esp,%ebp
f0103e6b:	83 ec 18             	sub    $0x18,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0103e6e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103e71:	83 c0 04             	add    $0x4,%eax
f0103e74:	8b 00                	mov    (%eax),%eax
f0103e76:	83 ec 04             	sub    $0x4,%esp
f0103e79:	6a 0a                	push   $0xa
f0103e7b:	6a 00                	push   $0x0
f0103e7d:	50                   	push   %eax
f0103e7e:	e8 07 70 01 00       	call   f011ae8a <strtol>
f0103e83:	83 c4 10             	add    $0x10,%esp
f0103e86:	89 45 f4             	mov    %eax,-0xc(%ebp)

	sched_kill_env(envId);
f0103e89:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103e8c:	83 ec 0c             	sub    $0xc,%esp
f0103e8f:	50                   	push   %eax
f0103e90:	e8 90 2b 00 00       	call   f0106a25 <sched_kill_env>
f0103e95:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103e98:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103e9d:	c9                   	leave  
f0103e9e:	c3                   	ret    

f0103e9f <commnad_load_env>:

int commnad_load_env(int number_of_arguments, char **arguments)
{
f0103e9f:	55                   	push   %ebp
f0103ea0:	89 e5                	mov    %esp,%ebp
f0103ea2:	83 ec 18             	sub    $0x18,%esp
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f0103ea5:	83 ec 08             	sub    $0x8,%esp
f0103ea8:	ff 75 0c             	pushl  0xc(%ebp)
f0103eab:	ff 75 08             	pushl  0x8(%ebp)
f0103eae:	e8 56 fc ff ff       	call   f0103b09 <CreateEnv>
f0103eb3:	83 c4 10             	add    $0x10,%esp
f0103eb6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (env == NULL)
f0103eb9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0103ebd:	75 07                	jne    f0103ec6 <commnad_load_env+0x27>
		return 0 ;
f0103ebf:	b8 00 00 00 00       	mov    $0x0,%eax
f0103ec4:	eb 2a                	jmp    f0103ef0 <commnad_load_env+0x51>

	sched_new_env(env) ;
f0103ec6:	83 ec 0c             	sub    $0xc,%esp
f0103ec9:	ff 75 f4             	pushl  -0xc(%ebp)
f0103ecc:	e8 b8 27 00 00       	call   f0106689 <sched_new_env>
f0103ed1:	83 c4 10             	add    $0x10,%esp

	cprintf("\nEnvironment Id= %d\n",env->env_id);
f0103ed4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103ed7:	8b 40 10             	mov    0x10(%eax),%eax
f0103eda:	83 ec 08             	sub    $0x8,%esp
f0103edd:	50                   	push   %eax
f0103ede:	68 e8 cf 12 f0       	push   $0xf012cfe8
f0103ee3:	e8 74 dc ff ff       	call   f0101b5c <cprintf>
f0103ee8:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103eeb:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103ef0:	c9                   	leave  
f0103ef1:	c3                   	ret    

f0103ef2 <command_run_all>:

int command_run_all(int number_of_arguments, char **arguments)
{
f0103ef2:	55                   	push   %ebp
f0103ef3:	89 e5                	mov    %esp,%ebp
f0103ef5:	83 ec 08             	sub    $0x8,%esp
	numOfKheapVACalls = 0;
f0103ef8:	c7 05 30 6c 85 f0 00 	movl   $0x0,0xf0856c30
f0103eff:	00 00 00 
	sched_run_all();
f0103f02:	e8 ef 30 00 00       	call   f0106ff6 <sched_run_all>

	return 0 ;
f0103f07:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103f0c:	c9                   	leave  
f0103f0d:	c3                   	ret    

f0103f0e <command_print_all>:

int command_print_all(int number_of_arguments, char **arguments)
{
f0103f0e:	55                   	push   %ebp
f0103f0f:	89 e5                	mov    %esp,%ebp
f0103f11:	83 ec 08             	sub    $0x8,%esp
	sched_print_all();
f0103f14:	e8 bc 2e 00 00       	call   f0106dd5 <sched_print_all>

	return 0 ;
f0103f19:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103f1e:	c9                   	leave  
f0103f1f:	c3                   	ret    

f0103f20 <command_kill_all>:

int command_kill_all(int number_of_arguments, char **arguments)
{
f0103f20:	55                   	push   %ebp
f0103f21:	89 e5                	mov    %esp,%ebp
f0103f23:	83 ec 08             	sub    $0x8,%esp
	sched_kill_all();
f0103f26:	e8 60 31 00 00       	call   f010708b <sched_kill_all>

	return 0 ;
f0103f2b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103f30:	c9                   	leave  
f0103f31:	c3                   	ret    

f0103f32 <command_set_page_rep_LRU>:

int command_set_page_rep_LRU(int number_of_arguments, char **arguments)
{
f0103f32:	55                   	push   %ebp
f0103f33:	89 e5                	mov    %esp,%ebp
f0103f35:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments < 2)
f0103f38:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0103f3c:	7f 1a                	jg     f0103f58 <command_set_page_rep_LRU+0x26>
	{
		cprintf("ERROR: please specify the LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0103f3e:	83 ec 0c             	sub    $0xc,%esp
f0103f41:	68 00 d0 12 f0       	push   $0xf012d000
f0103f46:	e8 11 dc ff ff       	call   f0101b5c <cprintf>
f0103f4b:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103f4e:	b8 00 00 00 00       	mov    $0x0,%eax
f0103f53:	e9 83 00 00 00       	jmp    f0103fdb <command_set_page_rep_LRU+0xa9>
	}
	int LRU_TYPE = strtol(arguments[1], NULL, 10) ;
f0103f58:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103f5b:	83 c0 04             	add    $0x4,%eax
f0103f5e:	8b 00                	mov    (%eax),%eax
f0103f60:	83 ec 04             	sub    $0x4,%esp
f0103f63:	6a 0a                	push   $0xa
f0103f65:	6a 00                	push   $0x0
f0103f67:	50                   	push   %eax
f0103f68:	e8 1d 6f 01 00       	call   f011ae8a <strtol>
f0103f6d:	83 c4 10             	add    $0x10,%esp
f0103f70:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (LRU_TYPE == PG_REP_LRU_TIME_APPROX)
f0103f73:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0103f77:	75 20                	jne    f0103f99 <command_set_page_rep_LRU+0x67>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f0103f79:	83 ec 0c             	sub    $0xc,%esp
f0103f7c:	ff 75 f4             	pushl  -0xc(%ebp)
f0103f7f:	e8 f6 b7 00 00       	call   f010f77a <setPageReplacmentAlgorithmLRU>
f0103f84:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with TimeStamp approximation\n");
f0103f87:	83 ec 0c             	sub    $0xc,%esp
f0103f8a:	68 60 d0 12 f0       	push   $0xf012d060
f0103f8f:	e8 c8 db ff ff       	call   f0101b5c <cprintf>
f0103f94:	83 c4 10             	add    $0x10,%esp
f0103f97:	eb 3d                	jmp    f0103fd6 <command_set_page_rep_LRU+0xa4>
	}
	else if (LRU_TYPE == PG_REP_LRU_LISTS_APPROX)
f0103f99:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0103f9d:	75 20                	jne    f0103fbf <command_set_page_rep_LRU+0x8d>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f0103f9f:	83 ec 0c             	sub    $0xc,%esp
f0103fa2:	ff 75 f4             	pushl  -0xc(%ebp)
f0103fa5:	e8 d0 b7 00 00       	call   f010f77a <setPageReplacmentAlgorithmLRU>
f0103faa:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with LISTS approximation\n");
f0103fad:	83 ec 0c             	sub    $0xc,%esp
f0103fb0:	68 a4 d0 12 f0       	push   $0xf012d0a4
f0103fb5:	e8 a2 db ff ff       	call   f0101b5c <cprintf>
f0103fba:	83 c4 10             	add    $0x10,%esp
f0103fbd:	eb 17                	jmp    f0103fd6 <command_set_page_rep_LRU+0xa4>
	}
	else
	{
		cprintf("ERROR: Invalid LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0103fbf:	83 ec 0c             	sub    $0xc,%esp
f0103fc2:	68 e4 d0 12 f0       	push   $0xf012d0e4
f0103fc7:	e8 90 db ff ff       	call   f0101b5c <cprintf>
f0103fcc:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103fcf:	b8 00 00 00 00       	mov    $0x0,%eax
f0103fd4:	eb 05                	jmp    f0103fdb <command_set_page_rep_LRU+0xa9>
	}
	return 0;
f0103fd6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103fdb:	c9                   	leave  
f0103fdc:	c3                   	ret    

f0103fdd <command_set_page_rep_nthCLOCK>:
//2021
int command_set_page_rep_nthCLOCK(int number_of_arguments, char **arguments)
{
f0103fdd:	55                   	push   %ebp
f0103fde:	89 e5                	mov    %esp,%ebp
f0103fe0:	83 ec 18             	sub    $0x18,%esp
	uint32 PageWSMaxSweeps = strtol(arguments[1], NULL, 10);
f0103fe3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103fe6:	83 c0 04             	add    $0x4,%eax
f0103fe9:	8b 00                	mov    (%eax),%eax
f0103feb:	83 ec 04             	sub    $0x4,%esp
f0103fee:	6a 0a                	push   $0xa
f0103ff0:	6a 00                	push   $0x0
f0103ff2:	50                   	push   %eax
f0103ff3:	e8 92 6e 01 00       	call   f011ae8a <strtol>
f0103ff8:	83 c4 10             	add    $0x10,%esp
f0103ffb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint8 type = strtol(arguments[2], NULL, 10);
f0103ffe:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104001:	83 c0 08             	add    $0x8,%eax
f0104004:	8b 00                	mov    (%eax),%eax
f0104006:	83 ec 04             	sub    $0x4,%esp
f0104009:	6a 0a                	push   $0xa
f010400b:	6a 00                	push   $0x0
f010400d:	50                   	push   %eax
f010400e:	e8 77 6e 01 00       	call   f011ae8a <strtol>
f0104013:	83 c4 10             	add    $0x10,%esp
f0104016:	88 45 f3             	mov    %al,-0xd(%ebp)
	if (PageWSMaxSweeps <= 0)
f0104019:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010401d:	75 17                	jne    f0104036 <command_set_page_rep_nthCLOCK+0x59>
	{
		cprintf("Invalid number of sweeps! it should be +ve.\n");
f010401f:	83 ec 0c             	sub    $0xc,%esp
f0104022:	68 38 d1 12 f0       	push   $0xf012d138
f0104027:	e8 30 db ff ff       	call   f0101b5c <cprintf>
f010402c:	83 c4 10             	add    $0x10,%esp
		return 0;
f010402f:	b8 00 00 00 00       	mov    $0x0,%eax
f0104034:	eb 4b                	jmp    f0104081 <command_set_page_rep_nthCLOCK+0xa4>
	}
	if (type == 1)		PageWSMaxSweeps = PageWSMaxSweeps * 1;
f0104036:	80 7d f3 01          	cmpb   $0x1,-0xd(%ebp)
f010403a:	74 22                	je     f010405e <command_set_page_rep_nthCLOCK+0x81>
	else if (type == 2)	PageWSMaxSweeps = PageWSMaxSweeps * -1;
f010403c:	80 7d f3 02          	cmpb   $0x2,-0xd(%ebp)
f0104040:	75 05                	jne    f0104047 <command_set_page_rep_nthCLOCK+0x6a>
f0104042:	f7 5d f4             	negl   -0xc(%ebp)
f0104045:	eb 17                	jmp    f010405e <command_set_page_rep_nthCLOCK+0x81>
	else
	{
		cprintf("Invalid type!\n	type=1: NORMAL Ver. type=2: MODIFIED Ver.\n");
f0104047:	83 ec 0c             	sub    $0xc,%esp
f010404a:	68 68 d1 12 f0       	push   $0xf012d168
f010404f:	e8 08 db ff ff       	call   f0101b5c <cprintf>
f0104054:	83 c4 10             	add    $0x10,%esp
		return 0;
f0104057:	b8 00 00 00 00       	mov    $0x0,%eax
f010405c:	eb 23                	jmp    f0104081 <command_set_page_rep_nthCLOCK+0xa4>
	}
	setPageReplacmentAlgorithmNchanceCLOCK(PageWSMaxSweeps);
f010405e:	83 ec 0c             	sub    $0xc,%esp
f0104061:	ff 75 f4             	pushl  -0xc(%ebp)
f0104064:	e8 84 b7 00 00       	call   f010f7ed <setPageReplacmentAlgorithmNchanceCLOCK>
f0104069:	83 c4 10             	add    $0x10,%esp
	cprintf("Page replacement algorithm is now N chance CLOCK\n");
f010406c:	83 ec 0c             	sub    $0xc,%esp
f010406f:	68 a4 d1 12 f0       	push   $0xf012d1a4
f0104074:	e8 e3 da ff ff       	call   f0101b5c <cprintf>
f0104079:	83 c4 10             	add    $0x10,%esp
	return 0;
f010407c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104081:	c9                   	leave  
f0104082:	c3                   	ret    

f0104083 <command_set_page_rep_CLOCK>:
int command_set_page_rep_CLOCK(int number_of_arguments, char **arguments)
{
f0104083:	55                   	push   %ebp
f0104084:	89 e5                	mov    %esp,%ebp
f0104086:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmCLOCK();
f0104089:	e8 1f b7 00 00       	call   f010f7ad <setPageReplacmentAlgorithmCLOCK>
	cprintf("Page replacement algorithm is now CLOCK\n");
f010408e:	83 ec 0c             	sub    $0xc,%esp
f0104091:	68 d8 d1 12 f0       	push   $0xf012d1d8
f0104096:	e8 c1 da ff ff       	call   f0101b5c <cprintf>
f010409b:	83 c4 10             	add    $0x10,%esp
	return 0;
f010409e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01040a3:	c9                   	leave  
f01040a4:	c3                   	ret    

f01040a5 <command_set_page_rep_FIFO>:

int command_set_page_rep_FIFO(int number_of_arguments, char **arguments)
{
f01040a5:	55                   	push   %ebp
f01040a6:	89 e5                	mov    %esp,%ebp
f01040a8:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmFIFO();
f01040ab:	e8 0d b7 00 00       	call   f010f7bd <setPageReplacmentAlgorithmFIFO>
	cprintf("Page replacement algorithm is now FIFO\n");
f01040b0:	83 ec 0c             	sub    $0xc,%esp
f01040b3:	68 04 d2 12 f0       	push   $0xf012d204
f01040b8:	e8 9f da ff ff       	call   f0101b5c <cprintf>
f01040bd:	83 c4 10             	add    $0x10,%esp
	return 0;
f01040c0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01040c5:	c9                   	leave  
f01040c6:	c3                   	ret    

f01040c7 <command_set_page_rep_ModifiedCLOCK>:

int command_set_page_rep_ModifiedCLOCK(int number_of_arguments, char **arguments)
{
f01040c7:	55                   	push   %ebp
f01040c8:	89 e5                	mov    %esp,%ebp
f01040ca:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmModifiedCLOCK();
f01040cd:	e8 fb b6 00 00       	call   f010f7cd <setPageReplacmentAlgorithmModifiedCLOCK>
	cprintf("Page replacement algorithm is now Modified CLOCK\n");
f01040d2:	83 ec 0c             	sub    $0xc,%esp
f01040d5:	68 2c d2 12 f0       	push   $0xf012d22c
f01040da:	e8 7d da ff ff       	call   f0101b5c <cprintf>
f01040df:	83 c4 10             	add    $0x10,%esp
	return 0;
f01040e2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01040e7:	c9                   	leave  
f01040e8:	c3                   	ret    

f01040e9 <command_set_page_rep_OPTIMAL>:

int command_set_page_rep_OPTIMAL(int number_of_arguments, char **arguments)
{
f01040e9:	55                   	push   %ebp
f01040ea:	89 e5                	mov    %esp,%ebp
f01040ec:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmOPTIMAL();
f01040ef:	e8 1f b7 00 00       	call   f010f813 <setPageReplacmentAlgorithmOPTIMAL>
	cprintf("Page replacement algorithm is now OPTIMAL\n");
f01040f4:	83 ec 0c             	sub    $0xc,%esp
f01040f7:	68 60 d2 12 f0       	push   $0xf012d260
f01040fc:	e8 5b da ff ff       	call   f0101b5c <cprintf>
f0104101:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104104:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104109:	c9                   	leave  
f010410a:	c3                   	ret    

f010410b <command_sch_RR>:

/*2018*///BEGIN======================================================
int command_sch_RR(int number_of_arguments, char **arguments)
{
f010410b:	55                   	push   %ebp
f010410c:	89 e5                	mov    %esp,%ebp
f010410e:	83 ec 18             	sub    $0x18,%esp
	uint8 quantum = strtol(arguments[1], NULL, 10);
f0104111:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104114:	83 c0 04             	add    $0x4,%eax
f0104117:	8b 00                	mov    (%eax),%eax
f0104119:	83 ec 04             	sub    $0x4,%esp
f010411c:	6a 0a                	push   $0xa
f010411e:	6a 00                	push   $0x0
f0104120:	50                   	push   %eax
f0104121:	e8 64 6d 01 00       	call   f011ae8a <strtol>
f0104126:	83 c4 10             	add    $0x10,%esp
f0104129:	88 45 f7             	mov    %al,-0x9(%ebp)

	sched_init_RR(quantum);
f010412c:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0104130:	83 ec 0c             	sub    $0xc,%esp
f0104133:	50                   	push   %eax
f0104134:	e8 09 38 00 00       	call   f0107942 <sched_init_RR>
f0104139:	83 c4 10             	add    $0x10,%esp
	cprintf("Scheduler is now set to Round Robin with quantum %d ms\n", quantums[0]);
f010413c:	a1 e4 6a 85 f0       	mov    0xf0856ae4,%eax
f0104141:	8a 00                	mov    (%eax),%al
f0104143:	0f b6 c0             	movzbl %al,%eax
f0104146:	83 ec 08             	sub    $0x8,%esp
f0104149:	50                   	push   %eax
f010414a:	68 8c d2 12 f0       	push   $0xf012d28c
f010414f:	e8 08 da ff ff       	call   f0101b5c <cprintf>
f0104154:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104157:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010415c:	c9                   	leave  
f010415d:	c3                   	ret    

f010415e <command_sch_MLFQ>:
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
f010415e:	55                   	push   %ebp
f010415f:	89 e5                	mov    %esp,%ebp
f0104161:	53                   	push   %ebx
f0104162:	83 ec 24             	sub    $0x24,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f0104165:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104168:	83 c0 04             	add    $0x4,%eax
f010416b:	8b 00                	mov    (%eax),%eax
f010416d:	83 ec 04             	sub    $0x4,%esp
f0104170:	6a 0a                	push   $0xa
f0104172:	6a 00                	push   $0x0
f0104174:	50                   	push   %eax
f0104175:	e8 10 6d 01 00       	call   f011ae8a <strtol>
f010417a:	83 c4 10             	add    $0x10,%esp
f010417d:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f0104180:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0104187:	eb 2e                	jmp    f01041b7 <command_sch_MLFQ+0x59>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
f0104189:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010418c:	8d 58 fe             	lea    -0x2(%eax),%ebx
f010418f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104192:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104199:	8b 45 0c             	mov    0xc(%ebp),%eax
f010419c:	01 d0                	add    %edx,%eax
f010419e:	8b 00                	mov    (%eax),%eax
f01041a0:	83 ec 04             	sub    $0x4,%esp
f01041a3:	6a 0a                	push   $0xa
f01041a5:	6a 00                	push   $0x0
f01041a7:	50                   	push   %eax
f01041a8:	e8 dd 6c 01 00       	call   f011ae8a <strtol>
f01041ad:	83 c4 10             	add    $0x10,%esp
f01041b0:	88 44 1d e1          	mov    %al,-0x1f(%ebp,%ebx,1)
}
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f01041b4:	ff 45 f4             	incl   -0xc(%ebp)
f01041b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01041ba:	3b 45 08             	cmp    0x8(%ebp),%eax
f01041bd:	7c ca                	jl     f0104189 <command_sch_MLFQ+0x2b>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);
f01041bf:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f01041c3:	83 ec 08             	sub    $0x8,%esp
f01041c6:	8d 55 e1             	lea    -0x1f(%ebp),%edx
f01041c9:	52                   	push   %edx
f01041ca:	50                   	push   %eax
f01041cb:	e8 20 38 00 00       	call   f01079f0 <sched_init_MLFQ>
f01041d0:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to MLFQ with quantums: ");
f01041d3:	83 ec 0c             	sub    $0xc,%esp
f01041d6:	68 c4 d2 12 f0       	push   $0xf012d2c4
f01041db:	e8 7c d9 ff ff       	call   f0101b5c <cprintf>
f01041e0:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues; i++)
f01041e3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01041ea:	eb 24                	jmp    f0104210 <command_sch_MLFQ+0xb2>
	{
		cprintf("%d   ", quantums[i]) ;
f01041ec:	8b 15 e4 6a 85 f0    	mov    0xf0856ae4,%edx
f01041f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01041f5:	01 d0                	add    %edx,%eax
f01041f7:	8a 00                	mov    (%eax),%al
f01041f9:	0f b6 c0             	movzbl %al,%eax
f01041fc:	83 ec 08             	sub    $0x8,%esp
f01041ff:	50                   	push   %eax
f0104200:	68 f1 d2 12 f0       	push   $0xf012d2f1
f0104205:	e8 52 d9 ff ff       	call   f0101b5c <cprintf>
f010420a:	83 c4 10             	add    $0x10,%esp
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);

	cprintf("Scheduler is now set to MLFQ with quantums: ");
	for (int i = 0 ; i < num_of_ready_queues; i++)
f010420d:	ff 45 f0             	incl   -0x10(%ebp)
f0104210:	a0 60 6d 85 f0       	mov    0xf0856d60,%al
f0104215:	0f b6 c0             	movzbl %al,%eax
f0104218:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010421b:	7f cf                	jg     f01041ec <command_sch_MLFQ+0x8e>
	{
		cprintf("%d   ", quantums[i]) ;
	}
	cprintf("\n");
f010421d:	83 ec 0c             	sub    $0xc,%esp
f0104220:	68 f7 d2 12 f0       	push   $0xf012d2f7
f0104225:	e8 32 d9 ff ff       	call   f0101b5c <cprintf>
f010422a:	83 c4 10             	add    $0x10,%esp
	return 0;
f010422d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104232:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104235:	c9                   	leave  
f0104236:	c3                   	ret    

f0104237 <command_sch_BSD>:
int command_sch_BSD(int number_of_arguments, char **arguments)
{
f0104237:	55                   	push   %ebp
f0104238:	89 e5                	mov    %esp,%ebp
f010423a:	83 ec 18             	sub    $0x18,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f010423d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104240:	83 c0 04             	add    $0x4,%eax
f0104243:	8b 00                	mov    (%eax),%eax
f0104245:	83 ec 04             	sub    $0x4,%esp
f0104248:	6a 0a                	push   $0xa
f010424a:	6a 00                	push   $0x0
f010424c:	50                   	push   %eax
f010424d:	e8 38 6c 01 00       	call   f011ae8a <strtol>
f0104252:	83 c4 10             	add    $0x10,%esp
f0104255:	88 45 f7             	mov    %al,-0x9(%ebp)
	uint8 quantum = strtol(arguments[2], NULL, 10);
f0104258:	8b 45 0c             	mov    0xc(%ebp),%eax
f010425b:	83 c0 08             	add    $0x8,%eax
f010425e:	8b 00                	mov    (%eax),%eax
f0104260:	83 ec 04             	sub    $0x4,%esp
f0104263:	6a 0a                	push   $0xa
f0104265:	6a 00                	push   $0x0
f0104267:	50                   	push   %eax
f0104268:	e8 1d 6c 01 00       	call   f011ae8a <strtol>
f010426d:	83 c4 10             	add    $0x10,%esp
f0104270:	88 45 f6             	mov    %al,-0xa(%ebp)

	sched_init_BSD(numOfLevels, quantum);
f0104273:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f0104277:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f010427b:	83 ec 08             	sub    $0x8,%esp
f010427e:	52                   	push   %edx
f010427f:	50                   	push   %eax
f0104280:	e8 8e 37 00 00       	call   f0107a13 <sched_init_BSD>
f0104285:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", numOfLevels, quantum);
f0104288:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f010428c:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0104290:	83 ec 04             	sub    $0x4,%esp
f0104293:	52                   	push   %edx
f0104294:	50                   	push   %eax
f0104295:	68 fc d2 12 f0       	push   $0xf012d2fc
f010429a:	e8 bd d8 ff ff       	call   f0101b5c <cprintf>
f010429f:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f01042a2:	83 ec 0c             	sub    $0xc,%esp
f01042a5:	68 f7 d2 12 f0       	push   $0xf012d2f7
f01042aa:	e8 ad d8 ff ff       	call   f0101b5c <cprintf>
f01042af:	83 c4 10             	add    $0x10,%esp
	return 0;
f01042b2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01042b7:	c9                   	leave  
f01042b8:	c3                   	ret    

f01042b9 <command_sch_PRIRR>:

int command_sch_PRIRR(int number_of_arguments, char **arguments)
{
f01042b9:	55                   	push   %ebp
f01042ba:	89 e5                	mov    %esp,%ebp
f01042bc:	83 ec 18             	sub    $0x18,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f01042bf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01042c2:	83 c0 04             	add    $0x4,%eax
f01042c5:	8b 00                	mov    (%eax),%eax
f01042c7:	83 ec 04             	sub    $0x4,%esp
f01042ca:	6a 0a                	push   $0xa
f01042cc:	6a 00                	push   $0x0
f01042ce:	50                   	push   %eax
f01042cf:	e8 b6 6b 01 00       	call   f011ae8a <strtol>
f01042d4:	83 c4 10             	add    $0x10,%esp
f01042d7:	88 45 f7             	mov    %al,-0x9(%ebp)
	uint8 quantum = strtol(arguments[2], NULL, 10);
f01042da:	8b 45 0c             	mov    0xc(%ebp),%eax
f01042dd:	83 c0 08             	add    $0x8,%eax
f01042e0:	8b 00                	mov    (%eax),%eax
f01042e2:	83 ec 04             	sub    $0x4,%esp
f01042e5:	6a 0a                	push   $0xa
f01042e7:	6a 00                	push   $0x0
f01042e9:	50                   	push   %eax
f01042ea:	e8 9b 6b 01 00       	call   f011ae8a <strtol>
f01042ef:	83 c4 10             	add    $0x10,%esp
f01042f2:	88 45 f6             	mov    %al,-0xa(%ebp)
	uint32 starvThresh = strtol(arguments[3], NULL, 10);
f01042f5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01042f8:	83 c0 0c             	add    $0xc,%eax
f01042fb:	8b 00                	mov    (%eax),%eax
f01042fd:	83 ec 04             	sub    $0x4,%esp
f0104300:	6a 0a                	push   $0xa
f0104302:	6a 00                	push   $0x0
f0104304:	50                   	push   %eax
f0104305:	e8 80 6b 01 00       	call   f011ae8a <strtol>
f010430a:	83 c4 10             	add    $0x10,%esp
f010430d:	89 45 f0             	mov    %eax,-0x10(%ebp)

	sched_init_PRIRR(numOfLevels, quantum, starvThresh);
f0104310:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f0104314:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0104318:	83 ec 04             	sub    $0x4,%esp
f010431b:	ff 75 f0             	pushl  -0x10(%ebp)
f010431e:	52                   	push   %edx
f010431f:	50                   	push   %eax
f0104320:	e8 17 37 00 00       	call   f0107a3c <sched_init_PRIRR>
f0104325:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to PRIORITY RR with %d priorities, quantum = %d and starvation thresh %d\n", numOfLevels, quantum, starvThresh);
f0104328:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f010432c:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0104330:	ff 75 f0             	pushl  -0x10(%ebp)
f0104333:	52                   	push   %edx
f0104334:	50                   	push   %eax
f0104335:	68 38 d3 12 f0       	push   $0xf012d338
f010433a:	e8 1d d8 ff ff       	call   f0101b5c <cprintf>
f010433f:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0104342:	83 ec 0c             	sub    $0xc,%esp
f0104345:	68 f7 d2 12 f0       	push   $0xf012d2f7
f010434a:	e8 0d d8 ff ff       	call   f0101b5c <cprintf>
f010434f:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104352:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104357:	c9                   	leave  
f0104358:	c3                   	ret    

f0104359 <command_set_starve_thresh>:
int command_set_starve_thresh(int number_of_arguments, char **arguments)
{
f0104359:	55                   	push   %ebp
f010435a:	89 e5                	mov    %esp,%ebp
f010435c:	83 ec 18             	sub    $0x18,%esp
	uint32 starvationThresh = strtol(arguments[1], NULL, 10);
f010435f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104362:	83 c0 04             	add    $0x4,%eax
f0104365:	8b 00                	mov    (%eax),%eax
f0104367:	83 ec 04             	sub    $0x4,%esp
f010436a:	6a 0a                	push   $0xa
f010436c:	6a 00                	push   $0x0
f010436e:	50                   	push   %eax
f010436f:	e8 16 6b 01 00       	call   f011ae8a <strtol>
f0104374:	83 c4 10             	add    $0x10,%esp
f0104377:	89 45 f4             	mov    %eax,-0xc(%ebp)
	sched_set_starv_thresh(starvationThresh);
f010437a:	83 ec 0c             	sub    $0xc,%esp
f010437d:	ff 75 f4             	pushl  -0xc(%ebp)
f0104380:	e8 f6 32 00 00       	call   f010767b <sched_set_starv_thresh>
f0104385:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104388:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010438d:	c9                   	leave  
f010438e:	c3                   	ret    

f010438f <command_set_priority>:
//*********************************************************************************//

int command_set_priority(int number_of_arguments, char **arguments)
{
f010438f:	55                   	push   %ebp
f0104390:	89 e5                	mov    %esp,%ebp
f0104392:	83 ec 18             	sub    $0x18,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0104395:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104398:	83 c0 04             	add    $0x4,%eax
f010439b:	8b 00                	mov    (%eax),%eax
f010439d:	83 ec 04             	sub    $0x4,%esp
f01043a0:	6a 0a                	push   $0xa
f01043a2:	6a 00                	push   $0x0
f01043a4:	50                   	push   %eax
f01043a5:	e8 e0 6a 01 00       	call   f011ae8a <strtol>
f01043aa:	83 c4 10             	add    $0x10,%esp
f01043ad:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int32 priority = strtol(arguments[2],NULL, 10);
f01043b0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01043b3:	83 c0 08             	add    $0x8,%eax
f01043b6:	8b 00                	mov    (%eax),%eax
f01043b8:	83 ec 04             	sub    $0x4,%esp
f01043bb:	6a 0a                	push   $0xa
f01043bd:	6a 00                	push   $0x0
f01043bf:	50                   	push   %eax
f01043c0:	e8 c5 6a 01 00       	call   f011ae8a <strtol>
f01043c5:	83 c4 10             	add    $0x10,%esp
f01043c8:	89 45 f0             	mov    %eax,-0x10(%ebp)

	env_set_priority(envId, priority);
f01043cb:	83 ec 08             	sub    $0x8,%esp
f01043ce:	ff 75 f0             	pushl  -0x10(%ebp)
f01043d1:	ff 75 f4             	pushl  -0xc(%ebp)
f01043d4:	e8 85 32 00 00       	call   f010765e <env_set_priority>
f01043d9:	83 c4 10             	add    $0x10,%esp

	return 0;
f01043dc:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01043e1:	c9                   	leave  
f01043e2:	c3                   	ret    

f01043e3 <command_print_sch_method>:
int command_print_sch_method(int number_of_arguments, char **arguments)
{
f01043e3:	55                   	push   %ebp
f01043e4:	89 e5                	mov    %esp,%ebp
f01043e6:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodMLFQ())
f01043e9:	e8 bc 32 00 00       	call   f01076aa <isSchedMethodMLFQ>
f01043ee:	85 c0                	test   %eax,%eax
f01043f0:	74 5f                	je     f0104451 <command_print_sch_method+0x6e>
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
f01043f2:	83 ec 0c             	sub    $0xc,%esp
f01043f5:	68 98 d3 12 f0       	push   $0xf012d398
f01043fa:	e8 5d d7 ff ff       	call   f0101b5c <cprintf>
f01043ff:	83 c4 10             	add    $0x10,%esp
		for (int i = 0 ; i < num_of_ready_queues; i++)
f0104402:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104409:	eb 24                	jmp    f010442f <command_print_sch_method+0x4c>
		{
			cprintf("%d   ", quantums[i]) ;
f010440b:	8b 15 e4 6a 85 f0    	mov    0xf0856ae4,%edx
f0104411:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104414:	01 d0                	add    %edx,%eax
f0104416:	8a 00                	mov    (%eax),%al
f0104418:	0f b6 c0             	movzbl %al,%eax
f010441b:	83 ec 08             	sub    $0x8,%esp
f010441e:	50                   	push   %eax
f010441f:	68 f1 d2 12 f0       	push   $0xf012d2f1
f0104424:	e8 33 d7 ff ff       	call   f0101b5c <cprintf>
f0104429:	83 c4 10             	add    $0x10,%esp
int command_print_sch_method(int number_of_arguments, char **arguments)
{
	if (isSchedMethodMLFQ())
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
		for (int i = 0 ; i < num_of_ready_queues; i++)
f010442c:	ff 45 f4             	incl   -0xc(%ebp)
f010442f:	a0 60 6d 85 f0       	mov    0xf0856d60,%al
f0104434:	0f b6 c0             	movzbl %al,%eax
f0104437:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010443a:	7f cf                	jg     f010440b <command_print_sch_method+0x28>
		{
			cprintf("%d   ", quantums[i]) ;
		}
		cprintf("\n");
f010443c:	83 ec 0c             	sub    $0xc,%esp
f010443f:	68 f7 d2 12 f0       	push   $0xf012d2f7
f0104444:	e8 13 d7 ff ff       	call   f0101b5c <cprintf>
f0104449:	83 c4 10             	add    $0x10,%esp
f010444c:	e9 94 00 00 00       	jmp    f01044e5 <command_print_sch_method+0x102>
	}
	else if (isSchedMethodRR())
f0104451:	e8 42 32 00 00       	call   f0107698 <isSchedMethodRR>
f0104456:	85 c0                	test   %eax,%eax
f0104458:	74 1d                	je     f0104477 <command_print_sch_method+0x94>
	{
		cprintf("Current scheduler method is Round Robin with quantum %d ms\n", quantums[0]);
f010445a:	a1 e4 6a 85 f0       	mov    0xf0856ae4,%eax
f010445f:	8a 00                	mov    (%eax),%al
f0104461:	0f b6 c0             	movzbl %al,%eax
f0104464:	83 ec 08             	sub    $0x8,%esp
f0104467:	50                   	push   %eax
f0104468:	68 cc d3 12 f0       	push   $0xf012d3cc
f010446d:	e8 ea d6 ff ff       	call   f0101b5c <cprintf>
f0104472:	83 c4 10             	add    $0x10,%esp
f0104475:	eb 6e                	jmp    f01044e5 <command_print_sch_method+0x102>
	}
	else if (isSchedMethodBSD())
f0104477:	e8 41 32 00 00       	call   f01076bd <isSchedMethodBSD>
f010447c:	85 c0                	test   %eax,%eax
f010447e:	74 26                	je     f01044a6 <command_print_sch_method+0xc3>
	{
		cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", num_of_ready_queues, quantums[0]);
f0104480:	a1 e4 6a 85 f0       	mov    0xf0856ae4,%eax
f0104485:	8a 00                	mov    (%eax),%al
f0104487:	0f b6 d0             	movzbl %al,%edx
f010448a:	a0 60 6d 85 f0       	mov    0xf0856d60,%al
f010448f:	0f b6 c0             	movzbl %al,%eax
f0104492:	83 ec 04             	sub    $0x4,%esp
f0104495:	52                   	push   %edx
f0104496:	50                   	push   %eax
f0104497:	68 fc d2 12 f0       	push   $0xf012d2fc
f010449c:	e8 bb d6 ff ff       	call   f0101b5c <cprintf>
f01044a1:	83 c4 10             	add    $0x10,%esp
f01044a4:	eb 3f                	jmp    f01044e5 <command_print_sch_method+0x102>
	}
	else if (isSchedMethodPRIRR())
f01044a6:	e8 25 32 00 00       	call   f01076d0 <isSchedMethodPRIRR>
f01044ab:	85 c0                	test   %eax,%eax
f01044ad:	74 26                	je     f01044d5 <command_print_sch_method+0xf2>
	{
		cprintf("Scheduler is now set to PRIORITY RR with %d priorities & quantum = %d\n", num_of_ready_queues, quantums[0]);
f01044af:	a1 e4 6a 85 f0       	mov    0xf0856ae4,%eax
f01044b4:	8a 00                	mov    (%eax),%al
f01044b6:	0f b6 d0             	movzbl %al,%edx
f01044b9:	a0 60 6d 85 f0       	mov    0xf0856d60,%al
f01044be:	0f b6 c0             	movzbl %al,%eax
f01044c1:	83 ec 04             	sub    $0x4,%esp
f01044c4:	52                   	push   %edx
f01044c5:	50                   	push   %eax
f01044c6:	68 08 d4 12 f0       	push   $0xf012d408
f01044cb:	e8 8c d6 ff ff       	call   f0101b5c <cprintf>
f01044d0:	83 c4 10             	add    $0x10,%esp
f01044d3:	eb 10                	jmp    f01044e5 <command_print_sch_method+0x102>
	}
	else
		cprintf("Current scheduler method is UNDEFINED\n");
f01044d5:	83 ec 0c             	sub    $0xc,%esp
f01044d8:	68 50 d4 12 f0       	push   $0xf012d450
f01044dd:	e8 7a d6 ff ff       	call   f0101b5c <cprintf>
f01044e2:	83 c4 10             	add    $0x10,%esp

	return 0;
f01044e5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01044ea:	c9                   	leave  
f01044eb:	c3                   	ret    

f01044ec <command_sch_test>:
int command_sch_test(int number_of_arguments, char **arguments)
{
f01044ec:	55                   	push   %ebp
f01044ed:	89 e5                	mov    %esp,%ebp
f01044ef:	83 ec 18             	sub    $0x18,%esp
	int status  = strtol(arguments[1], NULL, 10);
f01044f2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01044f5:	83 c0 04             	add    $0x4,%eax
f01044f8:	8b 00                	mov    (%eax),%eax
f01044fa:	83 ec 04             	sub    $0x4,%esp
f01044fd:	6a 0a                	push   $0xa
f01044ff:	6a 00                	push   $0x0
f0104501:	50                   	push   %eax
f0104502:	e8 83 69 01 00       	call   f011ae8a <strtol>
f0104507:	83 c4 10             	add    $0x10,%esp
f010450a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	chksch(status);
f010450d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104510:	0f b6 c0             	movzbl %al,%eax
f0104513:	83 ec 0c             	sub    $0xc,%esp
f0104516:	50                   	push   %eax
f0104517:	e8 0b 56 01 00       	call   f0119b27 <chksch>
f010451c:	83 c4 10             	add    $0x10,%esp
	if (status == 0)
f010451f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104523:	75 12                	jne    f0104537 <command_sch_test+0x4b>
		cprintf("Testing the scheduler is TURNED OFF\n");
f0104525:	83 ec 0c             	sub    $0xc,%esp
f0104528:	68 78 d4 12 f0       	push   $0xf012d478
f010452d:	e8 2a d6 ff ff       	call   f0101b5c <cprintf>
f0104532:	83 c4 10             	add    $0x10,%esp
f0104535:	eb 16                	jmp    f010454d <command_sch_test+0x61>
	else if (status == 1)
f0104537:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f010453b:	75 10                	jne    f010454d <command_sch_test+0x61>
		cprintf("Testing the scheduler is TURNED ON\n");
f010453d:	83 ec 0c             	sub    $0xc,%esp
f0104540:	68 a0 d4 12 f0       	push   $0xf012d4a0
f0104545:	e8 12 d6 ff ff       	call   f0101b5c <cprintf>
f010454a:	83 c4 10             	add    $0x10,%esp
	return 0;
f010454d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104552:	c9                   	leave  
f0104553:	c3                   	ret    

f0104554 <command_print_page_rep>:
/*2018*///END======================================================


/*2015*///BEGIN======================================================
int command_print_page_rep(int number_of_arguments, char **arguments)
{
f0104554:	55                   	push   %ebp
f0104555:	89 e5                	mov    %esp,%ebp
f0104557:	83 ec 08             	sub    $0x8,%esp
	if (isPageReplacmentAlgorithmCLOCK())
f010455a:	e8 da b2 00 00       	call   f010f839 <isPageReplacmentAlgorithmCLOCK>
f010455f:	85 c0                	test   %eax,%eax
f0104561:	74 15                	je     f0104578 <command_print_page_rep+0x24>
		cprintf("Page replacement algorithm is CLOCK\n");
f0104563:	83 ec 0c             	sub    $0xc,%esp
f0104566:	68 c4 d4 12 f0       	push   $0xf012d4c4
f010456b:	e8 ec d5 ff ff       	call   f0101b5c <cprintf>
f0104570:	83 c4 10             	add    $0x10,%esp
f0104573:	e9 ff 00 00 00       	jmp    f0104677 <command_print_page_rep+0x123>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f0104578:	83 ec 0c             	sub    $0xc,%esp
f010457b:	6a 01                	push   $0x1
f010457d:	e8 a1 b2 00 00       	call   f010f823 <isPageReplacmentAlgorithmLRU>
f0104582:	83 c4 10             	add    $0x10,%esp
f0104585:	85 c0                	test   %eax,%eax
f0104587:	74 15                	je     f010459e <command_print_page_rep+0x4a>
		cprintf("Page replacement algorithm is LRU with TimeStamp approximation\n");
f0104589:	83 ec 0c             	sub    $0xc,%esp
f010458c:	68 ec d4 12 f0       	push   $0xf012d4ec
f0104591:	e8 c6 d5 ff ff       	call   f0101b5c <cprintf>
f0104596:	83 c4 10             	add    $0x10,%esp
f0104599:	e9 d9 00 00 00       	jmp    f0104677 <command_print_page_rep+0x123>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010459e:	83 ec 0c             	sub    $0xc,%esp
f01045a1:	6a 02                	push   $0x2
f01045a3:	e8 7b b2 00 00       	call   f010f823 <isPageReplacmentAlgorithmLRU>
f01045a8:	83 c4 10             	add    $0x10,%esp
f01045ab:	85 c0                	test   %eax,%eax
f01045ad:	74 15                	je     f01045c4 <command_print_page_rep+0x70>
		cprintf("Page replacement algorithm is LRU with LISTS approximation\n");
f01045af:	83 ec 0c             	sub    $0xc,%esp
f01045b2:	68 2c d5 12 f0       	push   $0xf012d52c
f01045b7:	e8 a0 d5 ff ff       	call   f0101b5c <cprintf>
f01045bc:	83 c4 10             	add    $0x10,%esp
f01045bf:	e9 b3 00 00 00       	jmp    f0104677 <command_print_page_rep+0x123>
	else if (isPageReplacmentAlgorithmFIFO())
f01045c4:	e8 8b b2 00 00       	call   f010f854 <isPageReplacmentAlgorithmFIFO>
f01045c9:	85 c0                	test   %eax,%eax
f01045cb:	74 15                	je     f01045e2 <command_print_page_rep+0x8e>
		cprintf("Page replacement algorithm is FIFO\n");
f01045cd:	83 ec 0c             	sub    $0xc,%esp
f01045d0:	68 68 d5 12 f0       	push   $0xf012d568
f01045d5:	e8 82 d5 ff ff       	call   f0101b5c <cprintf>
f01045da:	83 c4 10             	add    $0x10,%esp
f01045dd:	e9 95 00 00 00       	jmp    f0104677 <command_print_page_rep+0x123>
	else if (isPageReplacmentAlgorithmModifiedCLOCK())
f01045e2:	e8 88 b2 00 00       	call   f010f86f <isPageReplacmentAlgorithmModifiedCLOCK>
f01045e7:	85 c0                	test   %eax,%eax
f01045e9:	74 12                	je     f01045fd <command_print_page_rep+0xa9>
		cprintf("Page replacement algorithm is Modified CLOCK\n");
f01045eb:	83 ec 0c             	sub    $0xc,%esp
f01045ee:	68 8c d5 12 f0       	push   $0xf012d58c
f01045f3:	e8 64 d5 ff ff       	call   f0101b5c <cprintf>
f01045f8:	83 c4 10             	add    $0x10,%esp
f01045fb:	eb 7a                	jmp    f0104677 <command_print_page_rep+0x123>
	else if (isPageReplacmentAlgorithmOPTIMAL())
f01045fd:	e8 be b2 00 00       	call   f010f8c0 <isPageReplacmentAlgorithmOPTIMAL>
f0104602:	85 c0                	test   %eax,%eax
f0104604:	74 12                	je     f0104618 <command_print_page_rep+0xc4>
		cprintf("Page replacement algorithm is OPTIMAL\n");
f0104606:	83 ec 0c             	sub    $0xc,%esp
f0104609:	68 bc d5 12 f0       	push   $0xf012d5bc
f010460e:	e8 49 d5 ff ff       	call   f0101b5c <cprintf>
f0104613:	83 c4 10             	add    $0x10,%esp
f0104616:	eb 5f                	jmp    f0104677 <command_print_page_rep+0x123>
	else if (isPageReplacmentAlgorithmNchanceCLOCK())
f0104618:	e8 88 b2 00 00       	call   f010f8a5 <isPageReplacmentAlgorithmNchanceCLOCK>
f010461d:	85 c0                	test   %eax,%eax
f010461f:	74 46                	je     f0104667 <command_print_page_rep+0x113>
	{
		cprintf("Page replacement algorithm is Nth Chance CLOCK ");
f0104621:	83 ec 0c             	sub    $0xc,%esp
f0104624:	68 e4 d5 12 f0       	push   $0xf012d5e4
f0104629:	e8 2e d5 ff ff       	call   f0101b5c <cprintf>
f010462e:	83 c4 10             	add    $0x10,%esp
		if (page_WS_max_sweeps > 0)			cprintf("[NORMAL ver]\n");
f0104631:	a1 b4 e7 83 f0       	mov    0xf083e7b4,%eax
f0104636:	85 c0                	test   %eax,%eax
f0104638:	7e 12                	jle    f010464c <command_print_page_rep+0xf8>
f010463a:	83 ec 0c             	sub    $0xc,%esp
f010463d:	68 14 d6 12 f0       	push   $0xf012d614
f0104642:	e8 15 d5 ff ff       	call   f0101b5c <cprintf>
f0104647:	83 c4 10             	add    $0x10,%esp
f010464a:	eb 2b                	jmp    f0104677 <command_print_page_rep+0x123>
		else if (page_WS_max_sweeps < 0)	cprintf("[MODIFIED ver]\n");
f010464c:	a1 b4 e7 83 f0       	mov    0xf083e7b4,%eax
f0104651:	85 c0                	test   %eax,%eax
f0104653:	79 22                	jns    f0104677 <command_print_page_rep+0x123>
f0104655:	83 ec 0c             	sub    $0xc,%esp
f0104658:	68 22 d6 12 f0       	push   $0xf012d622
f010465d:	e8 fa d4 ff ff       	call   f0101b5c <cprintf>
f0104662:	83 c4 10             	add    $0x10,%esp
f0104665:	eb 10                	jmp    f0104677 <command_print_page_rep+0x123>
	}
	else
		cprintf("Page replacement algorithm is UNDEFINED\n");
f0104667:	83 ec 0c             	sub    $0xc,%esp
f010466a:	68 34 d6 12 f0       	push   $0xf012d634
f010466f:	e8 e8 d4 ff ff       	call   f0101b5c <cprintf>
f0104674:	83 c4 10             	add    $0x10,%esp

	return 0;
f0104677:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010467c:	c9                   	leave  
f010467d:	c3                   	ret    

f010467e <command_set_uheap_plac_FIRSTFIT>:


int command_set_uheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f010467e:	55                   	push   %ebp
f010467f:	89 e5                	mov    %esp,%ebp
f0104681:	83 ec 08             	sub    $0x8,%esp
	set_uheap_strategy(UHP_PLACE_FIRSTFIT);
f0104684:	6a 01                	push   $0x1
f0104686:	e8 c9 e7 ff ff       	call   f0102e54 <set_uheap_strategy>
f010468b:	83 c4 04             	add    $0x4,%esp
	cprintf("User Heap placement strategy is now FIRST FIT\n");
f010468e:	83 ec 0c             	sub    $0xc,%esp
f0104691:	68 60 d6 12 f0       	push   $0xf012d660
f0104696:	e8 c1 d4 ff ff       	call   f0101b5c <cprintf>
f010469b:	83 c4 10             	add    $0x10,%esp
	return 0;
f010469e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01046a3:	c9                   	leave  
f01046a4:	c3                   	ret    

f01046a5 <command_set_uheap_plac_BESTFIT>:

int command_set_uheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f01046a5:	55                   	push   %ebp
f01046a6:	89 e5                	mov    %esp,%ebp
f01046a8:	83 ec 08             	sub    $0x8,%esp
	set_uheap_strategy(UHP_PLACE_BESTFIT);
f01046ab:	6a 02                	push   $0x2
f01046ad:	e8 a2 e7 ff ff       	call   f0102e54 <set_uheap_strategy>
f01046b2:	83 c4 04             	add    $0x4,%esp
	cprintf("User Heap placement strategy is now BEST FIT\n");
f01046b5:	83 ec 0c             	sub    $0xc,%esp
f01046b8:	68 90 d6 12 f0       	push   $0xf012d690
f01046bd:	e8 9a d4 ff ff       	call   f0101b5c <cprintf>
f01046c2:	83 c4 10             	add    $0x10,%esp
	return 0;
f01046c5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01046ca:	c9                   	leave  
f01046cb:	c3                   	ret    

f01046cc <command_set_uheap_plac_NEXTFIT>:

int command_set_uheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f01046cc:	55                   	push   %ebp
f01046cd:	89 e5                	mov    %esp,%ebp
f01046cf:	83 ec 08             	sub    $0x8,%esp
	set_uheap_strategy(UHP_PLACE_NEXTFIT);
f01046d2:	6a 03                	push   $0x3
f01046d4:	e8 7b e7 ff ff       	call   f0102e54 <set_uheap_strategy>
f01046d9:	83 c4 04             	add    $0x4,%esp
	cprintf("User Heap placement strategy is now NEXT FIT\n");
f01046dc:	83 ec 0c             	sub    $0xc,%esp
f01046df:	68 c0 d6 12 f0       	push   $0xf012d6c0
f01046e4:	e8 73 d4 ff ff       	call   f0101b5c <cprintf>
f01046e9:	83 c4 10             	add    $0x10,%esp
	return 0;
f01046ec:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01046f1:	c9                   	leave  
f01046f2:	c3                   	ret    

f01046f3 <command_set_uheap_plac_WORSTFIT>:
int command_set_uheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f01046f3:	55                   	push   %ebp
f01046f4:	89 e5                	mov    %esp,%ebp
f01046f6:	83 ec 08             	sub    $0x8,%esp
	set_uheap_strategy(UHP_PLACE_WORSTFIT);
f01046f9:	6a 04                	push   $0x4
f01046fb:	e8 54 e7 ff ff       	call   f0102e54 <set_uheap_strategy>
f0104700:	83 c4 04             	add    $0x4,%esp
	cprintf("User Heap placement strategy is now WORST FIT\n");
f0104703:	83 ec 0c             	sub    $0xc,%esp
f0104706:	68 f0 d6 12 f0       	push   $0xf012d6f0
f010470b:	e8 4c d4 ff ff       	call   f0101b5c <cprintf>
f0104710:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104713:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104718:	c9                   	leave  
f0104719:	c3                   	ret    

f010471a <command_set_uheap_plac_CUSTOMFIT>:
int command_set_uheap_plac_CUSTOMFIT(int number_of_arguments, char **arguments)
{
f010471a:	55                   	push   %ebp
f010471b:	89 e5                	mov    %esp,%ebp
f010471d:	83 ec 08             	sub    $0x8,%esp
	set_uheap_strategy(UHP_PLACE_CUSTOMFIT);
f0104720:	6a 05                	push   $0x5
f0104722:	e8 2d e7 ff ff       	call   f0102e54 <set_uheap_strategy>
f0104727:	83 c4 04             	add    $0x4,%esp
	cprintf("User Heap placement strategy is now CUSTOM FIT\n");
f010472a:	83 ec 0c             	sub    $0xc,%esp
f010472d:	68 20 d7 12 f0       	push   $0xf012d720
f0104732:	e8 25 d4 ff ff       	call   f0101b5c <cprintf>
f0104737:	83 c4 10             	add    $0x10,%esp
	return 0;
f010473a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010473f:	c9                   	leave  
f0104740:	c3                   	ret    

f0104741 <command_print_uheap_plac>:

int command_print_uheap_plac(int number_of_arguments, char **arguments)
{
f0104741:	55                   	push   %ebp
f0104742:	89 e5                	mov    %esp,%ebp
f0104744:	83 ec 18             	sub    $0x18,%esp
	uint32 strategy = get_uheap_strategy();
f0104747:	e8 16 e7 ff ff       	call   f0102e62 <get_uheap_strategy>
f010474c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (strategy)
f010474f:	83 7d f4 05          	cmpl   $0x5,-0xc(%ebp)
f0104753:	77 69                	ja     f01047be <command_print_uheap_plac+0x7d>
f0104755:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104758:	c1 e0 02             	shl    $0x2,%eax
f010475b:	05 58 d8 12 f0       	add    $0xf012d858,%eax
f0104760:	8b 00                	mov    (%eax),%eax
f0104762:	ff e0                	jmp    *%eax
	{
	case UHP_PLACE_FIRSTFIT:
		cprintf("User Heap placement strategy is FIRST FIT\n");
f0104764:	83 ec 0c             	sub    $0xc,%esp
f0104767:	68 50 d7 12 f0       	push   $0xf012d750
f010476c:	e8 eb d3 ff ff       	call   f0101b5c <cprintf>
f0104771:	83 c4 10             	add    $0x10,%esp
		break;
f0104774:	eb 58                	jmp    f01047ce <command_print_uheap_plac+0x8d>
	case UHP_PLACE_NEXTFIT:
		cprintf("User Heap placement strategy is NEXT FIT\n");
f0104776:	83 ec 0c             	sub    $0xc,%esp
f0104779:	68 7c d7 12 f0       	push   $0xf012d77c
f010477e:	e8 d9 d3 ff ff       	call   f0101b5c <cprintf>
f0104783:	83 c4 10             	add    $0x10,%esp
		break;
f0104786:	eb 46                	jmp    f01047ce <command_print_uheap_plac+0x8d>
	case UHP_PLACE_BESTFIT:
		cprintf("User Heap placement strategy is BEST FIT\n");
f0104788:	83 ec 0c             	sub    $0xc,%esp
f010478b:	68 a8 d7 12 f0       	push   $0xf012d7a8
f0104790:	e8 c7 d3 ff ff       	call   f0101b5c <cprintf>
f0104795:	83 c4 10             	add    $0x10,%esp
		break;
f0104798:	eb 34                	jmp    f01047ce <command_print_uheap_plac+0x8d>
	case UHP_PLACE_WORSTFIT:
		cprintf("User Heap placement strategy is WORST FIT\n");
f010479a:	83 ec 0c             	sub    $0xc,%esp
f010479d:	68 d4 d7 12 f0       	push   $0xf012d7d4
f01047a2:	e8 b5 d3 ff ff       	call   f0101b5c <cprintf>
f01047a7:	83 c4 10             	add    $0x10,%esp
		break;
f01047aa:	eb 22                	jmp    f01047ce <command_print_uheap_plac+0x8d>
	case UHP_PLACE_CUSTOMFIT:
		cprintf("User Heap placement strategy is CUSTOM FIT\n");
f01047ac:	83 ec 0c             	sub    $0xc,%esp
f01047af:	68 00 d8 12 f0       	push   $0xf012d800
f01047b4:	e8 a3 d3 ff ff       	call   f0101b5c <cprintf>
f01047b9:	83 c4 10             	add    $0x10,%esp
		break;
f01047bc:	eb 10                	jmp    f01047ce <command_print_uheap_plac+0x8d>
	default:
		cprintf("User Heap placement strategy is UNDEFINED\n");
f01047be:	83 ec 0c             	sub    $0xc,%esp
f01047c1:	68 2c d8 12 f0       	push   $0xf012d82c
f01047c6:	e8 91 d3 ff ff       	call   f0101b5c <cprintf>
f01047cb:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f01047ce:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01047d3:	c9                   	leave  
f01047d4:	c3                   	ret    

f01047d5 <command_set_kheap_plac_CONTALLOC>:
/*2015*///END======================================================

/*2017*///BEGIN======================================================

int command_set_kheap_plac_CONTALLOC(int number_of_arguments, char **arguments)
{
f01047d5:	55                   	push   %ebp
f01047d6:	89 e5                	mov    %esp,%ebp
f01047d8:	83 ec 08             	sub    $0x8,%esp
	set_kheap_strategy(KHP_PLACE_CONTALLOC);
f01047db:	6a 00                	push   $0x0
f01047dd:	e8 5a e6 ff ff       	call   f0102e3c <set_kheap_strategy>
f01047e2:	83 c4 04             	add    $0x4,%esp
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f01047e5:	83 ec 0c             	sub    $0xc,%esp
f01047e8:	68 70 d8 12 f0       	push   $0xf012d870
f01047ed:	e8 6a d3 ff ff       	call   f0101b5c <cprintf>
f01047f2:	83 c4 10             	add    $0x10,%esp
	return 0;
f01047f5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01047fa:	c9                   	leave  
f01047fb:	c3                   	ret    

f01047fc <command_set_kheap_plac_FIRSTFIT>:

int command_set_kheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f01047fc:	55                   	push   %ebp
f01047fd:	89 e5                	mov    %esp,%ebp
f01047ff:	83 ec 08             	sub    $0x8,%esp
	set_kheap_strategy(KHP_PLACE_FIRSTFIT);
f0104802:	6a 01                	push   $0x1
f0104804:	e8 33 e6 ff ff       	call   f0102e3c <set_kheap_strategy>
f0104809:	83 c4 04             	add    $0x4,%esp
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f010480c:	83 ec 0c             	sub    $0xc,%esp
f010480f:	68 70 d8 12 f0       	push   $0xf012d870
f0104814:	e8 43 d3 ff ff       	call   f0101b5c <cprintf>
f0104819:	83 c4 10             	add    $0x10,%esp
	return 0;
f010481c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104821:	c9                   	leave  
f0104822:	c3                   	ret    

f0104823 <command_set_kheap_plac_BESTFIT>:

int command_set_kheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f0104823:	55                   	push   %ebp
f0104824:	89 e5                	mov    %esp,%ebp
f0104826:	83 ec 08             	sub    $0x8,%esp
	set_kheap_strategy(KHP_PLACE_BESTFIT);
f0104829:	6a 02                	push   $0x2
f010482b:	e8 0c e6 ff ff       	call   f0102e3c <set_kheap_strategy>
f0104830:	83 c4 04             	add    $0x4,%esp
	cprintf("Kernel Heap placement strategy is now BEST FIT\n");
f0104833:	83 ec 0c             	sub    $0xc,%esp
f0104836:	68 a4 d8 12 f0       	push   $0xf012d8a4
f010483b:	e8 1c d3 ff ff       	call   f0101b5c <cprintf>
f0104840:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104843:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104848:	c9                   	leave  
f0104849:	c3                   	ret    

f010484a <command_set_kheap_plac_NEXTFIT>:

int command_set_kheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f010484a:	55                   	push   %ebp
f010484b:	89 e5                	mov    %esp,%ebp
f010484d:	83 ec 08             	sub    $0x8,%esp
	set_kheap_strategy(KHP_PLACE_NEXTFIT);
f0104850:	6a 03                	push   $0x3
f0104852:	e8 e5 e5 ff ff       	call   f0102e3c <set_kheap_strategy>
f0104857:	83 c4 04             	add    $0x4,%esp
	cprintf("Kernel Heap placement strategy is now NEXT FIT\n");
f010485a:	83 ec 0c             	sub    $0xc,%esp
f010485d:	68 d4 d8 12 f0       	push   $0xf012d8d4
f0104862:	e8 f5 d2 ff ff       	call   f0101b5c <cprintf>
f0104867:	83 c4 10             	add    $0x10,%esp
	return 0;
f010486a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010486f:	c9                   	leave  
f0104870:	c3                   	ret    

f0104871 <command_set_kheap_plac_WORSTFIT>:
int command_set_kheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f0104871:	55                   	push   %ebp
f0104872:	89 e5                	mov    %esp,%ebp
f0104874:	83 ec 08             	sub    $0x8,%esp
	set_kheap_strategy(KHP_PLACE_WORSTFIT);
f0104877:	6a 04                	push   $0x4
f0104879:	e8 be e5 ff ff       	call   f0102e3c <set_kheap_strategy>
f010487e:	83 c4 04             	add    $0x4,%esp
	cprintf("Kernel Heap placement strategy is now WORST FIT\n");
f0104881:	83 ec 0c             	sub    $0xc,%esp
f0104884:	68 04 d9 12 f0       	push   $0xf012d904
f0104889:	e8 ce d2 ff ff       	call   f0101b5c <cprintf>
f010488e:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104891:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104896:	c9                   	leave  
f0104897:	c3                   	ret    

f0104898 <command_set_kheap_plac_CUSTOMFIT>:
int command_set_kheap_plac_CUSTOMFIT(int number_of_arguments, char **arguments)
{
f0104898:	55                   	push   %ebp
f0104899:	89 e5                	mov    %esp,%ebp
f010489b:	83 ec 08             	sub    $0x8,%esp
	set_kheap_strategy(KHP_PLACE_CUSTOMFIT);
f010489e:	6a 05                	push   $0x5
f01048a0:	e8 97 e5 ff ff       	call   f0102e3c <set_kheap_strategy>
f01048a5:	83 c4 04             	add    $0x4,%esp
	cprintf("Kernel Heap placement strategy is now CUSTOM FIT\n");
f01048a8:	83 ec 0c             	sub    $0xc,%esp
f01048ab:	68 38 d9 12 f0       	push   $0xf012d938
f01048b0:	e8 a7 d2 ff ff       	call   f0101b5c <cprintf>
f01048b5:	83 c4 10             	add    $0x10,%esp
	return 0;
f01048b8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01048bd:	c9                   	leave  
f01048be:	c3                   	ret    

f01048bf <command_print_kheap_plac>:
int command_print_kheap_plac(int number_of_arguments, char **arguments)
{
f01048bf:	55                   	push   %ebp
f01048c0:	89 e5                	mov    %esp,%ebp
f01048c2:	83 ec 18             	sub    $0x18,%esp
	uint32 strategy = get_kheap_strategy();
f01048c5:	e8 80 e5 ff ff       	call   f0102e4a <get_kheap_strategy>
f01048ca:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (strategy)
f01048cd:	83 7d f4 05          	cmpl   $0x5,-0xc(%ebp)
f01048d1:	77 7b                	ja     f010494e <command_print_kheap_plac+0x8f>
f01048d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01048d6:	c1 e0 02             	shl    $0x2,%eax
f01048d9:	05 c0 da 12 f0       	add    $0xf012dac0,%eax
f01048de:	8b 00                	mov    (%eax),%eax
f01048e0:	ff e0                	jmp    *%eax
	{
	case KHP_PLACE_CONTALLOC:
		cprintf("Kernel Heap placement strategy is CONTINUOUS ALLOCATION\n");
f01048e2:	83 ec 0c             	sub    $0xc,%esp
f01048e5:	68 6c d9 12 f0       	push   $0xf012d96c
f01048ea:	e8 6d d2 ff ff       	call   f0101b5c <cprintf>
f01048ef:	83 c4 10             	add    $0x10,%esp
		break;
f01048f2:	eb 6a                	jmp    f010495e <command_print_kheap_plac+0x9f>
	case KHP_PLACE_FIRSTFIT:
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f01048f4:	83 ec 0c             	sub    $0xc,%esp
f01048f7:	68 a8 d9 12 f0       	push   $0xf012d9a8
f01048fc:	e8 5b d2 ff ff       	call   f0101b5c <cprintf>
f0104901:	83 c4 10             	add    $0x10,%esp
		break;
f0104904:	eb 58                	jmp    f010495e <command_print_kheap_plac+0x9f>
	case KHP_PLACE_NEXTFIT:
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f0104906:	83 ec 0c             	sub    $0xc,%esp
f0104909:	68 d8 d9 12 f0       	push   $0xf012d9d8
f010490e:	e8 49 d2 ff ff       	call   f0101b5c <cprintf>
f0104913:	83 c4 10             	add    $0x10,%esp
		break;
f0104916:	eb 46                	jmp    f010495e <command_print_kheap_plac+0x9f>
	case KHP_PLACE_BESTFIT:
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f0104918:	83 ec 0c             	sub    $0xc,%esp
f010491b:	68 04 da 12 f0       	push   $0xf012da04
f0104920:	e8 37 d2 ff ff       	call   f0101b5c <cprintf>
f0104925:	83 c4 10             	add    $0x10,%esp
		break;
f0104928:	eb 34                	jmp    f010495e <command_print_kheap_plac+0x9f>
	case KHP_PLACE_WORSTFIT:
		cprintf("Kernel Heap placement strategy is WORST FIT\n");
f010492a:	83 ec 0c             	sub    $0xc,%esp
f010492d:	68 30 da 12 f0       	push   $0xf012da30
f0104932:	e8 25 d2 ff ff       	call   f0101b5c <cprintf>
f0104937:	83 c4 10             	add    $0x10,%esp
		break;
f010493a:	eb 22                	jmp    f010495e <command_print_kheap_plac+0x9f>
	case KHP_PLACE_CUSTOMFIT:
		cprintf("Kernel Heap placement strategy is CUSTOM FIT\n");
f010493c:	83 ec 0c             	sub    $0xc,%esp
f010493f:	68 60 da 12 f0       	push   $0xf012da60
f0104944:	e8 13 d2 ff ff       	call   f0101b5c <cprintf>
f0104949:	83 c4 10             	add    $0x10,%esp
		break;
f010494c:	eb 10                	jmp    f010495e <command_print_kheap_plac+0x9f>
	default:
		cprintf("Kernel Heap placement strategy is UNDEFINED\n");
f010494e:	83 ec 0c             	sub    $0xc,%esp
f0104951:	68 90 da 12 f0       	push   $0xf012da90
f0104956:	e8 01 d2 ff ff       	call   f0101b5c <cprintf>
f010495b:	83 c4 10             	add    $0x10,%esp
	}

	return 0;
f010495e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104963:	c9                   	leave  
f0104964:	c3                   	ret    

f0104965 <command_disable_modified_buffer>:

/*2017*///END======================================================

int command_disable_modified_buffer(int number_of_arguments, char **arguments)
{
f0104965:	55                   	push   %ebp
f0104966:	89 e5                	mov    %esp,%ebp
f0104968:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f010496b:	e8 91 af 00 00       	call   f010f901 <isBufferingEnabled>
f0104970:	84 c0                	test   %al,%al
f0104972:	75 12                	jne    f0104986 <command_disable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f0104974:	83 ec 0c             	sub    $0xc,%esp
f0104977:	68 d8 da 12 f0       	push   $0xf012dad8
f010497c:	e8 db d1 ff ff       	call   f0101b5c <cprintf>
f0104981:	83 c4 10             	add    $0x10,%esp
f0104984:	eb 1d                	jmp    f01049a3 <command_disable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(0);
f0104986:	83 ec 0c             	sub    $0xc,%esp
f0104989:	6a 00                	push   $0x0
f010498b:	e8 4b af 00 00       	call   f010f8db <enableModifiedBuffer>
f0104990:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now DISABLED\n");
f0104993:	83 ec 0c             	sub    $0xc,%esp
f0104996:	68 14 db 12 f0       	push   $0xf012db14
f010499b:	e8 bc d1 ff ff       	call   f0101b5c <cprintf>
f01049a0:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f01049a3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01049a8:	c9                   	leave  
f01049a9:	c3                   	ret    

f01049aa <command_enable_modified_buffer>:


int command_enable_modified_buffer(int number_of_arguments, char **arguments)
{
f01049aa:	55                   	push   %ebp
f01049ab:	89 e5                	mov    %esp,%ebp
f01049ad:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f01049b0:	e8 4c af 00 00       	call   f010f901 <isBufferingEnabled>
f01049b5:	84 c0                	test   %al,%al
f01049b7:	75 12                	jne    f01049cb <command_enable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f01049b9:	83 ec 0c             	sub    $0xc,%esp
f01049bc:	68 d8 da 12 f0       	push   $0xf012dad8
f01049c1:	e8 96 d1 ff ff       	call   f0101b5c <cprintf>
f01049c6:	83 c4 10             	add    $0x10,%esp
f01049c9:	eb 1d                	jmp    f01049e8 <command_enable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(1);
f01049cb:	83 ec 0c             	sub    $0xc,%esp
f01049ce:	6a 01                	push   $0x1
f01049d0:	e8 06 af 00 00       	call   f010f8db <enableModifiedBuffer>
f01049d5:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now ENABLED\n");
f01049d8:	83 ec 0c             	sub    $0xc,%esp
f01049db:	68 38 db 12 f0       	push   $0xf012db38
f01049e0:	e8 77 d1 ff ff       	call   f0101b5c <cprintf>
f01049e5:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f01049e8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01049ed:	c9                   	leave  
f01049ee:	c3                   	ret    

f01049ef <command_disable_buffering>:

/*2016 ============================================================================*/

int command_disable_buffering(int number_of_arguments, char **arguments)
{
f01049ef:	55                   	push   %ebp
f01049f0:	89 e5                	mov    %esp,%ebp
f01049f2:	83 ec 08             	sub    $0x8,%esp
	enableBuffering(0);
f01049f5:	83 ec 0c             	sub    $0xc,%esp
f01049f8:	6a 00                	push   $0x0
f01049fa:	e8 f4 ae 00 00       	call   f010f8f3 <enableBuffering>
f01049ff:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(0);
f0104a02:	83 ec 0c             	sub    $0xc,%esp
f0104a05:	6a 00                	push   $0x0
f0104a07:	e8 cf ae 00 00       	call   f010f8db <enableModifiedBuffer>
f0104a0c:	83 c4 10             	add    $0x10,%esp
	cprintf("Buffering is now DISABLED\n");
f0104a0f:	83 ec 0c             	sub    $0xc,%esp
f0104a12:	68 58 db 12 f0       	push   $0xf012db58
f0104a17:	e8 40 d1 ff ff       	call   f0101b5c <cprintf>
f0104a1c:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104a1f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104a24:	c9                   	leave  
f0104a25:	c3                   	ret    

f0104a26 <command_enable_buffering>:


int command_enable_buffering(int number_of_arguments, char **arguments)
{
f0104a26:	55                   	push   %ebp
f0104a27:	89 e5                	mov    %esp,%ebp
f0104a29:	83 ec 78             	sub    $0x78,%esp
	enableBuffering(1);
f0104a2c:	83 ec 0c             	sub    $0xc,%esp
f0104a2f:	6a 01                	push   $0x1
f0104a31:	e8 bd ae 00 00       	call   f010f8f3 <enableBuffering>
f0104a36:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(1);
f0104a39:	83 ec 0c             	sub    $0xc,%esp
f0104a3c:	6a 01                	push   $0x1
f0104a3e:	e8 98 ae 00 00       	call   f010f8db <enableModifiedBuffer>
f0104a43:	83 c4 10             	add    $0x10,%esp
	if(getModifiedBufferLength() == 0)
f0104a46:	e8 ce ae 00 00       	call   f010f919 <getModifiedBufferLength>
f0104a4b:	85 c0                	test   %eax,%eax
f0104a4d:	75 59                	jne    f0104aa8 <command_enable_buffering+0x82>
	{
		cprintf("Modified buffer enabled but with length = 0\n");
f0104a4f:	83 ec 0c             	sub    $0xc,%esp
f0104a52:	68 74 db 12 f0       	push   $0xf012db74
f0104a57:	e8 00 d1 ff ff       	call   f0101b5c <cprintf>
f0104a5c:	83 c4 10             	add    $0x10,%esp
		char str[100];
		readline("Please enter the modified buff length = ", str);
f0104a5f:	83 ec 08             	sub    $0x8,%esp
f0104a62:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0104a65:	50                   	push   %eax
f0104a66:	68 a4 db 12 f0       	push   $0xf012dba4
f0104a6b:	e8 03 5e 01 00       	call   f011a873 <readline>
f0104a70:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(strtol(str, NULL, 10));
f0104a73:	83 ec 04             	sub    $0x4,%esp
f0104a76:	6a 0a                	push   $0xa
f0104a78:	6a 00                	push   $0x0
f0104a7a:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0104a7d:	50                   	push   %eax
f0104a7e:	e8 07 64 01 00       	call   f011ae8a <strtol>
f0104a83:	83 c4 10             	add    $0x10,%esp
f0104a86:	83 ec 0c             	sub    $0xc,%esp
f0104a89:	50                   	push   %eax
f0104a8a:	e8 7c ae 00 00       	call   f010f90b <setModifiedBufferLength>
f0104a8f:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0104a92:	e8 82 ae 00 00       	call   f010f919 <getModifiedBufferLength>
f0104a97:	83 ec 08             	sub    $0x8,%esp
f0104a9a:	50                   	push   %eax
f0104a9b:	68 d0 db 12 f0       	push   $0xf012dbd0
f0104aa0:	e8 b7 d0 ff ff       	call   f0101b5c <cprintf>
f0104aa5:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Buffering is now ENABLED\n");
f0104aa8:	83 ec 0c             	sub    $0xc,%esp
f0104aab:	68 f5 db 12 f0       	push   $0xf012dbf5
f0104ab0:	e8 a7 d0 ff ff       	call   f0101b5c <cprintf>
f0104ab5:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104ab8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104abd:	c9                   	leave  
f0104abe:	c3                   	ret    

f0104abf <command_set_modified_buffer_length>:

int command_set_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0104abf:	55                   	push   %ebp
f0104ac0:	89 e5                	mov    %esp,%ebp
f0104ac2:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0104ac5:	e8 37 ae 00 00       	call   f010f901 <isBufferingEnabled>
f0104aca:	84 c0                	test   %al,%al
f0104acc:	75 12                	jne    f0104ae0 <command_set_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0104ace:	83 ec 0c             	sub    $0xc,%esp
f0104ad1:	68 10 dc 12 f0       	push   $0xf012dc10
f0104ad6:	e8 81 d0 ff ff       	call   f0101b5c <cprintf>
f0104adb:	83 c4 10             	add    $0x10,%esp
f0104ade:	eb 19                	jmp    f0104af9 <command_set_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0104ae0:	e8 04 ae 00 00       	call   f010f8e9 <isModifiedBufferEnabled>
f0104ae5:	84 c0                	test   %al,%al
f0104ae7:	75 10                	jne    f0104af9 <command_set_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0104ae9:	83 ec 0c             	sub    $0xc,%esp
f0104aec:	68 60 dc 12 f0       	push   $0xf012dc60
f0104af1:	e8 66 d0 ff ff       	call   f0101b5c <cprintf>
f0104af6:	83 c4 10             	add    $0x10,%esp
	}
	setModifiedBufferLength(strtol(arguments[1], NULL, 10));
f0104af9:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104afc:	83 c0 04             	add    $0x4,%eax
f0104aff:	8b 00                	mov    (%eax),%eax
f0104b01:	83 ec 04             	sub    $0x4,%esp
f0104b04:	6a 0a                	push   $0xa
f0104b06:	6a 00                	push   $0x0
f0104b08:	50                   	push   %eax
f0104b09:	e8 7c 63 01 00       	call   f011ae8a <strtol>
f0104b0e:	83 c4 10             	add    $0x10,%esp
f0104b11:	83 ec 0c             	sub    $0xc,%esp
f0104b14:	50                   	push   %eax
f0104b15:	e8 f1 ad 00 00       	call   f010f90b <setModifiedBufferLength>
f0104b1a:	83 c4 10             	add    $0x10,%esp
	cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0104b1d:	e8 f7 ad 00 00       	call   f010f919 <getModifiedBufferLength>
f0104b22:	83 ec 08             	sub    $0x8,%esp
f0104b25:	50                   	push   %eax
f0104b26:	68 d0 db 12 f0       	push   $0xf012dbd0
f0104b2b:	e8 2c d0 ff ff       	call   f0101b5c <cprintf>
f0104b30:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104b33:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104b38:	c9                   	leave  
f0104b39:	c3                   	ret    

f0104b3a <command_get_modified_buffer_length>:

int command_get_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0104b3a:	55                   	push   %ebp
f0104b3b:	89 e5                	mov    %esp,%ebp
f0104b3d:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0104b40:	e8 bc ad 00 00       	call   f010f901 <isBufferingEnabled>
f0104b45:	84 c0                	test   %al,%al
f0104b47:	75 12                	jne    f0104b5b <command_get_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0104b49:	83 ec 0c             	sub    $0xc,%esp
f0104b4c:	68 10 dc 12 f0       	push   $0xf012dc10
f0104b51:	e8 06 d0 ff ff       	call   f0101b5c <cprintf>
f0104b56:	83 c4 10             	add    $0x10,%esp
f0104b59:	eb 19                	jmp    f0104b74 <command_get_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0104b5b:	e8 89 ad 00 00       	call   f010f8e9 <isModifiedBufferEnabled>
f0104b60:	84 c0                	test   %al,%al
f0104b62:	75 10                	jne    f0104b74 <command_get_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0104b64:	83 ec 0c             	sub    $0xc,%esp
f0104b67:	68 60 dc 12 f0       	push   $0xf012dc60
f0104b6c:	e8 eb cf ff ff       	call   f0101b5c <cprintf>
f0104b71:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Modified buffer length = %d\n", getModifiedBufferLength());
f0104b74:	e8 a0 ad 00 00       	call   f010f919 <getModifiedBufferLength>
f0104b79:	83 ec 08             	sub    $0x8,%esp
f0104b7c:	50                   	push   %eax
f0104b7d:	68 a6 dc 12 f0       	push   $0xf012dca6
f0104b82:	e8 d5 cf ff ff       	call   f0101b5c <cprintf>
f0104b87:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104b8a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104b8f:	c9                   	leave  
f0104b90:	c3                   	ret    

f0104b91 <command_tst>:

int command_tst(int number_of_arguments, char **arguments)
{
f0104b91:	55                   	push   %ebp
f0104b92:	89 e5                	mov    %esp,%ebp
f0104b94:	83 ec 08             	sub    $0x8,%esp
	return tst_handler(number_of_arguments, arguments);
f0104b97:	83 ec 08             	sub    $0x8,%esp
f0104b9a:	ff 75 0c             	pushl  0xc(%ebp)
f0104b9d:	ff 75 08             	pushl  0x8(%ebp)
f0104ba0:	e8 c1 b6 00 00       	call   f0110266 <tst_handler>
f0104ba5:	83 c4 10             	add    $0x10,%esp
}
f0104ba8:	c9                   	leave  
f0104ba9:	c3                   	ret    

f0104baa <command_cls>:

// *************** This clear screen feature is implemented by *************
// ********* Abd-Alrahman Zedan From Team Frozen-Bytes - FCIS'24-25 ********
int command_cls(int number_of_arguments, char **arguments)
{
f0104baa:	55                   	push   %ebp
f0104bab:	89 e5                	mov    %esp,%ebp
f0104bad:	83 ec 08             	sub    $0x8,%esp
	clear_screen_buffer();
f0104bb0:	e8 7b ce ff ff       	call   f0101a30 <clear_screen_buffer>
	return 0;
f0104bb5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104bba:	c9                   	leave  
f0104bbb:	c3                   	ret    

f0104bbc <read_disk_page>:
void __pf_remove_env_all_tables(struct Env* ptr_env);
void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address);


int read_disk_page(uint32 dfn, void* va)
{
f0104bbc:	55                   	push   %ebp
f0104bbd:	89 e5                	mov    %esp,%ebp
f0104bbf:	83 ec 18             	sub    $0x18,%esp
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0104bc2:	8b 45 08             	mov    0x8(%ebp),%eax
f0104bc5:	05 00 14 00 00       	add    $0x1400,%eax
f0104bca:	c1 e0 03             	shl    $0x3,%eax
f0104bcd:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf("reading from disk to mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_read(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0104bd0:	83 ec 04             	sub    $0x4,%esp
f0104bd3:	6a 08                	push   $0x8
f0104bd5:	ff 75 0c             	pushl  0xc(%ebp)
f0104bd8:	ff 75 f4             	pushl  -0xc(%ebp)
f0104bdb:	e8 3d 67 01 00       	call   f011b31d <ide_read>
f0104be0:	83 c4 10             	add    $0x10,%esp
f0104be3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf("read from disk successuflly.\n");} else {cprintf("read from disk failed !!\n");} );

	return success;
f0104be6:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104be9:	c9                   	leave  
f0104bea:	c3                   	ret    

f0104beb <write_disk_page>:


int write_disk_page(uint32 dfn, void* va)
{
f0104beb:	55                   	push   %ebp
f0104bec:	89 e5                	mov    %esp,%ebp
f0104bee:	83 ec 18             	sub    $0x18,%esp
	//write disk at wanted frame
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0104bf1:	8b 45 08             	mov    0x8(%ebp),%eax
f0104bf4:	05 00 14 00 00       	add    $0x1400,%eax
f0104bf9:	c1 e0 03             	shl    $0x3,%eax
f0104bfc:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf(">>> writing to disk from mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_write(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0104bff:	83 ec 04             	sub    $0x4,%esp
f0104c02:	6a 08                	push   $0x8
f0104c04:	ff 75 0c             	pushl  0xc(%ebp)
f0104c07:	ff 75 f4             	pushl  -0xc(%ebp)
f0104c0a:	e8 65 68 01 00       	call   f011b474 <ide_write>
f0104c0f:	83 c4 10             	add    $0x10,%esp
f0104c12:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf(">>> written to disk successfully.\n");} else {cprintf(">>> written to disk failed !!\n");} );

	if(success != 0)
f0104c15:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104c19:	74 14                	je     f0104c2f <write_disk_page+0x44>
		panic("Error writing on disk\n");
f0104c1b:	83 ec 04             	sub    $0x4,%esp
f0104c1e:	68 c4 dc 12 f0       	push   $0xf012dcc4
f0104c23:	6a 2f                	push   $0x2f
f0104c25:	68 db dc 12 f0       	push   $0xf012dcdb
f0104c2a:	e8 80 c2 ff ff       	call   f0100eaf <_panic>
	return success;
f0104c2f:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104c32:	c9                   	leave  
f0104c33:	c3                   	ret    

f0104c34 <initialize_disk_page_file>:
// After this point, ONLY use the functions below
// to allocate and deallocate physical memory via the disk_free_frame_list,
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//
void initialize_disk_page_file()
{
f0104c34:	55                   	push   %ebp
f0104c35:	89 e5                	mov    %esp,%ebp
f0104c37:	53                   	push   %ebx
f0104c38:	83 ec 14             	sub    $0x14,%esp
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);
f0104c3b:	c7 05 e0 6c 85 f0 00 	movl   $0x0,0xf0856ce0
f0104c42:	00 00 00 
f0104c45:	c7 05 e4 6c 85 f0 00 	movl   $0x0,0xf0856ce4
f0104c4c:	00 00 00 
f0104c4f:	c7 05 ec 6c 85 f0 00 	movl   $0x0,0xf0856cec
f0104c56:	00 00 00 

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0104c59:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f0104c60:	e9 ef 00 00 00       	jmp    f0104d54 <initialize_disk_page_file+0x120>
	{
		initialize_frame_info(&(disk_frames_info[i]));
f0104c65:	8b 0d 44 e5 83 f0    	mov    0xf083e544,%ecx
f0104c6b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104c6e:	89 d0                	mov    %edx,%eax
f0104c70:	c1 e0 02             	shl    $0x2,%eax
f0104c73:	01 d0                	add    %edx,%eax
f0104c75:	c1 e0 02             	shl    $0x2,%eax
f0104c78:	01 c8                	add    %ecx,%eax
f0104c7a:	83 ec 0c             	sub    $0xc,%esp
f0104c7d:	50                   	push   %eax
f0104c7e:	e8 a4 43 00 00       	call   f0109027 <initialize_frame_info>
f0104c83:	83 c4 10             	add    $0x10,%esp

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
f0104c86:	8b 0d 44 e5 83 f0    	mov    0xf083e544,%ecx
f0104c8c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104c8f:	89 d0                	mov    %edx,%eax
f0104c91:	c1 e0 02             	shl    $0x2,%eax
f0104c94:	01 d0                	add    %edx,%eax
f0104c96:	c1 e0 02             	shl    $0x2,%eax
f0104c99:	01 c8                	add    %ecx,%eax
f0104c9b:	85 c0                	test   %eax,%eax
f0104c9d:	75 14                	jne    f0104cb3 <initialize_disk_page_file+0x7f>
f0104c9f:	83 ec 04             	sub    $0x4,%esp
f0104ca2:	68 f8 dc 12 f0       	push   $0xf012dcf8
f0104ca7:	6a 56                	push   $0x56
f0104ca9:	68 db dc 12 f0       	push   $0xf012dcdb
f0104cae:	e8 fc c1 ff ff       	call   f0100eaf <_panic>
f0104cb3:	8b 0d 44 e5 83 f0    	mov    0xf083e544,%ecx
f0104cb9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104cbc:	89 d0                	mov    %edx,%eax
f0104cbe:	c1 e0 02             	shl    $0x2,%eax
f0104cc1:	01 d0                	add    %edx,%eax
f0104cc3:	c1 e0 02             	shl    $0x2,%eax
f0104cc6:	01 c8                	add    %ecx,%eax
f0104cc8:	8b 15 e0 6c 85 f0    	mov    0xf0856ce0,%edx
f0104cce:	89 10                	mov    %edx,(%eax)
f0104cd0:	8b 00                	mov    (%eax),%eax
f0104cd2:	85 c0                	test   %eax,%eax
f0104cd4:	74 20                	je     f0104cf6 <initialize_disk_page_file+0xc2>
f0104cd6:	8b 15 e0 6c 85 f0    	mov    0xf0856ce0,%edx
f0104cdc:	8b 1d 44 e5 83 f0    	mov    0xf083e544,%ebx
f0104ce2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0104ce5:	89 c8                	mov    %ecx,%eax
f0104ce7:	c1 e0 02             	shl    $0x2,%eax
f0104cea:	01 c8                	add    %ecx,%eax
f0104cec:	c1 e0 02             	shl    $0x2,%eax
f0104cef:	01 d8                	add    %ebx,%eax
f0104cf1:	89 42 04             	mov    %eax,0x4(%edx)
f0104cf4:	eb 1a                	jmp    f0104d10 <initialize_disk_page_file+0xdc>
f0104cf6:	8b 0d 44 e5 83 f0    	mov    0xf083e544,%ecx
f0104cfc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104cff:	89 d0                	mov    %edx,%eax
f0104d01:	c1 e0 02             	shl    $0x2,%eax
f0104d04:	01 d0                	add    %edx,%eax
f0104d06:	c1 e0 02             	shl    $0x2,%eax
f0104d09:	01 c8                	add    %ecx,%eax
f0104d0b:	a3 e4 6c 85 f0       	mov    %eax,0xf0856ce4
f0104d10:	8b 0d 44 e5 83 f0    	mov    0xf083e544,%ecx
f0104d16:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104d19:	89 d0                	mov    %edx,%eax
f0104d1b:	c1 e0 02             	shl    $0x2,%eax
f0104d1e:	01 d0                	add    %edx,%eax
f0104d20:	c1 e0 02             	shl    $0x2,%eax
f0104d23:	01 c8                	add    %ecx,%eax
f0104d25:	a3 e0 6c 85 f0       	mov    %eax,0xf0856ce0
f0104d2a:	8b 0d 44 e5 83 f0    	mov    0xf083e544,%ecx
f0104d30:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104d33:	89 d0                	mov    %edx,%eax
f0104d35:	c1 e0 02             	shl    $0x2,%eax
f0104d38:	01 d0                	add    %edx,%eax
f0104d3a:	c1 e0 02             	shl    $0x2,%eax
f0104d3d:	01 c8                	add    %ecx,%eax
f0104d3f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0104d46:	a1 ec 6c 85 f0       	mov    0xf0856cec,%eax
f0104d4b:	40                   	inc    %eax
f0104d4c:	a3 ec 6c 85 f0       	mov    %eax,0xf0856cec
{
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0104d51:	ff 45 f4             	incl   -0xc(%ebp)
f0104d54:	81 7d f4 ff 07 02 00 	cmpl   $0x207ff,-0xc(%ebp)
f0104d5b:	0f 8e 04 ff ff ff    	jle    f0104c65 <initialize_disk_page_file+0x31>

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
	}

	init_kspinlock(&DiskFrameLists.dfllock, "Disk FrameList Lock");
f0104d61:	83 ec 08             	sub    $0x8,%esp
f0104d64:	68 1b dd 12 f0       	push   $0xf012dd1b
f0104d69:	68 f0 6c 85 f0       	push   $0xf0856cf0
f0104d6e:	e8 d7 af 00 00       	call   f010fd4a <init_kspinlock>
f0104d73:	83 c4 10             	add    $0x10,%esp
}
f0104d76:	90                   	nop
f0104d77:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104d7a:	c9                   	leave  
f0104d7b:	c3                   	ret    

f0104d7c <to_disk_frame_number>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
static inline uint32 to_disk_frame_number(struct FrameInfo *ptr_frame_info)
{
f0104d7c:	55                   	push   %ebp
f0104d7d:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - disk_frames_info;
f0104d7f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d82:	8b 15 44 e5 83 f0    	mov    0xf083e544,%edx
f0104d88:	29 d0                	sub    %edx,%eax
f0104d8a:	c1 f8 02             	sar    $0x2,%eax
f0104d8d:	89 c2                	mov    %eax,%edx
f0104d8f:	89 d0                	mov    %edx,%eax
f0104d91:	c1 e0 02             	shl    $0x2,%eax
f0104d94:	01 d0                	add    %edx,%eax
f0104d96:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0104d9d:	01 c8                	add    %ecx,%eax
f0104d9f:	01 c0                	add    %eax,%eax
f0104da1:	01 d0                	add    %edx,%eax
f0104da3:	89 c1                	mov    %eax,%ecx
f0104da5:	c1 e1 08             	shl    $0x8,%ecx
f0104da8:	01 c8                	add    %ecx,%eax
f0104daa:	89 c1                	mov    %eax,%ecx
f0104dac:	c1 e1 10             	shl    $0x10,%ecx
f0104daf:	01 c8                	add    %ecx,%eax
f0104db1:	c1 e0 02             	shl    $0x2,%eax
f0104db4:	01 d0                	add    %edx,%eax
}
f0104db6:	5d                   	pop    %ebp
f0104db7:	c3                   	ret    

f0104db8 <allocate_disk_frame>:
// RETURNS
//   0 -- on success
//   E_NO_PAGE_FILE_SPACE -- otherwise
//
int allocate_disk_frame(uint32 *dfn)
{
f0104db8:	55                   	push   %ebp
f0104db9:	89 e5                	mov    %esp,%ebp
f0104dbb:	83 ec 18             	sub    $0x18,%esp
	int ret = 0;
f0104dbe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_kspinlock(&DiskFrameLists.dfllock);
f0104dc5:	83 ec 0c             	sub    $0xc,%esp
f0104dc8:	68 f0 6c 85 f0       	push   $0xf0856cf0
f0104dcd:	e8 a9 af 00 00       	call   f010fd7b <acquire_kspinlock>
f0104dd2:	83 c4 10             	add    $0x10,%esp
	{
		// Fill this function in
		struct FrameInfo *ptr_frame_info = LIST_FIRST(&DiskFrameLists.disk_free_frame_list);
f0104dd5:	a1 e0 6c 85 f0       	mov    0xf0856ce0,%eax
f0104dda:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(ptr_frame_info == NULL)
f0104ddd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104de1:	75 0c                	jne    f0104def <allocate_disk_frame+0x37>
		{
			ret = E_NO_PAGE_FILE_SPACE;
f0104de3:	c7 45 f4 f8 ff ff ff 	movl   $0xfffffff8,-0xc(%ebp)
f0104dea:	e9 a2 00 00 00       	jmp    f0104e91 <allocate_disk_frame+0xd9>
		}
		else
		{
			LIST_REMOVE(&DiskFrameLists.disk_free_frame_list, ptr_frame_info);
f0104def:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104df3:	75 14                	jne    f0104e09 <allocate_disk_frame+0x51>
f0104df5:	83 ec 04             	sub    $0x4,%esp
f0104df8:	68 2f dd 12 f0       	push   $0xf012dd2f
f0104dfd:	6a 7d                	push   $0x7d
f0104dff:	68 db dc 12 f0       	push   $0xf012dcdb
f0104e04:	e8 a6 c0 ff ff       	call   f0100eaf <_panic>
f0104e09:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104e0c:	8b 00                	mov    (%eax),%eax
f0104e0e:	85 c0                	test   %eax,%eax
f0104e10:	74 10                	je     f0104e22 <allocate_disk_frame+0x6a>
f0104e12:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104e15:	8b 00                	mov    (%eax),%eax
f0104e17:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104e1a:	8b 52 04             	mov    0x4(%edx),%edx
f0104e1d:	89 50 04             	mov    %edx,0x4(%eax)
f0104e20:	eb 0b                	jmp    f0104e2d <allocate_disk_frame+0x75>
f0104e22:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104e25:	8b 40 04             	mov    0x4(%eax),%eax
f0104e28:	a3 e4 6c 85 f0       	mov    %eax,0xf0856ce4
f0104e2d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104e30:	8b 40 04             	mov    0x4(%eax),%eax
f0104e33:	85 c0                	test   %eax,%eax
f0104e35:	74 0f                	je     f0104e46 <allocate_disk_frame+0x8e>
f0104e37:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104e3a:	8b 40 04             	mov    0x4(%eax),%eax
f0104e3d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104e40:	8b 12                	mov    (%edx),%edx
f0104e42:	89 10                	mov    %edx,(%eax)
f0104e44:	eb 0a                	jmp    f0104e50 <allocate_disk_frame+0x98>
f0104e46:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104e49:	8b 00                	mov    (%eax),%eax
f0104e4b:	a3 e0 6c 85 f0       	mov    %eax,0xf0856ce0
f0104e50:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104e53:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0104e59:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104e5c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0104e63:	a1 ec 6c 85 f0       	mov    0xf0856cec,%eax
f0104e68:	48                   	dec    %eax
f0104e69:	a3 ec 6c 85 f0       	mov    %eax,0xf0856cec
			initialize_frame_info(ptr_frame_info);
f0104e6e:	83 ec 0c             	sub    $0xc,%esp
f0104e71:	ff 75 f0             	pushl  -0x10(%ebp)
f0104e74:	e8 ae 41 00 00       	call   f0109027 <initialize_frame_info>
f0104e79:	83 c4 10             	add    $0x10,%esp
			*dfn = to_disk_frame_number(ptr_frame_info);
f0104e7c:	83 ec 0c             	sub    $0xc,%esp
f0104e7f:	ff 75 f0             	pushl  -0x10(%ebp)
f0104e82:	e8 f5 fe ff ff       	call   f0104d7c <to_disk_frame_number>
f0104e87:	83 c4 10             	add    $0x10,%esp
f0104e8a:	89 c2                	mov    %eax,%edx
f0104e8c:	8b 45 08             	mov    0x8(%ebp),%eax
f0104e8f:	89 10                	mov    %edx,(%eax)
		}
	}
	release_kspinlock(&DiskFrameLists.dfllock);
f0104e91:	83 ec 0c             	sub    $0xc,%esp
f0104e94:	68 f0 6c 85 f0       	push   $0xf0856cf0
f0104e99:	e8 82 af 00 00       	call   f010fe20 <release_kspinlock>
f0104e9e:	83 c4 10             	add    $0x10,%esp

	return ret;
f0104ea1:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0104ea4:	c9                   	leave  
f0104ea5:	c3                   	ret    

f0104ea6 <free_disk_frame>:

//
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
f0104ea6:	55                   	push   %ebp
f0104ea7:	89 e5                	mov    %esp,%ebp
f0104ea9:	53                   	push   %ebx
f0104eaa:	83 ec 04             	sub    $0x4,%esp
	// Fill this function in
	if(dfn == 0) return;
f0104ead:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104eb1:	0f 84 f0 00 00 00    	je     f0104fa7 <free_disk_frame+0x101>
	acquire_kspinlock(&DiskFrameLists.dfllock);
f0104eb7:	83 ec 0c             	sub    $0xc,%esp
f0104eba:	68 f0 6c 85 f0       	push   $0xf0856cf0
f0104ebf:	e8 b7 ae 00 00       	call   f010fd7b <acquire_kspinlock>
f0104ec4:	83 c4 10             	add    $0x10,%esp
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
f0104ec7:	8b 0d 44 e5 83 f0    	mov    0xf083e544,%ecx
f0104ecd:	8b 55 08             	mov    0x8(%ebp),%edx
f0104ed0:	89 d0                	mov    %edx,%eax
f0104ed2:	c1 e0 02             	shl    $0x2,%eax
f0104ed5:	01 d0                	add    %edx,%eax
f0104ed7:	c1 e0 02             	shl    $0x2,%eax
f0104eda:	01 c8                	add    %ecx,%eax
f0104edc:	85 c0                	test   %eax,%eax
f0104ede:	75 17                	jne    f0104ef7 <free_disk_frame+0x51>
f0104ee0:	83 ec 04             	sub    $0x4,%esp
f0104ee3:	68 f8 dc 12 f0       	push   $0xf012dcf8
f0104ee8:	68 90 00 00 00       	push   $0x90
f0104eed:	68 db dc 12 f0       	push   $0xf012dcdb
f0104ef2:	e8 b8 bf ff ff       	call   f0100eaf <_panic>
f0104ef7:	8b 0d 44 e5 83 f0    	mov    0xf083e544,%ecx
f0104efd:	8b 55 08             	mov    0x8(%ebp),%edx
f0104f00:	89 d0                	mov    %edx,%eax
f0104f02:	c1 e0 02             	shl    $0x2,%eax
f0104f05:	01 d0                	add    %edx,%eax
f0104f07:	c1 e0 02             	shl    $0x2,%eax
f0104f0a:	01 c8                	add    %ecx,%eax
f0104f0c:	8b 15 e0 6c 85 f0    	mov    0xf0856ce0,%edx
f0104f12:	89 10                	mov    %edx,(%eax)
f0104f14:	8b 00                	mov    (%eax),%eax
f0104f16:	85 c0                	test   %eax,%eax
f0104f18:	74 20                	je     f0104f3a <free_disk_frame+0x94>
f0104f1a:	8b 15 e0 6c 85 f0    	mov    0xf0856ce0,%edx
f0104f20:	8b 1d 44 e5 83 f0    	mov    0xf083e544,%ebx
f0104f26:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0104f29:	89 c8                	mov    %ecx,%eax
f0104f2b:	c1 e0 02             	shl    $0x2,%eax
f0104f2e:	01 c8                	add    %ecx,%eax
f0104f30:	c1 e0 02             	shl    $0x2,%eax
f0104f33:	01 d8                	add    %ebx,%eax
f0104f35:	89 42 04             	mov    %eax,0x4(%edx)
f0104f38:	eb 1a                	jmp    f0104f54 <free_disk_frame+0xae>
f0104f3a:	8b 0d 44 e5 83 f0    	mov    0xf083e544,%ecx
f0104f40:	8b 55 08             	mov    0x8(%ebp),%edx
f0104f43:	89 d0                	mov    %edx,%eax
f0104f45:	c1 e0 02             	shl    $0x2,%eax
f0104f48:	01 d0                	add    %edx,%eax
f0104f4a:	c1 e0 02             	shl    $0x2,%eax
f0104f4d:	01 c8                	add    %ecx,%eax
f0104f4f:	a3 e4 6c 85 f0       	mov    %eax,0xf0856ce4
f0104f54:	8b 0d 44 e5 83 f0    	mov    0xf083e544,%ecx
f0104f5a:	8b 55 08             	mov    0x8(%ebp),%edx
f0104f5d:	89 d0                	mov    %edx,%eax
f0104f5f:	c1 e0 02             	shl    $0x2,%eax
f0104f62:	01 d0                	add    %edx,%eax
f0104f64:	c1 e0 02             	shl    $0x2,%eax
f0104f67:	01 c8                	add    %ecx,%eax
f0104f69:	a3 e0 6c 85 f0       	mov    %eax,0xf0856ce0
f0104f6e:	8b 0d 44 e5 83 f0    	mov    0xf083e544,%ecx
f0104f74:	8b 55 08             	mov    0x8(%ebp),%edx
f0104f77:	89 d0                	mov    %edx,%eax
f0104f79:	c1 e0 02             	shl    $0x2,%eax
f0104f7c:	01 d0                	add    %edx,%eax
f0104f7e:	c1 e0 02             	shl    $0x2,%eax
f0104f81:	01 c8                	add    %ecx,%eax
f0104f83:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0104f8a:	a1 ec 6c 85 f0       	mov    0xf0856cec,%eax
f0104f8f:	40                   	inc    %eax
f0104f90:	a3 ec 6c 85 f0       	mov    %eax,0xf0856cec
	}
	release_kspinlock(&DiskFrameLists.dfllock);
f0104f95:	83 ec 0c             	sub    $0xc,%esp
f0104f98:	68 f0 6c 85 f0       	push   $0xf0856cf0
f0104f9d:	e8 7e ae 00 00       	call   f010fe20 <release_kspinlock>
f0104fa2:	83 c4 10             	add    $0x10,%esp
f0104fa5:	eb 01                	jmp    f0104fa8 <free_disk_frame+0x102>
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
	// Fill this function in
	if(dfn == 0) return;
f0104fa7:	90                   	nop
	acquire_kspinlock(&DiskFrameLists.dfllock);
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
	}
	release_kspinlock(&DiskFrameLists.dfllock);
}
f0104fa8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104fab:	c9                   	leave  
f0104fac:	c3                   	ret    

f0104fad <get_disk_page_table>:

int get_disk_page_table(uint32 *ptr_disk_page_directory, const uint32 virtual_address, int create, uint32 **ptr_disk_page_table)
{
f0104fad:	55                   	push   %ebp
f0104fae:	89 e5                	mov    %esp,%ebp
f0104fb0:	53                   	push   %ebx
f0104fb1:	83 ec 14             	sub    $0x14,%esp
	// Fill this function in
	uint32 disk_page_directory_entry = ptr_disk_page_directory[PDX(virtual_address)];
f0104fb4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104fb7:	c1 e8 16             	shr    $0x16,%eax
f0104fba:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104fc1:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fc4:	01 d0                	add    %edx,%eax
f0104fc6:	8b 00                	mov    (%eax),%eax
f0104fc8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0104fcb:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0104fd2:	77 1d                	ja     f0104ff1 <get_disk_page_table+0x44>
	{
		*ptr_disk_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(disk_page_directory_entry));
f0104fd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104fd7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104fdc:	83 ec 0c             	sub    $0xc,%esp
f0104fdf:	50                   	push   %eax
f0104fe0:	e8 85 4b 00 00       	call   f0109b6a <kheap_virtual_address>
f0104fe5:	83 c4 10             	add    $0x10,%esp
f0104fe8:	89 c2                	mov    %eax,%edx
f0104fea:	8b 45 14             	mov    0x14(%ebp),%eax
f0104fed:	89 10                	mov    %edx,(%eax)
f0104fef:	eb 44                	jmp    f0105035 <get_disk_page_table+0x88>
	}
	else
	{
		*ptr_disk_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(disk_page_directory_entry)) ;
f0104ff1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104ff4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0104ff9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0104ffc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104fff:	c1 e8 0c             	shr    $0xc,%eax
f0105002:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0105005:	a1 b8 e9 83 f0       	mov    0xf083e9b8,%eax
f010500a:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f010500d:	72 17                	jb     f0105026 <get_disk_page_table+0x79>
f010500f:	ff 75 f0             	pushl  -0x10(%ebp)
f0105012:	68 50 dd 12 f0       	push   $0xf012dd50
f0105017:	68 9f 00 00 00       	push   $0x9f
f010501c:	68 db dc 12 f0       	push   $0xf012dcdb
f0105021:	e8 89 be ff ff       	call   f0100eaf <_panic>
f0105026:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105029:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010502e:	89 c2                	mov    %eax,%edx
f0105030:	8b 45 14             	mov    0x14(%ebp),%eax
f0105033:	89 10                	mov    %edx,(%eax)
	}

	if (disk_page_directory_entry == 0)
f0105035:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105039:	0f 85 80 00 00 00    	jne    f01050bf <get_disk_page_table+0x112>
	{
		//LOG_STATMENT(cprintf("get_disk_page_table: disk directory at %x",ptr_disk_page_directory));
		//LOG_STATMENT(cprintf("get_disk_page_table: page table not found "));
		if (create)
f010503f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0105043:	74 6a                	je     f01050af <get_disk_page_table+0x102>
		{

#if USE_KHEAP
			{
				*ptr_disk_page_table = (uint32*)kmalloc(PAGE_SIZE);
f0105045:	83 ec 0c             	sub    $0xc,%esp
f0105048:	68 00 10 00 00       	push   $0x1000
f010504d:	e8 e4 4a 00 00       	call   f0109b36 <kmalloc>
f0105052:	83 c4 10             	add    $0x10,%esp
f0105055:	89 c2                	mov    %eax,%edx
f0105057:	8b 45 14             	mov    0x14(%ebp),%eax
f010505a:	89 10                	mov    %edx,(%eax)
				if(*ptr_disk_page_table == NULL)
f010505c:	8b 45 14             	mov    0x14(%ebp),%eax
f010505f:	8b 00                	mov    (%eax),%eax
f0105061:	85 c0                	test   %eax,%eax
f0105063:	75 07                	jne    f010506c <get_disk_page_table+0xbf>
				{
					return E_NO_VM;
f0105065:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f010506a:	eb 58                	jmp    f01050c4 <get_disk_page_table+0x117>
				}
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f010506c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010506f:	c1 e8 16             	shr    $0x16,%eax
f0105072:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0105079:	8b 45 08             	mov    0x8(%ebp),%eax
f010507c:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f010507f:	8b 45 14             	mov    0x14(%ebp),%eax
f0105082:	8b 00                	mov    (%eax),%eax
f0105084:	83 ec 0c             	sub    $0xc,%esp
f0105087:	50                   	push   %eax
f0105088:	e8 f7 4a 00 00       	call   f0109b84 <kheap_physical_address>
f010508d:	83 c4 10             	add    $0x10,%esp
f0105090:	83 c8 01             	or     $0x1,%eax
f0105093:	89 03                	mov    %eax,(%ebx)
				ptr_frame_info->references = 1;
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table,PERM_PRESENT);
			}
#endif
			//initialize new page table by 0's
			memset(*ptr_disk_page_table , 0, PAGE_SIZE);
f0105095:	8b 45 14             	mov    0x14(%ebp),%eax
f0105098:	8b 00                	mov    (%eax),%eax
f010509a:	83 ec 04             	sub    $0x4,%esp
f010509d:	68 00 10 00 00       	push   $0x1000
f01050a2:	6a 00                	push   $0x0
f01050a4:	50                   	push   %eax
f01050a5:	e8 bf 5b 01 00       	call   f011ac69 <memset>
f01050aa:	83 c4 10             	add    $0x10,%esp
f01050ad:	eb 10                	jmp    f01050bf <get_disk_page_table+0x112>
			//virtual_address, ptr_disk_page_directory[PDX(virtual_address)]));
		}
		else
		{
			//LOG_STATMENT(cprintf("NOT creating table ..."));
			*ptr_disk_page_table = 0;
f01050af:	8b 45 14             	mov    0x14(%ebp),%eax
f01050b2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			return 0;
f01050b8:	b8 00 00 00 00       	mov    $0x0,%eax
f01050bd:	eb 05                	jmp    f01050c4 <get_disk_page_table+0x117>
		}
	}
	//LOG_STATMENT(cprintf("found table at %x", *ptr_disk_page_table));
	return 0;
f01050bf:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01050c4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01050c7:	c9                   	leave  
f01050c8:	c3                   	ret    

f01050c9 <pf_add_empty_env_page>:

int pf_add_empty_env_page( struct Env* ptr_env, uint32 virtual_address, uint8 initializeByZero)
{
f01050c9:	55                   	push   %ebp
f01050ca:	89 e5                	mov    %esp,%ebp
f01050cc:	83 ec 28             	sub    $0x28,%esp
f01050cf:	8b 45 10             	mov    0x10(%ebp),%eax
f01050d2:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//2016: FIX:
	if (initializeByZero)
f01050d5:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
f01050d9:	74 72                	je     f010514d <pf_add_empty_env_page+0x84>
	{
		//2020
		if (virtual_address > USTACKBOTTOM && virtual_address < USTACKTOP - ptr_env->initNumStackPages * PAGE_SIZE)
f01050db:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f01050e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050e5:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f01050ea:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01050ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01050f0:	ba 00 00 00 00       	mov    $0x0,%edx
f01050f5:	f7 75 f4             	divl   -0xc(%ebp)
f01050f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01050fb:	29 d0                	sub    %edx,%eax
f01050fd:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0105100:	73 2f                	jae    f0105131 <pf_add_empty_env_page+0x68>
f0105102:	8b 45 08             	mov    0x8(%ebp),%eax
f0105105:	8b 50 6c             	mov    0x6c(%eax),%edx
f0105108:	b8 00 00 00 00       	mov    $0x0,%eax
f010510d:	29 d0                	sub    %edx,%eax
f010510f:	c1 e0 0c             	shl    $0xc,%eax
f0105112:	2d 00 20 40 11       	sub    $0x11402000,%eax
f0105117:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010511a:	76 15                	jbe    f0105131 <pf_add_empty_env_page+0x68>
			ptr_env->nNewPageAdded++ ;
f010511c:	8b 45 08             	mov    0x8(%ebp),%eax
f010511f:	8b 80 bc 05 00 00    	mov    0x5bc(%eax),%eax
f0105125:	8d 50 01             	lea    0x1(%eax),%edx
f0105128:	8b 45 08             	mov    0x8(%ebp),%eax
f010512b:	89 90 bc 05 00 00    	mov    %edx,0x5bc(%eax)
		//======================
		return pf_add_env_page(ptr_env, virtual_address, ptr_zero_page);
f0105131:	a1 18 6b 85 f0       	mov    0xf0856b18,%eax
f0105136:	83 ec 04             	sub    $0x4,%esp
f0105139:	50                   	push   %eax
f010513a:	ff 75 0c             	pushl  0xc(%ebp)
f010513d:	ff 75 08             	pushl  0x8(%ebp)
f0105140:	e8 b2 00 00 00       	call   f01051f7 <pf_add_env_page>
f0105145:	83 c4 10             	add    $0x10,%esp
f0105148:	e9 a8 00 00 00       	jmp    f01051f5 <pf_add_empty_env_page+0x12c>
	}

	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f010514d:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0105154:	76 19                	jbe    f010516f <pf_add_empty_env_page+0xa6>
f0105156:	68 80 dd 12 f0       	push   $0xf012dd80
f010515b:	68 a6 dd 12 f0       	push   $0xf012dda6
f0105160:	68 de 00 00 00       	push   $0xde
f0105165:	68 db dc 12 f0       	push   $0xf012dcdb
f010516a:	e8 40 bd ff ff       	call   f0100eaf <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f010516f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105172:	83 c0 74             	add    $0x74,%eax
f0105175:	83 ec 08             	sub    $0x8,%esp
f0105178:	50                   	push   %eax
f0105179:	ff 75 08             	pushl  0x8(%ebp)
f010517c:	e8 8f 05 00 00       	call   f0105710 <get_disk_page_directory>
f0105181:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f0105184:	8b 45 08             	mov    0x8(%ebp),%eax
f0105187:	8b 40 74             	mov    0x74(%eax),%eax
f010518a:	8d 55 ec             	lea    -0x14(%ebp),%edx
f010518d:	52                   	push   %edx
f010518e:	6a 01                	push   $0x1
f0105190:	ff 75 0c             	pushl  0xc(%ebp)
f0105193:	50                   	push   %eax
f0105194:	e8 14 fe ff ff       	call   f0104fad <get_disk_page_table>
f0105199:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f010519c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010519f:	8b 55 0c             	mov    0xc(%ebp),%edx
f01051a2:	c1 ea 0c             	shr    $0xc,%edx
f01051a5:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01051ab:	c1 e2 02             	shl    $0x2,%edx
f01051ae:	01 d0                	add    %edx,%eax
f01051b0:	8b 00                	mov    (%eax),%eax
f01051b2:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if( dfn == 0)
f01051b5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01051b8:	85 c0                	test   %eax,%eax
f01051ba:	75 34                	jne    f01051f0 <pf_add_empty_env_page+0x127>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01051bc:	83 ec 0c             	sub    $0xc,%esp
f01051bf:	8d 45 e8             	lea    -0x18(%ebp),%eax
f01051c2:	50                   	push   %eax
f01051c3:	e8 f0 fb ff ff       	call   f0104db8 <allocate_disk_frame>
f01051c8:	83 c4 10             	add    $0x10,%esp
f01051cb:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01051ce:	75 07                	jne    f01051d7 <pf_add_empty_env_page+0x10e>
f01051d0:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f01051d5:	eb 1e                	jmp    f01051f5 <pf_add_empty_env_page+0x12c>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f01051d7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01051da:	8b 55 0c             	mov    0xc(%ebp),%edx
f01051dd:	c1 ea 0c             	shr    $0xc,%edx
f01051e0:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01051e6:	c1 e2 02             	shl    $0x2,%edx
f01051e9:	01 c2                	add    %eax,%edx
f01051eb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01051ee:	89 02                	mov    %eax,(%edx)
	}

	return 0;
f01051f0:	b8 00 00 00 00       	mov    $0x0,%eax

}
f01051f5:	c9                   	leave  
f01051f6:	c3                   	ret    

f01051f7 <pf_add_env_page>:

int pf_add_env_page( struct Env* ptr_env, uint32 virtual_address, void* dataSrc)
{
f01051f7:	55                   	push   %ebp
f01051f8:	89 e5                	mov    %esp,%ebp
f01051fa:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f01051fd:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0105204:	76 19                	jbe    f010521f <pf_add_env_page+0x28>
f0105206:	68 80 dd 12 f0       	push   $0xf012dd80
f010520b:	68 a6 dd 12 f0       	push   $0xf012dda6
f0105210:	68 f3 00 00 00       	push   $0xf3
f0105215:	68 db dc 12 f0       	push   $0xf012dcdb
f010521a:	e8 90 bc ff ff       	call   f0100eaf <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f010521f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105222:	83 c0 74             	add    $0x74,%eax
f0105225:	83 ec 08             	sub    $0x8,%esp
f0105228:	50                   	push   %eax
f0105229:	ff 75 08             	pushl  0x8(%ebp)
f010522c:	e8 df 04 00 00       	call   f0105710 <get_disk_page_directory>
f0105231:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f0105234:	8b 45 08             	mov    0x8(%ebp),%eax
f0105237:	8b 40 74             	mov    0x74(%eax),%eax
f010523a:	8d 55 f0             	lea    -0x10(%ebp),%edx
f010523d:	52                   	push   %edx
f010523e:	6a 01                	push   $0x1
f0105240:	ff 75 0c             	pushl  0xc(%ebp)
f0105243:	50                   	push   %eax
f0105244:	e8 64 fd ff ff       	call   f0104fad <get_disk_page_table>
f0105249:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f010524c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010524f:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105252:	c1 ea 0c             	shr    $0xc,%edx
f0105255:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010525b:	c1 e2 02             	shl    $0x2,%edx
f010525e:	01 d0                	add    %edx,%eax
f0105260:	8b 00                	mov    (%eax),%eax
f0105262:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if( dfn == 0)
f0105265:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105268:	85 c0                	test   %eax,%eax
f010526a:	75 34                	jne    f01052a0 <pf_add_env_page+0xa9>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f010526c:	83 ec 0c             	sub    $0xc,%esp
f010526f:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0105272:	50                   	push   %eax
f0105273:	e8 40 fb ff ff       	call   f0104db8 <allocate_disk_frame>
f0105278:	83 c4 10             	add    $0x10,%esp
f010527b:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010527e:	75 07                	jne    f0105287 <pf_add_env_page+0x90>
f0105280:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f0105285:	eb 31                	jmp    f01052b8 <pf_add_env_page+0xc1>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f0105287:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010528a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010528d:	c1 ea 0c             	shr    $0xc,%edx
f0105290:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0105296:	c1 e2 02             	shl    $0x2,%edx
f0105299:	01 c2                	add    %eax,%edx
f010529b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010529e:	89 02                	mov    %eax,(%edx)
	//	uint32 oldDir = rcr3();
	//	lcr3(K_PHYSICAL_ADDRESS(ptr_env->env_pgdir));
	//	int ret = write_disk_page(dfn, (void*)dataSrc);
	//	lcr3(oldDir);

	int ret = write_disk_page(dfn, (void*)dataSrc);
f01052a0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01052a3:	83 ec 08             	sub    $0x8,%esp
f01052a6:	ff 75 10             	pushl  0x10(%ebp)
f01052a9:	50                   	push   %eax
f01052aa:	e8 3c f9 ff ff       	call   f0104beb <write_disk_page>
f01052af:	83 c4 10             	add    $0x10,%esp
f01052b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return ret;
f01052b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01052b8:	c9                   	leave  
f01052b9:	c3                   	ret    

f01052ba <pf_update_env_page>:

int pf_update_env_page(struct Env* ptr_env, uint32 virtual_address, struct FrameInfo* modified_page_frame_info)
{
f01052ba:	55                   	push   %ebp
f01052bb:	89 e5                	mov    %esp,%ebp
f01052bd:	83 ec 28             	sub    $0x28,%esp
	int ret;
	uint32 *ptr_disk_page_table;
	//ROUND DOWN it on 4 KB boundary in order to update the entire page starting from its first address.
	//virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);

	assert((uint32)virtual_address < KERNEL_BASE);
f01052c0:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f01052c7:	76 19                	jbe    f01052e2 <pf_update_env_page+0x28>
f01052c9:	68 80 dd 12 f0       	push   $0xf012dd80
f01052ce:	68 a6 dd 12 f0       	push   $0xf012dda6
f01052d3:	68 15 01 00 00       	push   $0x115
f01052d8:	68 db dc 12 f0       	push   $0xf012dcdb
f01052dd:	e8 cd bb ff ff       	call   f0100eaf <_panic>
	//char c = *((char*)virtual_address);
	//Get/Create the directory table
	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f01052e2:	8b 45 08             	mov    0x8(%ebp),%eax
f01052e5:	83 c0 74             	add    $0x74,%eax
f01052e8:	83 ec 08             	sub    $0x8,%esp
f01052eb:	50                   	push   %eax
f01052ec:	ff 75 08             	pushl  0x8(%ebp)
f01052ef:	e8 1c 04 00 00       	call   f0105710 <get_disk_page_directory>
f01052f4:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f01052f7:	8b 45 08             	mov    0x8(%ebp),%eax
f01052fa:	8b 40 74             	mov    0x74(%eax),%eax
f01052fd:	8d 55 e0             	lea    -0x20(%ebp),%edx
f0105300:	52                   	push   %edx
f0105301:	6a 00                	push   $0x0
f0105303:	ff 75 0c             	pushl  0xc(%ebp)
f0105306:	50                   	push   %eax
f0105307:	e8 a1 fc ff ff       	call   f0104fad <get_disk_page_table>
f010530c:	83 c4 10             	add    $0x10,%esp

	//2022
	if(ptr_disk_page_table == NULL || (ptr_disk_page_table != NULL && ptr_disk_page_table[PTX(virtual_address)]== 0))
f010530f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0105312:	85 c0                	test   %eax,%eax
f0105314:	74 29                	je     f010533f <pf_update_env_page+0x85>
f0105316:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0105319:	85 c0                	test   %eax,%eax
f010531b:	0f 84 bf 00 00 00    	je     f01053e0 <pf_update_env_page+0x126>
f0105321:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0105324:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105327:	c1 ea 0c             	shr    $0xc,%edx
f010532a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0105330:	c1 e2 02             	shl    $0x2,%edx
f0105333:	01 d0                	add    %edx,%eax
f0105335:	8b 00                	mov    (%eax),%eax
f0105337:	85 c0                	test   %eax,%eax
f0105339:	0f 85 a1 00 00 00    	jne    f01053e0 <pf_update_env_page+0x126>
	{

		if ((virtual_address >= USER_HEAP_START && virtual_address < USER_HEAP_MAX) ||
f010533f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105342:	85 c0                	test   %eax,%eax
f0105344:	79 09                	jns    f010534f <pf_update_env_page+0x95>
f0105346:	81 7d 0c ff ff ff 9f 	cmpl   $0x9fffffff,0xc(%ebp)
f010534d:	76 30                	jbe    f010537f <pf_update_env_page+0xc5>
				(virtual_address >= USTACKBOTTOM && virtual_address < USTACKTOP))
f010534f:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f0105356:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105359:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f010535e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0105361:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105364:	ba 00 00 00 00       	mov    $0x0,%edx
f0105369:	f7 75 f4             	divl   -0xc(%ebp)
f010536c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010536f:	29 d0                	sub    %edx,%eax

	//2022
	if(ptr_disk_page_table == NULL || (ptr_disk_page_table != NULL && ptr_disk_page_table[PTX(virtual_address)]== 0))
	{

		if ((virtual_address >= USER_HEAP_START && virtual_address < USER_HEAP_MAX) ||
f0105371:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0105374:	77 53                	ja     f01053c9 <pf_update_env_page+0x10f>
				(virtual_address >= USTACKBOTTOM && virtual_address < USTACKTOP))
f0105376:	81 7d 0c ff df bf ee 	cmpl   $0xeebfdfff,0xc(%ebp)
f010537d:	77 4a                	ja     f01053c9 <pf_update_env_page+0x10f>
			//				return ret ;
			//			}
			//			//Else, just add a new empty page to the page file, then update it with the given modified_page_frame_info in the below code
			//			else
			{
				ret = pf_add_empty_env_page(ptr_env, virtual_address, 0);
f010537f:	83 ec 04             	sub    $0x4,%esp
f0105382:	6a 00                	push   $0x0
f0105384:	ff 75 0c             	pushl  0xc(%ebp)
f0105387:	ff 75 08             	pushl  0x8(%ebp)
f010538a:	e8 3a fd ff ff       	call   f01050c9 <pf_add_empty_env_page>
f010538f:	83 c4 10             	add    $0x10,%esp
f0105392:	89 45 ec             	mov    %eax,-0x14(%ebp)

				if (ret == E_NO_PAGE_FILE_SPACE)
f0105395:	83 7d ec f8          	cmpl   $0xfffffff8,-0x14(%ebp)
f0105399:	75 17                	jne    f01053b2 <pf_update_env_page+0xf8>
				{
					panic("pf_update_env_page: attempt to add a new page, but page file out of space!") ;
f010539b:	83 ec 04             	sub    $0x4,%esp
f010539e:	68 bc dd 12 f0       	push   $0xf012ddbc
f01053a3:	68 45 01 00 00       	push   $0x145
f01053a8:	68 db dc 12 f0       	push   $0xf012dcdb
f01053ad:	e8 fd ba ff ff       	call   f0100eaf <_panic>
				}
				//cprintf("[%s] adding EMPTY page with content\n",ptr_env->prog_name);

				ptr_env->nNewPageAdded++ ;
f01053b2:	8b 45 08             	mov    0x8(%ebp),%eax
f01053b5:	8b 80 bc 05 00 00    	mov    0x5bc(%eax),%eax
f01053bb:	8d 50 01             	lea    0x1(%eax),%edx
f01053be:	8b 45 08             	mov    0x8(%ebp),%eax
f01053c1:	89 90 bc 05 00 00    	mov    %edx,0x5bc(%eax)
f01053c7:	eb 17                	jmp    f01053e0 <pf_update_env_page+0x126>
			}
		}
		else
		{
			panic("pf_update_env_page: Invalid Access - Attempt to add a new page to page file that's outside the USER HEAP and USER STACK!");
f01053c9:	83 ec 04             	sub    $0x4,%esp
f01053cc:	68 08 de 12 f0       	push   $0xf012de08
f01053d1:	68 4e 01 00 00       	push   $0x14e
f01053d6:	68 db dc 12 f0       	push   $0xf012dcdb
f01053db:	e8 cf ba ff ff       	call   f0100eaf <_panic>
		}
	}
	//2022 END========================================


	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f01053e0:	8b 45 08             	mov    0x8(%ebp),%eax
f01053e3:	8b 40 74             	mov    0x74(%eax),%eax
f01053e6:	8d 55 e0             	lea    -0x20(%ebp),%edx
f01053e9:	52                   	push   %edx
f01053ea:	6a 00                	push   $0x0
f01053ec:	ff 75 0c             	pushl  0xc(%ebp)
f01053ef:	50                   	push   %eax
f01053f0:	e8 b8 fb ff ff       	call   f0104fad <get_disk_page_table>
f01053f5:	83 c4 10             	add    $0x10,%esp
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01053f8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01053fb:	8b 55 0c             	mov    0xc(%ebp),%edx
f01053fe:	c1 ea 0c             	shr    $0xc,%edx
f0105401:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0105407:	c1 e2 02             	shl    $0x2,%edx
f010540a:	01 d0                	add    %edx,%eax
f010540c:	8b 00                	mov    (%eax),%eax
f010540e:	89 45 e8             	mov    %eax,-0x18(%ebp)

		//FIX'24 (el7): due to concurrency issues in 1-1 thread model, using the USER_LIMIT as a temp loc
		//				will lead to concurrency problems since it's shared among processes.
		//				Instead, use PGFLTEMP as a local temporarily page at user space for this mapping
		//				to do temp initialization of a frame.
		map_frame(ptr_env->env_page_directory, modified_page_frame_info, (uint32)PGFLTEMP, 0);
f0105411:	8b 45 08             	mov    0x8(%ebp),%eax
f0105414:	8b 40 64             	mov    0x64(%eax),%eax
f0105417:	6a 00                	push   $0x0
f0105419:	68 00 f0 3f 00       	push   $0x3ff000
f010541e:	ff 75 10             	pushl  0x10(%ebp)
f0105421:	50                   	push   %eax
f0105422:	e8 bc 40 00 00       	call   f01094e3 <map_frame>
f0105427:	83 c4 10             	add    $0x10,%esp

		ret = write_disk_page(dfn, (void*)ROUNDDOWN((uint32)PGFLTEMP, PAGE_SIZE));
f010542a:	c7 45 e4 00 f0 3f 00 	movl   $0x3ff000,-0x1c(%ebp)
f0105431:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105434:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0105439:	83 ec 08             	sub    $0x8,%esp
f010543c:	50                   	push   %eax
f010543d:	ff 75 e8             	pushl  -0x18(%ebp)
f0105440:	e8 a6 f7 ff ff       	call   f0104beb <write_disk_page>
f0105445:	83 c4 10             	add    $0x10,%esp
f0105448:	89 45 ec             	mov    %eax,-0x14(%ebp)

		// TEMPORARILY increase the references to prevent unmap_frame from removing the frame
		modified_page_frame_info->references += 1;
f010544b:	8b 45 10             	mov    0x10(%ebp),%eax
f010544e:	8b 40 08             	mov    0x8(%eax),%eax
f0105451:	40                   	inc    %eax
f0105452:	8b 55 10             	mov    0x10(%ebp),%edx
f0105455:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(ptr_env->env_page_directory, (uint32)PGFLTEMP);
f0105459:	8b 45 08             	mov    0x8(%ebp),%eax
f010545c:	8b 40 64             	mov    0x64(%eax),%eax
f010545f:	83 ec 08             	sub    $0x8,%esp
f0105462:	68 00 f0 3f 00       	push   $0x3ff000
f0105467:	50                   	push   %eax
f0105468:	e8 e2 41 00 00       	call   f010964f <unmap_frame>
f010546d:	83 c4 10             	add    $0x10,%esp
		// Return it to its original status
		modified_page_frame_info->references -= 1;
f0105470:	8b 45 10             	mov    0x10(%ebp),%eax
f0105473:	8b 40 08             	mov    0x8(%eax),%eax
f0105476:	48                   	dec    %eax
f0105477:	8b 55 10             	mov    0x10(%ebp),%edx
f010547a:	66 89 42 08          	mov    %ax,0x8(%edx)
		ret = write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(modified_page_frame_info)));
		//cprintf("[%s] finished updating page\n",ptr_env->prog_name);
	}
#endif
	//2020
	ptr_env->nPageOut++ ;
f010547e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105481:	8b 80 b8 05 00 00    	mov    0x5b8(%eax),%eax
f0105487:	8d 50 01             	lea    0x1(%eax),%edx
f010548a:	8b 45 08             	mov    0x8(%ebp),%eax
f010548d:	89 90 b8 05 00 00    	mov    %edx,0x5b8(%eax)
	//======================

	return ret;
f0105493:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0105496:	c9                   	leave  
f0105497:	c3                   	ret    

f0105498 <pf_read_env_page>:

	return write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(page_modified_frame_info)));
}
 */
int pf_read_env_page(struct Env* ptr_env, void* virtual_address)
{
f0105498:	55                   	push   %ebp
f0105499:	89 e5                	mov    %esp,%ebp
f010549b:	83 ec 18             	sub    $0x18,%esp
	uint32 *ptr_disk_page_table;

	//ROUND DOWN it on 4 KB boundary in order to read the entire page starting from its first address.
	virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);
f010549e:	8b 45 0c             	mov    0xc(%ebp),%eax
f01054a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01054a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01054a7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01054ac:	89 45 0c             	mov    %eax,0xc(%ebp)

	if( ptr_env->disk_env_pgdir == 0) return E_PAGE_NOT_EXIST_IN_PF;
f01054af:	8b 45 08             	mov    0x8(%ebp),%eax
f01054b2:	8b 40 74             	mov    0x74(%eax),%eax
f01054b5:	85 c0                	test   %eax,%eax
f01054b7:	75 0a                	jne    f01054c3 <pf_read_env_page+0x2b>
f01054b9:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f01054be:	e9 90 00 00 00       	jmp    f0105553 <pf_read_env_page+0xbb>

	get_disk_page_table(ptr_env->disk_env_pgdir, (uint32) virtual_address, 0, &ptr_disk_page_table);
f01054c3:	8b 55 0c             	mov    0xc(%ebp),%edx
f01054c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01054c9:	8b 40 74             	mov    0x74(%eax),%eax
f01054cc:	8d 4d e8             	lea    -0x18(%ebp),%ecx
f01054cf:	51                   	push   %ecx
f01054d0:	6a 00                	push   $0x0
f01054d2:	52                   	push   %edx
f01054d3:	50                   	push   %eax
f01054d4:	e8 d4 fa ff ff       	call   f0104fad <get_disk_page_table>
f01054d9:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return E_PAGE_NOT_EXIST_IN_PF;
f01054dc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01054df:	85 c0                	test   %eax,%eax
f01054e1:	75 07                	jne    f01054ea <pf_read_env_page+0x52>
f01054e3:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f01054e8:	eb 69                	jmp    f0105553 <pf_read_env_page+0xbb>

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01054ea:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01054ed:	8b 55 0c             	mov    0xc(%ebp),%edx
f01054f0:	c1 ea 0c             	shr    $0xc,%edx
f01054f3:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01054f9:	c1 e2 02             	shl    $0x2,%edx
f01054fc:	01 d0                	add    %edx,%eax
f01054fe:	8b 00                	mov    (%eax),%eax
f0105500:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if( dfn == 0) return E_PAGE_NOT_EXIST_IN_PF;
f0105503:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105507:	75 07                	jne    f0105510 <pf_read_env_page+0x78>
f0105509:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010550e:	eb 43                	jmp    f0105553 <pf_read_env_page+0xbb>

	int disk_read_error = read_disk_page(dfn, virtual_address);
f0105510:	83 ec 08             	sub    $0x8,%esp
f0105513:	ff 75 0c             	pushl  0xc(%ebp)
f0105516:	ff 75 f0             	pushl  -0x10(%ebp)
f0105519:	e8 9e f6 ff ff       	call   f0104bbc <read_disk_page>
f010551e:	83 c4 10             	add    $0x10,%esp
f0105521:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//reset modified bit to 0: because FOS copies the placed or replaced page from
	//HD to memory, the page modified bit is set to 1, but we want the modified bit to be
	// affected only by "user code" modifications, not our (FOS kernel) modifications
	pt_set_page_permissions(ptr_env->env_page_directory, (uint32)virtual_address, 0, PERM_MODIFIED);
f0105524:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105527:	8b 45 08             	mov    0x8(%ebp),%eax
f010552a:	8b 40 64             	mov    0x64(%eax),%eax
f010552d:	6a 40                	push   $0x40
f010552f:	6a 00                	push   $0x0
f0105531:	52                   	push   %edx
f0105532:	50                   	push   %eax
f0105533:	e8 c7 46 00 00       	call   f0109bff <pt_set_page_permissions>
f0105538:	83 c4 10             	add    $0x10,%esp

	//2020
	ptr_env->nPageIn++ ;
f010553b:	8b 45 08             	mov    0x8(%ebp),%eax
f010553e:	8b 80 b4 05 00 00    	mov    0x5b4(%eax),%eax
f0105544:	8d 50 01             	lea    0x1(%eax),%edx
f0105547:	8b 45 08             	mov    0x8(%ebp),%eax
f010554a:	89 90 b4 05 00 00    	mov    %edx,0x5b4(%eax)
	//======================

	return disk_read_error;
f0105550:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0105553:	c9                   	leave  
f0105554:	c3                   	ret    

f0105555 <pf_remove_env_page>:

void pf_remove_env_page(struct Env* ptr_env, uint32 virtual_address)
{
f0105555:	55                   	push   %ebp
f0105556:	89 e5                	mov    %esp,%ebp
f0105558:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f010555b:	8b 45 08             	mov    0x8(%ebp),%eax
f010555e:	8b 40 74             	mov    0x74(%eax),%eax
f0105561:	85 c0                	test   %eax,%eax
f0105563:	74 62                	je     f01055c7 <pf_remove_env_page+0x72>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0105565:	8b 45 08             	mov    0x8(%ebp),%eax
f0105568:	8b 40 74             	mov    0x74(%eax),%eax
f010556b:	8d 55 f0             	lea    -0x10(%ebp),%edx
f010556e:	52                   	push   %edx
f010556f:	6a 00                	push   $0x0
f0105571:	ff 75 0c             	pushl  0xc(%ebp)
f0105574:	50                   	push   %eax
f0105575:	e8 33 fa ff ff       	call   f0104fad <get_disk_page_table>
f010557a:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return;
f010557d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105580:	85 c0                	test   %eax,%eax
f0105582:	74 46                	je     f01055ca <pf_remove_env_page+0x75>

	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0105584:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105587:	8b 55 0c             	mov    0xc(%ebp),%edx
f010558a:	c1 ea 0c             	shr    $0xc,%edx
f010558d:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0105593:	c1 e2 02             	shl    $0x2,%edx
f0105596:	01 d0                	add    %edx,%eax
f0105598:	8b 00                	mov    (%eax),%eax
f010559a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_disk_page_table[PTX(virtual_address)] = 0;
f010559d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01055a0:	8b 55 0c             	mov    0xc(%ebp),%edx
f01055a3:	c1 ea 0c             	shr    $0xc,%edx
f01055a6:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01055ac:	c1 e2 02             	shl    $0x2,%edx
f01055af:	01 d0                	add    %edx,%eax
f01055b1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f01055b7:	83 ec 0c             	sub    $0xc,%esp
f01055ba:	ff 75 f4             	pushl  -0xc(%ebp)
f01055bd:	e8 e4 f8 ff ff       	call   f0104ea6 <free_disk_frame>
f01055c2:	83 c4 10             	add    $0x10,%esp
f01055c5:	eb 04                	jmp    f01055cb <pf_remove_env_page+0x76>
{
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f01055c7:	90                   	nop
f01055c8:	eb 01                	jmp    f01055cb <pf_remove_env_page+0x76>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
	if(ptr_disk_page_table == 0) return;
f01055ca:	90                   	nop
	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
	ptr_disk_page_table[PTX(virtual_address)] = 0;
	free_disk_frame(dfn);
	//LOG_STRING("pf_remove_env_page: 3");
}
f01055cb:	c9                   	leave  
f01055cc:	c3                   	ret    

f01055cd <pf_free_env>:

void pf_free_env(struct Env* ptr_env)
{
f01055cd:	55                   	push   %ebp
f01055ce:	89 e5                	mov    %esp,%ebp
f01055d0:	83 ec 28             	sub    $0x28,%esp
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f01055d3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01055da:	e9 b8 00 00 00       	jmp    f0105697 <pf_free_env+0xca>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
f01055df:	8b 45 08             	mov    0x8(%ebp),%eax
f01055e2:	8b 40 74             	mov    0x74(%eax),%eax
f01055e5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01055e8:	c1 e2 02             	shl    $0x2,%edx
f01055eb:	01 d0                	add    %edx,%eax
f01055ed:	8b 00                	mov    (%eax),%eax
f01055ef:	83 e0 01             	and    $0x1,%eax
f01055f2:	85 c0                	test   %eax,%eax
f01055f4:	0f 84 99 00 00 00    	je     f0105693 <pf_free_env+0xc6>
			continue;

		// find the pa and va of the page table
		uint32 pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdeno]);
f01055fa:	8b 45 08             	mov    0x8(%ebp),%eax
f01055fd:	8b 40 74             	mov    0x74(%eax),%eax
f0105600:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105603:	c1 e2 02             	shl    $0x2,%edx
f0105606:	01 d0                	add    %edx,%eax
f0105608:	8b 00                	mov    (%eax),%eax
f010560a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010560f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 *pt;
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f0105612:	83 ec 0c             	sub    $0xc,%esp
f0105615:	ff 75 ec             	pushl  -0x14(%ebp)
f0105618:	e8 4d 45 00 00       	call   f0109b6a <kheap_virtual_address>
f010561d:	83 c4 10             	add    $0x10,%esp
f0105620:	89 45 e8             	mov    %eax,-0x18(%ebp)
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f0105623:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010562a:	eb 3a                	jmp    f0105666 <pf_free_env+0x99>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[pteno];
f010562c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010562f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0105636:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105639:	01 d0                	add    %edx,%eax
f010563b:	8b 00                	mov    (%eax),%eax
f010563d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			pt[pteno] = 0;
f0105640:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105643:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010564a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010564d:	01 d0                	add    %edx,%eax
f010564f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			// and declare it free
			free_disk_frame(dfn);
f0105655:	83 ec 0c             	sub    $0xc,%esp
f0105658:	ff 75 e4             	pushl  -0x1c(%ebp)
f010565b:	e8 46 f8 ff ff       	call   f0104ea6 <free_disk_frame>
f0105660:	83 c4 10             	add    $0x10,%esp
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f0105663:	ff 45 f0             	incl   -0x10(%ebp)
f0105666:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
f010566d:	76 bd                	jbe    f010562c <pf_free_env+0x5f>
			// and declare it free
			free_disk_frame(dfn);
		}

		// free the disk page table itself
		ptr_env->disk_env_pgdir[pdeno] = 0;
f010566f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105672:	8b 40 74             	mov    0x74(%eax),%eax
f0105675:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105678:	c1 e2 02             	shl    $0x2,%edx
f010567b:	01 d0                	add    %edx,%eax
f010567d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
#if USE_KHEAP
		{
			kfree(pt);
f0105683:	83 ec 0c             	sub    $0xc,%esp
f0105686:	ff 75 e8             	pushl  -0x18(%ebp)
f0105689:	e8 c2 44 00 00       	call   f0109b50 <kfree>
f010568e:	83 c4 10             	add    $0x10,%esp
f0105691:	eb 01                	jmp    f0105694 <pf_free_env+0xc7>

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
			continue;
f0105693:	90                   	nop

void pf_free_env(struct Env* ptr_env)
{
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0105694:	ff 45 f4             	incl   -0xc(%ebp)
f0105697:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f010569e:	0f 86 3b ff ff ff    	jbe    f01055df <pf_free_env+0x12>
	}

	// free the disk page directory of the environment
#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_pgdir);
f01056a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01056a7:	8b 40 74             	mov    0x74(%eax),%eax
f01056aa:	83 ec 0c             	sub    $0xc,%esp
f01056ad:	50                   	push   %eax
f01056ae:	e8 9d 44 00 00       	call   f0109b50 <kfree>
f01056b3:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_pgdir_PA));
	}
#endif
	ptr_env->disk_env_pgdir = 0;
f01056b6:	8b 45 08             	mov    0x8(%ebp),%eax
f01056b9:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
	ptr_env->disk_env_pgdir_PA = 0;
f01056c0:	8b 45 08             	mov    0x8(%ebp),%eax
f01056c3:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
f01056ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01056cd:	8b 40 7c             	mov    0x7c(%eax),%eax
f01056d0:	85 c0                	test   %eax,%eax
f01056d2:	74 39                	je     f010570d <pf_free_env+0x140>
		return;
	__pf_remove_env_all_tables(ptr_env);
f01056d4:	83 ec 0c             	sub    $0xc,%esp
f01056d7:	ff 75 08             	pushl  0x8(%ebp)
f01056da:	e8 f1 02 00 00       	call   f01059d0 <__pf_remove_env_all_tables>
f01056df:	83 c4 10             	add    $0x10,%esp


#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_tabledir);
f01056e2:	8b 45 08             	mov    0x8(%ebp),%eax
f01056e5:	8b 40 7c             	mov    0x7c(%eax),%eax
f01056e8:	83 ec 0c             	sub    $0xc,%esp
f01056eb:	50                   	push   %eax
f01056ec:	e8 5f 44 00 00       	call   f0109b50 <kfree>
f01056f1:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_tabledir_PA));
	}
#endif
	ptr_env->disk_env_tabledir = 0;
f01056f4:	8b 45 08             	mov    0x8(%ebp),%eax
f01056f7:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
	ptr_env->disk_env_tabledir_PA = 0;
f01056fe:	8b 45 08             	mov    0x8(%ebp),%eax
f0105701:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f0105708:	00 00 00 
f010570b:	eb 01                	jmp    f010570e <pf_free_env+0x141>
	ptr_env->disk_env_pgdir_PA = 0;


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
		return;
f010570d:	90                   	nop
	}
#endif
	ptr_env->disk_env_tabledir = 0;
	ptr_env->disk_env_tabledir_PA = 0;

}
f010570e:	c9                   	leave  
f010570f:	c3                   	ret    

f0105710 <get_disk_page_directory>:


int get_disk_page_directory(struct Env* ptr_env, uint32** ptr_disk_page_directory)
{
f0105710:	55                   	push   %ebp
f0105711:	89 e5                	mov    %esp,%ebp
f0105713:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_page_directory = ptr_env->disk_env_pgdir;
f0105716:	8b 45 08             	mov    0x8(%ebp),%eax
f0105719:	8b 50 74             	mov    0x74(%eax),%edx
f010571c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010571f:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_page_directory == 0)
f0105721:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105724:	8b 00                	mov    (%eax),%eax
f0105726:	85 c0                	test   %eax,%eax
f0105728:	75 58                	jne    f0105782 <get_disk_page_directory+0x72>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_page_directory = kmalloc(PAGE_SIZE);
f010572a:	83 ec 0c             	sub    $0xc,%esp
f010572d:	68 00 10 00 00       	push   $0x1000
f0105732:	e8 ff 43 00 00       	call   f0109b36 <kmalloc>
f0105737:	83 c4 10             	add    $0x10,%esp
f010573a:	89 c2                	mov    %eax,%edx
f010573c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010573f:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_page_directory == NULL)
f0105741:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105744:	8b 00                	mov    (%eax),%eax
f0105746:	85 c0                	test   %eax,%eax
f0105748:	75 07                	jne    f0105751 <get_disk_page_directory+0x41>
			{
				return E_NO_VM;
f010574a:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f010574f:	eb 36                	jmp    f0105787 <get_disk_page_directory+0x77>
			}
			ptr_env->disk_env_pgdir_PA = kheap_physical_address((unsigned int)*ptr_disk_page_directory);
f0105751:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105754:	8b 00                	mov    (%eax),%eax
f0105756:	83 ec 0c             	sub    $0xc,%esp
f0105759:	50                   	push   %eax
f010575a:	e8 25 44 00 00       	call   f0109b84 <kheap_physical_address>
f010575f:	83 c4 10             	add    $0x10,%esp
f0105762:	89 c2                	mov    %eax,%edx
f0105764:	8b 45 08             	mov    0x8(%ebp),%eax
f0105767:	89 50 78             	mov    %edx,0x78(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_page_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_pgdir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_page_directory , 0, PAGE_SIZE);
f010576a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010576d:	8b 00                	mov    (%eax),%eax
f010576f:	83 ec 04             	sub    $0x4,%esp
f0105772:	68 00 10 00 00       	push   $0x1000
f0105777:	6a 00                	push   $0x0
f0105779:	50                   	push   %eax
f010577a:	e8 ea 54 01 00       	call   f011ac69 <memset>
f010577f:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f0105782:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0105787:	c9                   	leave  
f0105788:	c3                   	ret    

f0105789 <pf_calculate_allocated_pages>:

int pf_calculate_allocated_pages(struct Env* ptr_env)
{
f0105789:	55                   	push   %ebp
f010578a:	89 e5                	mov    %esp,%ebp
f010578c:	83 ec 28             	sub    $0x28,%esp
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;
f010578f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f0105796:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010579d:	eb 78                	jmp    f0105817 <pf_calculate_allocated_pages+0x8e>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
f010579f:	8b 45 08             	mov    0x8(%ebp),%eax
f01057a2:	8b 40 74             	mov    0x74(%eax),%eax
f01057a5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01057a8:	c1 e2 02             	shl    $0x2,%edx
f01057ab:	01 d0                	add    %edx,%eax
f01057ad:	8b 00                	mov    (%eax),%eax
f01057af:	83 e0 01             	and    $0x1,%eax
f01057b2:	85 c0                	test   %eax,%eax
f01057b4:	74 5d                	je     f0105813 <pf_calculate_allocated_pages+0x8a>
			continue;

		// find the pa and va of the page table
		pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdIndex]);
f01057b6:	8b 45 08             	mov    0x8(%ebp),%eax
f01057b9:	8b 40 74             	mov    0x74(%eax),%eax
f01057bc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01057bf:	c1 e2 02             	shl    $0x2,%edx
f01057c2:	01 d0                	add    %edx,%eax
f01057c4:	8b 00                	mov    (%eax),%eax
f01057c6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01057cb:	89 45 e8             	mov    %eax,-0x18(%ebp)
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f01057ce:	83 ec 0c             	sub    $0xc,%esp
f01057d1:	ff 75 e8             	pushl  -0x18(%ebp)
f01057d4:	e8 91 43 00 00       	call   f0109b6a <kheap_virtual_address>
f01057d9:	83 c4 10             	add    $0x10,%esp
f01057dc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f01057df:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01057e6:	eb 20                	jmp    f0105808 <pf_calculate_allocated_pages+0x7f>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[ptIndex];
f01057e8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01057eb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01057f2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01057f5:	01 d0                	add    %edx,%eax
f01057f7:	8b 00                	mov    (%eax),%eax
f01057f9:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if(dfn != 0)
f01057fc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0105800:	74 03                	je     f0105805 <pf_calculate_allocated_pages+0x7c>
				counter ++;
f0105802:	ff 45 f0             	incl   -0x10(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f0105805:	ff 45 ec             	incl   -0x14(%ebp)
f0105808:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
f010580f:	76 d7                	jbe    f01057e8 <pf_calculate_allocated_pages+0x5f>
f0105811:	eb 01                	jmp    f0105814 <pf_calculate_allocated_pages+0x8b>

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
			continue;
f0105813:	90                   	nop
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f0105814:	ff 45 f4             	incl   -0xc(%ebp)
f0105817:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f010581e:	0f 86 7b ff ff ff    	jbe    f010579f <pf_calculate_allocated_pages+0x16>
			if(dfn != 0)
				counter ++;
		}
	}

	return counter;
f0105824:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0105827:	c9                   	leave  
f0105828:	c3                   	ret    

f0105829 <pf_calculate_free_frames>:

//2016:
//calculate the disk free frames from the disk free frame list
int pf_calculate_free_frames()
{
f0105829:	55                   	push   %ebp
f010582a:	89 e5                	mov    %esp,%ebp
f010582c:	83 ec 18             	sub    $0x18,%esp
	uint32 totalFreeDiskFrames ;
	acquire_kspinlock(&DiskFrameLists.dfllock);
f010582f:	83 ec 0c             	sub    $0xc,%esp
f0105832:	68 f0 6c 85 f0       	push   $0xf0856cf0
f0105837:	e8 3f a5 00 00       	call   f010fd7b <acquire_kspinlock>
f010583c:	83 c4 10             	add    $0x10,%esp
	{
		/*2023: UPDATE beased on suggestion from T112 2023.Term1*/
		totalFreeDiskFrames = LIST_SIZE(&DiskFrameLists.disk_free_frame_list);
f010583f:	a1 ec 6c 85 f0       	mov    0xf0856cec,%eax
f0105844:	89 45 f4             	mov    %eax,-0xc(%ebp)
		//	LIST_FOREACH(ptr, &disk_free_frame_list)
		//	{
		//		totalFreeDiskFrames++ ;
		//	}
	}
	release_kspinlock(&DiskFrameLists.dfllock);
f0105847:	83 ec 0c             	sub    $0xc,%esp
f010584a:	68 f0 6c 85 f0       	push   $0xf0856cf0
f010584f:	e8 cc a5 00 00       	call   f010fe20 <release_kspinlock>
f0105854:	83 c4 10             	add    $0x10,%esp
	return totalFreeDiskFrames;
f0105857:	8b 45 f4             	mov    -0xc(%ebp),%eax

}
f010585a:	c9                   	leave  
f010585b:	c3                   	ret    

f010585c <get_disk_table_directory>:



/*========================== TABLE FILE MANAGMENT ==============================*/
int get_disk_table_directory(struct Env* ptr_env, uint32** ptr_disk_table_directory)
{
f010585c:	55                   	push   %ebp
f010585d:	89 e5                	mov    %esp,%ebp
f010585f:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_table_directory = ptr_env->disk_env_tabledir;
f0105862:	8b 45 08             	mov    0x8(%ebp),%eax
f0105865:	8b 50 7c             	mov    0x7c(%eax),%edx
f0105868:	8b 45 0c             	mov    0xc(%ebp),%eax
f010586b:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_table_directory == 0)
f010586d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105870:	8b 00                	mov    (%eax),%eax
f0105872:	85 c0                	test   %eax,%eax
f0105874:	75 5b                	jne    f01058d1 <get_disk_table_directory+0x75>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_table_directory = kmalloc(PAGE_SIZE);
f0105876:	83 ec 0c             	sub    $0xc,%esp
f0105879:	68 00 10 00 00       	push   $0x1000
f010587e:	e8 b3 42 00 00       	call   f0109b36 <kmalloc>
f0105883:	83 c4 10             	add    $0x10,%esp
f0105886:	89 c2                	mov    %eax,%edx
f0105888:	8b 45 0c             	mov    0xc(%ebp),%eax
f010588b:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_table_directory == NULL)
f010588d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105890:	8b 00                	mov    (%eax),%eax
f0105892:	85 c0                	test   %eax,%eax
f0105894:	75 07                	jne    f010589d <get_disk_table_directory+0x41>
			{
				return E_NO_VM;
f0105896:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f010589b:	eb 39                	jmp    f01058d6 <get_disk_table_directory+0x7a>
			}
			ptr_env->disk_env_tabledir_PA = kheap_physical_address((uint32)*ptr_disk_table_directory);
f010589d:	8b 45 0c             	mov    0xc(%ebp),%eax
f01058a0:	8b 00                	mov    (%eax),%eax
f01058a2:	83 ec 0c             	sub    $0xc,%esp
f01058a5:	50                   	push   %eax
f01058a6:	e8 d9 42 00 00       	call   f0109b84 <kheap_physical_address>
f01058ab:	83 c4 10             	add    $0x10,%esp
f01058ae:	89 c2                	mov    %eax,%edx
f01058b0:	8b 45 08             	mov    0x8(%ebp),%eax
f01058b3:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_table_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_tabledir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_table_directory , 0, PAGE_SIZE);
f01058b9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01058bc:	8b 00                	mov    (%eax),%eax
f01058be:	83 ec 04             	sub    $0x4,%esp
f01058c1:	68 00 10 00 00       	push   $0x1000
f01058c6:	6a 00                	push   $0x0
f01058c8:	50                   	push   %eax
f01058c9:	e8 9b 53 01 00       	call   f011ac69 <memset>
f01058ce:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f01058d1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01058d6:	c9                   	leave  
f01058d7:	c3                   	ret    

f01058d8 <__pf_write_env_table>:

int __pf_write_env_table( struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f01058d8:	55                   	push   %ebp
f01058d9:	89 e5                	mov    %esp,%ebp
f01058db:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	assert((uint32)virtual_address < KERNEL_BASE);
f01058de:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f01058e5:	76 19                	jbe    f0105900 <__pf_write_env_table+0x28>
f01058e7:	68 80 dd 12 f0       	push   $0xf012dd80
f01058ec:	68 a6 dd 12 f0       	push   $0xf012dda6
f01058f1:	68 98 02 00 00       	push   $0x298
f01058f6:	68 db dc 12 f0       	push   $0xf012dcdb
f01058fb:	e8 af b5 ff ff       	call   f0100eaf <_panic>

	get_disk_table_directory(ptr_env, &(ptr_env->disk_env_tabledir)) ;
f0105900:	8b 45 08             	mov    0x8(%ebp),%eax
f0105903:	83 c0 7c             	add    $0x7c,%eax
f0105906:	83 ec 08             	sub    $0x8,%esp
f0105909:	50                   	push   %eax
f010590a:	ff 75 08             	pushl  0x8(%ebp)
f010590d:	e8 4a ff ff ff       	call   f010585c <get_disk_table_directory>
f0105912:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0105915:	8b 45 08             	mov    0x8(%ebp),%eax
f0105918:	8b 40 7c             	mov    0x7c(%eax),%eax
f010591b:	8b 55 0c             	mov    0xc(%ebp),%edx
f010591e:	c1 ea 16             	shr    $0x16,%edx
f0105921:	c1 e2 02             	shl    $0x2,%edx
f0105924:	01 d0                	add    %edx,%eax
f0105926:	8b 00                	mov    (%eax),%eax
f0105928:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if( dfn == 0)
f010592b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010592e:	85 c0                	test   %eax,%eax
f0105930:	75 31                	jne    f0105963 <__pf_write_env_table+0x8b>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f0105932:	83 ec 0c             	sub    $0xc,%esp
f0105935:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0105938:	50                   	push   %eax
f0105939:	e8 7a f4 ff ff       	call   f0104db8 <allocate_disk_frame>
f010593e:	83 c4 10             	add    $0x10,%esp
f0105941:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0105944:	75 07                	jne    f010594d <__pf_write_env_table+0x75>
f0105946:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f010594b:	eb 2e                	jmp    f010597b <__pf_write_env_table+0xa3>
		ptr_env->disk_env_tabledir[PDX(virtual_address)] = dfn;
f010594d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105950:	8b 40 7c             	mov    0x7c(%eax),%eax
f0105953:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105956:	c1 ea 16             	shr    $0x16,%edx
f0105959:	c1 e2 02             	shl    $0x2,%edx
f010595c:	01 c2                	add    %eax,%edx
f010595e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105961:	89 02                	mov    %eax,(%edx)
	//	lcr3(oldDir);

	//We already read it from the KERNEL mapping instead of the USER mapping

	//cprintf("[%s] writing table\n",ptr_env->prog_name);
	int ret = write_disk_page(dfn, (void*)tableKVirtualAddress);
f0105963:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105966:	83 ec 08             	sub    $0x8,%esp
f0105969:	ff 75 10             	pushl  0x10(%ebp)
f010596c:	50                   	push   %eax
f010596d:	e8 79 f2 ff ff       	call   f0104beb <write_disk_page>
f0105972:	83 c4 10             	add    $0x10,%esp
f0105975:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("[%s] finished writing table\n",ptr_env->prog_name);
	return ret;
f0105978:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010597b:	c9                   	leave  
f010597c:	c3                   	ret    

f010597d <__pf_read_env_table>:

int __pf_read_env_table(struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f010597d:	55                   	push   %ebp
f010597e:	89 e5                	mov    %esp,%ebp
f0105980:	83 ec 18             	sub    $0x18,%esp
	if( ptr_env->disk_env_tabledir == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0105983:	8b 45 08             	mov    0x8(%ebp),%eax
f0105986:	8b 40 7c             	mov    0x7c(%eax),%eax
f0105989:	85 c0                	test   %eax,%eax
f010598b:	75 07                	jne    f0105994 <__pf_read_env_table+0x17>
f010598d:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0105992:	eb 3a                	jmp    f01059ce <__pf_read_env_table+0x51>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0105994:	8b 45 08             	mov    0x8(%ebp),%eax
f0105997:	8b 40 7c             	mov    0x7c(%eax),%eax
f010599a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010599d:	c1 ea 16             	shr    $0x16,%edx
f01059a0:	c1 e2 02             	shl    $0x2,%edx
f01059a3:	01 d0                	add    %edx,%eax
f01059a5:	8b 00                	mov    (%eax),%eax
f01059a7:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if( dfn == 0) return E_TABLE_NOT_EXIST_IN_PF;
f01059aa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01059ae:	75 07                	jne    f01059b7 <__pf_read_env_table+0x3a>
f01059b0:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f01059b5:	eb 17                	jmp    f01059ce <__pf_read_env_table+0x51>

	int disk_read_error = read_disk_page(dfn, tableKVirtualAddress);
f01059b7:	83 ec 08             	sub    $0x8,%esp
f01059ba:	ff 75 10             	pushl  0x10(%ebp)
f01059bd:	ff 75 f4             	pushl  -0xc(%ebp)
f01059c0:	e8 f7 f1 ff ff       	call   f0104bbc <read_disk_page>
f01059c5:	83 c4 10             	add    $0x10,%esp
f01059c8:	89 45 f0             	mov    %eax,-0x10(%ebp)

	return disk_read_error;
f01059cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f01059ce:	c9                   	leave  
f01059cf:	c3                   	ret    

f01059d0 <__pf_remove_env_all_tables>:

void __pf_remove_env_all_tables(struct Env* ptr_env)
{
f01059d0:	55                   	push   %ebp
f01059d1:	89 e5                	mov    %esp,%ebp
f01059d3:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f01059d6:	8b 45 08             	mov    0x8(%ebp),%eax
f01059d9:	8b 40 7c             	mov    0x7c(%eax),%eax
f01059dc:	85 c0                	test   %eax,%eax
f01059de:	74 4c                	je     f0105a2c <__pf_remove_env_all_tables+0x5c>

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f01059e0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01059e7:	eb 38                	jmp    f0105a21 <__pf_remove_env_all_tables+0x51>
	{
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
f01059e9:	8b 45 08             	mov    0x8(%ebp),%eax
f01059ec:	8b 40 7c             	mov    0x7c(%eax),%eax
f01059ef:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01059f2:	c1 e2 02             	shl    $0x2,%edx
f01059f5:	01 d0                	add    %edx,%eax
f01059f7:	8b 00                	mov    (%eax),%eax
f01059f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_env->disk_env_tabledir[pdeno] = 0;
f01059fc:	8b 45 08             	mov    0x8(%ebp),%eax
f01059ff:	8b 40 7c             	mov    0x7c(%eax),%eax
f0105a02:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105a05:	c1 e2 02             	shl    $0x2,%edx
f0105a08:	01 d0                	add    %edx,%eax
f0105a0a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		free_disk_frame(dfn);
f0105a10:	83 ec 0c             	sub    $0xc,%esp
f0105a13:	ff 75 f0             	pushl  -0x10(%ebp)
f0105a16:	e8 8b f4 ff ff       	call   f0104ea6 <free_disk_frame>
f0105a1b:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0105a1e:	ff 45 f4             	incl   -0xc(%ebp)
f0105a21:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f0105a28:	76 bf                	jbe    f01059e9 <__pf_remove_env_all_tables+0x19>
f0105a2a:	eb 01                	jmp    f0105a2d <__pf_remove_env_all_tables+0x5d>
void __pf_remove_env_all_tables(struct Env* ptr_env)
{
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0105a2c:	90                   	nop
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
		ptr_env->disk_env_tabledir[pdeno] = 0;
		free_disk_frame(dfn);
	}
	//LOG_STRING("pf_remove_env_page: 3");
}
f0105a2d:	c9                   	leave  
f0105a2e:	c3                   	ret    

f0105a2f <__pf_remove_env_table>:

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
f0105a2f:	55                   	push   %ebp
f0105a30:	89 e5                	mov    %esp,%ebp
f0105a32:	83 ec 18             	sub    $0x18,%esp
	if (virtual_address == 0)
f0105a35:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0105a39:	75 10                	jne    f0105a4b <__pf_remove_env_table+0x1c>
		cprintf("REMOVING table 0 from page file\n");
f0105a3b:	83 ec 0c             	sub    $0xc,%esp
f0105a3e:	68 84 de 12 f0       	push   $0xf012de84
f0105a43:	e8 14 c1 ff ff       	call   f0101b5c <cprintf>
f0105a48:	83 c4 10             	add    $0x10,%esp
	if( ptr_env->disk_env_tabledir == 0) return;
f0105a4b:	8b 45 08             	mov    0x8(%ebp),%eax
f0105a4e:	8b 40 7c             	mov    0x7c(%eax),%eax
f0105a51:	85 c0                	test   %eax,%eax
f0105a53:	74 3d                	je     f0105a92 <__pf_remove_env_table+0x63>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0105a55:	8b 45 08             	mov    0x8(%ebp),%eax
f0105a58:	8b 40 7c             	mov    0x7c(%eax),%eax
f0105a5b:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105a5e:	c1 ea 16             	shr    $0x16,%edx
f0105a61:	c1 e2 02             	shl    $0x2,%edx
f0105a64:	01 d0                	add    %edx,%eax
f0105a66:	8b 00                	mov    (%eax),%eax
f0105a68:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
f0105a6b:	8b 45 08             	mov    0x8(%ebp),%eax
f0105a6e:	8b 40 7c             	mov    0x7c(%eax),%eax
f0105a71:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105a74:	c1 ea 16             	shr    $0x16,%edx
f0105a77:	c1 e2 02             	shl    $0x2,%edx
f0105a7a:	01 d0                	add    %edx,%eax
f0105a7c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f0105a82:	83 ec 0c             	sub    $0xc,%esp
f0105a85:	ff 75 f4             	pushl  -0xc(%ebp)
f0105a88:	e8 19 f4 ff ff       	call   f0104ea6 <free_disk_frame>
f0105a8d:	83 c4 10             	add    $0x10,%esp
f0105a90:	eb 01                	jmp    f0105a93 <__pf_remove_env_table+0x64>

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
	if (virtual_address == 0)
		cprintf("REMOVING table 0 from page file\n");
	if( ptr_env->disk_env_tabledir == 0) return;
f0105a92:	90                   	nop

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
	free_disk_frame(dfn);
}
f0105a93:	c9                   	leave  
f0105a94:	c3                   	ret    

f0105a95 <test_disk_01>:
///========================== END OF TABLE FILE MANAGMENT =============================


void test_disk_01(void *virtual_address)
{
f0105a95:	55                   	push   %ebp
f0105a96:	89 e5                	mov    %esp,%ebp
f0105a98:	83 ec 18             	sub    $0x18,%esp
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
f0105a9b:	c7 45 f4 2d 60 01 00 	movl   $0x1602d,-0xc(%ebp)
	for(;i<140000;i += 500)
f0105aa2:	eb 1f                	jmp    f0105ac3 <test_disk_01+0x2e>
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
f0105aa4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105aa7:	83 ec 04             	sub    $0x4,%esp
f0105aaa:	6a 08                	push   $0x8
f0105aac:	ff 75 08             	pushl  0x8(%ebp)
f0105aaf:	50                   	push   %eax
f0105ab0:	e8 bf 59 01 00       	call   f011b474 <ide_write>
f0105ab5:	83 c4 10             	add    $0x10,%esp
f0105ab8:	85 c0                	test   %eax,%eax
f0105aba:	75 12                	jne    f0105ace <test_disk_01+0x39>

void test_disk_01(void *virtual_address)
{
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
	for(;i<140000;i += 500)
f0105abc:	81 45 f4 f4 01 00 00 	addl   $0x1f4,-0xc(%ebp)
f0105ac3:	81 7d f4 df 22 02 00 	cmpl   $0x222df,-0xc(%ebp)
f0105aca:	7e d8                	jle    f0105aa4 <test_disk_01+0xf>
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0105acc:	eb 01                	jmp    f0105acf <test_disk_01+0x3a>
	for(;i<140000;i += 500)
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
		{
			LOG_STATMENT(cprintf("FAILURE to write sector %d\n",i););
			break;
f0105ace:	90                   	nop
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0105acf:	90                   	nop
f0105ad0:	c9                   	leave  
f0105ad1:	c3                   	ret    

f0105ad2 <context_switch>:
# Switch stacks to new and pop previously-saved registers.

.globl context_switch
context_switch:
  # Save old callee-saved registers
  pushl %ebp
f0105ad2:	55                   	push   %ebp
  pushl %eax
f0105ad3:	50                   	push   %eax
  pushl %ebx
f0105ad4:	53                   	push   %ebx
  pushl %ecx
f0105ad5:	51                   	push   %ecx
  pushl %edx
f0105ad6:	52                   	push   %edx
  pushl %esi
f0105ad7:	56                   	push   %esi
  pushl %edi
f0105ad8:	57                   	push   %edi

  # Switch stacks
  movl 32(%esp), %eax
f0105ad9:	8b 44 24 20          	mov    0x20(%esp),%eax
  movl 36(%esp), %edx
f0105add:	8b 54 24 24          	mov    0x24(%esp),%edx
  movl %esp, (%eax)
f0105ae1:	89 20                	mov    %esp,(%eax)
  movl %edx, %esp
f0105ae3:	89 d4                	mov    %edx,%esp

  # Load new callee-saved registers
  popl %edi
f0105ae5:	5f                   	pop    %edi
  popl %esi
f0105ae6:	5e                   	pop    %esi
  popl %edx
f0105ae7:	5a                   	pop    %edx
  popl %ecx
f0105ae8:	59                   	pop    %ecx
  popl %ebx
f0105ae9:	5b                   	pop    %ebx
  popl %eax
f0105aea:	58                   	pop    %eax
  popl %ebp
f0105aeb:	5d                   	pop    %ebp
  ret
f0105aec:	c3                   	ret    

f0105aed <mc146818_read>:
#include <kern/trap/trap.h>


unsigned
mc146818_read(unsigned reg)
{
f0105aed:	55                   	push   %ebp
f0105aee:	89 e5                	mov    %esp,%ebp
f0105af0:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0105af3:	8b 45 08             	mov    0x8(%ebp),%eax
f0105af6:	0f b6 c0             	movzbl %al,%eax
f0105af9:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0105b00:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0105b03:	8a 45 f6             	mov    -0xa(%ebp),%al
f0105b06:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0105b09:	ee                   	out    %al,(%dx)
f0105b0a:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105b11:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0105b14:	89 c2                	mov    %eax,%edx
f0105b16:	ec                   	in     (%dx),%al
f0105b17:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0105b1a:	8a 45 f7             	mov    -0x9(%ebp),%al
	return inb(IO_RTC+1);
f0105b1d:	0f b6 c0             	movzbl %al,%eax
}
f0105b20:	c9                   	leave  
f0105b21:	c3                   	ret    

f0105b22 <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
f0105b22:	55                   	push   %ebp
f0105b23:	89 e5                	mov    %esp,%ebp
f0105b25:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0105b28:	8b 45 08             	mov    0x8(%ebp),%eax
f0105b2b:	0f b6 c0             	movzbl %al,%eax
f0105b2e:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0105b35:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0105b38:	8a 45 f6             	mov    -0xa(%ebp),%al
f0105b3b:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0105b3e:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
f0105b3f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105b42:	0f b6 c0             	movzbl %al,%eax
f0105b45:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)
f0105b4c:	88 45 f7             	mov    %al,-0x9(%ebp)
f0105b4f:	8a 45 f7             	mov    -0x9(%ebp),%al
f0105b52:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0105b55:	ee                   	out    %al,(%dx)
}
f0105b56:	90                   	nop
f0105b57:	c9                   	leave  
f0105b58:	c3                   	ret    

f0105b59 <kclock_init>:
 * PIT channel is reset, and the output immediately goes to its initial state
 * (which depends on the mode).
 */

void kclock_init()
{
f0105b59:	55                   	push   %ebp
f0105b5a:	89 e5                	mov    %esp,%ebp
f0105b5c:	83 ec 08             	sub    $0x8,%esp
	ticks = 0;
f0105b5f:	c7 05 28 6c 85 f0 00 	movl   $0x0,0xf0856c28
f0105b66:	00 00 00 
f0105b69:	c7 05 2c 6c 85 f0 00 	movl   $0x0,0xf0856c2c
f0105b70:	00 00 00 
	irq_install_handler(0, &clock_interrupt_handler);
f0105b73:	83 ec 08             	sub    $0x8,%esp
f0105b76:	68 c6 7b 10 f0       	push   $0xf0107bc6
f0105b7b:	6a 00                	push   $0x0
f0105b7d:	e8 3e 86 00 00       	call   f010e1c0 <irq_install_handler>
f0105b82:	83 c4 10             	add    $0x10,%esp
}
f0105b85:	90                   	nop
f0105b86:	c9                   	leave  
f0105b87:	c3                   	ret    

f0105b88 <kclock_start>:
void
kclock_start(uint8 quantum_in_ms)
{
f0105b88:	55                   	push   %ebp
f0105b89:	89 e5                	mov    %esp,%ebp
f0105b8b:	53                   	push   %ebx
f0105b8c:	83 ec 24             	sub    $0x24,%esp
f0105b8f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105b92:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0105b95:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0105b9c:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0105ba0:	8a 45 ef             	mov    -0x11(%ebp),%al
f0105ba3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105ba6:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);

	//2017
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) % 256);
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) / 256);
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0105ba7:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0105bab:	77 48                	ja     f0105bf5 <kclock_start+0x6d>
f0105bad:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0105bb4:	c6 45 ee 34          	movb   $0x34,-0x12(%ebp)
f0105bb8:	8a 45 ee             	mov    -0x12(%ebp),%al
f0105bbb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105bbe:	ee                   	out    %al,(%dx)
	{
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(TIMER_DIV((1000/quantum_in_ms))) ;
f0105bbf:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0105bc3:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0105bc8:	99                   	cltd   
f0105bc9:	f7 fb                	idiv   %ebx
f0105bcb:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0105bd1:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0105bd5:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0105bda:	99                   	cltd   
f0105bdb:	f7 fb                	idiv   %ebx
f0105bdd:	89 c3                	mov    %eax,%ebx
f0105bdf:	89 c8                	mov    %ecx,%eax
f0105be1:	99                   	cltd   
f0105be2:	f7 fb                	idiv   %ebx
f0105be4:	0f b7 c0             	movzwl %ax,%eax
f0105be7:	83 ec 0c             	sub    $0xc,%esp
f0105bea:	50                   	push   %eax
f0105beb:	e8 b3 01 00 00       	call   f0105da3 <kclock_write_cnt0_LSB_first>
f0105bf0:	83 c4 10             	add    $0x10,%esp
f0105bf3:	eb 13                	jmp    f0105c08 <kclock_start+0x80>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0105bf5:	6a 35                	push   $0x35
f0105bf7:	68 a8 de 12 f0       	push   $0xf012dea8
f0105bfc:	6a 41                	push   $0x41
f0105bfe:	68 04 df 12 f0       	push   $0xf012df04
f0105c03:	e8 a7 b2 ff ff       	call   f0100eaf <_panic>
//	uint16 cnt0_after = kclock_read_cnt0() ;

	//cprintf("	Setup IRQ0 (timer interrupts) via 8259A\n");

	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0105c08:	83 ec 0c             	sub    $0xc,%esp
f0105c0b:	6a 00                	push   $0x0
f0105c0d:	e8 46 22 00 00       	call   f0107e58 <irq_clear_mask>
f0105c12:	83 c4 10             	add    $0x10,%esp

	//cprintf("	unmasked timer interrupt\n");

	//cprintf("Timer STARTED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );

}
f0105c15:	90                   	nop
f0105c16:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0105c19:	c9                   	leave  
f0105c1a:	c3                   	ret    

f0105c1b <kclock_stop>:

void
kclock_stop(void)
{
f0105c1b:	55                   	push   %ebp
f0105c1c:	89 e5                	mov    %esp,%ebp
f0105c1e:	83 ec 18             	sub    $0x18,%esp
f0105c21:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0105c28:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0105c2c:	8a 45 f3             	mov    -0xd(%ebp),%al
f0105c2f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105c32:	ee                   	out    %al,(%dx)
//		cprintf("STOP AFTER: cnt0 = %d\n",cnt0);
//	}

	/*Mask the IRQ0 (Timer Interrupt)*/
	//irq_setmask_8259A(0xFFFF);
	irq_set_mask(0);
f0105c33:	83 ec 0c             	sub    $0xc,%esp
f0105c36:	6a 00                	push   $0x0
f0105c38:	e8 a6 21 00 00       	call   f0107de3 <irq_set_mask>
f0105c3d:	83 c4 10             	add    $0x10,%esp
//	uint16 cnt0 = kclock_read_cnt0() ;
//	cprintf("Timer STOPPED: Counter0 Value = %x\n", cnt0 );
	//cprintf("Timer STOPPED: Status Value = %x\n", status);


}
f0105c40:	90                   	nop
f0105c41:	c9                   	leave  
f0105c42:	c3                   	ret    

f0105c43 <kclock_resume>:

void
kclock_resume(void)
{
f0105c43:	55                   	push   %ebp
f0105c44:	89 e5                	mov    %esp,%ebp
f0105c46:	83 ec 18             	sub    $0x18,%esp
	/*2024: changed to latch
	 * the current count is copied into an internal "latch register" which can then be read via the data port corresponding to the selected channel (I/O ports 0x40 to 0x42). The value kept in the latch register remains the same until it has been fully read, or until a new mode/command register is written.
	 * The main benefit of the latch command is that it allows both bytes of the current count to be read without inconsistencies. For example, if you didn't use the latch command, then the current count may decrease from 0x0200 to 0x01FF after you've read the low byte but before you've read the high byte, so that your software thinks the counter was 0x0100 instead of 0x0200 (or 0x01FF).
	 */
	//uint16 cnt0 = kclock_read_cnt0() ;
	uint16 cnt0 = kclock_read_cnt0_latch() ;
f0105c49:	e8 f5 01 00 00       	call   f0105e43 <kclock_read_cnt0_latch>
f0105c4e:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	//cprintf("CLOCK RESUMED: Counter0 Value = %d\n", cnt0 );
	//2017: if the remaining time is small, then increase it a bit to avoid invoking the CLOCK INT
	//		before returning back to the environment (this cause INT inside INT!!!) el7 :)
	if (cnt0 < 20)
f0105c52:	66 83 7d f6 13       	cmpw   $0x13,-0xa(%ebp)
f0105c57:	77 06                	ja     f0105c5f <kclock_resume+0x1c>
	{
		cnt0 = 20;
f0105c59:	66 c7 45 f6 14 00    	movw   $0x14,-0xa(%ebp)
	}

	if (cnt0 % 2 == 1)
f0105c5f:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0105c63:	83 e0 01             	and    $0x1,%eax
f0105c66:	66 85 c0             	test   %ax,%ax
f0105c69:	74 09                	je     f0105c74 <kclock_resume+0x31>
		cnt0++;
f0105c6b:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0105c6f:	40                   	inc    %eax
f0105c70:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
f0105c74:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0105c7b:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0105c7f:	8a 45 ef             	mov    -0x11(%ebp),%al
f0105c82:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105c85:	ee                   	out    %al,(%dx)

	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0105c86:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0105c8a:	83 ec 0c             	sub    $0xc,%esp
f0105c8d:	50                   	push   %eax
f0105c8e:	e8 10 01 00 00       	call   f0105da3 <kclock_write_cnt0_LSB_first>
f0105c93:	83 c4 10             	add    $0x10,%esp
//	cprintf("Timer RESUMED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );


	//cprintf("	Setup IRQ0: timer interrupts via 8259A\n");
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0105c96:	83 ec 0c             	sub    $0xc,%esp
f0105c99:	6a 00                	push   $0x0
f0105c9b:	e8 b8 21 00 00       	call   f0107e58 <irq_clear_mask>
f0105ca0:	83 c4 10             	add    $0x10,%esp
	//cprintf("	unmasked timer interrupt\n");
}
f0105ca3:	90                   	nop
f0105ca4:	c9                   	leave  
f0105ca5:	c3                   	ret    

f0105ca6 <kclock_start_counter>:


//==============

void kclock_start_counter(uint8 cnt0)
{
f0105ca6:	55                   	push   %ebp
f0105ca7:	89 e5                	mov    %esp,%ebp
f0105ca9:	83 ec 28             	sub    $0x28,%esp
f0105cac:	8b 45 08             	mov    0x8(%ebp),%eax
f0105caf:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0105cb2:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0105cb9:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0105cbd:	8a 45 f3             	mov    -0xd(%ebp),%al
f0105cc0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105cc3:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0105cc4:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f0105cc8:	83 ec 0c             	sub    $0xc,%esp
f0105ccb:	50                   	push   %eax
f0105ccc:	e8 d2 00 00 00       	call   f0105da3 <kclock_write_cnt0_LSB_first>
f0105cd1:	83 c4 10             	add    $0x10,%esp
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0105cd4:	83 ec 0c             	sub    $0xc,%esp
f0105cd7:	6a 00                	push   $0x0
f0105cd9:	e8 7a 21 00 00       	call   f0107e58 <irq_clear_mask>
f0105cde:	83 c4 10             	add    $0x10,%esp
}
f0105ce1:	90                   	nop
f0105ce2:	c9                   	leave  
f0105ce3:	c3                   	ret    

f0105ce4 <kclock_set_quantum>:

//2018
//Reset the CNT0 to the given quantum value without affecting the interrupt status
void kclock_set_quantum(uint8 quantum_in_ms)
{
f0105ce4:	55                   	push   %ebp
f0105ce5:	89 e5                	mov    %esp,%ebp
f0105ce7:	56                   	push   %esi
f0105ce8:	53                   	push   %ebx
f0105ce9:	83 ec 20             	sub    $0x20,%esp
f0105cec:	8b 45 08             	mov    0x8(%ebp),%eax
f0105cef:	88 45 e4             	mov    %al,-0x1c(%ebp)
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0105cf2:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0105cf6:	0f 87 8a 00 00 00    	ja     f0105d86 <kclock_set_quantum+0xa2>
	{
		/*2023*/
//		int cnt = TIMER_DIV((1000/quantum_in_ms));
//		if (cnt%2 == 1)
//			cnt++;
		int cnt = NUM_CLKS_PER_QUANTUM(quantum_in_ms);
f0105cfc:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0105d00:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0105d05:	99                   	cltd   
f0105d06:	f7 fe                	idiv   %esi
f0105d08:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0105d0e:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0105d12:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0105d17:	99                   	cltd   
f0105d18:	f7 fb                	idiv   %ebx
f0105d1a:	89 c6                	mov    %eax,%esi
f0105d1c:	89 c8                	mov    %ecx,%eax
f0105d1e:	99                   	cltd   
f0105d1f:	f7 fe                	idiv   %esi
f0105d21:	89 c3                	mov    %eax,%ebx
f0105d23:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
f0105d27:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0105d2c:	99                   	cltd   
f0105d2d:	f7 f9                	idiv   %ecx
f0105d2f:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0105d35:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0105d39:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0105d3e:	99                   	cltd   
f0105d3f:	f7 fe                	idiv   %esi
f0105d41:	89 c6                	mov    %eax,%esi
f0105d43:	89 c8                	mov    %ecx,%eax
f0105d45:	99                   	cltd   
f0105d46:	f7 fe                	idiv   %esi
f0105d48:	25 01 00 00 80       	and    $0x80000001,%eax
f0105d4d:	85 c0                	test   %eax,%eax
f0105d4f:	79 05                	jns    f0105d56 <kclock_set_quantum+0x72>
f0105d51:	48                   	dec    %eax
f0105d52:	83 c8 fe             	or     $0xfffffffe,%eax
f0105d55:	40                   	inc    %eax
f0105d56:	01 d8                	add    %ebx,%eax
f0105d58:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105d5b:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0105d62:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0105d66:	8a 45 ef             	mov    -0x11(%ebp),%al
f0105d69:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105d6c:	ee                   	out    %al,(%dx)


		//cprintf("QUANTUM is set to %d ms (%d)\n", quantum_in_ms, TIMER_DIV((1000/quantum_in_ms)));
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(cnt) ;
f0105d6d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d70:	0f b7 c0             	movzwl %ax,%eax
f0105d73:	83 ec 0c             	sub    $0xc,%esp
f0105d76:	50                   	push   %eax
f0105d77:	e8 27 00 00 00       	call   f0105da3 <kclock_write_cnt0_LSB_first>
f0105d7c:	83 c4 10             	add    $0x10,%esp
		kclock_stop();
f0105d7f:	e8 97 fe ff ff       	call   f0105c1b <kclock_stop>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
	}
}
f0105d84:	eb 16                	jmp    f0105d9c <kclock_set_quantum+0xb8>
		//uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
		//cprintf("\nkclock_set_quantum: clock after stop = %d\n",cnt0);
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0105d86:	6a 35                	push   $0x35
f0105d88:	68 a8 de 12 f0       	push   $0xf012dea8
f0105d8d:	68 ea 00 00 00       	push   $0xea
f0105d92:	68 04 df 12 f0       	push   $0xf012df04
f0105d97:	e8 13 b1 ff ff       	call   f0100eaf <_panic>
	}
}
f0105d9c:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0105d9f:	5b                   	pop    %ebx
f0105da0:	5e                   	pop    %esi
f0105da1:	5d                   	pop    %ebp
f0105da2:	c3                   	ret    

f0105da3 <kclock_write_cnt0_LSB_first>:


//2017
void
kclock_write_cnt0_LSB_first(uint16 val)
{
f0105da3:	55                   	push   %ebp
f0105da4:	89 e5                	mov    %esp,%ebp
f0105da6:	83 ec 28             	sub    $0x28,%esp
f0105da9:	8b 45 08             	mov    0x8(%ebp),%eax
f0105dac:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
	/*You must prevent other code from setting the PIT channel's reload value or reading
	 * its current count once you've sent the lowest 8 bits. Disabling interrupts works
	 * for single CPU computers
	 * */
	pushcli();	//disable interrupt
f0105db0:	e8 7b 22 00 00       	call   f0108030 <pushcli>
	outb(TIMER_CNTR0, (uint8)(val & 0x00FF));
f0105db5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105db8:	0f b6 c0             	movzbl %al,%eax
f0105dbb:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
f0105dc2:	88 45 ee             	mov    %al,-0x12(%ebp)
f0105dc5:	8a 45 ee             	mov    -0x12(%ebp),%al
f0105dc8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105dcb:	ee                   	out    %al,(%dx)
	outb(TIMER_CNTR0, (uint8)((val>>8) & 0x00FF));
f0105dcc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105dcf:	66 c1 e8 08          	shr    $0x8,%ax
f0105dd3:	0f b6 c0             	movzbl %al,%eax
f0105dd6:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)
f0105ddd:	88 45 ef             	mov    %al,-0x11(%ebp)
f0105de0:	8a 45 ef             	mov    -0x11(%ebp),%al
f0105de3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105de6:	ee                   	out    %al,(%dx)
	popcli();	//enable interrupt
f0105de7:	e8 96 22 00 00       	call   f0108082 <popcli>

}
f0105dec:	90                   	nop
f0105ded:	c9                   	leave  
f0105dee:	c3                   	ret    

f0105def <kclock_read_cnt0>:
//==============


uint16
kclock_read_cnt0(void)
{
f0105def:	55                   	push   %ebp
f0105df0:	89 e5                	mov    %esp,%ebp
f0105df2:	83 ec 28             	sub    $0x28,%esp
	pushcli();	//disable interrupt
f0105df5:	e8 36 22 00 00       	call   f0108030 <pushcli>
f0105dfa:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105e01:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105e04:	89 c2                	mov    %eax,%edx
f0105e06:	ec                   	in     (%dx),%al
f0105e07:	88 45 e6             	mov    %al,-0x1a(%ebp)
	return data;
f0105e0a:	8a 45 e6             	mov    -0x1a(%ebp),%al
	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0105e0d:	88 45 f7             	mov    %al,-0x9(%ebp)
f0105e10:	c7 45 e8 40 00 00 00 	movl   $0x40,-0x18(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105e17:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105e1a:	89 c2                	mov    %eax,%edx
f0105e1c:	ec                   	in     (%dx),%al
f0105e1d:	88 45 e7             	mov    %al,-0x19(%ebp)
	return data;
f0105e20:	8a 45 e7             	mov    -0x19(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0105e23:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0105e26:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f0105e2a:	c1 e0 08             	shl    $0x8,%eax
f0105e2d:	89 c2                	mov    %eax,%edx
f0105e2f:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0105e33:	09 d0                	or     %edx,%eax
f0105e35:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	popcli();	//enable interrupt
f0105e39:	e8 44 22 00 00       	call   f0108082 <popcli>
	return cnt0 ;
f0105e3e:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0105e41:	c9                   	leave  
f0105e42:	c3                   	ret    

f0105e43 <kclock_read_cnt0_latch>:
 * instead of 0x0200 (or 0x01FF).
 * REF: OSDev Wiki
 */
uint16
kclock_read_cnt0_latch(void)
{
f0105e43:	55                   	push   %ebp
f0105e44:	89 e5                	mov    %esp,%ebp
f0105e46:	83 ec 30             	sub    $0x30,%esp
f0105e49:	c7 45 f8 43 00 00 00 	movl   $0x43,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105e50:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0105e53:	89 c2                	mov    %eax,%edx
f0105e55:	ec                   	in     (%dx),%al
f0105e56:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0105e59:	8a 45 db             	mov    -0x25(%ebp),%al
	uint8 old_mode = inb(TIMER_MODE) ;
f0105e5c:	88 45 ff             	mov    %al,-0x1(%ebp)
f0105e5f:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0105e66:	c6 45 dc 00          	movb   $0x0,-0x24(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0105e6a:	8a 45 dc             	mov    -0x24(%ebp),%al
f0105e6d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105e70:	ee                   	out    %al,(%dx)
f0105e71:	c7 45 ec 40 00 00 00 	movl   $0x40,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105e78:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105e7b:	89 c2                	mov    %eax,%edx
f0105e7d:	ec                   	in     (%dx),%al
f0105e7e:	88 45 dd             	mov    %al,-0x23(%ebp)
	return data;
f0105e81:	8a 45 dd             	mov    -0x23(%ebp),%al
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_LATCH);

	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0105e84:	88 45 f3             	mov    %al,-0xd(%ebp)
f0105e87:	c7 45 e4 40 00 00 00 	movl   $0x40,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105e8e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105e91:	89 c2                	mov    %eax,%edx
f0105e93:	ec                   	in     (%dx),%al
f0105e94:	88 45 de             	mov    %al,-0x22(%ebp)
	return data;
f0105e97:	8a 45 de             	mov    -0x22(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0105e9a:	88 45 eb             	mov    %al,-0x15(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0105e9d:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
f0105ea1:	c1 e0 08             	shl    $0x8,%eax
f0105ea4:	89 c2                	mov    %eax,%edx
f0105ea6:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0105eaa:	09 d0                	or     %edx,%eax
f0105eac:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
	outb(TIMER_MODE, old_mode);
f0105eb0:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
f0105eb4:	c7 45 e0 43 00 00 00 	movl   $0x43,-0x20(%ebp)
f0105ebb:	88 45 df             	mov    %al,-0x21(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0105ebe:	8a 45 df             	mov    -0x21(%ebp),%al
f0105ec1:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0105ec4:	ee                   	out    %al,(%dx)

	return cnt0 ;
f0105ec5:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f0105ec8:	c9                   	leave  
f0105ec9:	c3                   	ret    

f0105eca <init_queue>:

//================================
// [1] Initialize the given queue:
//================================
void init_queue(struct Env_Queue* queue)
{
f0105eca:	55                   	push   %ebp
f0105ecb:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0105ecd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105ed1:	74 1d                	je     f0105ef0 <init_queue+0x26>
	{
		LIST_INIT(queue);
f0105ed3:	8b 45 08             	mov    0x8(%ebp),%eax
f0105ed6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0105edc:	8b 45 08             	mov    0x8(%ebp),%eax
f0105edf:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0105ee6:	8b 45 08             	mov    0x8(%ebp),%eax
f0105ee9:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	}
}
f0105ef0:	90                   	nop
f0105ef1:	5d                   	pop    %ebp
f0105ef2:	c3                   	ret    

f0105ef3 <queue_size>:

//================================
// [2] Get queue size:
//================================
int queue_size(struct Env_Queue* queue)
{
f0105ef3:	55                   	push   %ebp
f0105ef4:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0105ef6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105efa:	74 08                	je     f0105f04 <queue_size+0x11>
	{
		return LIST_SIZE(queue);
f0105efc:	8b 45 08             	mov    0x8(%ebp),%eax
f0105eff:	8b 40 0c             	mov    0xc(%eax),%eax
f0105f02:	eb 05                	jmp    f0105f09 <queue_size+0x16>
	}
	else
	{
		return 0;
f0105f04:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0105f09:	5d                   	pop    %ebp
f0105f0a:	c3                   	ret    

f0105f0b <enqueue>:

//====================================
// [3] Enqueue env in the given queue:
//====================================
void enqueue(struct Env_Queue* queue, struct Env* env)
{
f0105f0b:	55                   	push   %ebp
f0105f0c:	89 e5                	mov    %esp,%ebp
f0105f0e:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f0105f11:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105f15:	75 16                	jne    f0105f2d <enqueue+0x22>
f0105f17:	68 18 df 12 f0       	push   $0xf012df18
f0105f1c:	68 26 df 12 f0       	push   $0xf012df26
f0105f21:	6a 34                	push   $0x34
f0105f23:	68 3b df 12 f0       	push   $0xf012df3b
f0105f28:	e8 82 af ff ff       	call   f0100eaf <_panic>
	if(env != NULL)
f0105f2d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0105f31:	74 66                	je     f0105f99 <enqueue+0x8e>
	{
		LIST_INSERT_HEAD(queue, env);
f0105f33:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0105f37:	75 14                	jne    f0105f4d <enqueue+0x42>
f0105f39:	83 ec 04             	sub    $0x4,%esp
f0105f3c:	68 54 df 12 f0       	push   $0xf012df54
f0105f41:	6a 37                	push   $0x37
f0105f43:	68 3b df 12 f0       	push   $0xf012df3b
f0105f48:	e8 62 af ff ff       	call   f0100eaf <_panic>
f0105f4d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105f50:	8b 10                	mov    (%eax),%edx
f0105f52:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105f55:	89 50 08             	mov    %edx,0x8(%eax)
f0105f58:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105f5b:	8b 40 08             	mov    0x8(%eax),%eax
f0105f5e:	85 c0                	test   %eax,%eax
f0105f60:	74 0d                	je     f0105f6f <enqueue+0x64>
f0105f62:	8b 45 08             	mov    0x8(%ebp),%eax
f0105f65:	8b 00                	mov    (%eax),%eax
f0105f67:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105f6a:	89 50 0c             	mov    %edx,0xc(%eax)
f0105f6d:	eb 09                	jmp    f0105f78 <enqueue+0x6d>
f0105f6f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105f72:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105f75:	89 50 04             	mov    %edx,0x4(%eax)
f0105f78:	8b 45 08             	mov    0x8(%ebp),%eax
f0105f7b:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105f7e:	89 10                	mov    %edx,(%eax)
f0105f80:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105f83:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105f8a:	8b 45 08             	mov    0x8(%ebp),%eax
f0105f8d:	8b 40 0c             	mov    0xc(%eax),%eax
f0105f90:	8d 50 01             	lea    0x1(%eax),%edx
f0105f93:	8b 45 08             	mov    0x8(%ebp),%eax
f0105f96:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f0105f99:	90                   	nop
f0105f9a:	c9                   	leave  
f0105f9b:	c3                   	ret    

f0105f9c <dequeue>:

//======================================
// [4] Dequeue env from the given queue:
//======================================
struct Env* dequeue(struct Env_Queue* queue)
{
f0105f9c:	55                   	push   %ebp
f0105f9d:	89 e5                	mov    %esp,%ebp
f0105f9f:	83 ec 18             	sub    $0x18,%esp
	if (queue == NULL) return NULL;
f0105fa2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105fa6:	75 0a                	jne    f0105fb2 <dequeue+0x16>
f0105fa8:	b8 00 00 00 00       	mov    $0x0,%eax
f0105fad:	e9 a0 00 00 00       	jmp    f0106052 <dequeue+0xb6>
	struct Env* envItem = LIST_LAST(queue);
f0105fb2:	8b 45 08             	mov    0x8(%ebp),%eax
f0105fb5:	8b 40 04             	mov    0x4(%eax),%eax
f0105fb8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (envItem != NULL)
f0105fbb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105fbf:	0f 84 8a 00 00 00    	je     f010604f <dequeue+0xb3>
	{
		LIST_REMOVE(queue, envItem);
f0105fc5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105fc9:	75 14                	jne    f0105fdf <dequeue+0x43>
f0105fcb:	83 ec 04             	sub    $0x4,%esp
f0105fce:	68 77 df 12 f0       	push   $0xf012df77
f0105fd3:	6a 44                	push   $0x44
f0105fd5:	68 3b df 12 f0       	push   $0xf012df3b
f0105fda:	e8 d0 ae ff ff       	call   f0100eaf <_panic>
f0105fdf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105fe2:	8b 40 08             	mov    0x8(%eax),%eax
f0105fe5:	85 c0                	test   %eax,%eax
f0105fe7:	74 11                	je     f0105ffa <dequeue+0x5e>
f0105fe9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105fec:	8b 40 08             	mov    0x8(%eax),%eax
f0105fef:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105ff2:	8b 52 0c             	mov    0xc(%edx),%edx
f0105ff5:	89 50 0c             	mov    %edx,0xc(%eax)
f0105ff8:	eb 0c                	jmp    f0106006 <dequeue+0x6a>
f0105ffa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ffd:	8b 50 0c             	mov    0xc(%eax),%edx
f0106000:	8b 45 08             	mov    0x8(%ebp),%eax
f0106003:	89 50 04             	mov    %edx,0x4(%eax)
f0106006:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106009:	8b 40 0c             	mov    0xc(%eax),%eax
f010600c:	85 c0                	test   %eax,%eax
f010600e:	74 11                	je     f0106021 <dequeue+0x85>
f0106010:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106013:	8b 40 0c             	mov    0xc(%eax),%eax
f0106016:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106019:	8b 52 08             	mov    0x8(%edx),%edx
f010601c:	89 50 08             	mov    %edx,0x8(%eax)
f010601f:	eb 0b                	jmp    f010602c <dequeue+0x90>
f0106021:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106024:	8b 50 08             	mov    0x8(%eax),%edx
f0106027:	8b 45 08             	mov    0x8(%ebp),%eax
f010602a:	89 10                	mov    %edx,(%eax)
f010602c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010602f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0106036:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106039:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0106040:	8b 45 08             	mov    0x8(%ebp),%eax
f0106043:	8b 40 0c             	mov    0xc(%eax),%eax
f0106046:	8d 50 ff             	lea    -0x1(%eax),%edx
f0106049:	8b 45 08             	mov    0x8(%ebp),%eax
f010604c:	89 50 0c             	mov    %edx,0xc(%eax)
	}
	return envItem;
f010604f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0106052:	c9                   	leave  
f0106053:	c3                   	ret    

f0106054 <remove_from_queue>:

//====================================
// [5] Remove env from the given queue:
//====================================
void remove_from_queue(struct Env_Queue* queue, struct Env* e)
{
f0106054:	55                   	push   %ebp
f0106055:	89 e5                	mov    %esp,%ebp
f0106057:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f010605a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010605e:	75 16                	jne    f0106076 <remove_from_queue+0x22>
f0106060:	68 18 df 12 f0       	push   $0xf012df18
f0106065:	68 26 df 12 f0       	push   $0xf012df26
f010606a:	6a 4e                	push   $0x4e
f010606c:	68 3b df 12 f0       	push   $0xf012df3b
f0106071:	e8 39 ae ff ff       	call   f0100eaf <_panic>

	if (e != NULL)
f0106076:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010607a:	0f 84 8a 00 00 00    	je     f010610a <remove_from_queue+0xb6>
	{
		LIST_REMOVE(queue, e);
f0106080:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0106084:	75 14                	jne    f010609a <remove_from_queue+0x46>
f0106086:	83 ec 04             	sub    $0x4,%esp
f0106089:	68 77 df 12 f0       	push   $0xf012df77
f010608e:	6a 52                	push   $0x52
f0106090:	68 3b df 12 f0       	push   $0xf012df3b
f0106095:	e8 15 ae ff ff       	call   f0100eaf <_panic>
f010609a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010609d:	8b 40 08             	mov    0x8(%eax),%eax
f01060a0:	85 c0                	test   %eax,%eax
f01060a2:	74 11                	je     f01060b5 <remove_from_queue+0x61>
f01060a4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01060a7:	8b 40 08             	mov    0x8(%eax),%eax
f01060aa:	8b 55 0c             	mov    0xc(%ebp),%edx
f01060ad:	8b 52 0c             	mov    0xc(%edx),%edx
f01060b0:	89 50 0c             	mov    %edx,0xc(%eax)
f01060b3:	eb 0c                	jmp    f01060c1 <remove_from_queue+0x6d>
f01060b5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01060b8:	8b 50 0c             	mov    0xc(%eax),%edx
f01060bb:	8b 45 08             	mov    0x8(%ebp),%eax
f01060be:	89 50 04             	mov    %edx,0x4(%eax)
f01060c1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01060c4:	8b 40 0c             	mov    0xc(%eax),%eax
f01060c7:	85 c0                	test   %eax,%eax
f01060c9:	74 11                	je     f01060dc <remove_from_queue+0x88>
f01060cb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01060ce:	8b 40 0c             	mov    0xc(%eax),%eax
f01060d1:	8b 55 0c             	mov    0xc(%ebp),%edx
f01060d4:	8b 52 08             	mov    0x8(%edx),%edx
f01060d7:	89 50 08             	mov    %edx,0x8(%eax)
f01060da:	eb 0b                	jmp    f01060e7 <remove_from_queue+0x93>
f01060dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01060df:	8b 50 08             	mov    0x8(%eax),%edx
f01060e2:	8b 45 08             	mov    0x8(%ebp),%eax
f01060e5:	89 10                	mov    %edx,(%eax)
f01060e7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01060ea:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01060f1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01060f4:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01060fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01060fe:	8b 40 0c             	mov    0xc(%eax),%eax
f0106101:	8d 50 ff             	lea    -0x1(%eax),%edx
f0106104:	8b 45 08             	mov    0x8(%ebp),%eax
f0106107:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f010610a:	90                   	nop
f010610b:	c9                   	leave  
f010610c:	c3                   	ret    

f010610d <find_env_in_queue>:

//========================================
// [6] Search by envID in the given queue:
//========================================
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
f010610d:	55                   	push   %ebp
f010610e:	89 e5                	mov    %esp,%ebp
f0106110:	83 ec 10             	sub    $0x10,%esp
	if (queue == NULL) return NULL;
f0106113:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0106117:	75 07                	jne    f0106120 <find_env_in_queue+0x13>
f0106119:	b8 00 00 00 00       	mov    $0x0,%eax
f010611e:	eb 58                	jmp    f0106178 <find_env_in_queue+0x6b>

	struct Env * ptr_env=NULL;
f0106120:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	LIST_FOREACH(ptr_env, queue)
f0106127:	8b 45 08             	mov    0x8(%ebp),%eax
f010612a:	8b 00                	mov    (%eax),%eax
f010612c:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010612f:	eb 19                	jmp    f010614a <find_env_in_queue+0x3d>
	{
		if(ptr_env->env_id == envID)
f0106131:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0106134:	8b 40 10             	mov    0x10(%eax),%eax
f0106137:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010613a:	75 05                	jne    f0106141 <find_env_in_queue+0x34>
		{
			return ptr_env;
f010613c:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010613f:	eb 37                	jmp    f0106178 <find_env_in_queue+0x6b>
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
	if (queue == NULL) return NULL;

	struct Env * ptr_env=NULL;
	LIST_FOREACH(ptr_env, queue)
f0106141:	8b 45 08             	mov    0x8(%ebp),%eax
f0106144:	8b 40 08             	mov    0x8(%eax),%eax
f0106147:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010614a:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f010614e:	74 08                	je     f0106158 <find_env_in_queue+0x4b>
f0106150:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0106153:	8b 40 08             	mov    0x8(%eax),%eax
f0106156:	eb 05                	jmp    f010615d <find_env_in_queue+0x50>
f0106158:	b8 00 00 00 00       	mov    $0x0,%eax
f010615d:	8b 55 08             	mov    0x8(%ebp),%edx
f0106160:	89 42 08             	mov    %eax,0x8(%edx)
f0106163:	8b 45 08             	mov    0x8(%ebp),%eax
f0106166:	8b 40 08             	mov    0x8(%eax),%eax
f0106169:	85 c0                	test   %eax,%eax
f010616b:	75 c4                	jne    f0106131 <find_env_in_queue+0x24>
f010616d:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0106171:	75 be                	jne    f0106131 <find_env_in_queue+0x24>
		if(ptr_env->env_id == envID)
		{
			return ptr_env;
		}
	}
	return NULL;
f0106173:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0106178:	c9                   	leave  
f0106179:	c3                   	ret    

f010617a <sched_delete_ready_queues>:

//========================================
// [1] Delete all ready queues:
//========================================
void sched_delete_ready_queues()
{
f010617a:	55                   	push   %ebp
f010617b:	89 e5                	mov    %esp,%ebp
f010617d:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	acquire_kspinlock(&ProcessQueues.qlock);
f0106180:	83 ec 0c             	sub    $0xc,%esp
f0106183:	68 20 e7 83 f0       	push   $0xf083e720
f0106188:	e8 ee 9b 00 00       	call   f010fd7b <acquire_kspinlock>
f010618d:	83 c4 10             	add    $0x10,%esp
	{
		if (ProcessQueues.env_ready_queues != NULL)
f0106190:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106195:	85 c0                	test   %eax,%eax
f0106197:	74 11                	je     f01061aa <sched_delete_ready_queues+0x30>
			kfree(ProcessQueues.env_ready_queues);
f0106199:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f010619e:	83 ec 0c             	sub    $0xc,%esp
f01061a1:	50                   	push   %eax
f01061a2:	e8 a9 39 00 00       	call   f0109b50 <kfree>
f01061a7:	83 c4 10             	add    $0x10,%esp
		if (quantums != NULL)
f01061aa:	a1 e4 6a 85 f0       	mov    0xf0856ae4,%eax
f01061af:	85 c0                	test   %eax,%eax
f01061b1:	74 11                	je     f01061c4 <sched_delete_ready_queues+0x4a>
			kfree(quantums);
f01061b3:	a1 e4 6a 85 f0       	mov    0xf0856ae4,%eax
f01061b8:	83 ec 0c             	sub    $0xc,%esp
f01061bb:	50                   	push   %eax
f01061bc:	e8 8f 39 00 00       	call   f0109b50 <kfree>
f01061c1:	83 c4 10             	add    $0x10,%esp
	}
	release_kspinlock(&ProcessQueues.qlock);
f01061c4:	83 ec 0c             	sub    $0xc,%esp
f01061c7:	68 20 e7 83 f0       	push   $0xf083e720
f01061cc:	e8 4f 9c 00 00       	call   f010fe20 <release_kspinlock>
f01061d1:	83 c4 10             	add    $0x10,%esp

#endif
}
f01061d4:	90                   	nop
f01061d5:	c9                   	leave  
f01061d6:	c3                   	ret    

f01061d7 <sched_insert_ready>:

//============================================================
// [2] Insert the given Env in the priority-based Ready Queue:
//============================================================
void sched_insert_ready(struct Env* env)
{
f01061d7:	55                   	push   %ebp
f01061d8:	89 e5                	mov    %esp,%ebp
f01061da:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f01061dd:	83 ec 0c             	sub    $0xc,%esp
f01061e0:	68 20 e7 83 f0       	push   $0xf083e720
f01061e5:	e8 e6 9d 00 00       	call   f010ffd0 <holding_kspinlock>
f01061ea:	83 c4 10             	add    $0x10,%esp
f01061ed:	85 c0                	test   %eax,%eax
f01061ef:	75 17                	jne    f0106208 <sched_insert_ready+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01061f1:	83 ec 04             	sub    $0x4,%esp
f01061f4:	68 98 df 12 f0       	push   $0xf012df98
f01061f9:	68 97 00 00 00       	push   $0x97
f01061fe:	68 3b df 12 f0       	push   $0xf012df3b
f0106203:	e8 a7 ac ff ff       	call   f0100eaf <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0106208:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010620c:	75 19                	jne    f0106227 <sched_insert_ready+0x50>
f010620e:	68 d9 df 12 f0       	push   $0xf012dfd9
f0106213:	68 26 df 12 f0       	push   $0xf012df26
f0106218:	68 9a 00 00 00       	push   $0x9a
f010621d:	68 3b df 12 f0       	push   $0xf012df3b
f0106222:	e8 88 ac ff ff       	call   f0100eaf <_panic>
	{
		//cprintf("\nInserting %d into ready queue 0\n", env->env_id);
		env->env_status = ENV_READY ;
f0106227:	8b 45 08             	mov    0x8(%ebp),%eax
f010622a:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		enqueue(&(ProcessQueues.env_ready_queues[env->priority]), env);
f0106231:	8b 15 b0 e7 83 f0    	mov    0xf083e7b0,%edx
f0106237:	8b 45 08             	mov    0x8(%ebp),%eax
f010623a:	8b 40 1c             	mov    0x1c(%eax),%eax
f010623d:	c1 e0 04             	shl    $0x4,%eax
f0106240:	01 d0                	add    %edx,%eax
f0106242:	83 ec 08             	sub    $0x8,%esp
f0106245:	ff 75 08             	pushl  0x8(%ebp)
f0106248:	50                   	push   %eax
f0106249:	e8 bd fc ff ff       	call   f0105f0b <enqueue>
f010624e:	83 c4 10             	add    $0x10,%esp
	}
}
f0106251:	90                   	nop
f0106252:	c9                   	leave  
f0106253:	c3                   	ret    

f0106254 <sched_remove_ready>:

//=================================================
// [3] Remove the given Env from the Ready Queue(s):
//=================================================
void sched_remove_ready(struct Env* env)
{
f0106254:	55                   	push   %ebp
f0106255:	89 e5                	mov    %esp,%ebp
f0106257:	83 ec 18             	sub    $0x18,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f010625a:	83 ec 0c             	sub    $0xc,%esp
f010625d:	68 20 e7 83 f0       	push   $0xf083e720
f0106262:	e8 69 9d 00 00       	call   f010ffd0 <holding_kspinlock>
f0106267:	83 c4 10             	add    $0x10,%esp
f010626a:	85 c0                	test   %eax,%eax
f010626c:	75 17                	jne    f0106285 <sched_remove_ready+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010626e:	83 ec 04             	sub    $0x4,%esp
f0106271:	68 98 df 12 f0       	push   $0xf012df98
f0106276:	68 a9 00 00 00       	push   $0xa9
f010627b:	68 3b df 12 f0       	push   $0xf012df3b
f0106280:	e8 2a ac ff ff       	call   f0100eaf <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
f0106285:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0106289:	74 0b                	je     f0106296 <sched_remove_ready+0x42>
f010628b:	8b 45 08             	mov    0x8(%ebp),%eax
f010628e:	8b 40 18             	mov    0x18(%eax),%eax
f0106291:	83 f8 01             	cmp    $0x1,%eax
f0106294:	74 19                	je     f01062af <sched_remove_ready+0x5b>
f0106296:	68 e8 df 12 f0       	push   $0xf012dfe8
f010629b:	68 26 df 12 f0       	push   $0xf012df26
f01062a0:	68 ac 00 00 00       	push   $0xac
f01062a5:	68 3b df 12 f0       	push   $0xf012df3b
f01062aa:	e8 00 ac ff ff       	call   f0100eaf <_panic>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f01062af:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01062b6:	e9 e4 00 00 00       	jmp    f010639f <sched_remove_ready+0x14b>
		{
			struct Env * ptr_env = find_env_in_queue(&(ProcessQueues.env_ready_queues[i]), env->env_id);
f01062bb:	8b 45 08             	mov    0x8(%ebp),%eax
f01062be:	8b 40 10             	mov    0x10(%eax),%eax
f01062c1:	89 c2                	mov    %eax,%edx
f01062c3:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f01062c8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01062cb:	c1 e1 04             	shl    $0x4,%ecx
f01062ce:	01 c8                	add    %ecx,%eax
f01062d0:	83 ec 08             	sub    $0x8,%esp
f01062d3:	52                   	push   %edx
f01062d4:	50                   	push   %eax
f01062d5:	e8 33 fe ff ff       	call   f010610d <find_env_in_queue>
f01062da:	83 c4 10             	add    $0x10,%esp
f01062dd:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_env != NULL)
f01062e0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01062e4:	0f 84 b2 00 00 00    	je     f010639c <sched_remove_ready+0x148>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), env);
f01062ea:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01062ee:	75 17                	jne    f0106307 <sched_remove_ready+0xb3>
f01062f0:	83 ec 04             	sub    $0x4,%esp
f01062f3:	68 77 df 12 f0       	push   $0xf012df77
f01062f8:	68 b3 00 00 00       	push   $0xb3
f01062fd:	68 3b df 12 f0       	push   $0xf012df3b
f0106302:	e8 a8 ab ff ff       	call   f0100eaf <_panic>
f0106307:	8b 45 08             	mov    0x8(%ebp),%eax
f010630a:	8b 40 08             	mov    0x8(%eax),%eax
f010630d:	85 c0                	test   %eax,%eax
f010630f:	74 11                	je     f0106322 <sched_remove_ready+0xce>
f0106311:	8b 45 08             	mov    0x8(%ebp),%eax
f0106314:	8b 40 08             	mov    0x8(%eax),%eax
f0106317:	8b 55 08             	mov    0x8(%ebp),%edx
f010631a:	8b 52 0c             	mov    0xc(%edx),%edx
f010631d:	89 50 0c             	mov    %edx,0xc(%eax)
f0106320:	eb 16                	jmp    f0106338 <sched_remove_ready+0xe4>
f0106322:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106327:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010632a:	c1 e2 04             	shl    $0x4,%edx
f010632d:	01 c2                	add    %eax,%edx
f010632f:	8b 45 08             	mov    0x8(%ebp),%eax
f0106332:	8b 40 0c             	mov    0xc(%eax),%eax
f0106335:	89 42 04             	mov    %eax,0x4(%edx)
f0106338:	8b 45 08             	mov    0x8(%ebp),%eax
f010633b:	8b 40 0c             	mov    0xc(%eax),%eax
f010633e:	85 c0                	test   %eax,%eax
f0106340:	74 11                	je     f0106353 <sched_remove_ready+0xff>
f0106342:	8b 45 08             	mov    0x8(%ebp),%eax
f0106345:	8b 40 0c             	mov    0xc(%eax),%eax
f0106348:	8b 55 08             	mov    0x8(%ebp),%edx
f010634b:	8b 52 08             	mov    0x8(%edx),%edx
f010634e:	89 50 08             	mov    %edx,0x8(%eax)
f0106351:	eb 15                	jmp    f0106368 <sched_remove_ready+0x114>
f0106353:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106358:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010635b:	c1 e2 04             	shl    $0x4,%edx
f010635e:	01 c2                	add    %eax,%edx
f0106360:	8b 45 08             	mov    0x8(%ebp),%eax
f0106363:	8b 40 08             	mov    0x8(%eax),%eax
f0106366:	89 02                	mov    %eax,(%edx)
f0106368:	8b 45 08             	mov    0x8(%ebp),%eax
f010636b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0106372:	8b 45 08             	mov    0x8(%ebp),%eax
f0106375:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010637c:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106381:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106384:	c1 e2 04             	shl    $0x4,%edx
f0106387:	01 d0                	add    %edx,%eax
f0106389:	8b 50 0c             	mov    0xc(%eax),%edx
f010638c:	4a                   	dec    %edx
f010638d:	89 50 0c             	mov    %edx,0xc(%eax)
				env->env_status = ENV_UNKNOWN;
f0106390:	8b 45 08             	mov    0x8(%ebp),%eax
f0106393:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%eax)
				return ;
f010639a:	eb 14                	jmp    f01063b0 <sched_remove_ready+0x15c>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f010639c:	ff 45 f4             	incl   -0xc(%ebp)
f010639f:	a0 60 6d 85 f0       	mov    0xf0856d60,%al
f01063a4:	0f b6 c0             	movzbl %al,%eax
f01063a7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01063aa:	0f 8f 0b ff ff ff    	jg     f01062bb <sched_remove_ready+0x67>
				env->env_status = ENV_UNKNOWN;
				return ;
			}
		}
	}
}
f01063b0:	c9                   	leave  
f01063b1:	c3                   	ret    

f01063b2 <sched_insert_new>:

//=================================================
// [4] Insert the given Env in NEW Queue:
//=================================================
void sched_insert_new(struct Env* env)
{
f01063b2:	55                   	push   %ebp
f01063b3:	89 e5                	mov    %esp,%ebp
f01063b5:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f01063b8:	83 ec 0c             	sub    $0xc,%esp
f01063bb:	68 20 e7 83 f0       	push   $0xf083e720
f01063c0:	e8 0b 9c 00 00       	call   f010ffd0 <holding_kspinlock>
f01063c5:	83 c4 10             	add    $0x10,%esp
f01063c8:	85 c0                	test   %eax,%eax
f01063ca:	75 17                	jne    f01063e3 <sched_insert_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01063cc:	83 ec 04             	sub    $0x4,%esp
f01063cf:	68 98 df 12 f0       	push   $0xf012df98
f01063d4:	68 c2 00 00 00       	push   $0xc2
f01063d9:	68 3b df 12 f0       	push   $0xf012df3b
f01063de:	e8 cc aa ff ff       	call   f0100eaf <_panic>
	/*********************************************************************/

	assert(env != NULL);
f01063e3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01063e7:	75 19                	jne    f0106402 <sched_insert_new+0x50>
f01063e9:	68 d9 df 12 f0       	push   $0xf012dfd9
f01063ee:	68 26 df 12 f0       	push   $0xf012df26
f01063f3:	68 c5 00 00 00       	push   $0xc5
f01063f8:	68 3b df 12 f0       	push   $0xf012df3b
f01063fd:	e8 ad aa ff ff       	call   f0100eaf <_panic>
	{
		env->env_status = ENV_NEW ;
f0106402:	8b 45 08             	mov    0x8(%ebp),%eax
f0106405:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
		enqueue(&ProcessQueues.env_new_queue, env);
f010640c:	83 ec 08             	sub    $0x8,%esp
f010640f:	ff 75 08             	pushl  0x8(%ebp)
f0106412:	68 90 e7 83 f0       	push   $0xf083e790
f0106417:	e8 ef fa ff ff       	call   f0105f0b <enqueue>
f010641c:	83 c4 10             	add    $0x10,%esp
	}
}
f010641f:	90                   	nop
f0106420:	c9                   	leave  
f0106421:	c3                   	ret    

f0106422 <sched_remove_new>:

//=================================================
// [5] Remove the given Env from NEW Queue:
//=================================================
void sched_remove_new(struct Env* env)
{
f0106422:	55                   	push   %ebp
f0106423:	89 e5                	mov    %esp,%ebp
f0106425:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f0106428:	83 ec 0c             	sub    $0xc,%esp
f010642b:	68 20 e7 83 f0       	push   $0xf083e720
f0106430:	e8 9b 9b 00 00       	call   f010ffd0 <holding_kspinlock>
f0106435:	83 c4 10             	add    $0x10,%esp
f0106438:	85 c0                	test   %eax,%eax
f010643a:	75 17                	jne    f0106453 <sched_remove_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010643c:	83 ec 04             	sub    $0x4,%esp
f010643f:	68 98 df 12 f0       	push   $0xf012df98
f0106444:	68 d3 00 00 00       	push   $0xd3
f0106449:	68 3b df 12 f0       	push   $0xf012df3b
f010644e:	e8 5c aa ff ff       	call   f0100eaf <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_NEW);
f0106453:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0106457:	74 0b                	je     f0106464 <sched_remove_new+0x42>
f0106459:	8b 45 08             	mov    0x8(%ebp),%eax
f010645c:	8b 40 18             	mov    0x18(%eax),%eax
f010645f:	83 f8 04             	cmp    $0x4,%eax
f0106462:	74 19                	je     f010647d <sched_remove_new+0x5b>
f0106464:	68 14 e0 12 f0       	push   $0xf012e014
f0106469:	68 26 df 12 f0       	push   $0xf012df26
f010646e:	68 d6 00 00 00       	push   $0xd6
f0106473:	68 3b df 12 f0       	push   $0xf012df3b
f0106478:	e8 32 aa ff ff       	call   f0100eaf <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_new_queue, env) ;
f010647d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0106481:	75 17                	jne    f010649a <sched_remove_new+0x78>
f0106483:	83 ec 04             	sub    $0x4,%esp
f0106486:	68 77 df 12 f0       	push   $0xf012df77
f010648b:	68 d8 00 00 00       	push   $0xd8
f0106490:	68 3b df 12 f0       	push   $0xf012df3b
f0106495:	e8 15 aa ff ff       	call   f0100eaf <_panic>
f010649a:	8b 45 08             	mov    0x8(%ebp),%eax
f010649d:	8b 40 08             	mov    0x8(%eax),%eax
f01064a0:	85 c0                	test   %eax,%eax
f01064a2:	74 11                	je     f01064b5 <sched_remove_new+0x93>
f01064a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01064a7:	8b 40 08             	mov    0x8(%eax),%eax
f01064aa:	8b 55 08             	mov    0x8(%ebp),%edx
f01064ad:	8b 52 0c             	mov    0xc(%edx),%edx
f01064b0:	89 50 0c             	mov    %edx,0xc(%eax)
f01064b3:	eb 0b                	jmp    f01064c0 <sched_remove_new+0x9e>
f01064b5:	8b 45 08             	mov    0x8(%ebp),%eax
f01064b8:	8b 40 0c             	mov    0xc(%eax),%eax
f01064bb:	a3 94 e7 83 f0       	mov    %eax,0xf083e794
f01064c0:	8b 45 08             	mov    0x8(%ebp),%eax
f01064c3:	8b 40 0c             	mov    0xc(%eax),%eax
f01064c6:	85 c0                	test   %eax,%eax
f01064c8:	74 11                	je     f01064db <sched_remove_new+0xb9>
f01064ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01064cd:	8b 40 0c             	mov    0xc(%eax),%eax
f01064d0:	8b 55 08             	mov    0x8(%ebp),%edx
f01064d3:	8b 52 08             	mov    0x8(%edx),%edx
f01064d6:	89 50 08             	mov    %edx,0x8(%eax)
f01064d9:	eb 0b                	jmp    f01064e6 <sched_remove_new+0xc4>
f01064db:	8b 45 08             	mov    0x8(%ebp),%eax
f01064de:	8b 40 08             	mov    0x8(%eax),%eax
f01064e1:	a3 90 e7 83 f0       	mov    %eax,0xf083e790
f01064e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01064e9:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01064f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01064f3:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01064fa:	a1 9c e7 83 f0       	mov    0xf083e79c,%eax
f01064ff:	48                   	dec    %eax
f0106500:	a3 9c e7 83 f0       	mov    %eax,0xf083e79c
		env->env_status = ENV_UNKNOWN;
f0106505:	8b 45 08             	mov    0x8(%ebp),%eax
f0106508:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%eax)
	}
}
f010650f:	90                   	nop
f0106510:	c9                   	leave  
f0106511:	c3                   	ret    

f0106512 <sched_insert_exit>:

//=================================================
// [6] Insert the given Env in EXIT Queue:
//=================================================
void sched_insert_exit(struct Env* env)
{
f0106512:	55                   	push   %ebp
f0106513:	89 e5                	mov    %esp,%ebp
f0106515:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f0106518:	83 ec 0c             	sub    $0xc,%esp
f010651b:	68 20 e7 83 f0       	push   $0xf083e720
f0106520:	e8 ab 9a 00 00       	call   f010ffd0 <holding_kspinlock>
f0106525:	83 c4 10             	add    $0x10,%esp
f0106528:	85 c0                	test   %eax,%eax
f010652a:	75 17                	jne    f0106543 <sched_insert_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010652c:	83 ec 04             	sub    $0x4,%esp
f010652f:	68 98 df 12 f0       	push   $0xf012df98
f0106534:	68 e4 00 00 00       	push   $0xe4
f0106539:	68 3b df 12 f0       	push   $0xf012df3b
f010653e:	e8 6c a9 ff ff       	call   f0100eaf <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0106543:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0106547:	75 19                	jne    f0106562 <sched_insert_exit+0x50>
f0106549:	68 d9 df 12 f0       	push   $0xf012dfd9
f010654e:	68 26 df 12 f0       	push   $0xf012df26
f0106553:	68 e7 00 00 00       	push   $0xe7
f0106558:	68 3b df 12 f0       	push   $0xf012df3b
f010655d:	e8 4d a9 ff ff       	call   f0100eaf <_panic>
	{
		if(isBufferingEnabled()) {cleanup_buffers(env);}
f0106562:	e8 9a 93 00 00       	call   f010f901 <isBufferingEnabled>
f0106567:	84 c0                	test   %al,%al
f0106569:	74 0e                	je     f0106579 <sched_insert_exit+0x67>
f010656b:	83 ec 0c             	sub    $0xc,%esp
f010656e:	ff 75 08             	pushl  0x8(%ebp)
f0106571:	e8 30 66 00 00       	call   f010cba6 <cleanup_buffers>
f0106576:	83 c4 10             	add    $0x10,%esp
		env->env_status = ENV_EXIT ;
f0106579:	8b 45 08             	mov    0x8(%ebp),%eax
f010657c:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%eax)
		enqueue(&ProcessQueues.env_exit_queue, env);
f0106583:	83 ec 08             	sub    $0x8,%esp
f0106586:	ff 75 08             	pushl  0x8(%ebp)
f0106589:	68 a0 e7 83 f0       	push   $0xf083e7a0
f010658e:	e8 78 f9 ff ff       	call   f0105f0b <enqueue>
f0106593:	83 c4 10             	add    $0x10,%esp
	}
}
f0106596:	90                   	nop
f0106597:	c9                   	leave  
f0106598:	c3                   	ret    

f0106599 <sched_remove_exit>:
//=================================================
// [7] Remove the given Env from EXIT Queue:
//=================================================
void sched_remove_exit(struct Env* env)
{
f0106599:	55                   	push   %ebp
f010659a:	89 e5                	mov    %esp,%ebp
f010659c:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f010659f:	83 ec 0c             	sub    $0xc,%esp
f01065a2:	68 20 e7 83 f0       	push   $0xf083e720
f01065a7:	e8 24 9a 00 00       	call   f010ffd0 <holding_kspinlock>
f01065ac:	83 c4 10             	add    $0x10,%esp
f01065af:	85 c0                	test   %eax,%eax
f01065b1:	75 17                	jne    f01065ca <sched_remove_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01065b3:	83 ec 04             	sub    $0x4,%esp
f01065b6:	68 98 df 12 f0       	push   $0xf012df98
f01065bb:	68 f5 00 00 00       	push   $0xf5
f01065c0:	68 3b df 12 f0       	push   $0xf012df3b
f01065c5:	e8 e5 a8 ff ff       	call   f0100eaf <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_EXIT);
f01065ca:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01065ce:	74 0b                	je     f01065db <sched_remove_exit+0x42>
f01065d0:	8b 45 08             	mov    0x8(%ebp),%eax
f01065d3:	8b 40 18             	mov    0x18(%eax),%eax
f01065d6:	83 f8 05             	cmp    $0x5,%eax
f01065d9:	74 19                	je     f01065f4 <sched_remove_exit+0x5b>
f01065db:	68 40 e0 12 f0       	push   $0xf012e040
f01065e0:	68 26 df 12 f0       	push   $0xf012df26
f01065e5:	68 f8 00 00 00       	push   $0xf8
f01065ea:	68 3b df 12 f0       	push   $0xf012df3b
f01065ef:	e8 bb a8 ff ff       	call   f0100eaf <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_exit_queue, env) ;
f01065f4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01065f8:	75 17                	jne    f0106611 <sched_remove_exit+0x78>
f01065fa:	83 ec 04             	sub    $0x4,%esp
f01065fd:	68 77 df 12 f0       	push   $0xf012df77
f0106602:	68 fa 00 00 00       	push   $0xfa
f0106607:	68 3b df 12 f0       	push   $0xf012df3b
f010660c:	e8 9e a8 ff ff       	call   f0100eaf <_panic>
f0106611:	8b 45 08             	mov    0x8(%ebp),%eax
f0106614:	8b 40 08             	mov    0x8(%eax),%eax
f0106617:	85 c0                	test   %eax,%eax
f0106619:	74 11                	je     f010662c <sched_remove_exit+0x93>
f010661b:	8b 45 08             	mov    0x8(%ebp),%eax
f010661e:	8b 40 08             	mov    0x8(%eax),%eax
f0106621:	8b 55 08             	mov    0x8(%ebp),%edx
f0106624:	8b 52 0c             	mov    0xc(%edx),%edx
f0106627:	89 50 0c             	mov    %edx,0xc(%eax)
f010662a:	eb 0b                	jmp    f0106637 <sched_remove_exit+0x9e>
f010662c:	8b 45 08             	mov    0x8(%ebp),%eax
f010662f:	8b 40 0c             	mov    0xc(%eax),%eax
f0106632:	a3 a4 e7 83 f0       	mov    %eax,0xf083e7a4
f0106637:	8b 45 08             	mov    0x8(%ebp),%eax
f010663a:	8b 40 0c             	mov    0xc(%eax),%eax
f010663d:	85 c0                	test   %eax,%eax
f010663f:	74 11                	je     f0106652 <sched_remove_exit+0xb9>
f0106641:	8b 45 08             	mov    0x8(%ebp),%eax
f0106644:	8b 40 0c             	mov    0xc(%eax),%eax
f0106647:	8b 55 08             	mov    0x8(%ebp),%edx
f010664a:	8b 52 08             	mov    0x8(%edx),%edx
f010664d:	89 50 08             	mov    %edx,0x8(%eax)
f0106650:	eb 0b                	jmp    f010665d <sched_remove_exit+0xc4>
f0106652:	8b 45 08             	mov    0x8(%ebp),%eax
f0106655:	8b 40 08             	mov    0x8(%eax),%eax
f0106658:	a3 a0 e7 83 f0       	mov    %eax,0xf083e7a0
f010665d:	8b 45 08             	mov    0x8(%ebp),%eax
f0106660:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0106667:	8b 45 08             	mov    0x8(%ebp),%eax
f010666a:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0106671:	a1 ac e7 83 f0       	mov    0xf083e7ac,%eax
f0106676:	48                   	dec    %eax
f0106677:	a3 ac e7 83 f0       	mov    %eax,0xf083e7ac
		env->env_status = ENV_UNKNOWN;
f010667c:	8b 45 08             	mov    0x8(%ebp),%eax
f010667f:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%eax)
	}
}
f0106686:	90                   	nop
f0106687:	c9                   	leave  
f0106688:	c3                   	ret    

f0106689 <sched_new_env>:

//=================================================
// [8] Sched the given Env in NEW Queue:
//=================================================
void sched_new_env(struct Env* e)
{
f0106689:	55                   	push   %ebp
f010668a:	89 e5                	mov    %esp,%ebp
f010668c:	83 ec 08             	sub    $0x8,%esp
	  //cprintf("\n[SCHED_NEW_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010668f:	83 ec 0c             	sub    $0xc,%esp
f0106692:	68 20 e7 83 f0       	push   $0xf083e720
f0106697:	e8 df 96 00 00       	call   f010fd7b <acquire_kspinlock>
f010669c:	83 c4 10             	add    $0x10,%esp

	//add the given env to the scheduler NEW queue
	assert (e!=NULL);
f010669f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01066a3:	75 19                	jne    f01066be <sched_new_env+0x35>
f01066a5:	68 6b e0 12 f0       	push   $0xf012e06b
f01066aa:	68 26 df 12 f0       	push   $0xf012df26
f01066af:	68 08 01 00 00       	push   $0x108
f01066b4:	68 3b df 12 f0       	push   $0xf012df3b
f01066b9:	e8 f1 a7 ff ff       	call   f0100eaf <_panic>
	{
		sched_insert_new(e);
f01066be:	83 ec 0c             	sub    $0xc,%esp
f01066c1:	ff 75 08             	pushl  0x8(%ebp)
f01066c4:	e8 e9 fc ff ff       	call   f01063b2 <sched_insert_new>
f01066c9:	83 c4 10             	add    $0x10,%esp
	}

	release_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01066cc:	83 ec 0c             	sub    $0xc,%esp
f01066cf:	68 20 e7 83 f0       	push   $0xf083e720
f01066d4:	e8 47 97 00 00       	call   f010fe20 <release_kspinlock>
f01066d9:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_NEW_ENV] release: lock status after = %d\n", qlock.locked);
}
f01066dc:	90                   	nop
f01066dd:	c9                   	leave  
f01066de:	c3                   	ret    

f01066df <sched_run_env>:

//=================================================
// [9] Run the given EnvID:
//=================================================
void sched_run_env(uint32 envId)
{
f01066df:	55                   	push   %ebp
f01066e0:	89 e5                	mov    %esp,%ebp
f01066e2:	83 ec 18             	sub    $0x18,%esp
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01066e5:	83 ec 0c             	sub    $0xc,%esp
f01066e8:	68 20 e7 83 f0       	push   $0xf083e720
f01066ed:	e8 89 96 00 00       	call   f010fd7b <acquire_kspinlock>
f01066f2:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f01066f5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01066fc:	a1 90 e7 83 f0       	mov    0xf083e790,%eax
f0106701:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106704:	eb 53                	jmp    f0106759 <sched_run_env+0x7a>
	{
		if(ptr_env->env_id == envId)
f0106706:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106709:	8b 40 10             	mov    0x10(%eax),%eax
f010670c:	3b 45 08             	cmp    0x8(%ebp),%eax
f010670f:	75 40                	jne    f0106751 <sched_run_env+0x72>
		{
			sched_remove_new(ptr_env);
f0106711:	83 ec 0c             	sub    $0xc,%esp
f0106714:	ff 75 f4             	pushl  -0xc(%ebp)
f0106717:	e8 06 fd ff ff       	call   f0106422 <sched_remove_new>
f010671c:	83 c4 10             	add    $0x10,%esp
			sched_insert_ready(ptr_env);
f010671f:	83 ec 0c             	sub    $0xc,%esp
f0106722:	ff 75 f4             	pushl  -0xc(%ebp)
f0106725:	e8 ad fa ff ff       	call   f01061d7 <sched_insert_ready>
f010672a:	83 c4 10             	add    $0x10,%esp

			/*2015*///if scheduler not run yet, then invoke it!
			if (mycpu()->scheduler_status == SCH_STOPPED)
f010672d:	e8 3e 18 00 00       	call   f0107f70 <mycpu>
f0106732:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f0106738:	85 c0                	test   %eax,%eax
f010673a:	75 46                	jne    f0106782 <sched_run_env+0xa3>
			{
				release_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010673c:	83 ec 0c             	sub    $0xc,%esp
f010673f:	68 20 e7 83 f0       	push   $0xf083e720
f0106744:	e8 d7 96 00 00       	call   f010fe20 <release_kspinlock>
f0106749:	83 c4 10             	add    $0x10,%esp
				  //cprintf("\n[SCHED_RUN_ENV] release#1: lock status after = %d\n", qlock.locked);
				fos_scheduler();
f010674c:	e8 f6 0f 00 00       	call   f0107747 <fos_scheduler>
void sched_run_env(uint32 envId)
{
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106751:	a1 98 e7 83 f0       	mov    0xf083e798,%eax
f0106756:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106759:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010675d:	74 08                	je     f0106767 <sched_run_env+0x88>
f010675f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106762:	8b 40 08             	mov    0x8(%eax),%eax
f0106765:	eb 05                	jmp    f010676c <sched_run_env+0x8d>
f0106767:	b8 00 00 00 00       	mov    $0x0,%eax
f010676c:	a3 98 e7 83 f0       	mov    %eax,0xf083e798
f0106771:	a1 98 e7 83 f0       	mov    0xf083e798,%eax
f0106776:	85 c0                	test   %eax,%eax
f0106778:	75 8c                	jne    f0106706 <sched_run_env+0x27>
f010677a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010677e:	75 86                	jne    f0106706 <sched_run_env+0x27>
f0106780:	eb 01                	jmp    f0106783 <sched_run_env+0xa4>
			}
			else
			{
				//can be invoked from a running environment via sys_run_env(), so just release the lock and resume
			}
			break;
f0106782:	90                   	nop
		}
	}
	release_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106783:	83 ec 0c             	sub    $0xc,%esp
f0106786:	68 20 e7 83 f0       	push   $0xf083e720
f010678b:	e8 90 96 00 00       	call   f010fe20 <release_kspinlock>
f0106790:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_RUN_ENV] release#2: lock status after = %d\n", qlock.locked);
}
f0106793:	90                   	nop
f0106794:	c9                   	leave  
f0106795:	c3                   	ret    

f0106796 <sched_exit_env>:

//=================================================
// [10] Exit the given EnvID:
//=================================================
void sched_exit_env(uint32 envId)
{
f0106796:	55                   	push   %ebp
f0106797:	89 e5                	mov    %esp,%ebp
f0106799:	83 ec 28             	sub    $0x28,%esp
	bool lock_already_held = holding_kspinlock(&ProcessQueues.qlock);
f010679c:	83 ec 0c             	sub    $0xc,%esp
f010679f:	68 20 e7 83 f0       	push   $0xf083e720
f01067a4:	e8 27 98 00 00       	call   f010ffd0 <holding_kspinlock>
f01067a9:	83 c4 10             	add    $0x10,%esp
f01067ac:	89 45 e8             	mov    %eax,-0x18(%ebp)
	  //cprintf("\n[SCHED_EXIT_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	if (!lock_already_held)
f01067af:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01067b3:	75 10                	jne    f01067c5 <sched_exit_env+0x2f>
	{
		acquire_kspinlock(&ProcessQueues.qlock);
f01067b5:	83 ec 0c             	sub    $0xc,%esp
f01067b8:	68 20 e7 83 f0       	push   $0xf083e720
f01067bd:	e8 b9 95 00 00       	call   f010fd7b <acquire_kspinlock>
f01067c2:	83 c4 10             	add    $0x10,%esp
	}
	struct Env* ptr_env=NULL;
f01067c5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f01067cc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f01067d3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01067d7:	75 59                	jne    f0106832 <sched_exit_env+0x9c>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01067d9:	a1 90 e7 83 f0       	mov    0xf083e790,%eax
f01067de:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01067e1:	eb 28                	jmp    f010680b <sched_exit_env+0x75>
		{
			if(ptr_env->env_id == envId)
f01067e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01067e6:	8b 40 10             	mov    0x10(%eax),%eax
f01067e9:	3b 45 08             	cmp    0x8(%ebp),%eax
f01067ec:	75 15                	jne    f0106803 <sched_exit_env+0x6d>
			{
				sched_remove_new(ptr_env);
f01067ee:	83 ec 0c             	sub    $0xc,%esp
f01067f1:	ff 75 f4             	pushl  -0xc(%ebp)
f01067f4:	e8 29 fc ff ff       	call   f0106422 <sched_remove_new>
f01067f9:	83 c4 10             	add    $0x10,%esp
				found = 1;
f01067fc:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106803:	a1 98 e7 83 f0       	mov    0xf083e798,%eax
f0106808:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010680b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010680f:	74 08                	je     f0106819 <sched_exit_env+0x83>
f0106811:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106814:	8b 40 08             	mov    0x8(%eax),%eax
f0106817:	eb 05                	jmp    f010681e <sched_exit_env+0x88>
f0106819:	b8 00 00 00 00       	mov    $0x0,%eax
f010681e:	a3 98 e7 83 f0       	mov    %eax,0xf083e798
f0106823:	a1 98 e7 83 f0       	mov    0xf083e798,%eax
f0106828:	85 c0                	test   %eax,%eax
f010682a:	75 b7                	jne    f01067e3 <sched_exit_env+0x4d>
f010682c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106830:	75 b1                	jne    f01067e3 <sched_exit_env+0x4d>
				found = 1;
				//			return;
			}
		}
	}
	if (!found)
f0106832:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106836:	0f 85 67 01 00 00    	jne    f01069a3 <sched_exit_env+0x20d>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f010683c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0106843:	e9 47 01 00 00       	jmp    f010698f <sched_exit_env+0x1f9>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0106848:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f010684d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106850:	c1 e2 04             	shl    $0x4,%edx
f0106853:	01 d0                	add    %edx,%eax
f0106855:	8b 00                	mov    (%eax),%eax
f0106857:	85 c0                	test   %eax,%eax
f0106859:	0f 84 27 01 00 00    	je     f0106986 <sched_exit_env+0x1f0>
			{
				ptr_env=NULL;
f010685f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106866:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f010686b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010686e:	c1 e2 04             	shl    $0x4,%edx
f0106871:	01 d0                	add    %edx,%eax
f0106873:	8b 00                	mov    (%eax),%eax
f0106875:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106878:	e9 d1 00 00 00       	jmp    f010694e <sched_exit_env+0x1b8>
				{
					if(ptr_env->env_id == envId)
f010687d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106880:	8b 40 10             	mov    0x10(%eax),%eax
f0106883:	3b 45 08             	cmp    0x8(%ebp),%eax
f0106886:	0f 85 af 00 00 00    	jne    f010693b <sched_exit_env+0x1a5>
					{
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f010688c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106890:	75 17                	jne    f01068a9 <sched_exit_env+0x113>
f0106892:	83 ec 04             	sub    $0x4,%esp
f0106895:	68 77 df 12 f0       	push   $0xf012df77
f010689a:	68 56 01 00 00       	push   $0x156
f010689f:	68 3b df 12 f0       	push   $0xf012df3b
f01068a4:	e8 06 a6 ff ff       	call   f0100eaf <_panic>
f01068a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01068ac:	8b 40 08             	mov    0x8(%eax),%eax
f01068af:	85 c0                	test   %eax,%eax
f01068b1:	74 11                	je     f01068c4 <sched_exit_env+0x12e>
f01068b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01068b6:	8b 40 08             	mov    0x8(%eax),%eax
f01068b9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01068bc:	8b 52 0c             	mov    0xc(%edx),%edx
f01068bf:	89 50 0c             	mov    %edx,0xc(%eax)
f01068c2:	eb 16                	jmp    f01068da <sched_exit_env+0x144>
f01068c4:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f01068c9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01068cc:	c1 e2 04             	shl    $0x4,%edx
f01068cf:	01 c2                	add    %eax,%edx
f01068d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01068d4:	8b 40 0c             	mov    0xc(%eax),%eax
f01068d7:	89 42 04             	mov    %eax,0x4(%edx)
f01068da:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01068dd:	8b 40 0c             	mov    0xc(%eax),%eax
f01068e0:	85 c0                	test   %eax,%eax
f01068e2:	74 11                	je     f01068f5 <sched_exit_env+0x15f>
f01068e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01068e7:	8b 40 0c             	mov    0xc(%eax),%eax
f01068ea:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01068ed:	8b 52 08             	mov    0x8(%edx),%edx
f01068f0:	89 50 08             	mov    %edx,0x8(%eax)
f01068f3:	eb 15                	jmp    f010690a <sched_exit_env+0x174>
f01068f5:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f01068fa:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01068fd:	c1 e2 04             	shl    $0x4,%edx
f0106900:	01 c2                	add    %eax,%edx
f0106902:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106905:	8b 40 08             	mov    0x8(%eax),%eax
f0106908:	89 02                	mov    %eax,(%edx)
f010690a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010690d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0106914:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106917:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010691e:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106923:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106926:	c1 e2 04             	shl    $0x4,%edx
f0106929:	01 d0                	add    %edx,%eax
f010692b:	8b 50 0c             	mov    0xc(%eax),%edx
f010692e:	4a                   	dec    %edx
f010692f:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f0106932:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f0106939:	eb 4b                	jmp    f0106986 <sched_exit_env+0x1f0>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f010693b:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106940:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106943:	c1 e2 04             	shl    $0x4,%edx
f0106946:	01 d0                	add    %edx,%eax
f0106948:	8b 40 08             	mov    0x8(%eax),%eax
f010694b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010694e:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106953:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106956:	c1 e2 04             	shl    $0x4,%edx
f0106959:	01 d0                	add    %edx,%eax
f010695b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010695f:	74 08                	je     f0106969 <sched_exit_env+0x1d3>
f0106961:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106964:	8b 52 08             	mov    0x8(%edx),%edx
f0106967:	eb 05                	jmp    f010696e <sched_exit_env+0x1d8>
f0106969:	ba 00 00 00 00       	mov    $0x0,%edx
f010696e:	89 50 08             	mov    %edx,0x8(%eax)
f0106971:	8b 40 08             	mov    0x8(%eax),%eax
f0106974:	85 c0                	test   %eax,%eax
f0106976:	0f 85 01 ff ff ff    	jne    f010687d <sched_exit_env+0xe7>
f010697c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106980:	0f 85 f7 fe ff ff    	jne    f010687d <sched_exit_env+0xe7>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f0106986:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010698a:	75 16                	jne    f01069a2 <sched_exit_env+0x20c>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f010698c:	ff 45 ec             	incl   -0x14(%ebp)
f010698f:	a0 60 6d 85 f0       	mov    0xf0856d60,%al
f0106994:	0f b6 c0             	movzbl %al,%eax
f0106997:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010699a:	0f 8f a8 fe ff ff    	jg     f0106848 <sched_exit_env+0xb2>
f01069a0:	eb 01                	jmp    f01069a3 <sched_exit_env+0x20d>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f01069a2:	90                   	nop
		}
	}
	struct Env* cur_env = get_cpu_proc();
f01069a3:	e8 70 50 00 00       	call   f010ba18 <get_cpu_proc>
f01069a8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f01069ab:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01069af:	75 19                	jne    f01069ca <sched_exit_env+0x234>
f01069b1:	68 73 e0 12 f0       	push   $0xf012e073
f01069b6:	68 26 df 12 f0       	push   $0xf012df26
f01069bb:	68 60 01 00 00       	push   $0x160
f01069c0:	68 3b df 12 f0       	push   $0xf012df3b
f01069c5:	e8 e5 a4 ff ff       	call   f0100eaf <_panic>
	if (!found)
f01069ca:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01069ce:	75 18                	jne    f01069e8 <sched_exit_env+0x252>
	{
		if (cur_env->env_id == envId)
f01069d0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01069d3:	8b 40 10             	mov    0x10(%eax),%eax
f01069d6:	3b 45 08             	cmp    0x8(%ebp),%eax
f01069d9:	75 0d                	jne    f01069e8 <sched_exit_env+0x252>
		{
			ptr_env = cur_env;
f01069db:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01069de:	89 45 f4             	mov    %eax,-0xc(%ebp)
			found = 1;
f01069e1:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		}
	}

	if (found)
f01069e8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01069ec:	74 1e                	je     f0106a0c <sched_exit_env+0x276>
	{
		sched_insert_exit(ptr_env);
f01069ee:	83 ec 0c             	sub    $0xc,%esp
f01069f1:	ff 75 f4             	pushl  -0xc(%ebp)
f01069f4:	e8 19 fb ff ff       	call   f0106512 <sched_insert_exit>
f01069f9:	83 c4 10             	add    $0x10,%esp

		//If it's the curenv, then reinvoke the scheduler as there's no meaning to return back
		//to an exited env. Status already set to EXIT in the sched_insert_exit()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		if (cur_env->env_id == envId)
f01069fc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01069ff:	8b 40 10             	mov    0x10(%eax),%eax
f0106a02:	3b 45 08             	cmp    0x8(%ebp),%eax
f0106a05:	75 05                	jne    f0106a0c <sched_exit_env+0x276>
		{
//			cprintf("\n[%d:%s] LAST WS BEFORE EXIT\n", cur_env->env_id,  cur_env->prog_name);
//			env_page_ws_print(cur_env);
			//2024: Replaced by sched() which call context switch
			//fos_scheduler();
			sched();
f0106a07:	e8 86 51 00 00       	call   f010bb92 <sched>
		}
	}
	if (!lock_already_held)
f0106a0c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0106a10:	75 10                	jne    f0106a22 <sched_exit_env+0x28c>
	{
		release_kspinlock(&ProcessQueues.qlock);
f0106a12:	83 ec 0c             	sub    $0xc,%esp
f0106a15:	68 20 e7 83 f0       	push   $0xf083e720
f0106a1a:	e8 01 94 00 00       	call   f010fe20 <release_kspinlock>
f0106a1f:	83 c4 10             	add    $0x10,%esp
	}
	//cprintf("\n[SCHED_EXIT_ENV] release: lock status after = %d\n", qlock.locked);
}
f0106a22:	90                   	nop
f0106a23:	c9                   	leave  
f0106a24:	c3                   	ret    

f0106a25 <sched_kill_env>:
/*2015*/
//=================================================
// [11] KILL the given EnvID:
//=================================================
void sched_kill_env(uint32 envId)
{
f0106a25:	55                   	push   %ebp
f0106a26:	89 e5                	mov    %esp,%ebp
f0106a28:	83 ec 18             	sub    $0x18,%esp
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106a2b:	83 ec 0c             	sub    $0xc,%esp
f0106a2e:	68 20 e7 83 f0       	push   $0xf083e720
f0106a33:	e8 43 93 00 00       	call   f010fd7b <acquire_kspinlock>
f0106a38:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0106a3b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f0106a42:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0106a49:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106a4d:	75 79                	jne    f0106ac8 <sched_kill_env+0xa3>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106a4f:	a1 90 e7 83 f0       	mov    0xf083e790,%eax
f0106a54:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106a57:	eb 48                	jmp    f0106aa1 <sched_kill_env+0x7c>
		{
			if(ptr_env->env_id == envId)
f0106a59:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106a5c:	8b 40 10             	mov    0x10(%eax),%eax
f0106a5f:	3b 45 08             	cmp    0x8(%ebp),%eax
f0106a62:	75 35                	jne    f0106a99 <sched_kill_env+0x74>
			{
				cprintf("[BEGIN] killing[%d] %s from the NEW queue...", ptr_env->env_id, ptr_env->prog_name);
f0106a64:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106a67:	8d 50 20             	lea    0x20(%eax),%edx
f0106a6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106a6d:	8b 40 10             	mov    0x10(%eax),%eax
f0106a70:	83 ec 04             	sub    $0x4,%esp
f0106a73:	52                   	push   %edx
f0106a74:	50                   	push   %eax
f0106a75:	68 84 e0 12 f0       	push   $0xf012e084
f0106a7a:	e8 dd b0 ff ff       	call   f0101b5c <cprintf>
f0106a7f:	83 c4 10             	add    $0x10,%esp
				sched_remove_new(ptr_env);
f0106a82:	83 ec 0c             	sub    $0xc,%esp
f0106a85:	ff 75 f4             	pushl  -0xc(%ebp)
f0106a88:	e8 95 f9 ff ff       	call   f0106422 <sched_remove_new>
f0106a8d:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0106a90:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0106a97:	eb 2f                	jmp    f0106ac8 <sched_kill_env+0xa3>
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106a99:	a1 98 e7 83 f0       	mov    0xf083e798,%eax
f0106a9e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106aa1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106aa5:	74 08                	je     f0106aaf <sched_kill_env+0x8a>
f0106aa7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106aaa:	8b 40 08             	mov    0x8(%eax),%eax
f0106aad:	eb 05                	jmp    f0106ab4 <sched_kill_env+0x8f>
f0106aaf:	b8 00 00 00 00       	mov    $0x0,%eax
f0106ab4:	a3 98 e7 83 f0       	mov    %eax,0xf083e798
f0106ab9:	a1 98 e7 83 f0       	mov    0xf083e798,%eax
f0106abe:	85 c0                	test   %eax,%eax
f0106ac0:	75 97                	jne    f0106a59 <sched_kill_env+0x34>
f0106ac2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106ac6:	75 91                	jne    f0106a59 <sched_kill_env+0x34>
				found = 1;
				break;
			}
		}
	}
	if (!found)
f0106ac8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106acc:	0f 85 85 01 00 00    	jne    f0106c57 <sched_kill_env+0x232>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106ad2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0106ad9:	e9 65 01 00 00       	jmp    f0106c43 <sched_kill_env+0x21e>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0106ade:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106ae3:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106ae6:	c1 e2 04             	shl    $0x4,%edx
f0106ae9:	01 d0                	add    %edx,%eax
f0106aeb:	8b 00                	mov    (%eax),%eax
f0106aed:	85 c0                	test   %eax,%eax
f0106aef:	0f 84 45 01 00 00    	je     f0106c3a <sched_kill_env+0x215>
			{
				ptr_env=NULL;
f0106af5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106afc:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106b01:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106b04:	c1 e2 04             	shl    $0x4,%edx
f0106b07:	01 d0                	add    %edx,%eax
f0106b09:	8b 00                	mov    (%eax),%eax
f0106b0b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106b0e:	e9 ef 00 00 00       	jmp    f0106c02 <sched_kill_env+0x1dd>
				{
					if(ptr_env->env_id == envId)
f0106b13:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106b16:	8b 40 10             	mov    0x10(%eax),%eax
f0106b19:	3b 45 08             	cmp    0x8(%ebp),%eax
f0106b1c:	0f 85 cd 00 00 00    	jne    f0106bef <sched_kill_env+0x1ca>
					{
						cprintf("[BEGIN] killing[%d] %s from the READY queue #%d...", ptr_env->env_id, ptr_env->prog_name, i);
f0106b22:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106b25:	8d 50 20             	lea    0x20(%eax),%edx
f0106b28:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106b2b:	8b 40 10             	mov    0x10(%eax),%eax
f0106b2e:	ff 75 ec             	pushl  -0x14(%ebp)
f0106b31:	52                   	push   %edx
f0106b32:	50                   	push   %eax
f0106b33:	68 b4 e0 12 f0       	push   $0xf012e0b4
f0106b38:	e8 1f b0 ff ff       	call   f0101b5c <cprintf>
f0106b3d:	83 c4 10             	add    $0x10,%esp
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0106b40:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106b44:	75 17                	jne    f0106b5d <sched_kill_env+0x138>
f0106b46:	83 ec 04             	sub    $0x4,%esp
f0106b49:	68 77 df 12 f0       	push   $0xf012df77
f0106b4e:	68 a5 01 00 00       	push   $0x1a5
f0106b53:	68 3b df 12 f0       	push   $0xf012df3b
f0106b58:	e8 52 a3 ff ff       	call   f0100eaf <_panic>
f0106b5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106b60:	8b 40 08             	mov    0x8(%eax),%eax
f0106b63:	85 c0                	test   %eax,%eax
f0106b65:	74 11                	je     f0106b78 <sched_kill_env+0x153>
f0106b67:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106b6a:	8b 40 08             	mov    0x8(%eax),%eax
f0106b6d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106b70:	8b 52 0c             	mov    0xc(%edx),%edx
f0106b73:	89 50 0c             	mov    %edx,0xc(%eax)
f0106b76:	eb 16                	jmp    f0106b8e <sched_kill_env+0x169>
f0106b78:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106b7d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106b80:	c1 e2 04             	shl    $0x4,%edx
f0106b83:	01 c2                	add    %eax,%edx
f0106b85:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106b88:	8b 40 0c             	mov    0xc(%eax),%eax
f0106b8b:	89 42 04             	mov    %eax,0x4(%edx)
f0106b8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106b91:	8b 40 0c             	mov    0xc(%eax),%eax
f0106b94:	85 c0                	test   %eax,%eax
f0106b96:	74 11                	je     f0106ba9 <sched_kill_env+0x184>
f0106b98:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106b9b:	8b 40 0c             	mov    0xc(%eax),%eax
f0106b9e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106ba1:	8b 52 08             	mov    0x8(%edx),%edx
f0106ba4:	89 50 08             	mov    %edx,0x8(%eax)
f0106ba7:	eb 15                	jmp    f0106bbe <sched_kill_env+0x199>
f0106ba9:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106bae:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106bb1:	c1 e2 04             	shl    $0x4,%edx
f0106bb4:	01 c2                	add    %eax,%edx
f0106bb6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106bb9:	8b 40 08             	mov    0x8(%eax),%eax
f0106bbc:	89 02                	mov    %eax,(%edx)
f0106bbe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106bc1:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0106bc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106bcb:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0106bd2:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106bd7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106bda:	c1 e2 04             	shl    $0x4,%edx
f0106bdd:	01 d0                	add    %edx,%eax
f0106bdf:	8b 50 0c             	mov    0xc(%eax),%edx
f0106be2:	4a                   	dec    %edx
f0106be3:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f0106be6:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f0106bed:	eb 4b                	jmp    f0106c3a <sched_kill_env+0x215>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106bef:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106bf4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106bf7:	c1 e2 04             	shl    $0x4,%edx
f0106bfa:	01 d0                	add    %edx,%eax
f0106bfc:	8b 40 08             	mov    0x8(%eax),%eax
f0106bff:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106c02:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106c07:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106c0a:	c1 e2 04             	shl    $0x4,%edx
f0106c0d:	01 d0                	add    %edx,%eax
f0106c0f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106c13:	74 08                	je     f0106c1d <sched_kill_env+0x1f8>
f0106c15:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106c18:	8b 52 08             	mov    0x8(%edx),%edx
f0106c1b:	eb 05                	jmp    f0106c22 <sched_kill_env+0x1fd>
f0106c1d:	ba 00 00 00 00       	mov    $0x0,%edx
f0106c22:	89 50 08             	mov    %edx,0x8(%eax)
f0106c25:	8b 40 08             	mov    0x8(%eax),%eax
f0106c28:	85 c0                	test   %eax,%eax
f0106c2a:	0f 85 e3 fe ff ff    	jne    f0106b13 <sched_kill_env+0xee>
f0106c30:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106c34:	0f 85 d9 fe ff ff    	jne    f0106b13 <sched_kill_env+0xee>
						found = 1;
						break;
					}
				}
			}
			if (found)
f0106c3a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106c3e:	75 16                	jne    f0106c56 <sched_kill_env+0x231>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106c40:	ff 45 ec             	incl   -0x14(%ebp)
f0106c43:	a0 60 6d 85 f0       	mov    0xf0856d60,%al
f0106c48:	0f b6 c0             	movzbl %al,%eax
f0106c4b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0106c4e:	0f 8f 8a fe ff ff    	jg     f0106ade <sched_kill_env+0xb9>
f0106c54:	eb 01                	jmp    f0106c57 <sched_kill_env+0x232>
						break;
					}
				}
			}
			if (found)
				break;
f0106c56:	90                   	nop
		}
	}
	if (!found)
f0106c57:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106c5b:	0f 85 80 00 00 00    	jne    f0106ce1 <sched_kill_env+0x2bc>
	{
		ptr_env=NULL;
f0106c61:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106c68:	a1 a0 e7 83 f0       	mov    0xf083e7a0,%eax
f0106c6d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106c70:	eb 48                	jmp    f0106cba <sched_kill_env+0x295>
		{
			if(ptr_env->env_id == envId)
f0106c72:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c75:	8b 40 10             	mov    0x10(%eax),%eax
f0106c78:	3b 45 08             	cmp    0x8(%ebp),%eax
f0106c7b:	75 35                	jne    f0106cb2 <sched_kill_env+0x28d>
			{
				cprintf("[BEGIN] killing[%d] %s from the EXIT queue...\n", ptr_env->env_id, ptr_env->prog_name);
f0106c7d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c80:	8d 50 20             	lea    0x20(%eax),%edx
f0106c83:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c86:	8b 40 10             	mov    0x10(%eax),%eax
f0106c89:	83 ec 04             	sub    $0x4,%esp
f0106c8c:	52                   	push   %edx
f0106c8d:	50                   	push   %eax
f0106c8e:	68 e8 e0 12 f0       	push   $0xf012e0e8
f0106c93:	e8 c4 ae ff ff       	call   f0101b5c <cprintf>
f0106c98:	83 c4 10             	add    $0x10,%esp
				sched_remove_exit(ptr_env);
f0106c9b:	83 ec 0c             	sub    $0xc,%esp
f0106c9e:	ff 75 f4             	pushl  -0xc(%ebp)
f0106ca1:	e8 f3 f8 ff ff       	call   f0106599 <sched_remove_exit>
f0106ca6:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0106ca9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0106cb0:	eb 2f                	jmp    f0106ce1 <sched_kill_env+0x2bc>
		}
	}
	if (!found)
	{
		ptr_env=NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106cb2:	a1 a8 e7 83 f0       	mov    0xf083e7a8,%eax
f0106cb7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106cba:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106cbe:	74 08                	je     f0106cc8 <sched_kill_env+0x2a3>
f0106cc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106cc3:	8b 40 08             	mov    0x8(%eax),%eax
f0106cc6:	eb 05                	jmp    f0106ccd <sched_kill_env+0x2a8>
f0106cc8:	b8 00 00 00 00       	mov    $0x0,%eax
f0106ccd:	a3 a8 e7 83 f0       	mov    %eax,0xf083e7a8
f0106cd2:	a1 a8 e7 83 f0       	mov    0xf083e7a8,%eax
f0106cd7:	85 c0                	test   %eax,%eax
f0106cd9:	75 97                	jne    f0106c72 <sched_kill_env+0x24d>
f0106cdb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106cdf:	75 91                	jne    f0106c72 <sched_kill_env+0x24d>
				found = 1;
				break;
			}
		}
	}
	release_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106ce1:	83 ec 0c             	sub    $0xc,%esp
f0106ce4:	68 20 e7 83 f0       	push   $0xf083e720
f0106ce9:	e8 32 91 00 00       	call   f010fe20 <release_kspinlock>
f0106cee:	83 c4 10             	add    $0x10,%esp

	if (found)
f0106cf1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106cf5:	74 23                	je     f0106d1a <sched_kill_env+0x2f5>
	{
		env_free(ptr_env);
f0106cf7:	83 ec 0c             	sub    $0xc,%esp
f0106cfa:	ff 75 f4             	pushl  -0xc(%ebp)
f0106cfd:	e8 b7 4c 00 00       	call   f010b9b9 <env_free>
f0106d02:	83 c4 10             	add    $0x10,%esp
		cprintf("[END] DONE\n");
f0106d05:	83 ec 0c             	sub    $0xc,%esp
f0106d08:	68 17 e1 12 f0       	push   $0xf012e117
f0106d0d:	e8 4a ae ff ff       	call   f0101b5c <cprintf>
f0106d12:	83 c4 10             	add    $0x10,%esp
			acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
			sched();
		}
	}

}
f0106d15:	e9 b8 00 00 00       	jmp    f0106dd2 <sched_kill_env+0x3ad>
		env_free(ptr_env);
		cprintf("[END] DONE\n");
	}
	else
	{
		struct Env* cur_env = get_cpu_proc();
f0106d1a:	e8 f9 4c 00 00       	call   f010ba18 <get_cpu_proc>
f0106d1f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		assert(cur_env != NULL);
f0106d22:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0106d26:	75 19                	jne    f0106d41 <sched_kill_env+0x31c>
f0106d28:	68 73 e0 12 f0       	push   $0xf012e073
f0106d2d:	68 26 df 12 f0       	push   $0xf012df26
f0106d32:	68 c7 01 00 00       	push   $0x1c7
f0106d37:	68 3b df 12 f0       	push   $0xf012df3b
f0106d3c:	e8 6e a1 ff ff       	call   f0100eaf <_panic>

		if (cur_env->env_id == envId)
f0106d41:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106d44:	8b 40 10             	mov    0x10(%eax),%eax
f0106d47:	3b 45 08             	cmp    0x8(%ebp),%eax
f0106d4a:	0f 85 82 00 00 00    	jne    f0106dd2 <sched_kill_env+0x3ad>
		{
			ptr_env = cur_env;
f0106d50:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106d53:	89 45 f4             	mov    %eax,-0xc(%ebp)
			assert(ptr_env->env_status == ENV_RUNNING);
f0106d56:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106d59:	8b 40 18             	mov    0x18(%eax),%eax
f0106d5c:	83 f8 02             	cmp    $0x2,%eax
f0106d5f:	74 19                	je     f0106d7a <sched_kill_env+0x355>
f0106d61:	68 24 e1 12 f0       	push   $0xf012e124
f0106d66:	68 26 df 12 f0       	push   $0xf012df26
f0106d6b:	68 cc 01 00 00       	push   $0x1cc
f0106d70:	68 3b df 12 f0       	push   $0xf012df3b
f0106d75:	e8 35 a1 ff ff       	call   f0100eaf <_panic>
			cprintf("[BEGIN] killing a RUNNABLE environment [%d] %s...\n", ptr_env->env_id, ptr_env->prog_name);
f0106d7a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106d7d:	8d 50 20             	lea    0x20(%eax),%edx
f0106d80:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106d83:	8b 40 10             	mov    0x10(%eax),%eax
f0106d86:	83 ec 04             	sub    $0x4,%esp
f0106d89:	52                   	push   %edx
f0106d8a:	50                   	push   %eax
f0106d8b:	68 48 e1 12 f0       	push   $0xf012e148
f0106d90:	e8 c7 ad ff ff       	call   f0101b5c <cprintf>
f0106d95:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0106d98:	83 ec 0c             	sub    $0xc,%esp
f0106d9b:	ff 75 f4             	pushl  -0xc(%ebp)
f0106d9e:	e8 16 4c 00 00       	call   f010b9b9 <env_free>
f0106da3:	83 c4 10             	add    $0x10,%esp
			cprintf("[END] DONE\n");
f0106da6:	83 ec 0c             	sub    $0xc,%esp
f0106da9:	68 17 e1 12 f0       	push   $0xf012e117
f0106dae:	e8 a9 ad ff ff       	call   f0101b5c <cprintf>
f0106db3:	83 c4 10             	add    $0x10,%esp
			found = 1;
f0106db6:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			//this process
			/*2024: replaced by sched() to apply context_switch*/
			//lcr3(phys_page_directory);
			//switchkvm();
			//fos_scheduler();
			acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106dbd:	83 ec 0c             	sub    $0xc,%esp
f0106dc0:	68 20 e7 83 f0       	push   $0xf083e720
f0106dc5:	e8 b1 8f 00 00       	call   f010fd7b <acquire_kspinlock>
f0106dca:	83 c4 10             	add    $0x10,%esp
			sched();
f0106dcd:	e8 c0 4d 00 00       	call   f010bb92 <sched>
		}
	}

}
f0106dd2:	90                   	nop
f0106dd3:	c9                   	leave  
f0106dd4:	c3                   	ret    

f0106dd5 <sched_print_all>:

//=================================================
// [12] PRINT ALL Envs from all queues:
//=================================================
void sched_print_all()
{
f0106dd5:	55                   	push   %ebp
f0106dd6:	89 e5                	mov    %esp,%ebp
f0106dd8:	83 ec 18             	sub    $0x18,%esp
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106ddb:	83 ec 0c             	sub    $0xc,%esp
f0106dde:	68 20 e7 83 f0       	push   $0xf083e720
f0106de3:	e8 93 8f 00 00       	call   f010fd7b <acquire_kspinlock>
f0106de8:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f0106deb:	a1 90 e7 83 f0       	mov    0xf083e790,%eax
f0106df0:	85 c0                	test   %eax,%eax
f0106df2:	74 69                	je     f0106e5d <sched_print_all+0x88>
	{
		cprintf("\nThe processes in NEW queue are:\n");
f0106df4:	83 ec 0c             	sub    $0xc,%esp
f0106df7:	68 7c e1 12 f0       	push   $0xf012e17c
f0106dfc:	e8 5b ad ff ff       	call   f0101b5c <cprintf>
f0106e01:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106e04:	a1 90 e7 83 f0       	mov    0xf083e790,%eax
f0106e09:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106e0c:	eb 26                	jmp    f0106e34 <sched_print_all+0x5f>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0106e0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106e11:	8d 50 20             	lea    0x20(%eax),%edx
f0106e14:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106e17:	8b 40 10             	mov    0x10(%eax),%eax
f0106e1a:	83 ec 04             	sub    $0x4,%esp
f0106e1d:	52                   	push   %edx
f0106e1e:	50                   	push   %eax
f0106e1f:	68 9e e1 12 f0       	push   $0xf012e19e
f0106e24:	e8 33 ad ff ff       	call   f0101b5c <cprintf>
f0106e29:	83 c4 10             	add    $0x10,%esp
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nThe processes in NEW queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106e2c:	a1 98 e7 83 f0       	mov    0xf083e798,%eax
f0106e31:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106e34:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106e38:	74 08                	je     f0106e42 <sched_print_all+0x6d>
f0106e3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106e3d:	8b 40 08             	mov    0x8(%eax),%eax
f0106e40:	eb 05                	jmp    f0106e47 <sched_print_all+0x72>
f0106e42:	b8 00 00 00 00       	mov    $0x0,%eax
f0106e47:	a3 98 e7 83 f0       	mov    %eax,0xf083e798
f0106e4c:	a1 98 e7 83 f0       	mov    0xf083e798,%eax
f0106e51:	85 c0                	test   %eax,%eax
f0106e53:	75 b9                	jne    f0106e0e <sched_print_all+0x39>
f0106e55:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106e59:	75 b3                	jne    f0106e0e <sched_print_all+0x39>
f0106e5b:	eb 10                	jmp    f0106e6d <sched_print_all+0x98>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("\nNo processes in NEW queue\n");
f0106e5d:	83 ec 0c             	sub    $0xc,%esp
f0106e60:	68 a8 e1 12 f0       	push   $0xf012e1a8
f0106e65:	e8 f2 ac ff ff       	call   f0101b5c <cprintf>
f0106e6a:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0106e6d:	83 ec 0c             	sub    $0xc,%esp
f0106e70:	68 c4 e1 12 f0       	push   $0xf012e1c4
f0106e75:	e8 e2 ac ff ff       	call   f0101b5c <cprintf>
f0106e7a:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106e7d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106e84:	e9 c7 00 00 00       	jmp    f0106f50 <sched_print_all+0x17b>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0106e89:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106e8e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106e91:	c1 e2 04             	shl    $0x4,%edx
f0106e94:	01 d0                	add    %edx,%eax
f0106e96:	8b 00                	mov    (%eax),%eax
f0106e98:	85 c0                	test   %eax,%eax
f0106e9a:	0f 84 8a 00 00 00    	je     f0106f2a <sched_print_all+0x155>
		{
			cprintf("The processes in READY queue #%d are:\n", i);
f0106ea0:	83 ec 08             	sub    $0x8,%esp
f0106ea3:	ff 75 f0             	pushl  -0x10(%ebp)
f0106ea6:	68 f8 e1 12 f0       	push   $0xf012e1f8
f0106eab:	e8 ac ac ff ff       	call   f0101b5c <cprintf>
f0106eb0:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106eb3:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106eb8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106ebb:	c1 e2 04             	shl    $0x4,%edx
f0106ebe:	01 d0                	add    %edx,%eax
f0106ec0:	8b 00                	mov    (%eax),%eax
f0106ec2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106ec5:	eb 31                	jmp    f0106ef8 <sched_print_all+0x123>
			{
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0106ec7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106eca:	8d 50 20             	lea    0x20(%eax),%edx
f0106ecd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106ed0:	8b 40 10             	mov    0x10(%eax),%eax
f0106ed3:	83 ec 04             	sub    $0x4,%esp
f0106ed6:	52                   	push   %edx
f0106ed7:	50                   	push   %eax
f0106ed8:	68 9e e1 12 f0       	push   $0xf012e19e
f0106edd:	e8 7a ac ff ff       	call   f0101b5c <cprintf>
f0106ee2:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("The processes in READY queue #%d are:\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106ee5:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106eea:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106eed:	c1 e2 04             	shl    $0x4,%edx
f0106ef0:	01 d0                	add    %edx,%eax
f0106ef2:	8b 40 08             	mov    0x8(%eax),%eax
f0106ef5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106ef8:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106efd:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106f00:	c1 e2 04             	shl    $0x4,%edx
f0106f03:	01 d0                	add    %edx,%eax
f0106f05:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106f09:	74 08                	je     f0106f13 <sched_print_all+0x13e>
f0106f0b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106f0e:	8b 52 08             	mov    0x8(%edx),%edx
f0106f11:	eb 05                	jmp    f0106f18 <sched_print_all+0x143>
f0106f13:	ba 00 00 00 00       	mov    $0x0,%edx
f0106f18:	89 50 08             	mov    %edx,0x8(%eax)
f0106f1b:	8b 40 08             	mov    0x8(%eax),%eax
f0106f1e:	85 c0                	test   %eax,%eax
f0106f20:	75 a5                	jne    f0106ec7 <sched_print_all+0xf2>
f0106f22:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106f26:	75 9f                	jne    f0106ec7 <sched_print_all+0xf2>
f0106f28:	eb 13                	jmp    f0106f3d <sched_print_all+0x168>
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n", i);
f0106f2a:	83 ec 08             	sub    $0x8,%esp
f0106f2d:	ff 75 f0             	pushl  -0x10(%ebp)
f0106f30:	68 20 e2 12 f0       	push   $0xf012e220
f0106f35:	e8 22 ac ff ff       	call   f0101b5c <cprintf>
f0106f3a:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f0106f3d:	83 ec 0c             	sub    $0xc,%esp
f0106f40:	68 c4 e1 12 f0       	push   $0xf012e1c4
f0106f45:	e8 12 ac ff ff       	call   f0101b5c <cprintf>
f0106f4a:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("\nNo processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106f4d:	ff 45 f0             	incl   -0x10(%ebp)
f0106f50:	a0 60 6d 85 f0       	mov    0xf0856d60,%al
f0106f55:	0f b6 c0             	movzbl %al,%eax
f0106f58:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0106f5b:	0f 8f 28 ff ff ff    	jg     f0106e89 <sched_print_all+0xb4>
		{
			cprintf("No processes in READY queue #%d\n", i);
		}
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0106f61:	a1 a0 e7 83 f0       	mov    0xf083e7a0,%eax
f0106f66:	85 c0                	test   %eax,%eax
f0106f68:	74 69                	je     f0106fd3 <sched_print_all+0x1fe>
	{
		cprintf("The processes in EXIT queue are:\n");
f0106f6a:	83 ec 0c             	sub    $0xc,%esp
f0106f6d:	68 44 e2 12 f0       	push   $0xf012e244
f0106f72:	e8 e5 ab ff ff       	call   f0101b5c <cprintf>
f0106f77:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106f7a:	a1 a0 e7 83 f0       	mov    0xf083e7a0,%eax
f0106f7f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106f82:	eb 26                	jmp    f0106faa <sched_print_all+0x1d5>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0106f84:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f87:	8d 50 20             	lea    0x20(%eax),%edx
f0106f8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f8d:	8b 40 10             	mov    0x10(%eax),%eax
f0106f90:	83 ec 04             	sub    $0x4,%esp
f0106f93:	52                   	push   %edx
f0106f94:	50                   	push   %eax
f0106f95:	68 9e e1 12 f0       	push   $0xf012e19e
f0106f9a:	e8 bd ab ff ff       	call   f0101b5c <cprintf>
f0106f9f:	83 c4 10             	add    $0x10,%esp
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("The processes in EXIT queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106fa2:	a1 a8 e7 83 f0       	mov    0xf083e7a8,%eax
f0106fa7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106faa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106fae:	74 08                	je     f0106fb8 <sched_print_all+0x1e3>
f0106fb0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106fb3:	8b 40 08             	mov    0x8(%eax),%eax
f0106fb6:	eb 05                	jmp    f0106fbd <sched_print_all+0x1e8>
f0106fb8:	b8 00 00 00 00       	mov    $0x0,%eax
f0106fbd:	a3 a8 e7 83 f0       	mov    %eax,0xf083e7a8
f0106fc2:	a1 a8 e7 83 f0       	mov    0xf083e7a8,%eax
f0106fc7:	85 c0                	test   %eax,%eax
f0106fc9:	75 b9                	jne    f0106f84 <sched_print_all+0x1af>
f0106fcb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106fcf:	75 b3                	jne    f0106f84 <sched_print_all+0x1af>
f0106fd1:	eb 10                	jmp    f0106fe3 <sched_print_all+0x20e>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f0106fd3:	83 ec 0c             	sub    $0xc,%esp
f0106fd6:	68 66 e2 12 f0       	push   $0xf012e266
f0106fdb:	e8 7c ab ff ff       	call   f0101b5c <cprintf>
f0106fe0:	83 c4 10             	add    $0x10,%esp
	}
	release_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106fe3:	83 ec 0c             	sub    $0xc,%esp
f0106fe6:	68 20 e7 83 f0       	push   $0xf083e720
f0106feb:	e8 30 8e 00 00       	call   f010fe20 <release_kspinlock>
f0106ff0:	83 c4 10             	add    $0x10,%esp
}
f0106ff3:	90                   	nop
f0106ff4:	c9                   	leave  
f0106ff5:	c3                   	ret    

f0106ff6 <sched_run_all>:

//=================================================
// [13] MOVE ALL NEW Envs into READY Q:
//=================================================
void sched_run_all()
{
f0106ff6:	55                   	push   %ebp
f0106ff7:	89 e5                	mov    %esp,%ebp
f0106ff9:	83 ec 18             	sub    $0x18,%esp
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106ffc:	83 ec 0c             	sub    $0xc,%esp
f0106fff:	68 20 e7 83 f0       	push   $0xf083e720
f0107004:	e8 72 8d 00 00       	call   f010fd7b <acquire_kspinlock>
f0107009:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f010700c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
f0107013:	a1 9c e7 83 f0       	mov    0xf083e79c,%eax
f0107018:	89 45 ec             	mov    %eax,-0x14(%ebp)
	for (int i = 0; i < q_size; ++i)
f010701b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0107022:	eb 24                	jmp    f0107048 <sched_run_all+0x52>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
f0107024:	83 ec 0c             	sub    $0xc,%esp
f0107027:	68 90 e7 83 f0       	push   $0xf083e790
f010702c:	e8 6b ef ff ff       	call   f0105f9c <dequeue>
f0107031:	83 c4 10             	add    $0x10,%esp
f0107034:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready(ptr_env);
f0107037:	83 ec 0c             	sub    $0xc,%esp
f010703a:	ff 75 f0             	pushl  -0x10(%ebp)
f010703d:	e8 95 f1 ff ff       	call   f01061d7 <sched_insert_ready>
f0107042:	83 c4 10             	add    $0x10,%esp

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
	for (int i = 0; i < q_size; ++i)
f0107045:	ff 45 f4             	incl   -0xc(%ebp)
f0107048:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010704b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010704e:	7c d4                	jl     f0107024 <sched_run_all+0x2e>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
		sched_insert_ready(ptr_env);
	}

	release_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0107050:	83 ec 0c             	sub    $0xc,%esp
f0107053:	68 20 e7 83 f0       	push   $0xf083e720
f0107058:	e8 c3 8d 00 00       	call   f010fe20 <release_kspinlock>
f010705d:	83 c4 10             	add    $0x10,%esp
	/*2015*///if scheduler not run yet, then invoke it!
	if (mycpu()->scheduler_status == SCH_STOPPED)
f0107060:	e8 0b 0f 00 00       	call   f0107f70 <mycpu>
f0107065:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f010706b:	85 c0                	test   %eax,%eax
f010706d:	75 05                	jne    f0107074 <sched_run_all+0x7e>
		fos_scheduler();
f010706f:	e8 d3 06 00 00       	call   f0107747 <fos_scheduler>
	else
		panic("scheduler status is NOT STOPPED while it's expected to be!!");
f0107074:	83 ec 04             	sub    $0x4,%esp
f0107077:	68 84 e2 12 f0       	push   $0xf012e284
f010707c:	68 2a 02 00 00       	push   $0x22a
f0107081:	68 3b df 12 f0       	push   $0xf012df3b
f0107086:	e8 24 9e ff ff       	call   f0100eaf <_panic>

f010708b <sched_kill_all>:

//=================================================
// [14] KILL ALL Envs in the System:
//=================================================
void sched_kill_all()
{
f010708b:	55                   	push   %ebp
f010708c:	89 e5                	mov    %esp,%ebp
f010708e:	83 ec 18             	sub    $0x18,%esp
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0107091:	83 ec 0c             	sub    $0xc,%esp
f0107094:	68 20 e7 83 f0       	push   $0xf083e720
f0107099:	e8 dd 8c 00 00       	call   f010fd7b <acquire_kspinlock>
f010709e:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f01070a1:	a1 90 e7 83 f0       	mov    0xf083e790,%eax
f01070a6:	85 c0                	test   %eax,%eax
f01070a8:	0f 84 95 00 00 00    	je     f0107143 <sched_kill_all+0xb8>
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
f01070ae:	83 ec 0c             	sub    $0xc,%esp
f01070b1:	68 c0 e2 12 f0       	push   $0xf012e2c0
f01070b6:	e8 a1 aa ff ff       	call   f0101b5c <cprintf>
f01070bb:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01070be:	a1 90 e7 83 f0       	mov    0xf083e790,%eax
f01070c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01070c6:	eb 52                	jmp    f010711a <sched_kill_all+0x8f>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01070c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070cb:	8d 50 20             	lea    0x20(%eax),%edx
f01070ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070d1:	8b 40 10             	mov    0x10(%eax),%eax
f01070d4:	83 ec 04             	sub    $0x4,%esp
f01070d7:	52                   	push   %edx
f01070d8:	50                   	push   %eax
f01070d9:	68 ec e2 12 f0       	push   $0xf012e2ec
f01070de:	e8 79 aa ff ff       	call   f0101b5c <cprintf>
f01070e3:	83 c4 10             	add    $0x10,%esp
			sched_remove_new(ptr_env);
f01070e6:	83 ec 0c             	sub    $0xc,%esp
f01070e9:	ff 75 f4             	pushl  -0xc(%ebp)
f01070ec:	e8 31 f3 ff ff       	call   f0106422 <sched_remove_new>
f01070f1:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f01070f4:	83 ec 0c             	sub    $0xc,%esp
f01070f7:	ff 75 f4             	pushl  -0xc(%ebp)
f01070fa:	e8 ba 48 00 00       	call   f010b9b9 <env_free>
f01070ff:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0107102:	83 ec 0c             	sub    $0xc,%esp
f0107105:	68 ff e2 12 f0       	push   $0xf012e2ff
f010710a:	e8 4d aa ff ff       	call   f0101b5c <cprintf>
f010710f:	83 c4 10             	add    $0x10,%esp
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0107112:	a1 98 e7 83 f0       	mov    0xf083e798,%eax
f0107117:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010711a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010711e:	74 08                	je     f0107128 <sched_kill_all+0x9d>
f0107120:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107123:	8b 40 08             	mov    0x8(%eax),%eax
f0107126:	eb 05                	jmp    f010712d <sched_kill_all+0xa2>
f0107128:	b8 00 00 00 00       	mov    $0x0,%eax
f010712d:	a3 98 e7 83 f0       	mov    %eax,0xf083e798
f0107132:	a1 98 e7 83 f0       	mov    0xf083e798,%eax
f0107137:	85 c0                	test   %eax,%eax
f0107139:	75 8d                	jne    f01070c8 <sched_kill_all+0x3d>
f010713b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010713f:	75 87                	jne    f01070c8 <sched_kill_all+0x3d>
f0107141:	eb 10                	jmp    f0107153 <sched_kill_all+0xc8>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in NEW queue\n");
f0107143:	83 ec 0c             	sub    $0xc,%esp
f0107146:	68 05 e3 12 f0       	push   $0xf012e305
f010714b:	e8 0c aa ff ff       	call   f0101b5c <cprintf>
f0107150:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0107153:	83 ec 0c             	sub    $0xc,%esp
f0107156:	68 c4 e1 12 f0       	push   $0xf012e1c4
f010715b:	e8 fc a9 ff ff       	call   f0101b5c <cprintf>
f0107160:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0107163:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010716a:	e9 96 01 00 00       	jmp    f0107305 <sched_kill_all+0x27a>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f010716f:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0107174:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107177:	c1 e2 04             	shl    $0x4,%edx
f010717a:	01 d0                	add    %edx,%eax
f010717c:	8b 00                	mov    (%eax),%eax
f010717e:	85 c0                	test   %eax,%eax
f0107180:	0f 84 59 01 00 00    	je     f01072df <sched_kill_all+0x254>
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
f0107186:	83 ec 08             	sub    $0x8,%esp
f0107189:	ff 75 f0             	pushl  -0x10(%ebp)
f010718c:	68 20 e3 12 f0       	push   $0xf012e320
f0107191:	e8 c6 a9 ff ff       	call   f0101b5c <cprintf>
f0107196:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0107199:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f010719e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01071a1:	c1 e2 04             	shl    $0x4,%edx
f01071a4:	01 d0                	add    %edx,%eax
f01071a6:	8b 00                	mov    (%eax),%eax
f01071a8:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01071ab:	e9 f5 00 00 00       	jmp    f01072a5 <sched_kill_all+0x21a>
			{
				cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01071b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071b3:	8d 50 20             	lea    0x20(%eax),%edx
f01071b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071b9:	8b 40 10             	mov    0x10(%eax),%eax
f01071bc:	83 ec 04             	sub    $0x4,%esp
f01071bf:	52                   	push   %edx
f01071c0:	50                   	push   %eax
f01071c1:	68 ec e2 12 f0       	push   $0xf012e2ec
f01071c6:	e8 91 a9 ff ff       	call   f0101b5c <cprintf>
f01071cb:	83 c4 10             	add    $0x10,%esp
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f01071ce:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01071d2:	75 17                	jne    f01071eb <sched_kill_all+0x160>
f01071d4:	83 ec 04             	sub    $0x4,%esp
f01071d7:	68 77 df 12 f0       	push   $0xf012df77
f01071dc:	68 4c 02 00 00       	push   $0x24c
f01071e1:	68 3b df 12 f0       	push   $0xf012df3b
f01071e6:	e8 c4 9c ff ff       	call   f0100eaf <_panic>
f01071eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071ee:	8b 40 08             	mov    0x8(%eax),%eax
f01071f1:	85 c0                	test   %eax,%eax
f01071f3:	74 11                	je     f0107206 <sched_kill_all+0x17b>
f01071f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071f8:	8b 40 08             	mov    0x8(%eax),%eax
f01071fb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01071fe:	8b 52 0c             	mov    0xc(%edx),%edx
f0107201:	89 50 0c             	mov    %edx,0xc(%eax)
f0107204:	eb 16                	jmp    f010721c <sched_kill_all+0x191>
f0107206:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f010720b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010720e:	c1 e2 04             	shl    $0x4,%edx
f0107211:	01 c2                	add    %eax,%edx
f0107213:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107216:	8b 40 0c             	mov    0xc(%eax),%eax
f0107219:	89 42 04             	mov    %eax,0x4(%edx)
f010721c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010721f:	8b 40 0c             	mov    0xc(%eax),%eax
f0107222:	85 c0                	test   %eax,%eax
f0107224:	74 11                	je     f0107237 <sched_kill_all+0x1ac>
f0107226:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107229:	8b 40 0c             	mov    0xc(%eax),%eax
f010722c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010722f:	8b 52 08             	mov    0x8(%edx),%edx
f0107232:	89 50 08             	mov    %edx,0x8(%eax)
f0107235:	eb 15                	jmp    f010724c <sched_kill_all+0x1c1>
f0107237:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f010723c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010723f:	c1 e2 04             	shl    $0x4,%edx
f0107242:	01 c2                	add    %eax,%edx
f0107244:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107247:	8b 40 08             	mov    0x8(%eax),%eax
f010724a:	89 02                	mov    %eax,(%edx)
f010724c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010724f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0107256:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107259:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0107260:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0107265:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107268:	c1 e2 04             	shl    $0x4,%edx
f010726b:	01 d0                	add    %edx,%eax
f010726d:	8b 50 0c             	mov    0xc(%eax),%edx
f0107270:	4a                   	dec    %edx
f0107271:	89 50 0c             	mov    %edx,0xc(%eax)
				env_free(ptr_env);
f0107274:	83 ec 0c             	sub    $0xc,%esp
f0107277:	ff 75 f4             	pushl  -0xc(%ebp)
f010727a:	e8 3a 47 00 00       	call   f010b9b9 <env_free>
f010727f:	83 c4 10             	add    $0x10,%esp
				cprintf("DONE\n");
f0107282:	83 ec 0c             	sub    $0xc,%esp
f0107285:	68 ff e2 12 f0       	push   $0xf012e2ff
f010728a:	e8 cd a8 ff ff       	call   f0101b5c <cprintf>
f010728f:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0107292:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0107297:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010729a:	c1 e2 04             	shl    $0x4,%edx
f010729d:	01 d0                	add    %edx,%eax
f010729f:	8b 40 08             	mov    0x8(%eax),%eax
f01072a2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01072a5:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f01072aa:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01072ad:	c1 e2 04             	shl    $0x4,%edx
f01072b0:	01 d0                	add    %edx,%eax
f01072b2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01072b6:	74 08                	je     f01072c0 <sched_kill_all+0x235>
f01072b8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01072bb:	8b 52 08             	mov    0x8(%edx),%edx
f01072be:	eb 05                	jmp    f01072c5 <sched_kill_all+0x23a>
f01072c0:	ba 00 00 00 00       	mov    $0x0,%edx
f01072c5:	89 50 08             	mov    %edx,0x8(%eax)
f01072c8:	8b 40 08             	mov    0x8(%eax),%eax
f01072cb:	85 c0                	test   %eax,%eax
f01072cd:	0f 85 dd fe ff ff    	jne    f01071b0 <sched_kill_all+0x125>
f01072d3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01072d7:	0f 85 d3 fe ff ff    	jne    f01071b0 <sched_kill_all+0x125>
f01072dd:	eb 13                	jmp    f01072f2 <sched_kill_all+0x267>
				cprintf("DONE\n");
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n",i);
f01072df:	83 ec 08             	sub    $0x8,%esp
f01072e2:	ff 75 f0             	pushl  -0x10(%ebp)
f01072e5:	68 20 e2 12 f0       	push   $0xf012e220
f01072ea:	e8 6d a8 ff ff       	call   f0101b5c <cprintf>
f01072ef:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f01072f2:	83 ec 0c             	sub    $0xc,%esp
f01072f5:	68 c4 e1 12 f0       	push   $0xf012e1c4
f01072fa:	e8 5d a8 ff ff       	call   f0101b5c <cprintf>
f01072ff:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("No processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0107302:	ff 45 f0             	incl   -0x10(%ebp)
f0107305:	a0 60 6d 85 f0       	mov    0xf0856d60,%al
f010730a:	0f b6 c0             	movzbl %al,%eax
f010730d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0107310:	0f 8f 59 fe ff ff    	jg     f010716f <sched_kill_all+0xe4>
			cprintf("No processes in READY queue #%d\n",i);
		}
		cprintf("================================================\n");
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0107316:	a1 a0 e7 83 f0       	mov    0xf083e7a0,%eax
f010731b:	85 c0                	test   %eax,%eax
f010731d:	0f 84 95 00 00 00    	je     f01073b8 <sched_kill_all+0x32d>
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
f0107323:	83 ec 0c             	sub    $0xc,%esp
f0107326:	68 54 e3 12 f0       	push   $0xf012e354
f010732b:	e8 2c a8 ff ff       	call   f0101b5c <cprintf>
f0107330:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0107333:	a1 a0 e7 83 f0       	mov    0xf083e7a0,%eax
f0107338:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010733b:	eb 52                	jmp    f010738f <sched_kill_all+0x304>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f010733d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107340:	8d 50 20             	lea    0x20(%eax),%edx
f0107343:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107346:	8b 40 10             	mov    0x10(%eax),%eax
f0107349:	83 ec 04             	sub    $0x4,%esp
f010734c:	52                   	push   %edx
f010734d:	50                   	push   %eax
f010734e:	68 ec e2 12 f0       	push   $0xf012e2ec
f0107353:	e8 04 a8 ff ff       	call   f0101b5c <cprintf>
f0107358:	83 c4 10             	add    $0x10,%esp
			sched_remove_exit(ptr_env);
f010735b:	83 ec 0c             	sub    $0xc,%esp
f010735e:	ff 75 f4             	pushl  -0xc(%ebp)
f0107361:	e8 33 f2 ff ff       	call   f0106599 <sched_remove_exit>
f0107366:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0107369:	83 ec 0c             	sub    $0xc,%esp
f010736c:	ff 75 f4             	pushl  -0xc(%ebp)
f010736f:	e8 45 46 00 00       	call   f010b9b9 <env_free>
f0107374:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0107377:	83 ec 0c             	sub    $0xc,%esp
f010737a:	68 ff e2 12 f0       	push   $0xf012e2ff
f010737f:	e8 d8 a7 ff ff       	call   f0101b5c <cprintf>
f0107384:	83 c4 10             	add    $0x10,%esp
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0107387:	a1 a8 e7 83 f0       	mov    0xf083e7a8,%eax
f010738c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010738f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0107393:	74 08                	je     f010739d <sched_kill_all+0x312>
f0107395:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107398:	8b 40 08             	mov    0x8(%eax),%eax
f010739b:	eb 05                	jmp    f01073a2 <sched_kill_all+0x317>
f010739d:	b8 00 00 00 00       	mov    $0x0,%eax
f01073a2:	a3 a8 e7 83 f0       	mov    %eax,0xf083e7a8
f01073a7:	a1 a8 e7 83 f0       	mov    0xf083e7a8,%eax
f01073ac:	85 c0                	test   %eax,%eax
f01073ae:	75 8d                	jne    f010733d <sched_kill_all+0x2b2>
f01073b0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01073b4:	75 87                	jne    f010733d <sched_kill_all+0x2b2>
f01073b6:	eb 10                	jmp    f01073c8 <sched_kill_all+0x33d>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f01073b8:	83 ec 0c             	sub    $0xc,%esp
f01073bb:	68 66 e2 12 f0       	push   $0xf012e266
f01073c0:	e8 97 a7 ff ff       	call   f0101b5c <cprintf>
f01073c5:	83 c4 10             	add    $0x10,%esp
	}

	struct Env* cur_env = get_cpu_proc();
f01073c8:	e8 4b 46 00 00       	call   f010ba18 <get_cpu_proc>
f01073cd:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (cur_env)
f01073d0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01073d4:	74 6b                	je     f0107441 <sched_kill_all+0x3b6>
	{
		ptr_env = cur_env;
f01073d6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01073d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(ptr_env->env_status == ENV_RUNNING);
f01073dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073df:	8b 40 18             	mov    0x18(%eax),%eax
f01073e2:	83 f8 02             	cmp    $0x2,%eax
f01073e5:	74 19                	je     f0107400 <sched_kill_all+0x375>
f01073e7:	68 24 e1 12 f0       	push   $0xf012e124
f01073ec:	68 26 df 12 f0       	push   $0xf012df26
f01073f1:	68 6c 02 00 00       	push   $0x26c
f01073f6:	68 3b df 12 f0       	push   $0xf012df3b
f01073fb:	e8 af 9a ff ff       	call   f0100eaf <_panic>
		cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0107400:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107403:	8d 50 20             	lea    0x20(%eax),%edx
f0107406:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107409:	8b 40 10             	mov    0x10(%eax),%eax
f010740c:	83 ec 04             	sub    $0x4,%esp
f010740f:	52                   	push   %edx
f0107410:	50                   	push   %eax
f0107411:	68 80 e3 12 f0       	push   $0xf012e380
f0107416:	e8 41 a7 ff ff       	call   f0101b5c <cprintf>
f010741b:	83 c4 10             	add    $0x10,%esp
		env_free(ptr_env);
f010741e:	83 ec 0c             	sub    $0xc,%esp
f0107421:	ff 75 f4             	pushl  -0xc(%ebp)
f0107424:	e8 90 45 00 00       	call   f010b9b9 <env_free>
f0107429:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f010742c:	83 ec 0c             	sub    $0xc,%esp
f010742f:	68 ff e2 12 f0       	push   $0xf012e2ff
f0107434:	e8 23 a7 ff ff       	call   f0101b5c <cprintf>
f0107439:	83 c4 10             	add    $0x10,%esp
		//return back to a killed env. Status already set to EXIT in the env_free()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		//reinvoke the scheduler since there're no env to return back to it
		/*2024: replaced by sched() to apply context_switch*/
		sched();
f010743c:	e8 51 47 00 00       	call   f010bb92 <sched>
	}
	release_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0107441:	83 ec 0c             	sub    $0xc,%esp
f0107444:	68 20 e7 83 f0       	push   $0xf083e720
f0107449:	e8 d2 89 00 00       	call   f010fe20 <release_kspinlock>
f010744e:	83 c4 10             	add    $0x10,%esp
	//get into the command prompt since there're no env to return back to it
	//fos_scheduler(); //2024: commented
	get_into_prompt();
f0107451:	e8 8c a8 ff ff       	call   f0101ce2 <get_into_prompt>

f0107456 <sched_exit_all_ready_envs>:
/*2018*/
//=================================================
// [14] EXIT ALL Ready Envs:
//=================================================
void sched_exit_all_ready_envs()
{
f0107456:	55                   	push   %ebp
f0107457:	89 e5                	mov    %esp,%ebp
f0107459:	83 ec 18             	sub    $0x18,%esp
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010745c:	83 ec 0c             	sub    $0xc,%esp
f010745f:	68 20 e7 83 f0       	push   $0xf083e720
f0107464:	e8 12 89 00 00       	call   f010fd7b <acquire_kspinlock>
f0107469:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f010746c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0107473:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010747a:	e9 37 01 00 00       	jmp    f01075b6 <sched_exit_all_ready_envs+0x160>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f010747f:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0107484:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107487:	c1 e2 04             	shl    $0x4,%edx
f010748a:	01 d0                	add    %edx,%eax
f010748c:	8b 00                	mov    (%eax),%eax
f010748e:	85 c0                	test   %eax,%eax
f0107490:	0f 84 1d 01 00 00    	je     f01075b3 <sched_exit_all_ready_envs+0x15d>
		{
			ptr_env=NULL;
f0107496:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f010749d:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f01074a2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01074a5:	c1 e2 04             	shl    $0x4,%edx
f01074a8:	01 d0                	add    %edx,%eax
f01074aa:	8b 00                	mov    (%eax),%eax
f01074ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01074af:	e9 c7 00 00 00       	jmp    f010757b <sched_exit_all_ready_envs+0x125>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f01074b4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01074b8:	75 17                	jne    f01074d1 <sched_exit_all_ready_envs+0x7b>
f01074ba:	83 ec 04             	sub    $0x4,%esp
f01074bd:	68 77 df 12 f0       	push   $0xf012df77
f01074c2:	68 8e 02 00 00       	push   $0x28e
f01074c7:	68 3b df 12 f0       	push   $0xf012df3b
f01074cc:	e8 de 99 ff ff       	call   f0100eaf <_panic>
f01074d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074d4:	8b 40 08             	mov    0x8(%eax),%eax
f01074d7:	85 c0                	test   %eax,%eax
f01074d9:	74 11                	je     f01074ec <sched_exit_all_ready_envs+0x96>
f01074db:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074de:	8b 40 08             	mov    0x8(%eax),%eax
f01074e1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01074e4:	8b 52 0c             	mov    0xc(%edx),%edx
f01074e7:	89 50 0c             	mov    %edx,0xc(%eax)
f01074ea:	eb 16                	jmp    f0107502 <sched_exit_all_ready_envs+0xac>
f01074ec:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f01074f1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01074f4:	c1 e2 04             	shl    $0x4,%edx
f01074f7:	01 c2                	add    %eax,%edx
f01074f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074fc:	8b 40 0c             	mov    0xc(%eax),%eax
f01074ff:	89 42 04             	mov    %eax,0x4(%edx)
f0107502:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107505:	8b 40 0c             	mov    0xc(%eax),%eax
f0107508:	85 c0                	test   %eax,%eax
f010750a:	74 11                	je     f010751d <sched_exit_all_ready_envs+0xc7>
f010750c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010750f:	8b 40 0c             	mov    0xc(%eax),%eax
f0107512:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107515:	8b 52 08             	mov    0x8(%edx),%edx
f0107518:	89 50 08             	mov    %edx,0x8(%eax)
f010751b:	eb 15                	jmp    f0107532 <sched_exit_all_ready_envs+0xdc>
f010751d:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0107522:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107525:	c1 e2 04             	shl    $0x4,%edx
f0107528:	01 c2                	add    %eax,%edx
f010752a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010752d:	8b 40 08             	mov    0x8(%eax),%eax
f0107530:	89 02                	mov    %eax,(%edx)
f0107532:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107535:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010753c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010753f:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0107546:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f010754b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010754e:	c1 e2 04             	shl    $0x4,%edx
f0107551:	01 d0                	add    %edx,%eax
f0107553:	8b 50 0c             	mov    0xc(%eax),%edx
f0107556:	4a                   	dec    %edx
f0107557:	89 50 0c             	mov    %edx,0xc(%eax)
				sched_insert_exit(ptr_env);
f010755a:	83 ec 0c             	sub    $0xc,%esp
f010755d:	ff 75 f4             	pushl  -0xc(%ebp)
f0107560:	e8 ad ef ff ff       	call   f0106512 <sched_insert_exit>
f0107565:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			ptr_env=NULL;
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0107568:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f010756d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107570:	c1 e2 04             	shl    $0x4,%edx
f0107573:	01 d0                	add    %edx,%eax
f0107575:	8b 40 08             	mov    0x8(%eax),%eax
f0107578:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010757b:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0107580:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107583:	c1 e2 04             	shl    $0x4,%edx
f0107586:	01 d0                	add    %edx,%eax
f0107588:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010758c:	74 08                	je     f0107596 <sched_exit_all_ready_envs+0x140>
f010758e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107591:	8b 52 08             	mov    0x8(%edx),%edx
f0107594:	eb 05                	jmp    f010759b <sched_exit_all_ready_envs+0x145>
f0107596:	ba 00 00 00 00       	mov    $0x0,%edx
f010759b:	89 50 08             	mov    %edx,0x8(%eax)
f010759e:	8b 40 08             	mov    0x8(%eax),%eax
f01075a1:	85 c0                	test   %eax,%eax
f01075a3:	0f 85 0b ff ff ff    	jne    f01074b4 <sched_exit_all_ready_envs+0x5e>
f01075a9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01075ad:	0f 85 01 ff ff ff    	jne    f01074b4 <sched_exit_all_ready_envs+0x5e>
//=================================================
void sched_exit_all_ready_envs()
{
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f01075b3:	ff 45 f0             	incl   -0x10(%ebp)
f01075b6:	a0 60 6d 85 f0       	mov    0xf0856d60,%al
f01075bb:	0f b6 c0             	movzbl %al,%eax
f01075be:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01075c1:	0f 8f b8 fe ff ff    	jg     f010747f <sched_exit_all_ready_envs+0x29>
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
				sched_insert_exit(ptr_env);
			}
		}
	}
	release_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01075c7:	83 ec 0c             	sub    $0xc,%esp
f01075ca:	68 20 e7 83 f0       	push   $0xf083e720
f01075cf:	e8 4c 88 00 00       	call   f010fe20 <release_kspinlock>
f01075d4:	83 c4 10             	add    $0x10,%esp
}
f01075d7:	90                   	nop
f01075d8:	c9                   	leave  
f01075d9:	c3                   	ret    

f01075da <timer_ticks>:

/*2023*/
/********* for BSD Priority Scheduler *************/
int64 timer_ticks()
{
f01075da:	55                   	push   %ebp
f01075db:	89 e5                	mov    %esp,%ebp
	return ticks;
f01075dd:	a1 28 6c 85 f0       	mov    0xf0856c28,%eax
f01075e2:	8b 15 2c 6c 85 f0    	mov    0xf0856c2c,%edx
}
f01075e8:	5d                   	pop    %ebp
f01075e9:	c3                   	ret    

f01075ea <env_get_nice>:
int env_get_nice(struct Env* e)
{
f01075ea:	55                   	push   %ebp
f01075eb:	89 e5                	mov    %esp,%ebp
f01075ed:	83 ec 08             	sub    $0x8,%esp
	panic("Not implemented function");
f01075f0:	83 ec 04             	sub    $0x4,%esp
f01075f3:	68 aa e3 12 f0       	push   $0xf012e3aa
f01075f8:	68 9e 02 00 00       	push   $0x29e
f01075fd:	68 3b df 12 f0       	push   $0xf012df3b
f0107602:	e8 a8 98 ff ff       	call   f0100eaf <_panic>

f0107607 <env_set_nice>:
}

void env_set_nice(struct Env* e, int nice_value)
{
f0107607:	55                   	push   %ebp
f0107608:	89 e5                	mov    %esp,%ebp
f010760a:	83 ec 08             	sub    $0x8,%esp
	panic("Not implemented function");
f010760d:	83 ec 04             	sub    $0x4,%esp
f0107610:	68 aa e3 12 f0       	push   $0xf012e3aa
f0107615:	68 a3 02 00 00       	push   $0x2a3
f010761a:	68 3b df 12 f0       	push   $0xf012df3b
f010761f:	e8 8b 98 ff ff       	call   f0100eaf <_panic>

f0107624 <env_get_recent_cpu>:
}
int env_get_recent_cpu(struct Env* e)
{
f0107624:	55                   	push   %ebp
f0107625:	89 e5                	mov    %esp,%ebp
f0107627:	83 ec 08             	sub    $0x8,%esp
	panic("Not implemented function");
f010762a:	83 ec 04             	sub    $0x4,%esp
f010762d:	68 aa e3 12 f0       	push   $0xf012e3aa
f0107632:	68 a7 02 00 00       	push   $0x2a7
f0107637:	68 3b df 12 f0       	push   $0xf012df3b
f010763c:	e8 6e 98 ff ff       	call   f0100eaf <_panic>

f0107641 <get_load_average>:
}
int get_load_average()
{
f0107641:	55                   	push   %ebp
f0107642:	89 e5                	mov    %esp,%ebp
f0107644:	83 ec 08             	sub    $0x8,%esp
	panic("Not implemented function");
f0107647:	83 ec 04             	sub    $0x4,%esp
f010764a:	68 aa e3 12 f0       	push   $0xf012e3aa
f010764f:	68 ab 02 00 00       	push   $0x2ab
f0107654:	68 3b df 12 f0       	push   $0xf012df3b
f0107659:	e8 51 98 ff ff       	call   f0100eaf <_panic>

f010765e <env_set_priority>:
//==================================================================================//

/*2024*/
/********* for Priority RR Scheduler *************/
void env_set_priority(int envID, int priority)
{
f010765e:	55                   	push   %ebp
f010765f:	89 e5                	mov    %esp,%ebp
f0107661:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#4] CPU SCHEDULING - #1 env_set_priority
	//Your code is here
	//Comment the following line
	panic("env_set_priority() is not implemented yet...!!");
f0107664:	83 ec 04             	sub    $0x4,%esp
f0107667:	68 c4 e3 12 f0       	push   $0xf012e3c4
f010766c:	68 b8 02 00 00       	push   $0x2b8
f0107671:	68 3b df 12 f0       	push   $0xf012df3b
f0107676:	e8 34 98 ff ff       	call   f0100eaf <_panic>

f010767b <sched_set_starv_thresh>:
}
void sched_set_starv_thresh(uint32 starvThresh)
{
f010767b:	55                   	push   %ebp
f010767c:	89 e5                	mov    %esp,%ebp
f010767e:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#4] CPU SCHEDULING - #1 sched_set_starv_thresh
	//Your code is here
	//Comment the following line
	panic("sched_set_starv_thresh() is not implemented yet...!!");
f0107681:	83 ec 04             	sub    $0x4,%esp
f0107684:	68 f4 e3 12 f0       	push   $0xf012e3f4
f0107689:	68 bf 02 00 00       	push   $0x2bf
f010768e:	68 3b df 12 f0       	push   $0xf012df3b
f0107693:	e8 17 98 ff ff       	call   f0100eaf <_panic>

f0107698 <isSchedMethodRR>:
#include <kern/cmd/command_prompt.h>
#include <kern/cpu/cpu.h>
#include <kern/cpu/picirq.h>


uint32 isSchedMethodRR(){return (scheduler_method == SCH_RR);}
f0107698:	55                   	push   %ebp
f0107699:	89 e5                	mov    %esp,%ebp
f010769b:	a1 fc 6a 85 f0       	mov    0xf0856afc,%eax
f01076a0:	85 c0                	test   %eax,%eax
f01076a2:	0f 94 c0             	sete   %al
f01076a5:	0f b6 c0             	movzbl %al,%eax
f01076a8:	5d                   	pop    %ebp
f01076a9:	c3                   	ret    

f01076aa <isSchedMethodMLFQ>:
uint32 isSchedMethodMLFQ(){return (scheduler_method == SCH_MLFQ); }
f01076aa:	55                   	push   %ebp
f01076ab:	89 e5                	mov    %esp,%ebp
f01076ad:	a1 fc 6a 85 f0       	mov    0xf0856afc,%eax
f01076b2:	83 f8 01             	cmp    $0x1,%eax
f01076b5:	0f 94 c0             	sete   %al
f01076b8:	0f b6 c0             	movzbl %al,%eax
f01076bb:	5d                   	pop    %ebp
f01076bc:	c3                   	ret    

f01076bd <isSchedMethodBSD>:
uint32 isSchedMethodBSD(){return(scheduler_method == SCH_BSD); }
f01076bd:	55                   	push   %ebp
f01076be:	89 e5                	mov    %esp,%ebp
f01076c0:	a1 fc 6a 85 f0       	mov    0xf0856afc,%eax
f01076c5:	83 f8 02             	cmp    $0x2,%eax
f01076c8:	0f 94 c0             	sete   %al
f01076cb:	0f b6 c0             	movzbl %al,%eax
f01076ce:	5d                   	pop    %ebp
f01076cf:	c3                   	ret    

f01076d0 <isSchedMethodPRIRR>:
uint32 isSchedMethodPRIRR(){return(scheduler_method == SCH_PRIRR); }
f01076d0:	55                   	push   %ebp
f01076d1:	89 e5                	mov    %esp,%ebp
f01076d3:	a1 fc 6a 85 f0       	mov    0xf0856afc,%eax
f01076d8:	83 f8 03             	cmp    $0x3,%eax
f01076db:	0f 94 c0             	sete   %al
f01076de:	0f b6 c0             	movzbl %al,%eax
f01076e1:	5d                   	pop    %ebp
f01076e2:	c3                   	ret    

f01076e3 <sched_init>:

//===================================
// [1] Default Scheduler Initializer:
//===================================
void sched_init()
{
f01076e3:	55                   	push   %ebp
f01076e4:	89 e5                	mov    %esp,%ebp
f01076e6:	83 ec 08             	sub    $0x8,%esp
	old_pf_counter = 0;
f01076e9:	c7 05 f8 e8 83 f0 00 	movl   $0x0,0xf083e8f8
f01076f0:	00 00 00 

	sched_init_RR(INIT_QUANTUM_IN_MS);
f01076f3:	83 ec 0c             	sub    $0xc,%esp
f01076f6:	6a 0a                	push   $0xa
f01076f8:	e8 45 02 00 00       	call   f0107942 <sched_init_RR>
f01076fd:	83 c4 10             	add    $0x10,%esp

	init_queue(&ProcessQueues.env_new_queue);
f0107700:	83 ec 0c             	sub    $0xc,%esp
f0107703:	68 90 e7 83 f0       	push   $0xf083e790
f0107708:	e8 bd e7 ff ff       	call   f0105eca <init_queue>
f010770d:	83 c4 10             	add    $0x10,%esp
	init_queue(&ProcessQueues.env_exit_queue);
f0107710:	83 ec 0c             	sub    $0xc,%esp
f0107713:	68 a0 e7 83 f0       	push   $0xf083e7a0
f0107718:	e8 ad e7 ff ff       	call   f0105eca <init_queue>
f010771d:	83 c4 10             	add    $0x10,%esp

	mycpu()->scheduler_status = SCH_STOPPED;
f0107720:	e8 4b 08 00 00       	call   f0107f70 <mycpu>
f0107725:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f010772c:	00 00 00 

	/*2024: initialize lock to protect these Qs in MULTI-CORE case only*/
	init_kspinlock(&ProcessQueues.qlock, "process queues lock");
f010772f:	83 ec 08             	sub    $0x8,%esp
f0107732:	68 2c e4 12 f0       	push   $0xf012e42c
f0107737:	68 20 e7 83 f0       	push   $0xf083e720
f010773c:	e8 09 86 00 00       	call   f010fd4a <init_kspinlock>
f0107741:	83 c4 10             	add    $0x10,%esp
}
f0107744:	90                   	nop
f0107745:	c9                   	leave  
f0107746:	c3                   	ret    

f0107747 <fos_scheduler>:
// [2] Main FOS Scheduler:
//=========================

void
fos_scheduler(void)
{
f0107747:	55                   	push   %ebp
f0107748:	89 e5                	mov    %esp,%ebp
f010774a:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010774d:	9c                   	pushf  
f010774e:	58                   	pop    %eax
f010774f:	89 45 dc             	mov    %eax,-0x24(%ebp)
        return eflags;
f0107752:	8b 45 dc             	mov    -0x24(%ebp),%eax
	//ensure that the scheduler is invoked while interrupt is disabled
	if (read_eflags() & FL_IF)
f0107755:	25 00 02 00 00       	and    $0x200,%eax
f010775a:	85 c0                	test   %eax,%eax
f010775c:	74 14                	je     f0107772 <fos_scheduler+0x2b>
		panic("fos_scheduler: called while the interrupt is enabled!");
f010775e:	83 ec 04             	sub    $0x4,%esp
f0107761:	68 40 e4 12 f0       	push   $0xf012e440
f0107766:	6a 3a                	push   $0x3a
f0107768:	68 76 e4 12 f0       	push   $0xf012e476
f010776d:	e8 3d 97 ff ff       	call   f0100eaf <_panic>

	//cprintf("inside scheduler - timer cnt = %d\n", kclock_read_cnt0());
	struct Env *p;
	struct cpu *c = mycpu();
f0107772:	e8 f9 07 00 00       	call   f0107f70 <mycpu>
f0107777:	89 45 ec             	mov    %eax,-0x14(%ebp)
	c->proc = 0;
f010777a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010777d:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0107784:	00 00 00 

	chk1();
f0107787:	e8 03 24 01 00       	call   f0119b8f <chk1>
	c->scheduler_status = SCH_STARTED;
f010778c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010778f:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
f0107796:	00 00 00 

	//This variable should be set to the next environment to be run (if any)
	struct Env* next_env = NULL;
f0107799:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

	//2024: should be outer loop as long as there's any BLOCKED processes.
	//Ref: xv6-x86 OS
	int is_any_blocked = 0;
f01077a0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f01077a7:	fb                   	sti    
		// to avoid a deadlock if all processes are waiting.
		sti();

		// Check ready queue(s) looking for process to run.
		//cprintf("\n[FOS_SCHEDULER] acquire: lock status before acquire = %d\n", qlock.locked);
		acquire_kspinlock(&(ProcessQueues.qlock));  //lock: to protect ready & blocked Qs in multi-CPU
f01077a8:	83 ec 0c             	sub    $0xc,%esp
f01077ab:	68 20 e7 83 f0       	push   $0xf083e720
f01077b0:	e8 c6 85 00 00       	call   f010fd7b <acquire_kspinlock>
f01077b5:	83 c4 10             	add    $0x10,%esp
		//cprintf("ACQUIRED\n");
		do
		{
			//Get next env according to the current scheduler
			next_env = sched_next[scheduler_method]() ;
f01077b8:	a1 fc 6a 85 f0       	mov    0xf0856afc,%eax
f01077bd:	8b 04 85 ac fb 17 f0 	mov    -0xfe80454(,%eax,4),%eax
f01077c4:	ff d0                	call   *%eax
f01077c6:	89 45 e8             	mov    %eax,-0x18(%ebp)

			if(next_env != NULL)
f01077c9:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01077cd:	0f 84 f5 00 00 00    	je     f01078c8 <fos_scheduler+0x181>
			{
				//cprintf("\nScheduler select program '%s' [%d]... clock counter = %d\n", next_env->prog_name, next_env->env_id, kclock_read_cnt0());
				// Switch to chosen process. It is the process's job to release qlock
				// and then reacquire it before jumping back to us.
				set_cpu_proc(next_env);
f01077d3:	83 ec 0c             	sub    $0xc,%esp
f01077d6:	ff 75 e8             	pushl  -0x18(%ebp)
f01077d9:	e8 63 42 00 00       	call   f010ba41 <set_cpu_proc>
f01077de:	83 c4 10             	add    $0x10,%esp
				switchuvm(next_env);
f01077e1:	83 ec 0c             	sub    $0xc,%esp
f01077e4:	ff 75 e8             	pushl  -0x18(%ebp)
f01077e7:	e8 c9 44 00 00       	call   f010bcb5 <switchuvm>
f01077ec:	83 c4 10             	add    $0x10,%esp

				//Change its status to RUNNING
				next_env->env_status = ENV_RUNNING;
f01077ef:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01077f2:	c7 40 18 02 00 00 00 	movl   $0x2,0x18(%eax)

				//Context switch to it
				context_switch(&(c->scheduler), next_env->context);
f01077f9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01077fc:	8b 40 04             	mov    0x4(%eax),%eax
f01077ff:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0107802:	83 c2 04             	add    $0x4,%edx
f0107805:	83 ec 08             	sub    $0x8,%esp
f0107808:	50                   	push   %eax
f0107809:	52                   	push   %edx
f010780a:	e8 c3 e2 ff ff       	call   f0105ad2 <context_switch>
f010780f:	83 c4 10             	add    $0x10,%esp

				//ensure that the qlock is still held after returning from the process
				if(!holding_kspinlock(&ProcessQueues.qlock))
f0107812:	83 ec 0c             	sub    $0xc,%esp
f0107815:	68 20 e7 83 f0       	push   $0xf083e720
f010781a:	e8 b1 87 00 00       	call   f010ffd0 <holding_kspinlock>
f010781f:	83 c4 10             	add    $0x10,%esp
f0107822:	85 c0                	test   %eax,%eax
f0107824:	75 24                	jne    f010784a <fos_scheduler+0x103>
				{
					printcallstack(&ProcessQueues.qlock);
f0107826:	83 ec 0c             	sub    $0xc,%esp
f0107829:	68 20 e7 83 f0       	push   $0xf083e720
f010782e:	e8 36 87 00 00       	call   f010ff69 <printcallstack>
f0107833:	83 c4 10             	add    $0x10,%esp
					panic("fos_scheduler(): qlock is either not held or held by another CPU!");
f0107836:	83 ec 04             	sub    $0x4,%esp
f0107839:	68 88 e4 12 f0       	push   $0xf012e488
f010783e:	6a 6c                	push   $0x6c
f0107840:	68 76 e4 12 f0       	push   $0xf012e476
f0107845:	e8 65 96 ff ff       	call   f0100eaf <_panic>
				}

				//Stop the clock now till finding a next proc (if any).
				//This is to avoid clock interrupt inside the scheduler after sti() of the outer loop
				kclock_stop();
f010784a:	e8 cc e3 ff ff       	call   f0105c1b <kclock_stop>
				//cprintf("\n[IEN = %d] clock is stopped! returned to scheduler after context_switch. curenv = %d\n", (read_eflags() & FL_IF) == 0? 0:1, c->proc == NULL? 0 : c->proc->env_id);

				// Process is done running for now. It should have changed its p->status before coming back.
				//If no process on CPU, switch to the kernel
				assert(get_cpu_proc() == c->proc);
f010784f:	e8 c4 41 00 00       	call   f010ba18 <get_cpu_proc>
f0107854:	89 c2                	mov    %eax,%edx
f0107856:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107859:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010785f:	39 c2                	cmp    %eax,%edx
f0107861:	74 16                	je     f0107879 <fos_scheduler+0x132>
f0107863:	68 ca e4 12 f0       	push   $0xf012e4ca
f0107868:	68 e4 e4 12 f0       	push   $0xf012e4e4
f010786d:	6a 76                	push   $0x76
f010786f:	68 76 e4 12 f0       	push   $0xf012e476
f0107874:	e8 36 96 ff ff       	call   f0100eaf <_panic>
				int status = c->proc->env_status ;
f0107879:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010787c:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f0107882:	8b 40 18             	mov    0x18(%eax),%eax
f0107885:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				assert(status != ENV_RUNNING);
f0107888:	83 7d e4 02          	cmpl   $0x2,-0x1c(%ebp)
f010788c:	75 16                	jne    f01078a4 <fos_scheduler+0x15d>
f010788e:	68 f9 e4 12 f0       	push   $0xf012e4f9
f0107893:	68 e4 e4 12 f0       	push   $0xf012e4e4
f0107898:	6a 78                	push   $0x78
f010789a:	68 76 e4 12 f0       	push   $0xf012e476
f010789f:	e8 0b 96 ff ff       	call   f0100eaf <_panic>
				if (status == ENV_READY)
f01078a4:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
f01078a8:	74 1e                	je     f01078c8 <fos_scheduler+0x181>
					//OK... will be placed to the correct ready Q in the next iteration
				}
				else
				{
					//					cprintf("scheduler: process %d is BLOCKED/EXITED\n", c->proc->env_id);
					switchkvm();
f01078aa:	e8 ef 43 00 00       	call   f010bc9e <switchkvm>
					struct Env* __e__ = c->proc;
f01078af:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01078b2:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f01078b8:	89 45 e0             	mov    %eax,-0x20(%ebp)
					set_cpu_proc(NULL);
f01078bb:	83 ec 0c             	sub    $0xc,%esp
f01078be:	6a 00                	push   $0x0
f01078c0:	e8 7c 41 00 00       	call   f010ba41 <set_cpu_proc>
f01078c5:	83 c4 10             	add    $0x10,%esp
				}
			}
		} while(next_env);
f01078c8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01078cc:	0f 85 e6 fe ff ff    	jne    f01077b8 <fos_scheduler+0x71>

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
f01078d2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (int i = 0; i < NENV; ++i)
f01078d9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01078e0:	eb 37                	jmp    f0107919 <fos_scheduler+0x1d2>
		{
			if (envs[i].env_status == ENV_BLOCKED)
f01078e2:	8b 0d 90 5b 81 f0    	mov    0xf0815b90,%ecx
f01078e8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01078eb:	89 d0                	mov    %edx,%eax
f01078ed:	c1 e0 02             	shl    $0x2,%eax
f01078f0:	01 d0                	add    %edx,%eax
f01078f2:	c1 e0 03             	shl    $0x3,%eax
f01078f5:	01 d0                	add    %edx,%eax
f01078f7:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01078fe:	01 d0                	add    %edx,%eax
f0107900:	c1 e0 02             	shl    $0x2,%eax
f0107903:	01 c8                	add    %ecx,%eax
f0107905:	8b 40 18             	mov    0x18(%eax),%eax
f0107908:	83 f8 03             	cmp    $0x3,%eax
f010790b:	75 09                	jne    f0107916 <fos_scheduler+0x1cf>
			{
				is_any_blocked = 1;
f010790d:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f0107914:	eb 0d                	jmp    f0107923 <fos_scheduler+0x1dc>
			}
		} while(next_env);

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
		for (int i = 0; i < NENV; ++i)
f0107916:	ff 45 f0             	incl   -0x10(%ebp)
f0107919:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010791c:	3d c5 02 00 00       	cmp    $0x2c5,%eax
f0107921:	76 bf                	jbe    f01078e2 <fos_scheduler+0x19b>
			{
				is_any_blocked = 1;
				break;
			}
		}
		release_kspinlock(&ProcessQueues.qlock);  //release lock: to protect ready & blocked Qs in multi-CPU
f0107923:	83 ec 0c             	sub    $0xc,%esp
f0107926:	68 20 e7 83 f0       	push   $0xf083e720
f010792b:	e8 f0 84 00 00       	call   f010fe20 <release_kspinlock>
f0107930:	83 c4 10             	add    $0x10,%esp
		//cprintf("\n[FOS_SCHEDULER] release: lock status after = %d\n", qlock.locked);
	} while (is_any_blocked > 0);
f0107933:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0107937:	0f 8f 6a fe ff ff    	jg     f01077a7 <fos_scheduler+0x60>

	/*2015*///No more envs... curenv doesn't exist any more! return back to command prompt
	{
		//cprintf("[sched] no envs - nothing more to do!\n");
		get_into_prompt();
f010793d:	e8 a0 a3 ff ff       	call   f0101ce2 <get_into_prompt>

f0107942 <sched_init_RR>:

//=============================
// [3] Initialize RR Scheduler:
//=============================
void sched_init_RR(uint8 quantum)
{
f0107942:	55                   	push   %ebp
f0107943:	89 e5                	mov    %esp,%ebp
f0107945:	83 ec 28             	sub    $0x28,%esp
f0107948:	8b 45 08             	mov    0x8(%ebp),%eax
f010794b:	88 45 e4             	mov    %al,-0x1c(%ebp)
	// Create 1 ready queue for the RR
	num_of_ready_queues = 1;
f010794e:	c6 05 60 6d 85 f0 01 	movb   $0x1,0xf0856d60
#if USE_KHEAP
	sched_delete_ready_queues();
f0107955:	e8 20 e8 ff ff       	call   f010617a <sched_delete_ready_queues>
	ProcessQueues.env_ready_queues = kmalloc(sizeof(struct Env_Queue));
f010795a:	83 ec 0c             	sub    $0xc,%esp
f010795d:	6a 10                	push   $0x10
f010795f:	e8 d2 21 00 00       	call   f0109b36 <kmalloc>
f0107964:	83 c4 10             	add    $0x10,%esp
f0107967:	a3 b0 e7 83 f0       	mov    %eax,0xf083e7b0
	quantums = kmalloc(num_of_ready_queues * sizeof(uint8)) ;
f010796c:	a0 60 6d 85 f0       	mov    0xf0856d60,%al
f0107971:	0f b6 c0             	movzbl %al,%eax
f0107974:	83 ec 0c             	sub    $0xc,%esp
f0107977:	50                   	push   %eax
f0107978:	e8 b9 21 00 00       	call   f0109b36 <kmalloc>
f010797d:	83 c4 10             	add    $0x10,%esp
f0107980:	a3 e4 6a 85 f0       	mov    %eax,0xf0856ae4
#endif
	quantums[0] = quantum;
f0107985:	a1 e4 6a 85 f0       	mov    0xf0856ae4,%eax
f010798a:	8a 55 e4             	mov    -0x1c(%ebp),%dl
f010798d:	88 10                	mov    %dl,(%eax)
	kclock_set_quantum(quantums[0]);
f010798f:	a1 e4 6a 85 f0       	mov    0xf0856ae4,%eax
f0107994:	8a 00                	mov    (%eax),%al
f0107996:	0f b6 c0             	movzbl %al,%eax
f0107999:	83 ec 0c             	sub    $0xc,%esp
f010799c:	50                   	push   %eax
f010799d:	e8 42 e3 ff ff       	call   f0105ce4 <kclock_set_quantum>
f01079a2:	83 c4 10             	add    $0x10,%esp
	init_queue(&(ProcessQueues.env_ready_queues[0]));
f01079a5:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f01079aa:	83 ec 0c             	sub    $0xc,%esp
f01079ad:	50                   	push   %eax
f01079ae:	e8 17 e5 ff ff       	call   f0105eca <init_queue>
f01079b3:	83 c4 10             	add    $0x10,%esp
	//=========================================
	//DON'T CHANGE THESE LINES=================
	uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
f01079b6:	e8 88 e4 ff ff       	call   f0105e43 <kclock_read_cnt0_latch>
f01079bb:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	cprintf("*	RR scheduler with initial clock = %d\n", cnt0);
f01079bf:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f01079c3:	83 ec 08             	sub    $0x8,%esp
f01079c6:	50                   	push   %eax
f01079c7:	68 10 e5 12 f0       	push   $0xf012e510
f01079cc:	e8 8b a1 ff ff       	call   f0101b5c <cprintf>
f01079d1:	83 c4 10             	add    $0x10,%esp
	mycpu()->scheduler_status = SCH_STOPPED;
f01079d4:	e8 97 05 00 00       	call   f0107f70 <mycpu>
f01079d9:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f01079e0:	00 00 00 
	scheduler_method = SCH_RR;
f01079e3:	c7 05 fc 6a 85 f0 00 	movl   $0x0,0xf0856afc
f01079ea:	00 00 00 
	//=========================================
	//=========================================
}
f01079ed:	90                   	nop
f01079ee:	c9                   	leave  
f01079ef:	c3                   	ret    

f01079f0 <sched_init_MLFQ>:

//===============================
// [4] Initialize MLFQ Scheduler:
//===============================
void sched_init_MLFQ(uint8 numOfLevels, uint8 *quantumOfEachLevel)
{
f01079f0:	55                   	push   %ebp
f01079f1:	89 e5                	mov    %esp,%ebp
f01079f3:	83 ec 18             	sub    $0x18,%esp
f01079f6:	8b 45 08             	mov    0x8(%ebp),%eax
f01079f9:	88 45 f4             	mov    %al,-0xc(%ebp)
	panic("Not implemented yet");
f01079fc:	83 ec 04             	sub    $0x4,%esp
f01079ff:	68 38 e5 12 f0       	push   $0xf012e538
f0107a04:	68 bb 00 00 00       	push   $0xbb
f0107a09:	68 76 e4 12 f0       	push   $0xf012e476
f0107a0e:	e8 9c 94 ff ff       	call   f0100eaf <_panic>

f0107a13 <sched_init_BSD>:

//===============================
// [5] Initialize BSD Scheduler:
//===============================
void sched_init_BSD(uint8 numOfLevels, uint8 quantum)
{
f0107a13:	55                   	push   %ebp
f0107a14:	89 e5                	mov    %esp,%ebp
f0107a16:	83 ec 18             	sub    $0x18,%esp
f0107a19:	8b 55 08             	mov    0x8(%ebp),%edx
f0107a1c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107a1f:	88 55 f4             	mov    %dl,-0xc(%ebp)
f0107a22:	88 45 f0             	mov    %al,-0x10(%ebp)
	panic("Not implemented yet");
f0107a25:	83 ec 04             	sub    $0x4,%esp
f0107a28:	68 38 e5 12 f0       	push   $0xf012e538
f0107a2d:	68 ce 00 00 00       	push   $0xce
f0107a32:	68 76 e4 12 f0       	push   $0xf012e476
f0107a37:	e8 73 94 ff ff       	call   f0100eaf <_panic>

f0107a3c <sched_init_PRIRR>:

//======================================
// [6] Initialize PRIORITY RR Scheduler:
//======================================
void sched_init_PRIRR(uint8 numOfPriorities, uint8 quantum, uint32 starvThresh)
{
f0107a3c:	55                   	push   %ebp
f0107a3d:	89 e5                	mov    %esp,%ebp
f0107a3f:	83 ec 18             	sub    $0x18,%esp
f0107a42:	8b 55 08             	mov    0x8(%ebp),%edx
f0107a45:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107a48:	88 55 f4             	mov    %dl,-0xc(%ebp)
f0107a4b:	88 45 f0             	mov    %al,-0x10(%ebp)
	{
		//TODO: [PROJECT'25.IM#4] CPU SCHEDULING - #2 sched_init_PRIRR
		//Your code is here
		//Comment the following line
		panic("sched_init_PRIRR() is not implemented yet...!!");
f0107a4e:	83 ec 04             	sub    $0x4,%esp
f0107a51:	68 4c e5 12 f0       	push   $0xf012e54c
f0107a56:	68 e4 00 00 00       	push   $0xe4
f0107a5b:	68 76 e4 12 f0       	push   $0xf012e476
f0107a60:	e8 4a 94 ff ff       	call   f0100eaf <_panic>

f0107a65 <fos_scheduler_RR>:

//=========================
// [7] RR Scheduler:
//=========================
struct Env* fos_scheduler_RR()
{
f0107a65:	55                   	push   %ebp
f0107a66:	89 e5                	mov    %esp,%ebp
f0107a68:	83 ec 18             	sub    $0x18,%esp
	// Pick next environment from the ready queue,
	// and switch to such environment if found.
	// It's OK to choose the previously running env if no other env
	// is runnable.
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f0107a6b:	83 ec 0c             	sub    $0xc,%esp
f0107a6e:	68 20 e7 83 f0       	push   $0xf083e720
f0107a73:	e8 58 85 00 00       	call   f010ffd0 <holding_kspinlock>
f0107a78:	83 c4 10             	add    $0x10,%esp
f0107a7b:	85 c0                	test   %eax,%eax
f0107a7d:	75 17                	jne    f0107a96 <fos_scheduler_RR+0x31>
		panic("fos_scheduler_RR: q.lock is not held by this CPU while it's expected to be.");
f0107a7f:	83 ec 04             	sub    $0x4,%esp
f0107a82:	68 7c e5 12 f0       	push   $0xf012e57c
f0107a87:	68 ff 00 00 00       	push   $0xff
f0107a8c:	68 76 e4 12 f0       	push   $0xf012e476
f0107a91:	e8 19 94 ff ff       	call   f0100eaf <_panic>
	/****************************************************************************************/
	struct Env *next_env = NULL;
f0107a96:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct Env *cur_env = get_cpu_proc();
f0107a9d:	e8 76 3f 00 00       	call   f010ba18 <get_cpu_proc>
f0107aa2:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//If the curenv is still exist, then insert it again in the ready queue
	if (cur_env != NULL)
f0107aa5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0107aa9:	74 14                	je     f0107abf <fos_scheduler_RR+0x5a>
	{
		//cprintf("RR: [%d] with status %d will be added to ready Q", cur_env->env_id, cur_env->env_status);
		enqueue(&(ProcessQueues.env_ready_queues[0]), cur_env);
f0107aab:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0107ab0:	83 ec 08             	sub    $0x8,%esp
f0107ab3:	ff 75 f0             	pushl  -0x10(%ebp)
f0107ab6:	50                   	push   %eax
f0107ab7:	e8 4f e4 ff ff       	call   f0105f0b <enqueue>
f0107abc:	83 c4 10             	add    $0x10,%esp
	}

	//Pick the next environment from the ready queue
	next_env = dequeue(&(ProcessQueues.env_ready_queues[0]));
f0107abf:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0107ac4:	83 ec 0c             	sub    $0xc,%esp
f0107ac7:	50                   	push   %eax
f0107ac8:	e8 cf e4 ff ff       	call   f0105f9c <dequeue>
f0107acd:	83 c4 10             	add    $0x10,%esp
f0107ad0:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//Reset the quantum
	//2017: Reset the value of CNT0 for the next clock interval
	kclock_set_quantum(quantums[0]);
f0107ad3:	a1 e4 6a 85 f0       	mov    0xf0856ae4,%eax
f0107ad8:	8a 00                	mov    (%eax),%al
f0107ada:	0f b6 c0             	movzbl %al,%eax
f0107add:	83 ec 0c             	sub    $0xc,%esp
f0107ae0:	50                   	push   %eax
f0107ae1:	e8 fe e1 ff ff       	call   f0105ce4 <kclock_set_quantum>
f0107ae6:	83 c4 10             	add    $0x10,%esp
	//uint16 cnt0 = kclock_read_cnt0_latch() ;
	//cprintf("CLOCK INTERRUPT AFTER RESET: Counter0 Value = %d\n", cnt0 );

	return next_env;
f0107ae9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0107aec:	c9                   	leave  
f0107aed:	c3                   	ret    

f0107aee <fos_scheduler_MLFQ>:

//=========================
// [8] MLFQ Scheduler:
//=========================
struct Env* fos_scheduler_MLFQ()
{
f0107aee:	55                   	push   %ebp
f0107aef:	89 e5                	mov    %esp,%ebp
f0107af1:	83 ec 08             	sub    $0x8,%esp
	//Apply the MLFQ with the specified levels to pick up the next environment
	//Note: the "curenv" (if exist) should be placed in its correct queue
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f0107af4:	83 ec 0c             	sub    $0xc,%esp
f0107af7:	68 20 e7 83 f0       	push   $0xf083e720
f0107afc:	e8 cf 84 00 00       	call   f010ffd0 <holding_kspinlock>
f0107b01:	83 c4 10             	add    $0x10,%esp
f0107b04:	85 c0                	test   %eax,%eax
f0107b06:	75 17                	jne    f0107b1f <fos_scheduler_MLFQ+0x31>
		panic("fos_scheduler_MLFQ: q.lock is not held by this CPU while it's expected to be.");
f0107b08:	83 ec 04             	sub    $0x4,%esp
f0107b0b:	68 c8 e5 12 f0       	push   $0xf012e5c8
f0107b10:	68 1f 01 00 00       	push   $0x11f
f0107b15:	68 76 e4 12 f0       	push   $0xf012e476
f0107b1a:	e8 90 93 ff ff       	call   f0100eaf <_panic>
	/****************************************************************************************/
	panic("Not implemented yet");
f0107b1f:	83 ec 04             	sub    $0x4,%esp
f0107b22:	68 38 e5 12 f0       	push   $0xf012e538
f0107b27:	68 21 01 00 00       	push   $0x121
f0107b2c:	68 76 e4 12 f0       	push   $0xf012e476
f0107b31:	e8 79 93 ff ff       	call   f0100eaf <_panic>

f0107b36 <fos_scheduler_BSD>:

//=========================
// [9] BSD Scheduler:
//=========================
struct Env* fos_scheduler_BSD()
{
f0107b36:	55                   	push   %ebp
f0107b37:	89 e5                	mov    %esp,%ebp
f0107b39:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f0107b3c:	83 ec 0c             	sub    $0xc,%esp
f0107b3f:	68 20 e7 83 f0       	push   $0xf083e720
f0107b44:	e8 87 84 00 00       	call   f010ffd0 <holding_kspinlock>
f0107b49:	83 c4 10             	add    $0x10,%esp
f0107b4c:	85 c0                	test   %eax,%eax
f0107b4e:	75 17                	jne    f0107b67 <fos_scheduler_BSD+0x31>
		panic("fos_scheduler_BSD: q.lock is not held by this CPU while it's expected to be.");
f0107b50:	83 ec 04             	sub    $0x4,%esp
f0107b53:	68 18 e6 12 f0       	push   $0xf012e618
f0107b58:	68 2b 01 00 00       	push   $0x12b
f0107b5d:	68 76 e4 12 f0       	push   $0xf012e476
f0107b62:	e8 48 93 ff ff       	call   f0100eaf <_panic>
	/****************************************************************************************/
	panic("Not implemented yet");
f0107b67:	83 ec 04             	sub    $0x4,%esp
f0107b6a:	68 38 e5 12 f0       	push   $0xf012e538
f0107b6f:	68 2d 01 00 00       	push   $0x12d
f0107b74:	68 76 e4 12 f0       	push   $0xf012e476
f0107b79:	e8 31 93 ff ff       	call   f0100eaf <_panic>

f0107b7e <fos_scheduler_PRIRR>:

//=============================
// [10] PRIORITY RR Scheduler:
//=============================
struct Env* fos_scheduler_PRIRR()
{
f0107b7e:	55                   	push   %ebp
f0107b7f:	89 e5                	mov    %esp,%ebp
f0107b81:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f0107b84:	83 ec 0c             	sub    $0xc,%esp
f0107b87:	68 20 e7 83 f0       	push   $0xf083e720
f0107b8c:	e8 3f 84 00 00       	call   f010ffd0 <holding_kspinlock>
f0107b91:	83 c4 10             	add    $0x10,%esp
f0107b94:	85 c0                	test   %eax,%eax
f0107b96:	75 17                	jne    f0107baf <fos_scheduler_PRIRR+0x31>
		panic("fos_scheduler_PRIRR: q.lock is not held by this CPU while it's expected to be.");
f0107b98:	83 ec 04             	sub    $0x4,%esp
f0107b9b:	68 68 e6 12 f0       	push   $0xf012e668
f0107ba0:	68 37 01 00 00       	push   $0x137
f0107ba5:	68 76 e4 12 f0       	push   $0xf012e476
f0107baa:	e8 00 93 ff ff       	call   f0100eaf <_panic>
	/****************************************************************************************/
	//TODO: [PROJECT'25.IM#4] CPU SCHEDULING - #3 fos_scheduler_PRIRR
	//Your code is here
	//Comment the following line
	panic("fos_scheduler_PRIRR() is not implemented yet...!!");
f0107baf:	83 ec 04             	sub    $0x4,%esp
f0107bb2:	68 b8 e6 12 f0       	push   $0xf012e6b8
f0107bb7:	68 3c 01 00 00       	push   $0x13c
f0107bbc:	68 76 e4 12 f0       	push   $0xf012e476
f0107bc1:	e8 e9 92 ff ff       	call   f0100eaf <_panic>

f0107bc6 <clock_interrupt_handler>:
//========================================
// [11] Clock Interrupt Handler
//	  (Automatically Called Every Quantum)
//========================================
void clock_interrupt_handler(struct Trapframe* tf)
{
f0107bc6:	55                   	push   %ebp
f0107bc7:	89 e5                	mov    %esp,%ebp
f0107bc9:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodPRIRR())
f0107bcc:	e8 ff fa ff ff       	call   f01076d0 <isSchedMethodPRIRR>
f0107bd1:	85 c0                	test   %eax,%eax
f0107bd3:	74 17                	je     f0107bec <clock_interrupt_handler+0x26>
	{
		//TODO: [PROJECT'25.IM#4] CPU SCHEDULING - #4 clock_interrupt_handler
		//Your code is here
		//Comment the following line
		panic("clock_interrupt_handler() is not implemented yet...!!");
f0107bd5:	83 ec 04             	sub    $0x4,%esp
f0107bd8:	68 ec e6 12 f0       	push   $0xf012e6ec
f0107bdd:	68 4a 01 00 00       	push   $0x14a
f0107be2:	68 76 e4 12 f0       	push   $0xf012e476
f0107be7:	e8 c3 92 ff ff       	call   f0100eaf <_panic>


	}

	/********DON'T CHANGE THESE LINES***********/
	ticks++ ;
f0107bec:	a1 28 6c 85 f0       	mov    0xf0856c28,%eax
f0107bf1:	8b 15 2c 6c 85 f0    	mov    0xf0856c2c,%edx
f0107bf7:	83 c0 01             	add    $0x1,%eax
f0107bfa:	83 d2 00             	adc    $0x0,%edx
f0107bfd:	a3 28 6c 85 f0       	mov    %eax,0xf0856c28
f0107c02:	89 15 2c 6c 85 f0    	mov    %edx,0xf0856c2c
	struct Env* p = get_cpu_proc();
f0107c08:	e8 0b 3e 00 00       	call   f010ba18 <get_cpu_proc>
f0107c0d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (p == NULL)
f0107c10:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0107c14:	74 30                	je     f0107c46 <clock_interrupt_handler+0x80>
//		cprintf("scheduler status = %d\n", mycpu()->scheduler_status) ;
		//panic("clock_interrupt_handler: no running process at the cpu! unexpected clock interrupt in the kernel!");
	}
	else
	{
		p->nClocks++ ;
f0107c16:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107c19:	8b 80 c0 05 00 00    	mov    0x5c0(%eax),%eax
f0107c1f:	8d 50 01             	lea    0x1(%eax),%edx
f0107c22:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107c25:	89 90 c0 05 00 00    	mov    %edx,0x5c0(%eax)
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f0107c2b:	83 ec 0c             	sub    $0xc,%esp
f0107c2e:	6a 01                	push   $0x1
f0107c30:	e8 ee 7b 00 00       	call   f010f823 <isPageReplacmentAlgorithmLRU>
f0107c35:	83 c4 10             	add    $0x10,%esp
f0107c38:	85 c0                	test   %eax,%eax
f0107c3a:	74 05                	je     f0107c41 <clock_interrupt_handler+0x7b>
		{
			update_WS_time_stamps();
f0107c3c:	e8 08 00 00 00       	call   f0107c49 <update_WS_time_stamps>
		}
		//cprintf("\n***************\nClock Handler\n***************\n") ;
		//fos_scheduler();
		yield();
f0107c41:	e8 ed 3e 00 00       	call   f010bb33 <yield>
	}
	/*****************************************/
}
f0107c46:	90                   	nop
f0107c47:	c9                   	leave  
f0107c48:	c3                   	ret    

f0107c49 <update_WS_time_stamps>:
//===================================================================
// [9] Update LRU Timestamp of WS Elements
//	  (Automatically Called Every Quantum in case of LRU Time Approx)
//===================================================================
void update_WS_time_stamps()
{
f0107c49:	55                   	push   %ebp
f0107c4a:	89 e5                	mov    %esp,%ebp
f0107c4c:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#6] FAULT HANDLER II - #1 update_WS_time_stamps
	//Your code is here
	//Comment the following line
	panic("update_WS_time_stamps is not implemented yet...!!");
f0107c4f:	83 ec 04             	sub    $0x4,%esp
f0107c52:	68 24 e7 12 f0       	push   $0xf012e724
f0107c57:	68 72 01 00 00       	push   $0x172
f0107c5c:	68 76 e4 12 f0       	push   $0xf012e476
f0107c61:	e8 49 92 ff ff       	call   f0100eaf <_panic>

f0107c66 <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
f0107c66:	55                   	push   %ebp
f0107c67:	89 e5                	mov    %esp,%ebp
f0107c69:	83 ec 58             	sub    $0x58,%esp
	didinit = 1;
f0107c6c:	c7 05 8c 5b 81 f0 01 	movl   $0x1,0xf0815b8c
f0107c73:	00 00 00 
f0107c76:	c7 45 f4 21 00 00 00 	movl   $0x21,-0xc(%ebp)
f0107c7d:	c6 45 b2 ff          	movb   $0xff,-0x4e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0107c81:	8a 45 b2             	mov    -0x4e(%ebp),%al
f0107c84:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107c87:	ee                   	out    %al,(%dx)
f0107c88:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%ebp)
f0107c8f:	c6 45 b3 ff          	movb   $0xff,-0x4d(%ebp)
f0107c93:	8a 45 b3             	mov    -0x4d(%ebp),%al
f0107c96:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107c99:	ee                   	out    %al,(%dx)
f0107c9a:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%ebp)
f0107ca1:	c6 45 b4 11          	movb   $0x11,-0x4c(%ebp)
f0107ca5:	8a 45 b4             	mov    -0x4c(%ebp),%al
f0107ca8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0107cab:	ee                   	out    %al,(%dx)
f0107cac:	c7 45 e8 21 00 00 00 	movl   $0x21,-0x18(%ebp)
f0107cb3:	c6 45 b5 20          	movb   $0x20,-0x4b(%ebp)
f0107cb7:	8a 45 b5             	mov    -0x4b(%ebp),%al
f0107cba:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107cbd:	ee                   	out    %al,(%dx)
f0107cbe:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%ebp)
f0107cc5:	c6 45 b6 04          	movb   $0x4,-0x4a(%ebp)
f0107cc9:	8a 45 b6             	mov    -0x4a(%ebp),%al
f0107ccc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0107ccf:	ee                   	out    %al,(%dx)
f0107cd0:	c7 45 e0 21 00 00 00 	movl   $0x21,-0x20(%ebp)
f0107cd7:	c6 45 b7 03          	movb   $0x3,-0x49(%ebp)
f0107cdb:	8a 45 b7             	mov    -0x49(%ebp),%al
f0107cde:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0107ce1:	ee                   	out    %al,(%dx)
f0107ce2:	c7 45 dc a0 00 00 00 	movl   $0xa0,-0x24(%ebp)
f0107ce9:	c6 45 b8 11          	movb   $0x11,-0x48(%ebp)
f0107ced:	8a 45 b8             	mov    -0x48(%ebp),%al
f0107cf0:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0107cf3:	ee                   	out    %al,(%dx)
f0107cf4:	c7 45 d8 a1 00 00 00 	movl   $0xa1,-0x28(%ebp)
f0107cfb:	c6 45 b9 28          	movb   $0x28,-0x47(%ebp)
f0107cff:	8a 45 b9             	mov    -0x47(%ebp),%al
f0107d02:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0107d05:	ee                   	out    %al,(%dx)
f0107d06:	c7 45 d4 a1 00 00 00 	movl   $0xa1,-0x2c(%ebp)
f0107d0d:	c6 45 ba 02          	movb   $0x2,-0x46(%ebp)
f0107d11:	8a 45 ba             	mov    -0x46(%ebp),%al
f0107d14:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0107d17:	ee                   	out    %al,(%dx)
f0107d18:	c7 45 d0 a1 00 00 00 	movl   $0xa1,-0x30(%ebp)
f0107d1f:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
f0107d23:	8a 45 bb             	mov    -0x45(%ebp),%al
f0107d26:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0107d29:	ee                   	out    %al,(%dx)
f0107d2a:	c7 45 cc 20 00 00 00 	movl   $0x20,-0x34(%ebp)
f0107d31:	c6 45 bc 68          	movb   $0x68,-0x44(%ebp)
f0107d35:	8a 45 bc             	mov    -0x44(%ebp),%al
f0107d38:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0107d3b:	ee                   	out    %al,(%dx)
f0107d3c:	c7 45 c8 20 00 00 00 	movl   $0x20,-0x38(%ebp)
f0107d43:	c6 45 bd 0a          	movb   $0xa,-0x43(%ebp)
f0107d47:	8a 45 bd             	mov    -0x43(%ebp),%al
f0107d4a:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0107d4d:	ee                   	out    %al,(%dx)
f0107d4e:	c7 45 c4 a0 00 00 00 	movl   $0xa0,-0x3c(%ebp)
f0107d55:	c6 45 be 68          	movb   $0x68,-0x42(%ebp)
f0107d59:	8a 45 be             	mov    -0x42(%ebp),%al
f0107d5c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0107d5f:	ee                   	out    %al,(%dx)
f0107d60:	c7 45 c0 a0 00 00 00 	movl   $0xa0,-0x40(%ebp)
f0107d67:	c6 45 bf 0a          	movb   $0xa,-0x41(%ebp)
f0107d6b:	8a 45 bf             	mov    -0x41(%ebp),%al
f0107d6e:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0107d71:	ee                   	out    %al,(%dx)
	outb(PIC1_CMD, 0x0a);             /* read IRR by default */

	outb(PIC2_CMD, 0x68);               /* OCW3 */
	outb(PIC2_CMD, 0x0a);               /* OCW3 */

	if (irq_init_mask_8259A != 0xFFFF)
f0107d72:	66 a1 bc fb 17 f0    	mov    0xf017fbbc,%ax
f0107d78:	66 83 f8 ff          	cmp    $0xffff,%ax
f0107d7c:	74 15                	je     f0107d93 <pic_init+0x12d>
		irq_setmask_8259A(irq_init_mask_8259A);
f0107d7e:	66 a1 bc fb 17 f0    	mov    0xf017fbbc,%ax
f0107d84:	0f b7 c0             	movzwl %ax,%eax
f0107d87:	83 ec 0c             	sub    $0xc,%esp
f0107d8a:	50                   	push   %eax
f0107d8b:	e8 06 00 00 00       	call   f0107d96 <irq_setmask_8259A>
f0107d90:	83 c4 10             	add    $0x10,%esp
}
f0107d93:	90                   	nop
f0107d94:	c9                   	leave  
f0107d95:	c3                   	ret    

f0107d96 <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16 mask)
{
f0107d96:	55                   	push   %ebp
f0107d97:	89 e5                	mov    %esp,%ebp
f0107d99:	83 ec 14             	sub    $0x14,%esp
f0107d9c:	8b 45 08             	mov    0x8(%ebp),%eax
f0107d9f:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	 * We then use the new functions irq_set_mask() and irq_clear_mask()
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
f0107da3:	a1 8c 5b 81 f0       	mov    0xf0815b8c,%eax
f0107da8:	85 c0                	test   %eax,%eax
f0107daa:	74 34                	je     f0107de0 <irq_setmask_8259A+0x4a>
		return;

	outb(PIC1_DATA, (char)mask);
f0107dac:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107daf:	0f b6 c0             	movzbl %al,%eax
f0107db2:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%ebp)
f0107db9:	88 45 f6             	mov    %al,-0xa(%ebp)
f0107dbc:	8a 45 f6             	mov    -0xa(%ebp),%al
f0107dbf:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0107dc2:	ee                   	out    %al,(%dx)
	outb(PIC2_DATA, (char)(mask >> 8));
f0107dc3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107dc6:	66 c1 e8 08          	shr    $0x8,%ax
f0107dca:	0f b6 c0             	movzbl %al,%eax
f0107dcd:	c7 45 f8 a1 00 00 00 	movl   $0xa1,-0x8(%ebp)
f0107dd4:	88 45 f7             	mov    %al,-0x9(%ebp)
f0107dd7:	8a 45 f7             	mov    -0x9(%ebp),%al
f0107dda:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0107ddd:	ee                   	out    %al,(%dx)
f0107dde:	eb 01                	jmp    f0107de1 <irq_setmask_8259A+0x4b>
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
		return;
f0107de0:	90                   	nop
	//cprintf("enabled interrupts:");
	//for (int i = 0; i < 16; i++)
	//if (~mask & (1<<i))
	//cprintf(" %d", i);
	//cprintf("\n");
}
f0107de1:	c9                   	leave  
f0107de2:	c3                   	ret    

f0107de3 <irq_set_mask>:

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
f0107de3:	55                   	push   %ebp
f0107de4:	89 e5                	mov    %esp,%ebp
f0107de6:	53                   	push   %ebx
f0107de7:	83 ec 14             	sub    $0x14,%esp
f0107dea:	8b 45 08             	mov    0x8(%ebp),%eax
f0107ded:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0107df0:	a1 8c 5b 81 f0       	mov    0xf0815b8c,%eax
f0107df5:	85 c0                	test   %eax,%eax
f0107df7:	74 58                	je     f0107e51 <irq_set_mask+0x6e>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0107df9:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0107dfd:	77 08                	ja     f0107e07 <irq_set_mask+0x24>
		port = PIC1_DATA;
f0107dff:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0107e05:	eb 0a                	jmp    f0107e11 <irq_set_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0107e07:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0107e0d:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) | (1 << IRQline);
f0107e11:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0107e15:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0107e18:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e1b:	89 c2                	mov    %eax,%edx
f0107e1d:	ec                   	in     (%dx),%al
f0107e1e:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0107e21:	8a 45 ee             	mov    -0x12(%ebp),%al
f0107e24:	88 c2                	mov    %al,%dl
f0107e26:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0107e2a:	bb 01 00 00 00       	mov    $0x1,%ebx
f0107e2f:	88 c1                	mov    %al,%cl
f0107e31:	d3 e3                	shl    %cl,%ebx
f0107e33:	89 d8                	mov    %ebx,%eax
f0107e35:	09 d0                	or     %edx,%eax
f0107e37:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0107e3a:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0107e3e:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0107e42:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0107e45:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0107e48:	8a 45 ef             	mov    -0x11(%ebp),%al
f0107e4b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107e4e:	ee                   	out    %al,(%dx)
f0107e4f:	eb 01                	jmp    f0107e52 <irq_set_mask+0x6f>

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0107e51:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) | (1 << IRQline);
	outb(port, value);
}
f0107e52:	83 c4 14             	add    $0x14,%esp
f0107e55:	5b                   	pop    %ebx
f0107e56:	5d                   	pop    %ebp
f0107e57:	c3                   	ret    

f0107e58 <irq_clear_mask>:

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
f0107e58:	55                   	push   %ebp
f0107e59:	89 e5                	mov    %esp,%ebp
f0107e5b:	53                   	push   %ebx
f0107e5c:	83 ec 14             	sub    $0x14,%esp
f0107e5f:	8b 45 08             	mov    0x8(%ebp),%eax
f0107e62:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0107e65:	a1 8c 5b 81 f0       	mov    0xf0815b8c,%eax
f0107e6a:	85 c0                	test   %eax,%eax
f0107e6c:	74 5a                	je     f0107ec8 <irq_clear_mask+0x70>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0107e6e:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0107e72:	77 08                	ja     f0107e7c <irq_clear_mask+0x24>
		port = PIC1_DATA;
f0107e74:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0107e7a:	eb 0a                	jmp    f0107e86 <irq_clear_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0107e7c:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0107e82:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & ~(1 << IRQline);
f0107e86:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0107e8a:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0107e8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107e90:	89 c2                	mov    %eax,%edx
f0107e92:	ec                   	in     (%dx),%al
f0107e93:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0107e96:	8a 45 ee             	mov    -0x12(%ebp),%al
f0107e99:	88 c2                	mov    %al,%dl
f0107e9b:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0107e9f:	bb 01 00 00 00       	mov    $0x1,%ebx
f0107ea4:	88 c1                	mov    %al,%cl
f0107ea6:	d3 e3                	shl    %cl,%ebx
f0107ea8:	89 d8                	mov    %ebx,%eax
f0107eaa:	f7 d0                	not    %eax
f0107eac:	21 d0                	and    %edx,%eax
f0107eae:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0107eb1:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0107eb5:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0107eb9:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0107ebc:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0107ebf:	8a 45 ef             	mov    -0x11(%ebp),%al
f0107ec2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107ec5:	ee                   	out    %al,(%dx)
f0107ec6:	eb 01                	jmp    f0107ec9 <irq_clear_mask+0x71>

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0107ec8:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) & ~(1 << IRQline);
	outb(port, value);
}
f0107ec9:	83 c4 14             	add    $0x14,%esp
f0107ecc:	5b                   	pop    %ebx
f0107ecd:	5d                   	pop    %ebp
f0107ece:	c3                   	ret    

f0107ecf <irq_get_mask>:


int irq_get_mask(uint8 IRQline)
{
f0107ecf:	55                   	push   %ebp
f0107ed0:	89 e5                	mov    %esp,%ebp
f0107ed2:	53                   	push   %ebx
f0107ed3:	83 ec 14             	sub    $0x14,%esp
f0107ed6:	8b 45 08             	mov    0x8(%ebp),%eax
f0107ed9:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0107edc:	a1 8c 5b 81 f0       	mov    0xf0815b8c,%eax
f0107ee1:	85 c0                	test   %eax,%eax
f0107ee3:	75 07                	jne    f0107eec <irq_get_mask+0x1d>
		return -1;
f0107ee5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0107eea:	eb 45                	jmp    f0107f31 <irq_get_mask+0x62>

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0107eec:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0107ef0:	77 08                	ja     f0107efa <irq_get_mask+0x2b>
		port = PIC1_DATA;
f0107ef2:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0107ef8:	eb 0a                	jmp    f0107f04 <irq_get_mask+0x35>
	} else {
		port = PIC2_DATA;
f0107efa:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0107f00:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & (1 << IRQline);
f0107f04:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0107f08:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0107f0b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107f0e:	89 c2                	mov    %eax,%edx
f0107f10:	ec                   	in     (%dx),%al
f0107f11:	88 45 f3             	mov    %al,-0xd(%ebp)
	return data;
f0107f14:	8a 45 f3             	mov    -0xd(%ebp),%al
f0107f17:	88 c2                	mov    %al,%dl
f0107f19:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0107f1d:	bb 01 00 00 00       	mov    $0x1,%ebx
f0107f22:	88 c1                	mov    %al,%cl
f0107f24:	d3 e3                	shl    %cl,%ebx
f0107f26:	89 d8                	mov    %ebx,%eax
f0107f28:	21 d0                	and    %edx,%eax
f0107f2a:	88 45 f9             	mov    %al,-0x7(%ebp)
	return value;
f0107f2d:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
}
f0107f31:	83 c4 14             	add    $0x14,%esp
f0107f34:	5b                   	pop    %ebx
f0107f35:	5d                   	pop    %ebp
f0107f36:	c3                   	ret    

f0107f37 <pic_sendEOI>:
 * If the IRQ came from the Master PIC, it is sufficient to issue this command only to the
 * Master PIC; however if the IRQ came from the Slave PIC, it is necessary to issue the command
 * to both PIC chips.
 */
void pic_sendEOI(uint8 irq)
{
f0107f37:	55                   	push   %ebp
f0107f38:	89 e5                	mov    %esp,%ebp
f0107f3a:	83 ec 14             	sub    $0x14,%esp
f0107f3d:	8b 45 08             	mov    0x8(%ebp),%eax
f0107f40:	88 45 ec             	mov    %al,-0x14(%ebp)
	if(irq >= 8)
f0107f43:	80 7d ec 07          	cmpb   $0x7,-0x14(%ebp)
f0107f47:	76 12                	jbe    f0107f5b <pic_sendEOI+0x24>
f0107f49:	c7 45 f8 a0 00 00 00 	movl   $0xa0,-0x8(%ebp)
f0107f50:	c6 45 f7 20          	movb   $0x20,-0x9(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0107f54:	8a 45 f7             	mov    -0x9(%ebp),%al
f0107f57:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0107f5a:	ee                   	out    %al,(%dx)
f0107f5b:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%ebp)
f0107f62:	c6 45 f6 20          	movb   $0x20,-0xa(%ebp)
f0107f66:	8a 45 f6             	mov    -0xa(%ebp),%al
f0107f69:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0107f6c:	ee                   	out    %al,(%dx)
		outb(PIC2_CMD,PIC_EOI);

	outb(PIC1_CMD,PIC_EOI);
}
f0107f6d:	90                   	nop
f0107f6e:	c9                   	leave  
f0107f6f:	c3                   	ret    

f0107f70 <mycpu>:
extern void idt_init(void);

// Must be called with interrupts disabled to avoid the caller being
// rescheduled between reading lapicid and running through the loop.
struct cpu* mycpu()
{
f0107f70:	55                   	push   %ebp
f0107f71:	89 e5                	mov    %esp,%ebp
	return &CPUS[0]; //main CPU
f0107f73:	b8 00 e9 83 f0       	mov    $0xf083e900,%eax
//  for (i = 0; i < ncpu; ++i) {
//    if (cpus[i].apicid == apicid)
//      return &cpus[i];
//  }
//  panic("unknown apicid\n");
}
f0107f78:	5d                   	pop    %ebp
f0107f79:	c3                   	ret    

f0107f7a <cpu_init>:

// Common CPU setup code.
void cpu_init(int cpuIndx)
{
f0107f7a:	55                   	push   %ebp
f0107f7b:	89 e5                	mov    %esp,%ebp
f0107f7d:	83 ec 28             	sub    $0x28,%esp
  struct cpu* c = mycpu();
f0107f80:	e8 eb ff ff ff       	call   f0107f70 <mycpu>
f0107f85:	89 45 f4             	mov    %eax,-0xc(%ebp)
  c->proc = NULL;
f0107f88:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107f8b:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0107f92:	00 00 00 
  c->ncli = 0;
f0107f95:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107f98:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f0107f9f:	00 00 00 

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0107fa2:	9c                   	pushf  
f0107fa3:	58                   	pop    %eax
f0107fa4:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f0107fa7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  c->intena = read_eflags() & FL_IF ? 1 : 0;
f0107faa:	25 00 02 00 00       	and    $0x200,%eax
f0107faf:	85 c0                	test   %eax,%eax
f0107fb1:	0f 95 c0             	setne  %al
f0107fb4:	0f b6 d0             	movzbl %al,%edx
f0107fb7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107fba:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  //c->apicid = ?? ;

  //Initialize the CPU Context to NULL.
  //to be set later to the correct position on the stack during the
  //first switch from scheduler to the first process
  c->scheduler = NULL ;
f0107fc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107fc3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  c->scheduler_status = SCH_UNINITIALIZED;
f0107fca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107fcd:	c7 80 b4 00 00 00 ff 	movl   $0xffffffff,0xb4(%eax)
f0107fd4:	ff ff ff 

  //Initialize its sched stack
  c->stack = (char*)(KERN_STACK_TOP - (cpuIndx+1)*KERNEL_STACK_SIZE);
f0107fd7:	8b 45 08             	mov    0x8(%ebp),%eax
f0107fda:	f7 d0                	not    %eax
f0107fdc:	c1 e0 0f             	shl    $0xf,%eax
f0107fdf:	2d 00 00 40 10       	sub    $0x10400000,%eax
f0107fe4:	89 c2                	mov    %eax,%edx
f0107fe6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107fe9:	89 50 08             	mov    %edx,0x8(%eax)

  //initialize GDT & set it to this CPU
  seg_init();
f0107fec:	e8 18 01 00 00       	call   f0108109 <seg_init>

  //initialize IDT
  idt_init();       // load idt register
f0107ff1:	e8 01 50 00 00       	call   f010cff7 <idt_init>

  //Initialize the TaskState to ZERO.
  //to be initialized later in init.c
  memset(&(c->ts), 0, sizeof(c->ts)) ;
f0107ff6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ff9:	83 c0 0c             	add    $0xc,%eax
f0107ffc:	83 ec 04             	sub    $0x4,%esp
f0107fff:	6a 68                	push   $0x68
f0108001:	6a 00                	push   $0x0
f0108003:	50                   	push   %eax
f0108004:	e8 60 2c 01 00       	call   f011ac69 <memset>
f0108009:	83 c4 10             	add    $0x10,%esp

  //Indicate it's started
  xchg(&(c->started), 1); // tell startothers() we're up
f010800c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010800f:	05 a4 00 00 00       	add    $0xa4,%eax
f0108014:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108017:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f010801e:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0108021:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108024:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0108027:	f0 87 02             	lock xchg %eax,(%edx)
f010802a:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  //scheduler();     // start running processes
}
f010802d:	90                   	nop
f010802e:	c9                   	leave  
f010802f:	c3                   	ret    

f0108030 <pushcli>:
// Pushcli/popcli are like cli/sti except that they are matched:
// it takes two popcli to undo two pushcli.  Also, if interrupts
// are off, then pushcli, popcli leaves them off.

void pushcli(void)
{
f0108030:	55                   	push   %ebp
f0108031:	89 e5                	mov    %esp,%ebp
f0108033:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0108036:	9c                   	pushf  
f0108037:	58                   	pop    %eax
f0108038:	89 45 f8             	mov    %eax,-0x8(%ebp)
        return eflags;
f010803b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  int eflags = read_eflags();
f010803e:	89 45 fc             	mov    %eax,-0x4(%ebp)
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0108041:	fa                   	cli    
  cli();
  struct cpu* c = mycpu();
f0108042:	e8 29 ff ff ff       	call   f0107f70 <mycpu>
f0108047:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(c->ncli == 0)
f010804a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010804d:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0108053:	85 c0                	test   %eax,%eax
f0108055:	75 13                	jne    f010806a <pushcli+0x3a>
    c->intena = eflags & FL_IF;
f0108057:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010805a:	25 00 02 00 00       	and    $0x200,%eax
f010805f:	89 c2                	mov    %eax,%edx
f0108061:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108064:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  c->ncli += 1;
f010806a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010806d:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0108073:	8d 50 01             	lea    0x1(%eax),%edx
f0108076:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108079:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
}
f010807f:	90                   	nop
f0108080:	c9                   	leave  
f0108081:	c3                   	ret    

f0108082 <popcli>:

void popcli(void)
{
f0108082:	55                   	push   %ebp
f0108083:	89 e5                	mov    %esp,%ebp
f0108085:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0108088:	9c                   	pushf  
f0108089:	58                   	pop    %eax
f010808a:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f010808d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  if(read_eflags()&FL_IF)
f0108090:	25 00 02 00 00       	and    $0x200,%eax
f0108095:	85 c0                	test   %eax,%eax
f0108097:	74 14                	je     f01080ad <popcli+0x2b>
    panic("popcli - interruptible");
f0108099:	83 ec 04             	sub    $0x4,%esp
f010809c:	68 56 e7 12 f0       	push   $0xf012e756
f01080a1:	6a 5e                	push   $0x5e
f01080a3:	68 6d e7 12 f0       	push   $0xf012e76d
f01080a8:	e8 02 8e ff ff       	call   f0100eaf <_panic>
  struct cpu* c = mycpu();
f01080ad:	e8 be fe ff ff       	call   f0107f70 <mycpu>
f01080b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(--c->ncli < 0)
f01080b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01080b8:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f01080be:	8d 50 ff             	lea    -0x1(%eax),%edx
f01080c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01080c4:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
f01080ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01080cd:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f01080d3:	85 c0                	test   %eax,%eax
f01080d5:	79 14                	jns    f01080eb <popcli+0x69>
    panic("popcli");
f01080d7:	83 ec 04             	sub    $0x4,%esp
f01080da:	68 7c e7 12 f0       	push   $0xf012e77c
f01080df:	6a 61                	push   $0x61
f01080e1:	68 6d e7 12 f0       	push   $0xf012e76d
f01080e6:	e8 c4 8d ff ff       	call   f0100eaf <_panic>
  if(c->ncli == 0 && c->intena)
f01080eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01080ee:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f01080f4:	85 c0                	test   %eax,%eax
f01080f6:	75 0e                	jne    f0108106 <popcli+0x84>
f01080f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01080fb:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f0108101:	85 c0                	test   %eax,%eax
f0108103:	74 01                	je     f0108106 <popcli+0x84>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f0108105:	fb                   	sti    
    sti();
}
f0108106:	90                   	nop
f0108107:	c9                   	leave  
f0108108:	c3                   	ret    

f0108109 <seg_init>:

// Set up CPU's kernel segment descriptors.
// Run once on entry on each CPU.
void
seg_init(void)
{
f0108109:	55                   	push   %ebp
f010810a:	89 e5                	mov    %esp,%ebp
f010810c:	83 ec 18             	sub    $0x18,%esp
	// The kernel and user segments are identical(except for the DPL).
	// To load the SS register, the CPL must equal the DPL.  Thus,
	// we must duplicate the segments for the user and the kernel.
	//

	pushcli();	//disable interrupt
f010810f:	e8 1c ff ff ff       	call   f0108030 <pushcli>

	c = mycpu();
f0108114:	e8 57 fe ff ff       	call   f0107f70 <mycpu>
f0108119:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// 0x0 - unused (always faults -- for trapping NULL far pointers)
	c->gdt[0] = SEG_NULL;
f010811c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010811f:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
f0108126:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

	// 0x8 - kernel code segment
	c->gdt[GD_KT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 0);
f010812d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108130:	66 c7 40 7c ff ff    	movw   $0xffff,0x7c(%eax)
f0108136:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108139:	66 c7 40 7e 00 00    	movw   $0x0,0x7e(%eax)
f010813f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108142:	c6 80 80 00 00 00 00 	movb   $0x0,0x80(%eax)
f0108149:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010814c:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0108152:	83 e2 f0             	and    $0xfffffff0,%edx
f0108155:	83 ca 0a             	or     $0xa,%edx
f0108158:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f010815e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108161:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0108167:	83 ca 10             	or     $0x10,%edx
f010816a:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0108170:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108173:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0108179:	83 e2 9f             	and    $0xffffff9f,%edx
f010817c:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0108182:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108185:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f010818b:	83 ca 80             	or     $0xffffff80,%edx
f010818e:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0108194:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108197:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f010819d:	83 ca 0f             	or     $0xf,%edx
f01081a0:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f01081a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01081a9:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f01081af:	83 e2 ef             	and    $0xffffffef,%edx
f01081b2:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f01081b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01081bb:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f01081c1:	83 e2 df             	and    $0xffffffdf,%edx
f01081c4:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f01081ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01081cd:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f01081d3:	83 ca 40             	or     $0x40,%edx
f01081d6:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f01081dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01081df:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f01081e5:	83 ca 80             	or     $0xffffff80,%edx
f01081e8:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f01081ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01081f1:	c6 80 83 00 00 00 00 	movb   $0x0,0x83(%eax)

	// 0x10 - kernel data segment
	c->gdt[GD_KD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 0);
f01081f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01081fb:	66 c7 80 84 00 00 00 	movw   $0xffff,0x84(%eax)
f0108202:	ff ff 
f0108204:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108207:	66 c7 80 86 00 00 00 	movw   $0x0,0x86(%eax)
f010820e:	00 00 
f0108210:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108213:	c6 80 88 00 00 00 00 	movb   $0x0,0x88(%eax)
f010821a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010821d:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f0108223:	83 e2 f0             	and    $0xfffffff0,%edx
f0108226:	83 ca 02             	or     $0x2,%edx
f0108229:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f010822f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108232:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f0108238:	83 ca 10             	or     $0x10,%edx
f010823b:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0108241:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108244:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f010824a:	83 e2 9f             	and    $0xffffff9f,%edx
f010824d:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0108253:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108256:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f010825c:	83 ca 80             	or     $0xffffff80,%edx
f010825f:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0108265:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108268:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f010826e:	83 ca 0f             	or     $0xf,%edx
f0108271:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0108277:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010827a:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0108280:	83 e2 ef             	and    $0xffffffef,%edx
f0108283:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0108289:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010828c:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0108292:	83 e2 df             	and    $0xffffffdf,%edx
f0108295:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010829b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010829e:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f01082a4:	83 ca 40             	or     $0x40,%edx
f01082a7:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f01082ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01082b0:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f01082b6:	83 ca 80             	or     $0xffffff80,%edx
f01082b9:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f01082bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01082c2:	c6 80 8b 00 00 00 00 	movb   $0x0,0x8b(%eax)

	// 0x18 - user code segment
	c->gdt[GD_UT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 3);
f01082c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01082cc:	66 c7 80 8c 00 00 00 	movw   $0xffff,0x8c(%eax)
f01082d3:	ff ff 
f01082d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01082d8:	66 c7 80 8e 00 00 00 	movw   $0x0,0x8e(%eax)
f01082df:	00 00 
f01082e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01082e4:	c6 80 90 00 00 00 00 	movb   $0x0,0x90(%eax)
f01082eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01082ee:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01082f4:	83 e2 f0             	and    $0xfffffff0,%edx
f01082f7:	83 ca 0a             	or     $0xa,%edx
f01082fa:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f0108300:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108303:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f0108309:	83 ca 10             	or     $0x10,%edx
f010830c:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f0108312:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108315:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f010831b:	83 ca 60             	or     $0x60,%edx
f010831e:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f0108324:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108327:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f010832d:	83 ca 80             	or     $0xffffff80,%edx
f0108330:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f0108336:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108339:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f010833f:	83 ca 0f             	or     $0xf,%edx
f0108342:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f0108348:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010834b:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0108351:	83 e2 ef             	and    $0xffffffef,%edx
f0108354:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010835a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010835d:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0108363:	83 e2 df             	and    $0xffffffdf,%edx
f0108366:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010836c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010836f:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0108375:	83 ca 40             	or     $0x40,%edx
f0108378:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010837e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108381:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0108387:	83 ca 80             	or     $0xffffff80,%edx
f010838a:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f0108390:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108393:	c6 80 93 00 00 00 00 	movb   $0x0,0x93(%eax)

	// 0x20 - user data segment
	c->gdt[GD_UD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 3);
f010839a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010839d:	66 c7 80 94 00 00 00 	movw   $0xffff,0x94(%eax)
f01083a4:	ff ff 
f01083a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01083a9:	66 c7 80 96 00 00 00 	movw   $0x0,0x96(%eax)
f01083b0:	00 00 
f01083b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01083b5:	c6 80 98 00 00 00 00 	movb   $0x0,0x98(%eax)
f01083bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01083bf:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f01083c5:	83 e2 f0             	and    $0xfffffff0,%edx
f01083c8:	83 ca 02             	or     $0x2,%edx
f01083cb:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f01083d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01083d4:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f01083da:	83 ca 10             	or     $0x10,%edx
f01083dd:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f01083e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01083e6:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f01083ec:	83 ca 60             	or     $0x60,%edx
f01083ef:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f01083f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01083f8:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f01083fe:	83 ca 80             	or     $0xffffff80,%edx
f0108401:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0108407:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010840a:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0108410:	83 ca 0f             	or     $0xf,%edx
f0108413:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0108419:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010841c:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0108422:	83 e2 ef             	and    $0xffffffef,%edx
f0108425:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f010842b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010842e:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0108434:	83 e2 df             	and    $0xffffffdf,%edx
f0108437:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f010843d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108440:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0108446:	83 ca 40             	or     $0x40,%edx
f0108449:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f010844f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108452:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0108458:	83 ca 80             	or     $0xffffff80,%edx
f010845b:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0108461:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108464:	c6 80 9b 00 00 00 00 	movb   $0x0,0x9b(%eax)

	// 0x28 - tss, initialized in idt_init()
	c->gdt[GD_TSS >> 3] = SEG_NULL;
f010846b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010846e:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
f0108475:	00 00 00 
f0108478:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f010847f:	00 00 00 

	popcli();	//enable interrupt
f0108482:	e8 fb fb ff ff       	call   f0108082 <popcli>


}
f0108487:	90                   	nop
f0108488:	c9                   	leave  
f0108489:	c3                   	ret    

f010848a <initialize_kernel_VM>:
//
// From USER_TOP to USER_LIMIT, the user is allowed to read but not write.
// Above USER_LIMIT the user cannot read (or write).

void initialize_kernel_VM()
{
f010848a:	55                   	push   %ebp
f010848b:	89 e5                	mov    %esp,%ebp
f010848d:	83 ec 38             	sub    $0x38,%esp
	//panic("initialize_kernel_VM: This function is not finished\n");

	//////////////////////////////////////////////////////////////////////
	// create initial page directory.

	ptr_page_directory = boot_allocate_space(PAGE_SIZE, PAGE_SIZE);
f0108490:	83 ec 08             	sub    $0x8,%esp
f0108493:	68 00 10 00 00       	push   $0x1000
f0108498:	68 00 10 00 00       	push   $0x1000
f010849d:	e8 43 02 00 00       	call   f01086e5 <boot_allocate_space>
f01084a2:	83 c4 10             	add    $0x10,%esp
f01084a5:	a3 d8 6c 85 f0       	mov    %eax,0xf0856cd8
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(ptr_page_directory, 0, PAGE_SIZE);
	phys_page_directory = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f01084aa:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01084af:	89 45 e0             	mov    %eax,-0x20(%ebp)
f01084b2:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f01084b9:	77 14                	ja     f01084cf <initialize_kernel_VM+0x45>
f01084bb:	ff 75 e0             	pushl  -0x20(%ebp)
f01084be:	68 84 e7 12 f0       	push   $0xf012e784
f01084c3:	6a 57                	push   $0x57
f01084c5:	68 b8 e7 12 f0       	push   $0xf012e7b8
f01084ca:	e8 e0 89 ff ff       	call   f0100eaf <_panic>
f01084cf:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01084d2:	05 00 00 00 10       	add    $0x10000000,%eax
f01084d7:	a3 e0 6d 85 f0       	mov    %eax,0xf0856de0
	// Your code goes here:

	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
f01084dc:	c7 45 dc 00 70 17 f0 	movl   $0xf0177000,-0x24(%ebp)
f01084e3:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f01084ea:	77 14                	ja     f0108500 <initialize_kernel_VM+0x76>
f01084ec:	ff 75 dc             	pushl  -0x24(%ebp)
f01084ef:	68 84 e7 12 f0       	push   $0xf012e784
f01084f4:	6a 63                	push   $0x63
f01084f6:	68 b8 e7 12 f0       	push   $0xf012e7b8
f01084fb:	e8 af 89 ff ff       	call   f0100eaf <_panic>
f0108500:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108503:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0108509:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f010850e:	83 ec 0c             	sub    $0xc,%esp
f0108511:	6a 02                	push   $0x2
f0108513:	52                   	push   %edx
f0108514:	68 00 80 00 00       	push   $0x8000
f0108519:	68 00 80 bf ef       	push   $0xefbf8000
f010851e:	50                   	push   %eax
f010851f:	e8 35 02 00 00       	call   f0108759 <boot_map_range>
f0108524:	83 c4 20             	add    $0x20,%esp
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f0108527:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010852e:	eb 24                	jmp    f0108554 <initialize_kernel_VM+0xca>
	{
		pt_set_page_permissions(ptr_page_directory, KERN_STACK_TOP - ((c+1)*KERNEL_STACK_SIZE), 0, PERM_PRESENT);
f0108530:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108533:	f7 d0                	not    %eax
f0108535:	c1 e0 0f             	shl    $0xf,%eax
f0108538:	8d 90 00 00 c0 ef    	lea    -0x10400000(%eax),%edx
f010853e:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0108543:	6a 01                	push   $0x1
f0108545:	6a 00                	push   $0x0
f0108547:	52                   	push   %edx
f0108548:	50                   	push   %eax
f0108549:	e8 b1 16 00 00       	call   f0109bff <pt_set_page_permissions>
f010854e:	83 c4 10             	add    $0x10,%esp
	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f0108551:	ff 45 f4             	incl   -0xc(%ebp)
f0108554:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108558:	7e d6                	jle    f0108530 <initialize_kernel_VM+0xa6>
	// Permissions: kernel RW, user NONE
	// Your code goes here:

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
f010855a:	c7 45 e8 00 00 00 f0 	movl   $0xf0000000,-0x18(%ebp)
f0108561:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	unsigned int nTables=0;
f0108568:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f010856f:	eb 25                	jmp    f0108596 <initialize_kernel_VM+0x10c>
	{
		++nTables;
f0108571:	ff 45 e4             	incl   -0x1c(%ebp)
		boot_get_page_table(ptr_page_directory, (uint32)sva, 1);
f0108574:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0108577:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f010857c:	83 ec 04             	sub    $0x4,%esp
f010857f:	6a 01                	push   $0x1
f0108581:	52                   	push   %edx
f0108582:	50                   	push   %eax
f0108583:	e8 45 02 00 00       	call   f01087cd <boot_get_page_table>
f0108588:	83 c4 10             	add    $0x10,%esp

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
	unsigned int nTables=0;
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f010858b:	81 45 e8 00 00 40 00 	addl   $0x400000,-0x18(%ebp)
f0108592:	83 55 ec 00          	adcl   $0x0,-0x14(%ebp)
f0108596:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010859a:	72 d5                	jb     f0108571 <initialize_kernel_VM+0xe7>
f010859c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01085a0:	77 06                	ja     f01085a8 <initialize_kernel_VM+0x11e>
f01085a2:	83 7d e8 fe          	cmpl   $0xfffffffe,-0x18(%ebp)
f01085a6:	76 c9                	jbe    f0108571 <initialize_kernel_VM+0xe7>
	//    - frames_info -- kernel RW, user NONE
	//    - the image mapped at READ_ONLY_FRAMES_INFO  -- kernel R, user R
	// Your code goes here:
	//cprintf("size of WorkingSetPage = %d\n",sizeof(struct WorkingSetPage));
	uint32 array_size;
	array_size = number_of_frames * sizeof(struct FrameInfo) ;
f01085a8:	8b 15 b8 e9 83 f0    	mov    0xf083e9b8,%edx
f01085ae:	89 d0                	mov    %edx,%eax
f01085b0:	c1 e0 02             	shl    $0x2,%eax
f01085b3:	01 d0                	add    %edx,%eax
f01085b5:	c1 e0 02             	shl    $0x2,%eax
f01085b8:	89 45 d8             	mov    %eax,-0x28(%ebp)
	frames_info = boot_allocate_space(array_size, PAGE_SIZE);
f01085bb:	83 ec 08             	sub    $0x8,%esp
f01085be:	68 00 10 00 00       	push   $0x1000
f01085c3:	ff 75 d8             	pushl  -0x28(%ebp)
f01085c6:	e8 1a 01 00 00       	call   f01086e5 <boot_allocate_space>
f01085cb:	83 c4 10             	add    $0x10,%esp
f01085ce:	a3 08 6b 85 f0       	mov    %eax,0xf0856b08
	//2016: Not valid any more since the RAM size exceed the 64 MB limit. This lead to the
	// 		size of "frames_info" can exceed the 4 MB space for "READ_ONLY_FRAMES_INFO"
	//boot_map_range(ptr_page_directory, READ_ONLY_FRAMES_INFO, array_size, STATIC_KERNEL_PHYSICAL_ADDRESS(frames_info),PERM_USER) ;


	uint32 disk_array_size = PAGES_PER_FILE * sizeof(struct FrameInfo);
f01085d3:	c7 45 d4 00 a0 28 00 	movl   $0x28a000,-0x2c(%ebp)
	disk_frames_info = boot_allocate_space(disk_array_size , PAGE_SIZE);
f01085da:	83 ec 08             	sub    $0x8,%esp
f01085dd:	68 00 10 00 00       	push   $0x1000
f01085e2:	ff 75 d4             	pushl  -0x2c(%ebp)
f01085e5:	e8 fb 00 00 00       	call   f01086e5 <boot_allocate_space>
f01085ea:	83 c4 10             	add    $0x10,%esp
f01085ed:	a3 44 e5 83 f0       	mov    %eax,0xf083e544
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(disk_frames_info , 0, disk_array_size);

	// This allows the kernel & user to access any page table entry using a
	// specified VA for each: VPT for kernel and UVPT for User.
	setup_listing_to_all_page_tables_entries();
f01085f2:	e8 05 05 00 00       	call   f0108afc <setup_listing_to_all_page_tables_entries>
	// Permissions:
	//    - envs itself -- kernel RW, user NONE
	//    - the image of envs mapped at UENVS  -- kernel R, user R

	// LAB 3: Your code here.
	cprintf("*	Max Envs = %d, Nearest Pow of 2 = %d\n",NENV, NEARPOW2NENV);
f01085f7:	83 ec 0c             	sub    $0xc,%esp
f01085fa:	68 c6 02 00 00       	push   $0x2c6
f01085ff:	e8 17 05 01 00       	call   f0118b1b <nearest_pow2_ceil>
f0108604:	83 c4 10             	add    $0x10,%esp
f0108607:	83 ec 04             	sub    $0x4,%esp
f010860a:	50                   	push   %eax
f010860b:	68 c6 02 00 00       	push   $0x2c6
f0108610:	68 d8 e7 12 f0       	push   $0xf012e7d8
f0108615:	e8 42 95 ff ff       	call   f0101b5c <cprintf>
f010861a:	83 c4 10             	add    $0x10,%esp
	int envs_size = NENV * sizeof(struct Env) ;
f010861d:	c7 45 d0 98 fd 0f 00 	movl   $0xffd98,-0x30(%ebp)

	//allocate space for "envs" array aligned on 4KB boundary
	envs = boot_allocate_space(envs_size, PAGE_SIZE);
f0108624:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0108627:	83 ec 08             	sub    $0x8,%esp
f010862a:	68 00 10 00 00       	push   $0x1000
f010862f:	50                   	push   %eax
f0108630:	e8 b0 00 00 00       	call   f01086e5 <boot_allocate_space>
f0108635:	83 c4 10             	add    $0x10,%esp
f0108638:	a3 90 5b 81 f0       	mov    %eax,0xf0815b90
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(envs , 0, envs_size);

	//make the user to access this array by mapping it to UPAGES linear address (UPAGES is in User/Kernel space)
	boot_map_range(ptr_page_directory, UENVS, envs_size, STATIC_KERNEL_PHYSICAL_ADDRESS(envs), PERM_USER) ;
f010863d:	a1 90 5b 81 f0       	mov    0xf0815b90,%eax
f0108642:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0108645:	81 7d cc ff ff ff ef 	cmpl   $0xefffffff,-0x34(%ebp)
f010864c:	77 17                	ja     f0108665 <initialize_kernel_VM+0x1db>
f010864e:	ff 75 cc             	pushl  -0x34(%ebp)
f0108651:	68 84 e7 12 f0       	push   $0xf012e784
f0108656:	68 b1 00 00 00       	push   $0xb1
f010865b:	68 b8 e7 12 f0       	push   $0xf012e7b8
f0108660:	e8 4a 88 ff ff       	call   f0100eaf <_panic>
f0108665:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0108668:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f010866e:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0108671:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0108676:	83 ec 0c             	sub    $0xc,%esp
f0108679:	6a 04                	push   $0x4
f010867b:	51                   	push   %ecx
f010867c:	52                   	push   %edx
f010867d:	68 00 00 c0 ee       	push   $0xeec00000
f0108682:	50                   	push   %eax
f0108683:	e8 d1 00 00 00       	call   f0108759 <boot_map_range>
f0108688:	83 c4 20             	add    $0x20,%esp

	//update permissions of the corresponding entry in page directory to make it USER with PERMISSION read only
	ptr_page_directory[PDX(UENVS)] = ptr_page_directory[PDX(UENVS)]|(PERM_USER|(PERM_PRESENT & (~PERM_WRITEABLE)));
f010868b:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0108690:	05 ec 0e 00 00       	add    $0xeec,%eax
f0108695:	8b 15 d8 6c 85 f0    	mov    0xf0856cd8,%edx
f010869b:	81 c2 ec 0e 00 00    	add    $0xeec,%edx
f01086a1:	8b 12                	mov    (%edx),%edx
f01086a3:	83 ca 05             	or     $0x5,%edx
f01086a6:	89 10                	mov    %edx,(%eax)
#if USE_KHEAP
	{
		// MAKE SURE THAT THIS MAPPING HAPPENS AFTER ALL BOOT ALLOCATIONS (boot_allocate_space)
		// calls are fininshed, and no remaining data to be allocated for the kernel
		// map all used pages so far for the kernel
		boot_map_range(ptr_page_directory, KERNEL_BASE, (uint32)ptr_free_mem - KERNEL_BASE, 0, PERM_WRITEABLE) ;
f01086a8:	a1 d0 6c 85 f0       	mov    0xf0856cd0,%eax
f01086ad:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f01086b3:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01086b8:	83 ec 0c             	sub    $0xc,%esp
f01086bb:	6a 02                	push   $0x2
f01086bd:	6a 00                	push   $0x0
f01086bf:	52                   	push   %edx
f01086c0:	68 00 00 00 f0       	push   $0xf0000000
f01086c5:	50                   	push   %eax
f01086c6:	e8 8e 00 00 00       	call   f0108759 <boot_map_range>
f01086cb:	83 c4 20             	add    $0x20,%esp
	{
		boot_map_range(ptr_page_directory, KERNEL_BASE, 0xFFFFFFFF - KERNEL_BASE, 0, PERM_WRITEABLE) ;
	}
#endif
	// Check that the initial page directory has been set up correctly.
	check_boot_pgdir();
f01086ce:	e8 31 18 01 00       	call   f0119f04 <check_boot_pgdir>

	memory_scarce_threshold_percentage = DEFAULT_MEM_SCARCE_PERCENTAGE;	// Memory remains plentiful till % of free frames gets below 25% of the memory space
f01086d3:	c7 05 f0 e8 83 f0 19 	movl   $0x19,0xf083e8f0
f01086da:	00 00 00 

	/*
	NOW: Turn off the segmentation by setting the segments' base to 0, and
	turn on the paging by setting the corresponding flags in control register 0 (cr0)
	 */
	turn_on_paging() ;
f01086dd:	e8 e6 02 00 00       	call   f01089c8 <turn_on_paging>
}
f01086e2:	90                   	nop
f01086e3:	c9                   	leave  
f01086e4:	c3                   	ret    

f01086e5 <boot_allocate_space>:
// It's too early to run out of memory.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void* boot_allocate_space(uint32 size, uint32 align)
{
f01086e5:	55                   	push   %ebp
f01086e6:	89 e5                	mov    %esp,%ebp
f01086e8:	83 ec 18             	sub    $0x18,%esp
	// Initialize ptr_free_mem if this is the first time.
	// 'end_of_kernel' is a symbol automatically generated by the linker,
	// which points to the end of the kernel-
	// i.e., the first virtual address that the linker
	// did not assign to any kernel code or global variables.
	if (ptr_free_mem == 0)
f01086eb:	a1 d0 6c 85 f0       	mov    0xf0856cd0,%eax
f01086f0:	85 c0                	test   %eax,%eax
f01086f2:	75 0a                	jne    f01086fe <boot_allocate_space+0x19>
		ptr_free_mem = end_of_kernel;
f01086f4:	c7 05 d0 6c 85 f0 d0 	movl   $0xf087d6d0,0xf0856cd0
f01086fb:	d6 87 f0 

	// Your code here:
	//	Step 1: round ptr_free_mem up to be aligned properly
	ptr_free_mem = ROUNDUP(ptr_free_mem, align) ;
f01086fe:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108701:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108704:	a1 d0 6c 85 f0       	mov    0xf0856cd0,%eax
f0108709:	89 c2                	mov    %eax,%edx
f010870b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010870e:	01 d0                	add    %edx,%eax
f0108710:	48                   	dec    %eax
f0108711:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108714:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108717:	ba 00 00 00 00       	mov    $0x0,%edx
f010871c:	f7 75 f4             	divl   -0xc(%ebp)
f010871f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108722:	29 d0                	sub    %edx,%eax
f0108724:	a3 d0 6c 85 f0       	mov    %eax,0xf0856cd0

	//	Step 2: save current value of ptr_free_mem as allocated space
	void *ptr_allocated_mem;
	ptr_allocated_mem = ptr_free_mem ;
f0108729:	a1 d0 6c 85 f0       	mov    0xf0856cd0,%eax
f010872e:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//	Step 3: increase ptr_free_mem to record allocation
	ptr_free_mem += size ;
f0108731:	8b 15 d0 6c 85 f0    	mov    0xf0856cd0,%edx
f0108737:	8b 45 08             	mov    0x8(%ebp),%eax
f010873a:	01 d0                	add    %edx,%eax
f010873c:	a3 d0 6c 85 f0       	mov    %eax,0xf0856cd0

	//// 2016: Step 3.5: initialize allocated space by ZEROOOOOOOOOOOOOO
	/*2023*/ /*THIS LINE IS UNCOMMENTED To Ensure that any boot allocations ARE SET TO ZERO
	 * This is mainly to ensure that any restart will be fresh and no grabage data will be exist
	 */
	memset(ptr_allocated_mem, 0, size);
f0108741:	83 ec 04             	sub    $0x4,%esp
f0108744:	ff 75 08             	pushl  0x8(%ebp)
f0108747:	6a 00                	push   $0x0
f0108749:	ff 75 ec             	pushl  -0x14(%ebp)
f010874c:	e8 18 25 01 00       	call   f011ac69 <memset>
f0108751:	83 c4 10             	add    $0x10,%esp

	//	Step 4: return allocated space
	return ptr_allocated_mem ;
f0108754:	8b 45 ec             	mov    -0x14(%ebp),%eax

}
f0108757:	c9                   	leave  
f0108758:	c3                   	ret    

f0108759 <boot_map_range>:
//
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void boot_map_range(uint32 *ptr_page_directory, uint32 virtual_address, uint32 size, uint32 physical_address, int perm)
{
f0108759:	55                   	push   %ebp
f010875a:	89 e5                	mov    %esp,%ebp
f010875c:	83 ec 18             	sub    $0x18,%esp
	int i = 0 ;
f010875f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0108766:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010876d:	eb 53                	jmp    f01087c2 <boot_map_range+0x69>
	{
		uint32 *ptr_page_table = boot_get_page_table(ptr_page_directory, virtual_address, 1) ;
f010876f:	83 ec 04             	sub    $0x4,%esp
f0108772:	6a 01                	push   $0x1
f0108774:	ff 75 0c             	pushl  0xc(%ebp)
f0108777:	ff 75 08             	pushl  0x8(%ebp)
f010877a:	e8 4e 00 00 00       	call   f01087cd <boot_get_page_table>
f010877f:	83 c4 10             	add    $0x10,%esp
f0108782:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 index_page_table = PTX(virtual_address);
f0108785:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108788:	c1 e8 0c             	shr    $0xc,%eax
f010878b:	25 ff 03 00 00       	and    $0x3ff,%eax
f0108790:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//LOG_VARS("\nCONSTRUCT_ENTRY = %x",physical_address);
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;
f0108793:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108796:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010879d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01087a0:	01 c2                	add    %eax,%edx
f01087a2:	8b 45 18             	mov    0x18(%ebp),%eax
f01087a5:	0b 45 14             	or     0x14(%ebp),%eax
f01087a8:	83 c8 01             	or     $0x1,%eax
f01087ab:	89 02                	mov    %eax,(%edx)

		physical_address += PAGE_SIZE ;
f01087ad:	81 45 14 00 10 00 00 	addl   $0x1000,0x14(%ebp)
		virtual_address += PAGE_SIZE ;
f01087b4:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
{
	int i = 0 ;
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f01087bb:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f01087c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01087c5:	3b 45 10             	cmp    0x10(%ebp),%eax
f01087c8:	72 a5                	jb     f010876f <boot_map_range+0x16>
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;

		physical_address += PAGE_SIZE ;
		virtual_address += PAGE_SIZE ;
	}
}
f01087ca:	90                   	nop
f01087cb:	c9                   	leave  
f01087cc:	c3                   	ret    

f01087cd <boot_get_page_table>:
// boot_get_page_table cannot fail.  It's too early to fail.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
uint32* boot_get_page_table(uint32 *ptr_page_directory, uint32 virtual_address, int create)
{
f01087cd:	55                   	push   %ebp
f01087ce:	89 e5                	mov    %esp,%ebp
f01087d0:	83 ec 28             	sub    $0x28,%esp
	uint32 index_page_directory = PDX(virtual_address);
f01087d3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01087d6:	c1 e8 16             	shr    $0x16,%eax
f01087d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 page_directory_entry = ptr_page_directory[index_page_directory];
f01087dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01087df:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01087e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01087e9:	01 d0                	add    %edx,%eax
f01087eb:	8b 00                	mov    (%eax),%eax
f01087ed:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//cprintf("boot d ind = %d, entry = %x\n",index_page_directory, page_directory_entry);
	uint32 phys_page_table = EXTRACT_ADDRESS(page_directory_entry);
f01087f0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01087f3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01087f8:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 *ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table);
f01087fb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01087fe:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0108801:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108804:	c1 e8 0c             	shr    $0xc,%eax
f0108807:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010880a:	a1 b8 e9 83 f0       	mov    0xf083e9b8,%eax
f010880f:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0108812:	72 17                	jb     f010882b <boot_get_page_table+0x5e>
f0108814:	ff 75 e8             	pushl  -0x18(%ebp)
f0108817:	68 00 e8 12 f0       	push   $0xf012e800
f010881c:	68 33 01 00 00       	push   $0x133
f0108821:	68 b8 e7 12 f0       	push   $0xf012e7b8
f0108826:	e8 84 86 ff ff       	call   f0100eaf <_panic>
f010882b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010882e:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108833:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (phys_page_table == 0)
f0108836:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010883a:	75 72                	jne    f01088ae <boot_get_page_table+0xe1>
	{
		if (create)
f010883c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0108840:	74 65                	je     f01088a7 <boot_get_page_table+0xda>
		{
			ptr_page_table = boot_allocate_space(PAGE_SIZE, PAGE_SIZE) ;
f0108842:	83 ec 08             	sub    $0x8,%esp
f0108845:	68 00 10 00 00       	push   $0x1000
f010884a:	68 00 10 00 00       	push   $0x1000
f010884f:	e8 91 fe ff ff       	call   f01086e5 <boot_allocate_space>
f0108854:	83 c4 10             	add    $0x10,%esp
f0108857:	89 45 e0             	mov    %eax,-0x20(%ebp)
			phys_page_table = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_table);
f010885a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010885d:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0108860:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f0108867:	77 17                	ja     f0108880 <boot_get_page_table+0xb3>
f0108869:	ff 75 dc             	pushl  -0x24(%ebp)
f010886c:	68 84 e7 12 f0       	push   $0xf012e784
f0108871:	68 39 01 00 00       	push   $0x139
f0108876:	68 b8 e7 12 f0       	push   $0xf012e7b8
f010887b:	e8 2f 86 ff ff       	call   f0100eaf <_panic>
f0108880:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108883:	05 00 00 00 10       	add    $0x10000000,%eax
f0108888:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_page_directory[index_page_directory] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_WRITEABLE);
f010888b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010888e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108895:	8b 45 08             	mov    0x8(%ebp),%eax
f0108898:	01 d0                	add    %edx,%eax
f010889a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010889d:	83 ca 03             	or     $0x3,%edx
f01088a0:	89 10                	mov    %edx,(%eax)
			return ptr_page_table ;
f01088a2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01088a5:	eb 0a                	jmp    f01088b1 <boot_get_page_table+0xe4>
		}
		else
			return 0 ;
f01088a7:	b8 00 00 00 00       	mov    $0x0,%eax
f01088ac:	eb 03                	jmp    f01088b1 <boot_get_page_table+0xe4>
	}
	return ptr_page_table ;
f01088ae:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f01088b1:	c9                   	leave  
f01088b2:	c3                   	ret    

f01088b3 <nvram_read>:


int nvram_read(int r)
{
f01088b3:	55                   	push   %ebp
f01088b4:	89 e5                	mov    %esp,%ebp
f01088b6:	53                   	push   %ebx
f01088b7:	83 ec 04             	sub    $0x4,%esp
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
f01088ba:	8b 45 08             	mov    0x8(%ebp),%eax
f01088bd:	83 ec 0c             	sub    $0xc,%esp
f01088c0:	50                   	push   %eax
f01088c1:	e8 27 d2 ff ff       	call   f0105aed <mc146818_read>
f01088c6:	83 c4 10             	add    $0x10,%esp
f01088c9:	89 c3                	mov    %eax,%ebx
f01088cb:	8b 45 08             	mov    0x8(%ebp),%eax
f01088ce:	40                   	inc    %eax
f01088cf:	83 ec 0c             	sub    $0xc,%esp
f01088d2:	50                   	push   %eax
f01088d3:	e8 15 d2 ff ff       	call   f0105aed <mc146818_read>
f01088d8:	83 c4 10             	add    $0x10,%esp
f01088db:	c1 e0 08             	shl    $0x8,%eax
f01088de:	09 d8                	or     %ebx,%eax
}
f01088e0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01088e3:	c9                   	leave  
f01088e4:	c3                   	ret    

f01088e5 <detect_memory>:

void detect_memory()
{
f01088e5:	55                   	push   %ebp
f01088e6:	89 e5                	mov    %esp,%ebp
f01088e8:	83 ec 28             	sub    $0x28,%esp
	uint32 maxpa;	// Maximum physical address
	uint32 size_of_base_mem;		// Amount of base memory (in bytes)
	uint32 size_of_extended_mem;		// Amount of extended memory (in bytes)

	// CMOS tells us how many kilobytes there are
	size_of_base_mem = ROUNDDOWN(nvram_read(NVRAM_BASELO)*1024, PAGE_SIZE);
f01088eb:	83 ec 0c             	sub    $0xc,%esp
f01088ee:	6a 15                	push   $0x15
f01088f0:	e8 be ff ff ff       	call   f01088b3 <nvram_read>
f01088f5:	83 c4 10             	add    $0x10,%esp
f01088f8:	c1 e0 0a             	shl    $0xa,%eax
f01088fb:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01088fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108901:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108906:	89 45 e8             	mov    %eax,-0x18(%ebp)
	size_of_extended_mem = ROUNDDOWN(nvram_read(NVRAM_EXTLO)*1024, PAGE_SIZE);
f0108909:	83 ec 0c             	sub    $0xc,%esp
f010890c:	6a 17                	push   $0x17
f010890e:	e8 a0 ff ff ff       	call   f01088b3 <nvram_read>
f0108913:	83 c4 10             	add    $0x10,%esp
f0108916:	c1 e0 0a             	shl    $0xa,%eax
f0108919:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010891c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010891f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108924:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//2016
	//For physical memory larger than 16MB, we needed to read total memory size
	// from a different register of the MC chip, see here:
	// http://bochs.sourceforge.net/techspec/CMOS-reference.txt
	// "CMOS 34h - AMI -"
	uint32 size_of_other_mem = ROUNDDOWN(nvram_read(0x34)*1024*64, PAGE_SIZE);
f0108927:	83 ec 0c             	sub    $0xc,%esp
f010892a:	6a 34                	push   $0x34
f010892c:	e8 82 ff ff ff       	call   f01088b3 <nvram_read>
f0108931:	83 c4 10             	add    $0x10,%esp
f0108934:	c1 e0 10             	shl    $0x10,%eax
f0108937:	89 45 e0             	mov    %eax,-0x20(%ebp)
f010893a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010893d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108942:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//cprintf("other mem = %dK\n", size_of_other_mem/1024);

	// Calculate the maximum physical address based on whether
	// or not there is any extended memory.  See comment in ../inc/mmu.h.
	//2016
	if(size_of_other_mem > 0)
f0108945:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0108949:	74 18                	je     f0108963 <detect_memory+0x7e>
	{
		maxpa = size_of_other_mem + 16*1024*1024;
f010894b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010894e:	05 00 00 00 01       	add    $0x1000000,%eax
f0108953:	89 45 f4             	mov    %eax,-0xc(%ebp)
		size_of_extended_mem = maxpa - PHYS_EXTENDED_MEM;
f0108956:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108959:	2d 00 00 10 00       	sub    $0x100000,%eax
f010895e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108961:	eb 19                	jmp    f010897c <detect_memory+0x97>
	}
	else
	{
		if (size_of_extended_mem)
f0108963:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0108967:	74 0d                	je     f0108976 <detect_memory+0x91>
			maxpa = PHYS_EXTENDED_MEM + size_of_extended_mem;
f0108969:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010896c:	05 00 00 10 00       	add    $0x100000,%eax
f0108971:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108974:	eb 06                	jmp    f010897c <detect_memory+0x97>
		else
			maxpa = size_of_extended_mem;
f0108976:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108979:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	uint32 kernel_virtual_area = ((0xFFFFFFFF-KERNEL_BASE)+1);
f010897c:	c7 45 d8 00 00 00 10 	movl   $0x10000000,-0x28(%ebp)
	{
		cprintf("*	Error!: Physical memory = %dK larger than kernel virtual area (%dK)\n", maxpa/1024, kernel_virtual_area/1024);
		cprintf("*	Cannot use physical memory larger than kernel virtual area\nTo enable physical memory larger than virtual kernel area, set USE_KHEAP = 1 in FOS code");
		while(1);
	}
	number_of_frames = maxpa / PAGE_SIZE;
f0108983:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108986:	c1 e8 0c             	shr    $0xc,%eax
f0108989:	a3 b8 e9 83 f0       	mov    %eax,0xf083e9b8

	cprintf("*	Physical memory: %dK available, ", (int)(maxpa/1024));
f010898e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108991:	c1 e8 0a             	shr    $0xa,%eax
f0108994:	83 ec 08             	sub    $0x8,%esp
f0108997:	50                   	push   %eax
f0108998:	68 30 e8 12 f0       	push   $0xf012e830
f010899d:	e8 ba 91 ff ff       	call   f0101b5c <cprintf>
f01089a2:	83 c4 10             	add    $0x10,%esp
	cprintf("base = %dK, extended = %dK\n", (int)(size_of_base_mem/1024), (int)(size_of_extended_mem/1024));
f01089a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01089a8:	c1 e8 0a             	shr    $0xa,%eax
f01089ab:	89 c2                	mov    %eax,%edx
f01089ad:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01089b0:	c1 e8 0a             	shr    $0xa,%eax
f01089b3:	83 ec 04             	sub    $0x4,%esp
f01089b6:	52                   	push   %edx
f01089b7:	50                   	push   %eax
f01089b8:	68 53 e8 12 f0       	push   $0xf012e853
f01089bd:	e8 9a 91 ff ff       	call   f0101b5c <cprintf>
f01089c2:	83 c4 10             	add    $0x10,%esp
}
f01089c5:	90                   	nop
f01089c6:	c9                   	leave  
f01089c7:	c3                   	ret    

f01089c8 <turn_on_paging>:
// --------------------------------------------------------------
// Set up initial memory mappings and turn on MMU.
// --------------------------------------------------------------

void turn_on_paging()
{
f01089c8:	55                   	push   %ebp
f01089c9:	89 e5                	mov    %esp,%ebp
f01089cb:	83 ec 48             	sub    $0x48,%esp
	// (Limits our kernel to <4MB)

	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
f01089ce:	c7 45 f4 c0 03 00 00 	movl   $0x3c0,-0xc(%ebp)
		int j = 0;
f01089d5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f01089dc:	eb 24                	jmp    f0108a02 <turn_on_paging+0x3a>
		{
			ptr_page_directory[j] = ptr_page_directory[i];
f01089de:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01089e3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01089e6:	c1 e2 02             	shl    $0x2,%edx
f01089e9:	01 c2                	add    %eax,%edx
f01089eb:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01089f0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01089f3:	c1 e1 02             	shl    $0x2,%ecx
f01089f6:	01 c8                	add    %ecx,%eax
f01089f8:	8b 00                	mov    (%eax),%eax
f01089fa:	89 02                	mov    %eax,(%edx)
	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f01089fc:	ff 45 f4             	incl   -0xc(%ebp)
f01089ff:	ff 45 f0             	incl   -0x10(%ebp)
f0108a02:	a1 d0 6c 85 f0       	mov    0xf0856cd0,%eax
f0108a07:	c1 e8 16             	shr    $0x16,%eax
f0108a0a:	89 c2                	mov    %eax,%edx
f0108a0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108a0f:	39 c2                	cmp    %eax,%edx
f0108a11:	77 cb                	ja     f01089de <turn_on_paging+0x16>
			ptr_page_directory[j] = ptr_page_directory[i];
		}
	}

	// Install page table.
	lcr3(phys_page_directory);
f0108a13:	a1 e0 6d 85 f0       	mov    0xf0856de0,%eax
f0108a18:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0108a1b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108a1e:	0f 22 d8             	mov    %eax,%cr3

static __inline uint32
rcr0(void)
{
	uint32 val;
	__asm __volatile("movl %%cr0,%0" : "=r" (val));
f0108a21:	0f 20 c0             	mov    %cr0,%eax
f0108a24:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0108a27:	8b 45 d8             	mov    -0x28(%ebp),%eax

	// Turn on paging.
	uint32 cr0;
	cr0 = rcr0();
f0108a2a:	89 45 dc             	mov    %eax,-0x24(%ebp)
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_TS|CR0_EM|CR0_MP;
f0108a2d:	81 4d dc 2f 00 05 80 	orl    $0x8005002f,-0x24(%ebp)
	cr0 &= ~(CR0_TS|CR0_EM);
f0108a34:	83 65 dc f3          	andl   $0xfffffff3,-0x24(%ebp)
f0108a38:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108a3b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr0(uint32 val)
{
	__asm __volatile("movl %0,%%cr0" : : "r" (val));
f0108a3e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0108a41:	0f 22 c0             	mov    %eax,%cr0
	// (x < 4MB so uses paging ptr_page_directory[0])

	// Reload all segment registers.
	//2024: replaced by lgdt()
	//asm volatile("lgdt gdt_pd");
	pushcli();	//disable interrupt
f0108a44:	e8 e7 f5 ff ff       	call   f0108030 <pushcli>
	lgdt(mycpu()->gdt, sizeof(mycpu()->gdt));
f0108a49:	e8 22 f5 ff ff       	call   f0107f70 <mycpu>
f0108a4e:	83 c0 74             	add    $0x74,%eax
f0108a51:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0108a54:	c7 45 cc 30 00 00 00 	movl   $0x30,-0x34(%ebp)
static __inline void
lgdt(struct Segdesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f0108a5b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0108a5e:	48                   	dec    %eax
f0108a5f:	66 89 45 c6          	mov    %ax,-0x3a(%ebp)
  pd[1] = (uint32)p;
f0108a63:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0108a66:	66 89 45 c8          	mov    %ax,-0x38(%ebp)
  pd[2] = (uint32)p >> 16;
f0108a6a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0108a6d:	c1 e8 10             	shr    $0x10,%eax
f0108a70:	66 89 45 ca          	mov    %ax,-0x36(%ebp)

  __asm __volatile("lgdt (%0)" : : "r" (pd));
f0108a74:	8d 45 c6             	lea    -0x3a(%ebp),%eax
f0108a77:	0f 01 10             	lgdtl  (%eax)
	popcli();	//enable interrupt
f0108a7a:	e8 03 f6 ff ff       	call   f0108082 <popcli>
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
f0108a7f:	b8 23 00 00 00       	mov    $0x23,%eax
f0108a84:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
f0108a86:	b8 23 00 00 00       	mov    $0x23,%eax
f0108a8b:	8e e0                	mov    %eax,%fs
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
f0108a8d:	b8 10 00 00 00       	mov    $0x10,%eax
f0108a92:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
f0108a94:	b8 10 00 00 00       	mov    $0x10,%eax
f0108a99:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
f0108a9b:	b8 10 00 00 00       	mov    $0x10,%eax
f0108aa0:	8e d0                	mov    %eax,%ss
	asm volatile("ljmp %0,$1f\n 1:\n" :: "i" (GD_KT));  // reload cs
f0108aa2:	ea a9 8a 10 f0 08 00 	ljmp   $0x8,$0xf0108aa9
	asm volatile("lldt %%ax" :: "a" (0));
f0108aa9:	b8 00 00 00 00       	mov    $0x0,%eax
f0108aae:	0f 00 d0             	lldt   %ax
	// This mapping was only used after paging was turned on but
	// before the segment registers were reloaded.
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
f0108ab1:	c7 45 ec c0 03 00 00 	movl   $0x3c0,-0x14(%ebp)
		int j = 0;
f0108ab8:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0108abf:	eb 19                	jmp    f0108ada <turn_on_paging+0x112>
		{
			ptr_page_directory[j] = 0;
f0108ac1:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0108ac6:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0108ac9:	c1 e2 02             	shl    $0x2,%edx
f0108acc:	01 d0                	add    %edx,%eax
f0108ace:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0108ad4:	ff 45 ec             	incl   -0x14(%ebp)
f0108ad7:	ff 45 e8             	incl   -0x18(%ebp)
f0108ada:	a1 d0 6c 85 f0       	mov    0xf0856cd0,%eax
f0108adf:	c1 e8 16             	shr    $0x16,%eax
f0108ae2:	89 c2                	mov    %eax,%edx
f0108ae4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108ae7:	39 c2                	cmp    %eax,%edx
f0108ae9:	77 d6                	ja     f0108ac1 <turn_on_paging+0xf9>
			ptr_page_directory[j] = 0;
		}
	}

	// Flush the TLB for good measure, to kill the ptr_page_directory[0] mapping.
	lcr3(phys_page_directory);
f0108aeb:	a1 e0 6d 85 f0       	mov    0xf0856de0,%eax
f0108af0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0108af3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108af6:	0f 22 d8             	mov    %eax,%cr3

}
f0108af9:	90                   	nop
f0108afa:	c9                   	leave  
f0108afb:	c3                   	ret    

f0108afc <setup_listing_to_all_page_tables_entries>:

void setup_listing_to_all_page_tables_entries()
{
f0108afc:	55                   	push   %ebp
f0108afd:	89 e5                	mov    %esp,%ebp
f0108aff:	83 ec 18             	sub    $0x18,%esp
	//////////////////////////////////////////////////////////////////////
	// Recursively insert PD in itself as a page table, to form
	// a virtual page table at virtual address VPT.

	// Permissions: kernel RW, user NONE
	uint32 phys_frame_address = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0108b02:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0108b07:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108b0a:	81 7d f4 ff ff ff ef 	cmpl   $0xefffffff,-0xc(%ebp)
f0108b11:	77 17                	ja     f0108b2a <setup_listing_to_all_page_tables_entries+0x2e>
f0108b13:	ff 75 f4             	pushl  -0xc(%ebp)
f0108b16:	68 84 e7 12 f0       	push   $0xf012e784
f0108b1b:	68 cf 01 00 00       	push   $0x1cf
f0108b20:	68 b8 e7 12 f0       	push   $0xf012e7b8
f0108b25:	e8 85 83 ff ff       	call   f0100eaf <_panic>
f0108b2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108b2d:	05 00 00 00 10       	add    $0x10000000,%eax
f0108b32:	89 45 f0             	mov    %eax,-0x10(%ebp)
	ptr_page_directory[PDX(VPT)] = CONSTRUCT_ENTRY(phys_frame_address , PERM_PRESENT | PERM_WRITEABLE);
f0108b35:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0108b3a:	05 fc 0e 00 00       	add    $0xefc,%eax
f0108b3f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108b42:	83 ca 03             	or     $0x3,%edx
f0108b45:	89 10                	mov    %edx,(%eax)

	// same for UVPT
	//Permissions: kernel R, user R
	ptr_page_directory[PDX(UVPT)] = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory)|PERM_USER|PERM_PRESENT;
f0108b47:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0108b4c:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f0108b52:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0108b57:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108b5a:	81 7d ec ff ff ff ef 	cmpl   $0xefffffff,-0x14(%ebp)
f0108b61:	77 17                	ja     f0108b7a <setup_listing_to_all_page_tables_entries+0x7e>
f0108b63:	ff 75 ec             	pushl  -0x14(%ebp)
f0108b66:	68 84 e7 12 f0       	push   $0xf012e784
f0108b6b:	68 d4 01 00 00       	push   $0x1d4
f0108b70:	68 b8 e7 12 f0       	push   $0xf012e7b8
f0108b75:	e8 35 83 ff ff       	call   f0100eaf <_panic>
f0108b7a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108b7d:	05 00 00 00 10       	add    $0x10000000,%eax
f0108b82:	83 c8 05             	or     $0x5,%eax
f0108b85:	89 02                	mov    %eax,(%edx)

}
f0108b87:	90                   	nop
f0108b88:	c9                   	leave  
f0108b89:	c3                   	ret    

f0108b8a <to_frame_number>:
struct FrameInfo *get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table);
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);

static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0108b8a:	55                   	push   %ebp
f0108b8b:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0108b8d:	8b 45 08             	mov    0x8(%ebp),%eax
f0108b90:	8b 15 08 6b 85 f0    	mov    0xf0856b08,%edx
f0108b96:	29 d0                	sub    %edx,%eax
f0108b98:	c1 f8 02             	sar    $0x2,%eax
f0108b9b:	89 c2                	mov    %eax,%edx
f0108b9d:	89 d0                	mov    %edx,%eax
f0108b9f:	c1 e0 02             	shl    $0x2,%eax
f0108ba2:	01 d0                	add    %edx,%eax
f0108ba4:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0108bab:	01 c8                	add    %ecx,%eax
f0108bad:	01 c0                	add    %eax,%eax
f0108baf:	01 d0                	add    %edx,%eax
f0108bb1:	89 c1                	mov    %eax,%ecx
f0108bb3:	c1 e1 08             	shl    $0x8,%ecx
f0108bb6:	01 c8                	add    %ecx,%eax
f0108bb8:	89 c1                	mov    %eax,%ecx
f0108bba:	c1 e1 10             	shl    $0x10,%ecx
f0108bbd:	01 c8                	add    %ecx,%eax
f0108bbf:	c1 e0 02             	shl    $0x2,%eax
f0108bc2:	01 d0                	add    %edx,%eax
}
f0108bc4:	5d                   	pop    %ebp
f0108bc5:	c3                   	ret    

f0108bc6 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f0108bc6:	55                   	push   %ebp
f0108bc7:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0108bc9:	ff 75 08             	pushl  0x8(%ebp)
f0108bcc:	e8 b9 ff ff ff       	call   f0108b8a <to_frame_number>
f0108bd1:	83 c4 04             	add    $0x4,%esp
f0108bd4:	c1 e0 0c             	shl    $0xc,%eax
}
f0108bd7:	c9                   	leave  
f0108bd8:	c3                   	ret    

f0108bd9 <to_frame_info>:

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0108bd9:	55                   	push   %ebp
f0108bda:	89 e5                	mov    %esp,%ebp
f0108bdc:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0108bdf:	8b 45 08             	mov    0x8(%ebp),%eax
f0108be2:	c1 e8 0c             	shr    $0xc,%eax
f0108be5:	89 c2                	mov    %eax,%edx
f0108be7:	a1 b8 e9 83 f0       	mov    0xf083e9b8,%eax
f0108bec:	39 c2                	cmp    %eax,%edx
f0108bee:	72 14                	jb     f0108c04 <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f0108bf0:	83 ec 04             	sub    $0x4,%esp
f0108bf3:	68 70 e8 12 f0       	push   $0xf012e870
f0108bf8:	6a 4e                	push   $0x4e
f0108bfa:	68 95 e8 12 f0       	push   $0xf012e895
f0108bff:	e8 ab 82 ff ff       	call   f0100eaf <_panic>
	return &frames_info[PPN(physical_address)];
f0108c04:	8b 15 08 6b 85 f0    	mov    0xf0856b08,%edx
f0108c0a:	8b 45 08             	mov    0x8(%ebp),%eax
f0108c0d:	c1 e8 0c             	shr    $0xc,%eax
f0108c10:	89 c1                	mov    %eax,%ecx
f0108c12:	89 c8                	mov    %ecx,%eax
f0108c14:	c1 e0 02             	shl    $0x2,%eax
f0108c17:	01 c8                	add    %ecx,%eax
f0108c19:	c1 e0 02             	shl    $0x2,%eax
f0108c1c:	01 d0                	add    %edx,%eax
}
f0108c1e:	c9                   	leave  
f0108c1f:	c3                   	ret    

f0108c20 <tlb_invalidate>:




void tlb_invalidate(uint32 *ptr_page_directory, void *virtual_address)
{
f0108c20:	55                   	push   %ebp
f0108c21:	89 e5                	mov    %esp,%ebp
f0108c23:	83 ec 18             	sub    $0x18,%esp
	// Flush the entry only if we're modifying the current address space.
	/*2025*/ //check is added
	struct Env* e = get_cpu_proc();
f0108c26:	e8 ed 2d 00 00       	call   f010ba18 <get_cpu_proc>
f0108c2b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!e || e->env_page_directory == ptr_page_directory)
f0108c2e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108c32:	74 0b                	je     f0108c3f <tlb_invalidate+0x1f>
f0108c34:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c37:	8b 40 64             	mov    0x64(%eax),%eax
f0108c3a:	3b 45 08             	cmp    0x8(%ebp),%eax
f0108c3d:	75 0c                	jne    f0108c4b <tlb_invalidate+0x2b>
f0108c3f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108c42:	89 45 f0             	mov    %eax,-0x10(%ebp)
}

static __inline void
invlpg(void *addr)
{
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
f0108c45:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108c48:	0f 01 38             	invlpg (%eax)
		invlpg(virtual_address);
}
f0108c4b:	90                   	nop
f0108c4c:	c9                   	leave  
f0108c4d:	c3                   	ret    

f0108c4e <initialize_paging>:
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//

extern void initialize_disk_page_file();
void initialize_paging()
{
f0108c4e:	55                   	push   %ebp
f0108c4f:	89 e5                	mov    %esp,%ebp
f0108c51:	53                   	push   %ebx
f0108c52:	83 ec 24             	sub    $0x24,%esp
	//     Some of it is in use, some is free. Where is the kernel?
	//     Which frames are used for page tables and other data structures?
	//
	// Change the code to reflect this.
	int i;
	LIST_INIT(&MemFrameLists.free_frame_list);
f0108c55:	c7 05 c0 e7 83 f0 00 	movl   $0x0,0xf083e7c0
f0108c5c:	00 00 00 
f0108c5f:	c7 05 c4 e7 83 f0 00 	movl   $0x0,0xf083e7c4
f0108c66:	00 00 00 
f0108c69:	c7 05 cc e7 83 f0 00 	movl   $0x0,0xf083e7cc
f0108c70:	00 00 00 
	LIST_INIT(&MemFrameLists.modified_frame_list);
f0108c73:	c7 05 d0 e7 83 f0 00 	movl   $0x0,0xf083e7d0
f0108c7a:	00 00 00 
f0108c7d:	c7 05 d4 e7 83 f0 00 	movl   $0x0,0xf083e7d4
f0108c84:	00 00 00 
f0108c87:	c7 05 dc e7 83 f0 00 	movl   $0x0,0xf083e7dc
f0108c8e:	00 00 00 

	//Initialize the corresponding lock
	init_kspinlock(&MemFrameLists.mfllock, "Frame Info Lock");
f0108c91:	83 ec 08             	sub    $0x8,%esp
f0108c94:	68 af e8 12 f0       	push   $0xf012e8af
f0108c99:	68 e0 e7 83 f0       	push   $0xf083e7e0
f0108c9e:	e8 a7 70 00 00       	call   f010fd4a <init_kspinlock>
f0108ca3:	83 c4 10             	add    $0x10,%esp

	frames_info[0].references = 1;
f0108ca6:	a1 08 6b 85 f0       	mov    0xf0856b08,%eax
f0108cab:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[1].references = 1;
f0108cb1:	a1 08 6b 85 f0       	mov    0xf0856b08,%eax
f0108cb6:	83 c0 14             	add    $0x14,%eax
f0108cb9:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[2].references = 1;
f0108cbf:	a1 08 6b 85 f0       	mov    0xf0856b08,%eax
f0108cc4:	83 c0 28             	add    $0x28,%eax
f0108cc7:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
f0108ccd:	c7 05 18 6b 85 f0 00 	movl   $0xf0001000,0xf0856b18
f0108cd4:	10 00 f0 
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
f0108cd7:	c7 05 64 6d 85 f0 00 	movl   $0xf0002000,0xf0856d64
f0108cde:	20 00 f0 
	i =0;
f0108ce1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<1024; i++)
f0108ce8:	eb 1f                	jmp    f0108d09 <initialize_paging+0xbb>
	{
		ptr_zero_page[i]=0;
f0108cea:	8b 15 18 6b 85 f0    	mov    0xf0856b18,%edx
f0108cf0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108cf3:	01 d0                	add    %edx,%eax
f0108cf5:	c6 00 00             	movb   $0x0,(%eax)
		ptr_temp_page[i]=0;
f0108cf8:	8b 15 64 6d 85 f0    	mov    0xf0856d64,%edx
f0108cfe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108d01:	01 d0                	add    %edx,%eax
f0108d03:	c6 00 00             	movb   $0x0,(%eax)
	frames_info[1].references = 1;
	frames_info[2].references = 1;
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
	i =0;
	for(;i<1024; i++)
f0108d06:	ff 45 f4             	incl   -0xc(%ebp)
f0108d09:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f0108d10:	7e d8                	jle    f0108cea <initialize_paging+0x9c>
	{
		ptr_zero_page[i]=0;
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);
f0108d12:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f0108d19:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108d1c:	05 ff ff 09 00       	add    $0x9ffff,%eax
f0108d21:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108d24:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108d27:	ba 00 00 00 00       	mov    $0x0,%edx
f0108d2c:	f7 75 f0             	divl   -0x10(%ebp)
f0108d2f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108d32:	29 d0                	sub    %edx,%eax
f0108d34:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0108d37:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
f0108d3e:	e9 ef 00 00 00       	jmp    f0108e32 <initialize_paging+0x1e4>
	{

		initialize_frame_info(&(frames_info[i]));
f0108d43:	8b 0d 08 6b 85 f0    	mov    0xf0856b08,%ecx
f0108d49:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108d4c:	89 d0                	mov    %edx,%eax
f0108d4e:	c1 e0 02             	shl    $0x2,%eax
f0108d51:	01 d0                	add    %edx,%eax
f0108d53:	c1 e0 02             	shl    $0x2,%eax
f0108d56:	01 c8                	add    %ecx,%eax
f0108d58:	83 ec 0c             	sub    $0xc,%esp
f0108d5b:	50                   	push   %eax
f0108d5c:	e8 c6 02 00 00       	call   f0109027 <initialize_frame_info>
f0108d61:	83 c4 10             	add    $0x10,%esp
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f0108d64:	8b 0d 08 6b 85 f0    	mov    0xf0856b08,%ecx
f0108d6a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108d6d:	89 d0                	mov    %edx,%eax
f0108d6f:	c1 e0 02             	shl    $0x2,%eax
f0108d72:	01 d0                	add    %edx,%eax
f0108d74:	c1 e0 02             	shl    $0x2,%eax
f0108d77:	01 c8                	add    %ecx,%eax
f0108d79:	85 c0                	test   %eax,%eax
f0108d7b:	75 14                	jne    f0108d91 <initialize_paging+0x143>
f0108d7d:	83 ec 04             	sub    $0x4,%esp
f0108d80:	68 c0 e8 12 f0       	push   $0xf012e8c0
f0108d85:	6a 62                	push   $0x62
f0108d87:	68 e3 e8 12 f0       	push   $0xf012e8e3
f0108d8c:	e8 1e 81 ff ff       	call   f0100eaf <_panic>
f0108d91:	8b 0d 08 6b 85 f0    	mov    0xf0856b08,%ecx
f0108d97:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108d9a:	89 d0                	mov    %edx,%eax
f0108d9c:	c1 e0 02             	shl    $0x2,%eax
f0108d9f:	01 d0                	add    %edx,%eax
f0108da1:	c1 e0 02             	shl    $0x2,%eax
f0108da4:	01 c8                	add    %ecx,%eax
f0108da6:	8b 15 c0 e7 83 f0    	mov    0xf083e7c0,%edx
f0108dac:	89 10                	mov    %edx,(%eax)
f0108dae:	8b 00                	mov    (%eax),%eax
f0108db0:	85 c0                	test   %eax,%eax
f0108db2:	74 20                	je     f0108dd4 <initialize_paging+0x186>
f0108db4:	8b 15 c0 e7 83 f0    	mov    0xf083e7c0,%edx
f0108dba:	8b 1d 08 6b 85 f0    	mov    0xf0856b08,%ebx
f0108dc0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0108dc3:	89 c8                	mov    %ecx,%eax
f0108dc5:	c1 e0 02             	shl    $0x2,%eax
f0108dc8:	01 c8                	add    %ecx,%eax
f0108dca:	c1 e0 02             	shl    $0x2,%eax
f0108dcd:	01 d8                	add    %ebx,%eax
f0108dcf:	89 42 04             	mov    %eax,0x4(%edx)
f0108dd2:	eb 1a                	jmp    f0108dee <initialize_paging+0x1a0>
f0108dd4:	8b 0d 08 6b 85 f0    	mov    0xf0856b08,%ecx
f0108dda:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108ddd:	89 d0                	mov    %edx,%eax
f0108ddf:	c1 e0 02             	shl    $0x2,%eax
f0108de2:	01 d0                	add    %edx,%eax
f0108de4:	c1 e0 02             	shl    $0x2,%eax
f0108de7:	01 c8                	add    %ecx,%eax
f0108de9:	a3 c4 e7 83 f0       	mov    %eax,0xf083e7c4
f0108dee:	8b 0d 08 6b 85 f0    	mov    0xf0856b08,%ecx
f0108df4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108df7:	89 d0                	mov    %edx,%eax
f0108df9:	c1 e0 02             	shl    $0x2,%eax
f0108dfc:	01 d0                	add    %edx,%eax
f0108dfe:	c1 e0 02             	shl    $0x2,%eax
f0108e01:	01 c8                	add    %ecx,%eax
f0108e03:	a3 c0 e7 83 f0       	mov    %eax,0xf083e7c0
f0108e08:	8b 0d 08 6b 85 f0    	mov    0xf0856b08,%ecx
f0108e0e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108e11:	89 d0                	mov    %edx,%eax
f0108e13:	c1 e0 02             	shl    $0x2,%eax
f0108e16:	01 d0                	add    %edx,%eax
f0108e18:	c1 e0 02             	shl    $0x2,%eax
f0108e1b:	01 c8                	add    %ecx,%eax
f0108e1d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0108e24:	a1 cc e7 83 f0       	mov    0xf083e7cc,%eax
f0108e29:	40                   	inc    %eax
f0108e2a:	a3 cc e7 83 f0       	mov    %eax,0xf083e7cc
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0108e2f:	ff 45 f4             	incl   -0xc(%ebp)
f0108e32:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108e35:	85 c0                	test   %eax,%eax
f0108e37:	79 05                	jns    f0108e3e <initialize_paging+0x1f0>
f0108e39:	05 ff 0f 00 00       	add    $0xfff,%eax
f0108e3e:	c1 f8 0c             	sar    $0xc,%eax
f0108e41:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0108e44:	0f 8f f9 fe ff ff    	jg     f0108d43 <initialize_paging+0xf5>
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0108e4a:	c7 45 f4 a0 00 00 00 	movl   $0xa0,-0xc(%ebp)
f0108e51:	eb 1e                	jmp    f0108e71 <initialize_paging+0x223>
	{
		frames_info[i].references = 1;
f0108e53:	8b 0d 08 6b 85 f0    	mov    0xf0856b08,%ecx
f0108e59:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108e5c:	89 d0                	mov    %edx,%eax
f0108e5e:	c1 e0 02             	shl    $0x2,%eax
f0108e61:	01 d0                	add    %edx,%eax
f0108e63:	c1 e0 02             	shl    $0x2,%eax
f0108e66:	01 c8                	add    %ecx,%eax
f0108e68:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0108e6e:	ff 45 f4             	incl   -0xc(%ebp)
f0108e71:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0108e78:	7e d9                	jle    f0108e53 <initialize_paging+0x205>
	{
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);
f0108e7a:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0108e81:	a1 d0 6c 85 f0       	mov    0xf0856cd0,%eax
f0108e86:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0108e89:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0108e90:	77 14                	ja     f0108ea6 <initialize_paging+0x258>
f0108e92:	ff 75 e0             	pushl  -0x20(%ebp)
f0108e95:	68 00 e9 12 f0       	push   $0xf012e900
f0108e9a:	6a 6a                	push   $0x6a
f0108e9c:	68 e3 e8 12 f0       	push   $0xf012e8e3
f0108ea1:	e8 09 80 ff ff       	call   f0100eaf <_panic>
f0108ea6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108ea9:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0108eaf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108eb2:	01 d0                	add    %edx,%eax
f0108eb4:	48                   	dec    %eax
f0108eb5:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0108eb8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108ebb:	ba 00 00 00 00       	mov    $0x0,%edx
f0108ec0:	f7 75 e4             	divl   -0x1c(%ebp)
f0108ec3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108ec6:	29 d0                	sub    %edx,%eax
f0108ec8:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0108ecb:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
f0108ed2:	eb 1e                	jmp    f0108ef2 <initialize_paging+0x2a4>
	{
		frames_info[i].references = 1;
f0108ed4:	8b 0d 08 6b 85 f0    	mov    0xf0856b08,%ecx
f0108eda:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108edd:	89 d0                	mov    %edx,%eax
f0108edf:	c1 e0 02             	shl    $0x2,%eax
f0108ee2:	01 d0                	add    %edx,%eax
f0108ee4:	c1 e0 02             	shl    $0x2,%eax
f0108ee7:	01 c8                	add    %ecx,%eax
f0108ee9:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0108eef:	ff 45 f4             	incl   -0xc(%ebp)
f0108ef2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108ef5:	85 c0                	test   %eax,%eax
f0108ef7:	79 05                	jns    f0108efe <initialize_paging+0x2b0>
f0108ef9:	05 ff 0f 00 00       	add    $0xfff,%eax
f0108efe:	c1 f8 0c             	sar    $0xc,%eax
f0108f01:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0108f04:	7f ce                	jg     f0108ed4 <initialize_paging+0x286>
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f0108f06:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108f09:	85 c0                	test   %eax,%eax
f0108f0b:	79 05                	jns    f0108f12 <initialize_paging+0x2c4>
f0108f0d:	05 ff 0f 00 00       	add    $0xfff,%eax
f0108f12:	c1 f8 0c             	sar    $0xc,%eax
f0108f15:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108f18:	e9 ef 00 00 00       	jmp    f010900c <initialize_paging+0x3be>
	{
		initialize_frame_info(&(frames_info[i]));
f0108f1d:	8b 0d 08 6b 85 f0    	mov    0xf0856b08,%ecx
f0108f23:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108f26:	89 d0                	mov    %edx,%eax
f0108f28:	c1 e0 02             	shl    $0x2,%eax
f0108f2b:	01 d0                	add    %edx,%eax
f0108f2d:	c1 e0 02             	shl    $0x2,%eax
f0108f30:	01 c8                	add    %ecx,%eax
f0108f32:	83 ec 0c             	sub    $0xc,%esp
f0108f35:	50                   	push   %eax
f0108f36:	e8 ec 00 00 00       	call   f0109027 <initialize_frame_info>
f0108f3b:	83 c4 10             	add    $0x10,%esp

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f0108f3e:	8b 0d 08 6b 85 f0    	mov    0xf0856b08,%ecx
f0108f44:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108f47:	89 d0                	mov    %edx,%eax
f0108f49:	c1 e0 02             	shl    $0x2,%eax
f0108f4c:	01 d0                	add    %edx,%eax
f0108f4e:	c1 e0 02             	shl    $0x2,%eax
f0108f51:	01 c8                	add    %ecx,%eax
f0108f53:	85 c0                	test   %eax,%eax
f0108f55:	75 14                	jne    f0108f6b <initialize_paging+0x31d>
f0108f57:	83 ec 04             	sub    $0x4,%esp
f0108f5a:	68 c0 e8 12 f0       	push   $0xf012e8c0
f0108f5f:	6a 76                	push   $0x76
f0108f61:	68 e3 e8 12 f0       	push   $0xf012e8e3
f0108f66:	e8 44 7f ff ff       	call   f0100eaf <_panic>
f0108f6b:	8b 0d 08 6b 85 f0    	mov    0xf0856b08,%ecx
f0108f71:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108f74:	89 d0                	mov    %edx,%eax
f0108f76:	c1 e0 02             	shl    $0x2,%eax
f0108f79:	01 d0                	add    %edx,%eax
f0108f7b:	c1 e0 02             	shl    $0x2,%eax
f0108f7e:	01 c8                	add    %ecx,%eax
f0108f80:	8b 15 c0 e7 83 f0    	mov    0xf083e7c0,%edx
f0108f86:	89 10                	mov    %edx,(%eax)
f0108f88:	8b 00                	mov    (%eax),%eax
f0108f8a:	85 c0                	test   %eax,%eax
f0108f8c:	74 20                	je     f0108fae <initialize_paging+0x360>
f0108f8e:	8b 15 c0 e7 83 f0    	mov    0xf083e7c0,%edx
f0108f94:	8b 1d 08 6b 85 f0    	mov    0xf0856b08,%ebx
f0108f9a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0108f9d:	89 c8                	mov    %ecx,%eax
f0108f9f:	c1 e0 02             	shl    $0x2,%eax
f0108fa2:	01 c8                	add    %ecx,%eax
f0108fa4:	c1 e0 02             	shl    $0x2,%eax
f0108fa7:	01 d8                	add    %ebx,%eax
f0108fa9:	89 42 04             	mov    %eax,0x4(%edx)
f0108fac:	eb 1a                	jmp    f0108fc8 <initialize_paging+0x37a>
f0108fae:	8b 0d 08 6b 85 f0    	mov    0xf0856b08,%ecx
f0108fb4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108fb7:	89 d0                	mov    %edx,%eax
f0108fb9:	c1 e0 02             	shl    $0x2,%eax
f0108fbc:	01 d0                	add    %edx,%eax
f0108fbe:	c1 e0 02             	shl    $0x2,%eax
f0108fc1:	01 c8                	add    %ecx,%eax
f0108fc3:	a3 c4 e7 83 f0       	mov    %eax,0xf083e7c4
f0108fc8:	8b 0d 08 6b 85 f0    	mov    0xf0856b08,%ecx
f0108fce:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108fd1:	89 d0                	mov    %edx,%eax
f0108fd3:	c1 e0 02             	shl    $0x2,%eax
f0108fd6:	01 d0                	add    %edx,%eax
f0108fd8:	c1 e0 02             	shl    $0x2,%eax
f0108fdb:	01 c8                	add    %ecx,%eax
f0108fdd:	a3 c0 e7 83 f0       	mov    %eax,0xf083e7c0
f0108fe2:	8b 0d 08 6b 85 f0    	mov    0xf0856b08,%ecx
f0108fe8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108feb:	89 d0                	mov    %edx,%eax
f0108fed:	c1 e0 02             	shl    $0x2,%eax
f0108ff0:	01 d0                	add    %edx,%eax
f0108ff2:	c1 e0 02             	shl    $0x2,%eax
f0108ff5:	01 c8                	add    %ecx,%eax
f0108ff7:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0108ffe:	a1 cc e7 83 f0       	mov    0xf083e7cc,%eax
f0109003:	40                   	inc    %eax
f0109004:	a3 cc e7 83 f0       	mov    %eax,0xf083e7cc
	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f0109009:	ff 45 f4             	incl   -0xc(%ebp)
f010900c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010900f:	a1 b8 e9 83 f0       	mov    0xf083e9b8,%eax
f0109014:	39 c2                	cmp    %eax,%edx
f0109016:	0f 82 01 ff ff ff    	jb     f0108f1d <initialize_paging+0x2cf>

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	initialize_disk_page_file();
f010901c:	e8 13 bc ff ff       	call   f0104c34 <initialize_disk_page_file>
}
f0109021:	90                   	nop
f0109022:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109025:	c9                   	leave  
f0109026:	c3                   	ret    

f0109027 <initialize_frame_info>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
void initialize_frame_info(struct FrameInfo *ptr_frame_info)
{
f0109027:	55                   	push   %ebp
f0109028:	89 e5                	mov    %esp,%ebp
f010902a:	83 ec 08             	sub    $0x8,%esp
	memset(ptr_frame_info, 0, sizeof(*ptr_frame_info));
f010902d:	83 ec 04             	sub    $0x4,%esp
f0109030:	6a 14                	push   $0x14
f0109032:	6a 00                	push   $0x0
f0109034:	ff 75 08             	pushl  0x8(%ebp)
f0109037:	e8 2d 1c 01 00       	call   f011ac69 <memset>
f010903c:	83 c4 10             	add    $0x10,%esp
}
f010903f:	90                   	nop
f0109040:	c9                   	leave  
f0109041:	c3                   	ret    

f0109042 <allocate_frame>:
//   If failed, it panic.
//
// Hint: use LIST_FIRST, LIST_REMOVE, and initialize_frame_info
// Hint: references should not be incremented
int allocate_frame(struct FrameInfo **ptr_frame_info)
{
f0109042:	55                   	push   %ebp
f0109043:	89 e5                	mov    %esp,%ebp
f0109045:	83 ec 18             	sub    $0x18,%esp
	bool lock_already_held = holding_kspinlock(&MemFrameLists.mfllock);
f0109048:	83 ec 0c             	sub    $0xc,%esp
f010904b:	68 e0 e7 83 f0       	push   $0xf083e7e0
f0109050:	e8 7b 6f 00 00       	call   f010ffd0 <holding_kspinlock>
f0109055:	83 c4 10             	add    $0x10,%esp
f0109058:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f010905b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010905f:	75 10                	jne    f0109071 <allocate_frame+0x2f>
	{
		acquire_kspinlock(&MemFrameLists.mfllock);
f0109061:	83 ec 0c             	sub    $0xc,%esp
f0109064:	68 e0 e7 83 f0       	push   $0xf083e7e0
f0109069:	e8 0d 6d 00 00       	call   f010fd7b <acquire_kspinlock>
f010906e:	83 c4 10             	add    $0x10,%esp
	}

	*ptr_frame_info = LIST_FIRST(&MemFrameLists.free_frame_list);
f0109071:	8b 15 c0 e7 83 f0    	mov    0xf083e7c0,%edx
f0109077:	8b 45 08             	mov    0x8(%ebp),%eax
f010907a:	89 10                	mov    %edx,(%eax)
	int c = 0;
f010907c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	if (*ptr_frame_info == NULL)
f0109083:	8b 45 08             	mov    0x8(%ebp),%eax
f0109086:	8b 00                	mov    (%eax),%eax
f0109088:	85 c0                	test   %eax,%eax
f010908a:	75 17                	jne    f01090a3 <allocate_frame+0x61>
	{
		panic("ERROR: Kernel run out of memory... allocate_frame cannot find a free frame.\n");
f010908c:	83 ec 04             	sub    $0x4,%esp
f010908f:	68 34 e9 12 f0       	push   $0xf012e934
f0109094:	68 a2 00 00 00       	push   $0xa2
f0109099:	68 e3 e8 12 f0       	push   $0xf012e8e3
f010909e:	e8 0c 7e ff ff       	call   f0100eaf <_panic>
	}

	LIST_REMOVE(&MemFrameLists.free_frame_list,*ptr_frame_info);
f01090a3:	8b 45 08             	mov    0x8(%ebp),%eax
f01090a6:	8b 00                	mov    (%eax),%eax
f01090a8:	85 c0                	test   %eax,%eax
f01090aa:	75 17                	jne    f01090c3 <allocate_frame+0x81>
f01090ac:	83 ec 04             	sub    $0x4,%esp
f01090af:	68 81 e9 12 f0       	push   $0xf012e981
f01090b4:	68 a5 00 00 00       	push   $0xa5
f01090b9:	68 e3 e8 12 f0       	push   $0xf012e8e3
f01090be:	e8 ec 7d ff ff       	call   f0100eaf <_panic>
f01090c3:	8b 45 08             	mov    0x8(%ebp),%eax
f01090c6:	8b 00                	mov    (%eax),%eax
f01090c8:	8b 00                	mov    (%eax),%eax
f01090ca:	85 c0                	test   %eax,%eax
f01090cc:	74 14                	je     f01090e2 <allocate_frame+0xa0>
f01090ce:	8b 45 08             	mov    0x8(%ebp),%eax
f01090d1:	8b 00                	mov    (%eax),%eax
f01090d3:	8b 00                	mov    (%eax),%eax
f01090d5:	8b 55 08             	mov    0x8(%ebp),%edx
f01090d8:	8b 12                	mov    (%edx),%edx
f01090da:	8b 52 04             	mov    0x4(%edx),%edx
f01090dd:	89 50 04             	mov    %edx,0x4(%eax)
f01090e0:	eb 0d                	jmp    f01090ef <allocate_frame+0xad>
f01090e2:	8b 45 08             	mov    0x8(%ebp),%eax
f01090e5:	8b 00                	mov    (%eax),%eax
f01090e7:	8b 40 04             	mov    0x4(%eax),%eax
f01090ea:	a3 c4 e7 83 f0       	mov    %eax,0xf083e7c4
f01090ef:	8b 45 08             	mov    0x8(%ebp),%eax
f01090f2:	8b 00                	mov    (%eax),%eax
f01090f4:	8b 40 04             	mov    0x4(%eax),%eax
f01090f7:	85 c0                	test   %eax,%eax
f01090f9:	74 13                	je     f010910e <allocate_frame+0xcc>
f01090fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01090fe:	8b 00                	mov    (%eax),%eax
f0109100:	8b 40 04             	mov    0x4(%eax),%eax
f0109103:	8b 55 08             	mov    0x8(%ebp),%edx
f0109106:	8b 12                	mov    (%edx),%edx
f0109108:	8b 12                	mov    (%edx),%edx
f010910a:	89 10                	mov    %edx,(%eax)
f010910c:	eb 0c                	jmp    f010911a <allocate_frame+0xd8>
f010910e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109111:	8b 00                	mov    (%eax),%eax
f0109113:	8b 00                	mov    (%eax),%eax
f0109115:	a3 c0 e7 83 f0       	mov    %eax,0xf083e7c0
f010911a:	8b 45 08             	mov    0x8(%ebp),%eax
f010911d:	8b 00                	mov    (%eax),%eax
f010911f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0109125:	8b 45 08             	mov    0x8(%ebp),%eax
f0109128:	8b 00                	mov    (%eax),%eax
f010912a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0109131:	a1 cc e7 83 f0       	mov    0xf083e7cc,%eax
f0109136:	48                   	dec    %eax
f0109137:	a3 cc e7 83 f0       	mov    %eax,0xf083e7cc
	}

	/**********************************************************
	 ***********************************************************/

	initialize_frame_info(*ptr_frame_info);
f010913c:	8b 45 08             	mov    0x8(%ebp),%eax
f010913f:	8b 00                	mov    (%eax),%eax
f0109141:	83 ec 0c             	sub    $0xc,%esp
f0109144:	50                   	push   %eax
f0109145:	e8 dd fe ff ff       	call   f0109027 <initialize_frame_info>
f010914a:	83 c4 10             	add    $0x10,%esp

	if (!lock_already_held)
f010914d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109151:	75 10                	jne    f0109163 <allocate_frame+0x121>
	{
		release_kspinlock(&MemFrameLists.mfllock);
f0109153:	83 ec 0c             	sub    $0xc,%esp
f0109156:	68 e0 e7 83 f0       	push   $0xf083e7e0
f010915b:	e8 c0 6c 00 00       	call   f010fe20 <release_kspinlock>
f0109160:	83 c4 10             	add    $0x10,%esp
	}

	return 0;
f0109163:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0109168:	c9                   	leave  
f0109169:	c3                   	ret    

f010916a <free_frame>:
//
// Return a frame to the free_frame_list.
// (This function should only be called when ptr_frame_info->references reaches 0.)
//
void free_frame(struct FrameInfo *ptr_frame_info)
{
f010916a:	55                   	push   %ebp
f010916b:	89 e5                	mov    %esp,%ebp
f010916d:	83 ec 18             	sub    $0x18,%esp
	bool lock_already_held = holding_kspinlock(&MemFrameLists.mfllock);
f0109170:	83 ec 0c             	sub    $0xc,%esp
f0109173:	68 e0 e7 83 f0       	push   $0xf083e7e0
f0109178:	e8 53 6e 00 00       	call   f010ffd0 <holding_kspinlock>
f010917d:	83 c4 10             	add    $0x10,%esp
f0109180:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f0109183:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109187:	75 10                	jne    f0109199 <free_frame+0x2f>
	{
		acquire_kspinlock(&MemFrameLists.mfllock);
f0109189:	83 ec 0c             	sub    $0xc,%esp
f010918c:	68 e0 e7 83 f0       	push   $0xf083e7e0
f0109191:	e8 e5 6b 00 00       	call   f010fd7b <acquire_kspinlock>
f0109196:	83 c4 10             	add    $0x10,%esp
	}
	{
		/*2012: clear it to ensure that its members (env, isBuffered, ...) become NULL*/
		initialize_frame_info(ptr_frame_info);
f0109199:	83 ec 0c             	sub    $0xc,%esp
f010919c:	ff 75 08             	pushl  0x8(%ebp)
f010919f:	e8 83 fe ff ff       	call   f0109027 <initialize_frame_info>
f01091a4:	83 c4 10             	add    $0x10,%esp
		/*=============================================================================*/
		// Fill this function in
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, ptr_frame_info);
f01091a7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01091ab:	75 17                	jne    f01091c4 <free_frame+0x5a>
f01091ad:	83 ec 04             	sub    $0x4,%esp
f01091b0:	68 c0 e8 12 f0       	push   $0xf012e8c0
f01091b5:	68 ce 00 00 00       	push   $0xce
f01091ba:	68 e3 e8 12 f0       	push   $0xf012e8e3
f01091bf:	e8 eb 7c ff ff       	call   f0100eaf <_panic>
f01091c4:	8b 15 c0 e7 83 f0    	mov    0xf083e7c0,%edx
f01091ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01091cd:	89 10                	mov    %edx,(%eax)
f01091cf:	8b 45 08             	mov    0x8(%ebp),%eax
f01091d2:	8b 00                	mov    (%eax),%eax
f01091d4:	85 c0                	test   %eax,%eax
f01091d6:	74 0d                	je     f01091e5 <free_frame+0x7b>
f01091d8:	a1 c0 e7 83 f0       	mov    0xf083e7c0,%eax
f01091dd:	8b 55 08             	mov    0x8(%ebp),%edx
f01091e0:	89 50 04             	mov    %edx,0x4(%eax)
f01091e3:	eb 08                	jmp    f01091ed <free_frame+0x83>
f01091e5:	8b 45 08             	mov    0x8(%ebp),%eax
f01091e8:	a3 c4 e7 83 f0       	mov    %eax,0xf083e7c4
f01091ed:	8b 45 08             	mov    0x8(%ebp),%eax
f01091f0:	a3 c0 e7 83 f0       	mov    %eax,0xf083e7c0
f01091f5:	8b 45 08             	mov    0x8(%ebp),%eax
f01091f8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01091ff:	a1 cc e7 83 f0       	mov    0xf083e7cc,%eax
f0109204:	40                   	inc    %eax
f0109205:	a3 cc e7 83 f0       	mov    %eax,0xf083e7cc
		//LOG_STATMENT(cprintf("FN # %d FREED",to_frame_number(ptr_frame_info)));
	}
	if (!lock_already_held)
f010920a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010920e:	75 10                	jne    f0109220 <free_frame+0xb6>
	{
		release_kspinlock(&MemFrameLists.mfllock);
f0109210:	83 ec 0c             	sub    $0xc,%esp
f0109213:	68 e0 e7 83 f0       	push   $0xf083e7e0
f0109218:	e8 03 6c 00 00       	call   f010fe20 <release_kspinlock>
f010921d:	83 c4 10             	add    $0x10,%esp
	}
}
f0109220:	90                   	nop
f0109221:	c9                   	leave  
f0109222:	c3                   	ret    

f0109223 <decrement_references>:
//
// Decrement the reference count on a frame
// freeing it if there are no more references.
//
void decrement_references(struct FrameInfo* ptr_frame_info)
{
f0109223:	55                   	push   %ebp
f0109224:	89 e5                	mov    %esp,%ebp
f0109226:	83 ec 08             	sub    $0x8,%esp
	if (--(ptr_frame_info->references) == 0)
f0109229:	8b 45 08             	mov    0x8(%ebp),%eax
f010922c:	8b 40 08             	mov    0x8(%eax),%eax
f010922f:	48                   	dec    %eax
f0109230:	8b 55 08             	mov    0x8(%ebp),%edx
f0109233:	66 89 42 08          	mov    %ax,0x8(%edx)
f0109237:	8b 45 08             	mov    0x8(%ebp),%eax
f010923a:	8b 40 08             	mov    0x8(%eax),%eax
f010923d:	66 85 c0             	test   %ax,%ax
f0109240:	75 0e                	jne    f0109250 <decrement_references+0x2d>
		free_frame(ptr_frame_info);
f0109242:	83 ec 0c             	sub    $0xc,%esp
f0109245:	ff 75 08             	pushl  0x8(%ebp)
f0109248:	e8 1d ff ff ff       	call   f010916a <free_frame>
f010924d:	83 c4 10             	add    $0x10,%esp
}
f0109250:	90                   	nop
f0109251:	c9                   	leave  
f0109252:	c3                   	ret    

f0109253 <get_page_table>:
//  TABLE_IN_MEMORY : if page table exists in main memory
//	TABLE_NOT_EXIST : if page table doesn't exist,
//

int get_page_table(uint32 *ptr_page_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f0109253:	55                   	push   %ebp
f0109254:	89 e5                	mov    %esp,%ebp
f0109256:	83 ec 28             	sub    $0x28,%esp
	//	cprintf("gpt .05\n");
	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0109259:	8b 45 0c             	mov    0xc(%ebp),%eax
f010925c:	c1 e8 16             	shr    $0x16,%eax
f010925f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109266:	8b 45 08             	mov    0x8(%ebp),%eax
f0109269:	01 d0                	add    %edx,%eax
f010926b:	8b 00                	mov    (%eax),%eax
f010926d:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//2022: check PERM_PRESENT of the table first before calculating its PA
	if ( (page_directory_entry & PERM_PRESENT) == PERM_PRESENT)
f0109270:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109273:	83 e0 01             	and    $0x1,%eax
f0109276:	85 c0                	test   %eax,%eax
f0109278:	74 74                	je     f01092ee <get_page_table+0x9b>
	{
		//	cprintf("gpt .07, page_directory_entry= %x \n",page_directory_entry);
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f010927a:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0109281:	77 1d                	ja     f01092a0 <get_page_table+0x4d>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f0109283:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109286:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010928b:	83 ec 0c             	sub    $0xc,%esp
f010928e:	50                   	push   %eax
f010928f:	e8 d6 08 00 00       	call   f0109b6a <kheap_virtual_address>
f0109294:	83 c4 10             	add    $0x10,%esp
f0109297:	89 c2                	mov    %eax,%edx
f0109299:	8b 45 10             	mov    0x10(%ebp),%eax
f010929c:	89 10                	mov    %edx,(%eax)
f010929e:	eb 44                	jmp    f01092e4 <get_page_table+0x91>
			//cprintf("===>get_page_table: page_dir_entry = %x ptr_page_table = %x\n", page_directory_entry,*ptr_page_table);
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f01092a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01092a3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01092a8:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01092ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01092ae:	c1 e8 0c             	shr    $0xc,%eax
f01092b1:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01092b4:	a1 b8 e9 83 f0       	mov    0xf083e9b8,%eax
f01092b9:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f01092bc:	72 17                	jb     f01092d5 <get_page_table+0x82>
f01092be:	ff 75 f0             	pushl  -0x10(%ebp)
f01092c1:	68 a0 e9 12 f0       	push   $0xf012e9a0
f01092c6:	68 fa 00 00 00       	push   $0xfa
f01092cb:	68 e3 e8 12 f0       	push   $0xf012e8e3
f01092d0:	e8 da 7b ff ff       	call   f0100eaf <_panic>
f01092d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01092d8:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01092dd:	89 c2                	mov    %eax,%edx
f01092df:	8b 45 10             	mov    0x10(%ebp),%eax
f01092e2:	89 10                	mov    %edx,(%eax)
		}
		return TABLE_IN_MEMORY;
f01092e4:	b8 00 00 00 00       	mov    $0x0,%eax
f01092e9:	e9 b9 00 00 00       	jmp    f01093a7 <get_page_table+0x154>
	}
	else if (page_directory_entry != 0) //the table exists but not in main mem, so it must be in sec mem
f01092ee:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01092f2:	0f 84 a1 00 00 00    	je     f0109399 <get_page_table+0x146>
f01092f8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01092fb:	89 45 e0             	mov    %eax,-0x20(%ebp)

//Ahmed 2010:
static __inline void
lcr2(uint32 val)
{
	__asm __volatile("movl %0,%%cr2" : : "r" (val));
f01092fe:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109301:	0f 22 d0             	mov    %eax,%cr2
		// Call the fault_handler() to load the table in memory for us ...
		//		cprintf("gpt .1\n, %x page_directory_entry\n", page_directory_entry);
		lcr2((uint32)virtual_address) ;

		//		cprintf("gpt .12\n");
		fault_handler(NULL);
f0109304:	83 ec 0c             	sub    $0xc,%esp
f0109307:	6a 00                	push   $0x0
f0109309:	e8 41 66 00 00       	call   f010f94f <fault_handler>
f010930e:	83 c4 10             	add    $0x10,%esp

		//		cprintf("gpt .15\n");
		// now the page_fault_handler() should have returned successfully and updated the
		// directory with the new table frame number in memory
		page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0109311:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109314:	c1 e8 16             	shr    $0x16,%eax
f0109317:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010931e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109321:	01 d0                	add    %edx,%eax
f0109323:	8b 00                	mov    (%eax),%eax
f0109325:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0109328:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f010932f:	77 1d                	ja     f010934e <get_page_table+0xfb>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f0109331:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109334:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109339:	83 ec 0c             	sub    $0xc,%esp
f010933c:	50                   	push   %eax
f010933d:	e8 28 08 00 00       	call   f0109b6a <kheap_virtual_address>
f0109342:	83 c4 10             	add    $0x10,%esp
f0109345:	89 c2                	mov    %eax,%edx
f0109347:	8b 45 10             	mov    0x10(%ebp),%eax
f010934a:	89 10                	mov    %edx,(%eax)
f010934c:	eb 44                	jmp    f0109392 <get_page_table+0x13f>
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f010934e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109351:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109356:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0109359:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010935c:	c1 e8 0c             	shr    $0xc,%eax
f010935f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0109362:	a1 b8 e9 83 f0       	mov    0xf083e9b8,%eax
f0109367:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010936a:	72 17                	jb     f0109383 <get_page_table+0x130>
f010936c:	ff 75 e8             	pushl  -0x18(%ebp)
f010936f:	68 a0 e9 12 f0       	push   $0xf012e9a0
f0109374:	68 12 01 00 00       	push   $0x112
f0109379:	68 e3 e8 12 f0       	push   $0xf012e8e3
f010937e:	e8 2c 7b ff ff       	call   f0100eaf <_panic>
f0109383:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109386:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010938b:	89 c2                	mov    %eax,%edx
f010938d:	8b 45 10             	mov    0x10(%ebp),%eax
f0109390:	89 10                	mov    %edx,(%eax)
		}

		return TABLE_IN_MEMORY;
f0109392:	b8 00 00 00 00       	mov    $0x0,%eax
f0109397:	eb 0e                	jmp    f01093a7 <get_page_table+0x154>
	}
	else // there is no table for this va anywhere. This is a new table required, so check if the user want creation
	{
		//		cprintf("gpt .2\n");
		*ptr_page_table = 0;
f0109399:	8b 45 10             	mov    0x10(%ebp),%eax
f010939c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return TABLE_NOT_EXIST;
f01093a2:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
f01093a7:	c9                   	leave  
f01093a8:	c3                   	ret    

f01093a9 <create_page_table>:

void * create_page_table(uint32 *ptr_directory, const uint32 virtual_address)
{
f01093a9:	55                   	push   %ebp
f01093aa:	89 e5                	mov    %esp,%ebp
f01093ac:	53                   	push   %ebx
f01093ad:	83 ec 14             	sub    $0x14,%esp
	//	b.	clear the TLB cache (using "tlbflush()")

	//change this "return" according to your answer

#if USE_KHEAP
	uint32 * ptr_page_table = kmalloc(PAGE_SIZE);
f01093b0:	83 ec 0c             	sub    $0xc,%esp
f01093b3:	68 00 10 00 00       	push   $0x1000
f01093b8:	e8 79 07 00 00       	call   f0109b36 <kmalloc>
f01093bd:	83 c4 10             	add    $0x10,%esp
f01093c0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("new table is created==================\n");
	if(ptr_page_table == NULL)
f01093c3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01093c7:	75 17                	jne    f01093e0 <create_page_table+0x37>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f01093c9:	83 ec 04             	sub    $0x4,%esp
f01093cc:	68 cf e9 12 f0       	push   $0xf012e9cf
f01093d1:	68 32 01 00 00       	push   $0x132
f01093d6:	68 e3 e8 12 f0       	push   $0xf012e8e3
f01093db:	e8 cf 7a ff ff       	call   f0100eaf <_panic>
	}
	//cprintf("Table is created for va %x\n", virtual_address);
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f01093e0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01093e3:	c1 e8 16             	shr    $0x16,%eax
f01093e6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01093ed:	8b 45 08             	mov    0x8(%ebp),%eax
f01093f0:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f01093f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01093f6:	83 ec 0c             	sub    $0xc,%esp
f01093f9:	50                   	push   %eax
f01093fa:	e8 85 07 00 00       	call   f0109b84 <kheap_physical_address>
f01093ff:	83 c4 10             	add    $0x10,%esp
f0109402:	83 c8 07             	or     $0x7,%eax
f0109405:	89 03                	mov    %eax,(%ebx)
			kheap_physical_address((unsigned int)ptr_page_table)
			, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);

	//================
	memset(ptr_page_table , 0, PAGE_SIZE);
f0109407:	83 ec 04             	sub    $0x4,%esp
f010940a:	68 00 10 00 00       	push   $0x1000
f010940f:	6a 00                	push   $0x0
f0109411:	ff 75 f4             	pushl  -0xc(%ebp)
f0109414:	e8 50 18 01 00       	call   f011ac69 <memset>
f0109419:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010941c:	0f 20 d8             	mov    %cr3,%eax
f010941f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0109422:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109425:	0f 22 d8             	mov    %eax,%cr3
	__static_cpt(ptr_directory, virtual_address, &ptr_page_table) ;
#endif

	//cprintf("KERNEL: NEW TABLE for va %x \n", virtual_address);

	return ptr_page_table;
f0109428:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010942b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010942e:	c9                   	leave  
f010942f:	c3                   	ret    

f0109430 <__static_cpt>:

void __static_cpt(uint32 *ptr_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f0109430:	55                   	push   %ebp
f0109431:	89 e5                	mov    %esp,%ebp
f0109433:	83 ec 28             	sub    $0x28,%esp
	struct FrameInfo* ptr_new_frame_info;
	int err = allocate_frame(&ptr_new_frame_info) ;
f0109436:	83 ec 0c             	sub    $0xc,%esp
f0109439:	8d 45 e0             	lea    -0x20(%ebp),%eax
f010943c:	50                   	push   %eax
f010943d:	e8 00 fc ff ff       	call   f0109042 <allocate_frame>
f0109442:	83 c4 10             	add    $0x10,%esp
f0109445:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uint32 phys_page_table = to_physical_address(ptr_new_frame_info);
f0109448:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010944b:	83 ec 0c             	sub    $0xc,%esp
f010944e:	50                   	push   %eax
f010944f:	e8 72 f7 ff ff       	call   f0108bc6 <to_physical_address>
f0109454:	83 c4 10             	add    $0x10,%esp
f0109457:	89 45 f0             	mov    %eax,-0x10(%ebp)
	*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table) ;
f010945a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010945d:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0109460:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109463:	c1 e8 0c             	shr    $0xc,%eax
f0109466:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0109469:	a1 b8 e9 83 f0       	mov    0xf083e9b8,%eax
f010946e:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f0109471:	72 17                	jb     f010948a <__static_cpt+0x5a>
f0109473:	ff 75 ec             	pushl  -0x14(%ebp)
f0109476:	68 a0 e9 12 f0       	push   $0xf012e9a0
f010947b:	68 4d 01 00 00       	push   $0x14d
f0109480:	68 e3 e8 12 f0       	push   $0xf012e8e3
f0109485:	e8 25 7a ff ff       	call   f0100eaf <_panic>
f010948a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010948d:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0109492:	89 c2                	mov    %eax,%edx
f0109494:	8b 45 10             	mov    0x10(%ebp),%eax
f0109497:	89 10                	mov    %edx,(%eax)
	ptr_new_frame_info->references = 1;
f0109499:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010949c:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);
f01094a2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01094a5:	c1 e8 16             	shr    $0x16,%eax
f01094a8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01094af:	8b 45 08             	mov    0x8(%ebp),%eax
f01094b2:	01 d0                	add    %edx,%eax
f01094b4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01094b7:	83 ca 07             	or     $0x7,%edx
f01094ba:	89 10                	mov    %edx,(%eax)
	//initialize new page table by 0's
	memset(*ptr_page_table , 0, PAGE_SIZE);
f01094bc:	8b 45 10             	mov    0x10(%ebp),%eax
f01094bf:	8b 00                	mov    (%eax),%eax
f01094c1:	83 ec 04             	sub    $0x4,%esp
f01094c4:	68 00 10 00 00       	push   $0x1000
f01094c9:	6a 00                	push   $0x0
f01094cb:	50                   	push   %eax
f01094cc:	e8 98 17 01 00       	call   f011ac69 <memset>
f01094d1:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f01094d4:	0f 20 d8             	mov    %cr3,%eax
f01094d7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f01094da:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01094dd:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f01094e0:	90                   	nop
f01094e1:	c9                   	leave  
f01094e2:	c3                   	ret    

f01094e3 <map_frame>:
//   0 on success
//
// Hint: implement using get_page_table() and unmap_frame().
//
int map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f01094e3:	55                   	push   %ebp
f01094e4:	89 e5                	mov    %esp,%ebp
f01094e6:	83 ec 28             	sub    $0x28,%esp
	// Fill this function in
	uint32 physical_address = to_physical_address(ptr_frame_info);
f01094e9:	ff 75 0c             	pushl  0xc(%ebp)
f01094ec:	e8 d5 f6 ff ff       	call   f0108bc6 <to_physical_address>
f01094f1:	83 c4 04             	add    $0x4,%esp
f01094f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ptr_page_table;
	if( get_page_table(ptr_page_directory, virtual_address, &ptr_page_table) == TABLE_NOT_EXIST)
f01094f7:	83 ec 04             	sub    $0x4,%esp
f01094fa:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f01094fd:	50                   	push   %eax
f01094fe:	ff 75 10             	pushl  0x10(%ebp)
f0109501:	ff 75 08             	pushl  0x8(%ebp)
f0109504:	e8 4a fd ff ff       	call   f0109253 <get_page_table>
f0109509:	83 c4 10             	add    $0x10,%esp
f010950c:	83 f8 01             	cmp    $0x1,%eax
f010950f:	75 1b                	jne    f010952c <map_frame+0x49>
		//page_directory_entry = ptr_page_directory[PDX(virtual_address)];
		//ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
		=============================================================================================*/
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, (uint32)virtual_address);
f0109511:	83 ec 08             	sub    $0x8,%esp
f0109514:	ff 75 10             	pushl  0x10(%ebp)
f0109517:	ff 75 08             	pushl  0x8(%ebp)
f010951a:	e8 8a fe ff ff       	call   f01093a9 <create_page_table>
f010951f:	83 c4 10             	add    $0x10,%esp
f0109522:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			//cprintf("======>page table created using kheap for VA %x at dir = %x PT = %x\n", virtual_address, ptr_page_directory[PDX(virtual_address)], ptr_page_table);
			uint32* ptr_page_table2 =NULL;
f0109525:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
#endif

	}

	//cprintf("NOW .. map add = %x ptr_page_table = %x PTX(virtual_address) = %d\n", virtual_address, ptr_page_table,PTX(virtual_address));
	uint32 page_table_entry = ptr_page_table[PTX(virtual_address)];
f010952c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010952f:	8b 55 10             	mov    0x10(%ebp),%edx
f0109532:	c1 ea 0c             	shr    $0xc,%edx
f0109535:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010953b:	c1 e2 02             	shl    $0x2,%edx
f010953e:	01 d0                	add    %edx,%eax
f0109540:	8b 00                	mov    (%eax),%eax
f0109542:	89 45 ec             	mov    %eax,-0x14(%ebp)

	}*/

	/*NEW'15 CORRECT SOLUTION*/
	//If already mapped
	if ((page_table_entry & PERM_PRESENT) == PERM_PRESENT)
f0109545:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109548:	83 e0 01             	and    $0x1,%eax
f010954b:	85 c0                	test   %eax,%eax
f010954d:	74 25                	je     f0109574 <map_frame+0x91>
	{
		//on this pa, then do nothing
		if (EXTRACT_ADDRESS(page_table_entry) == physical_address)
f010954f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109552:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109557:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010955a:	75 07                	jne    f0109563 <map_frame+0x80>
			return 0;
f010955c:	b8 00 00 00 00       	mov    $0x0,%eax
f0109561:	eb 68                	jmp    f01095cb <map_frame+0xe8>
		//on another pa, then unmap it
		else
			unmap_frame(ptr_page_directory , virtual_address);
f0109563:	83 ec 08             	sub    $0x8,%esp
f0109566:	ff 75 10             	pushl  0x10(%ebp)
f0109569:	ff 75 08             	pushl  0x8(%ebp)
f010956c:	e8 de 00 00 00       	call   f010964f <unmap_frame>
f0109571:	83 c4 10             	add    $0x10,%esp
	}
	ptr_frame_info->references++;
f0109574:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109577:	8b 40 08             	mov    0x8(%eax),%eax
f010957a:	40                   	inc    %eax
f010957b:	8b 55 0c             	mov    0xc(%ebp),%edx
f010957e:	66 89 42 08          	mov    %ax,0x8(%edx)

	/*********************************************************************************/
	/*NEW'23 el7:)
	 * map_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
	uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f0109582:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109585:	8b 55 10             	mov    0x10(%ebp),%edx
f0109588:	c1 ea 0c             	shr    $0xc,%edx
f010958b:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109591:	c1 e2 02             	shl    $0x2,%edx
f0109594:	01 d0                	add    %edx,%eax
f0109596:	8b 00                	mov    (%eax),%eax
f0109598:	25 00 0e 00 00       	and    $0xe00,%eax
f010959d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , pte_available_bits | perm | PERM_PRESENT);
f01095a0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01095a3:	8b 55 10             	mov    0x10(%ebp),%edx
f01095a6:	c1 ea 0c             	shr    $0xc,%edx
f01095a9:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01095af:	c1 e2 02             	shl    $0x2,%edx
f01095b2:	01 c2                	add    %eax,%edx
f01095b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01095b7:	0b 45 e8             	or     -0x18(%ebp),%eax
f01095ba:	89 c1                	mov    %eax,%ecx
f01095bc:	8b 45 14             	mov    0x14(%ebp),%eax
f01095bf:	09 c8                	or     %ecx,%eax
f01095c1:	83 c8 01             	or     $0x1,%eax
f01095c4:	89 02                	mov    %eax,(%edx)
	/*********************************************************************************/

	return 0;
f01095c6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01095cb:	c9                   	leave  
f01095cc:	c3                   	ret    

f01095cd <get_frame_info>:
//	2. buffered to 'virtual_address'
// If the page table entry corresponding to 'virtual_address' exists, then we store a pointer to the table in 'ptr_page_table'
// Return 0 if there is no frame mapped/buffered at virtual_address.
//
struct FrameInfo * get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table)
{
f01095cd:	55                   	push   %ebp
f01095ce:	89 e5                	mov    %esp,%ebp
f01095d0:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	uint32 ret =  get_page_table(ptr_page_directory, virtual_address, ptr_page_table) ;
f01095d3:	83 ec 04             	sub    $0x4,%esp
f01095d6:	ff 75 10             	pushl  0x10(%ebp)
f01095d9:	ff 75 0c             	pushl  0xc(%ebp)
f01095dc:	ff 75 08             	pushl  0x8(%ebp)
f01095df:	e8 6f fc ff ff       	call   f0109253 <get_page_table>
f01095e4:	83 c4 10             	add    $0x10,%esp
f01095e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if((*ptr_page_table) != 0)
f01095ea:	8b 45 10             	mov    0x10(%ebp),%eax
f01095ed:	8b 00                	mov    (%eax),%eax
f01095ef:	85 c0                	test   %eax,%eax
f01095f1:	74 55                	je     f0109648 <get_frame_info+0x7b>
	{
		uint32 index_page_table = PTX(virtual_address);
f01095f3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01095f6:	c1 e8 0c             	shr    $0xc,%eax
f01095f9:	25 ff 03 00 00       	and    $0x3ff,%eax
f01095fe:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 page_table_entry = (*ptr_page_table)[index_page_table];
f0109601:	8b 45 10             	mov    0x10(%ebp),%eax
f0109604:	8b 00                	mov    (%eax),%eax
f0109606:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109609:	c1 e2 02             	shl    $0x2,%edx
f010960c:	01 d0                	add    %edx,%eax
f010960e:	8b 00                	mov    (%eax),%eax
f0109610:	89 45 ec             	mov    %eax,-0x14(%ebp)

		/*2023 el7:)*///Make sure it has a frame number other than 0 (not just a marked page from the page allocator)
		/*2025 el7:)*///or if it's 0, make sure it's either present or buffered
		//if( page_table_entry != 0)
		//if((page_table_entry & ~0xFFF) != 0)
		if( ((page_table_entry & ~0xFFF) != 0) || ((page_table_entry & (PERM_PRESENT|PERM_BUFFERED)) != 0))
f0109613:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109616:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010961b:	85 c0                	test   %eax,%eax
f010961d:	75 0c                	jne    f010962b <get_frame_info+0x5e>
f010961f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109622:	25 01 02 00 00       	and    $0x201,%eax
f0109627:	85 c0                	test   %eax,%eax
f0109629:	74 16                	je     f0109641 <get_frame_info+0x74>
		{
			return to_frame_info( EXTRACT_ADDRESS ( page_table_entry ) );
f010962b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010962e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109633:	83 ec 0c             	sub    $0xc,%esp
f0109636:	50                   	push   %eax
f0109637:	e8 9d f5 ff ff       	call   f0108bd9 <to_frame_info>
f010963c:	83 c4 10             	add    $0x10,%esp
f010963f:	eb 0c                	jmp    f010964d <get_frame_info+0x80>
		}
		return 0;
f0109641:	b8 00 00 00 00       	mov    $0x0,%eax
f0109646:	eb 05                	jmp    f010964d <get_frame_info+0x80>
	}
	return 0;
f0109648:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010964d:	c9                   	leave  
f010964e:	c3                   	ret    

f010964f <unmap_frame>:
//
// Hint: implement using get_frame_info(),
// 	tlb_invalidate(), and decrement_references().
//
void unmap_frame(uint32 *ptr_page_directory, uint32 virtual_address)
{
f010964f:	55                   	push   %ebp
f0109650:	89 e5                	mov    %esp,%ebp
f0109652:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	uint32 *ptr_page_table;
	struct FrameInfo* ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_page_table);
f0109655:	83 ec 04             	sub    $0x4,%esp
f0109658:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010965b:	50                   	push   %eax
f010965c:	ff 75 0c             	pushl  0xc(%ebp)
f010965f:	ff 75 08             	pushl  0x8(%ebp)
f0109662:	e8 66 ff ff ff       	call   f01095cd <get_frame_info>
f0109667:	83 c4 10             	add    $0x10,%esp
f010966a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if( ptr_frame_info != 0 )
f010966d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109671:	74 7d                	je     f01096f0 <unmap_frame+0xa1>
	{
		if (ptr_frame_info->isBuffered && !CHECK_IF_KERNEL_ADDRESS((uint32)virtual_address))
f0109673:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109676:	8a 40 10             	mov    0x10(%eax),%al
f0109679:	84 c0                	test   %al,%al
f010967b:	74 1c                	je     f0109699 <unmap_frame+0x4a>
f010967d:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0109684:	77 13                	ja     f0109699 <unmap_frame+0x4a>
			cprintf("WARNING: Freeing BUFFERED frame at va %x!!!\n", virtual_address) ;
f0109686:	83 ec 08             	sub    $0x8,%esp
f0109689:	ff 75 0c             	pushl  0xc(%ebp)
f010968c:	68 ec e9 12 f0       	push   $0xf012e9ec
f0109691:	e8 c6 84 ff ff       	call   f0101b5c <cprintf>
f0109696:	83 c4 10             	add    $0x10,%esp
		decrement_references(ptr_frame_info);
f0109699:	83 ec 0c             	sub    $0xc,%esp
f010969c:	ff 75 f4             	pushl  -0xc(%ebp)
f010969f:	e8 7f fb ff ff       	call   f0109223 <decrement_references>
f01096a4:	83 c4 10             	add    $0x10,%esp

		/*********************************************************************************/
		/*NEW'23 el7:)
		 * unmap_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
		uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f01096a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01096aa:	8b 55 0c             	mov    0xc(%ebp),%edx
f01096ad:	c1 ea 0c             	shr    $0xc,%edx
f01096b0:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01096b6:	c1 e2 02             	shl    $0x2,%edx
f01096b9:	01 d0                	add    %edx,%eax
f01096bb:	8b 00                	mov    (%eax),%eax
f01096bd:	25 00 0e 00 00       	and    $0xe00,%eax
f01096c2:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_page_table[PTX(virtual_address)] = pte_available_bits;
f01096c5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01096c8:	8b 55 0c             	mov    0xc(%ebp),%edx
f01096cb:	c1 ea 0c             	shr    $0xc,%edx
f01096ce:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01096d4:	c1 e2 02             	shl    $0x2,%edx
f01096d7:	01 c2                	add    %eax,%edx
f01096d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01096dc:	89 02                	mov    %eax,(%edx)
		/*********************************************************************************/

		tlb_invalidate(ptr_page_directory, (void *)virtual_address);
f01096de:	8b 45 0c             	mov    0xc(%ebp),%eax
f01096e1:	83 ec 08             	sub    $0x8,%esp
f01096e4:	50                   	push   %eax
f01096e5:	ff 75 08             	pushl  0x8(%ebp)
f01096e8:	e8 33 f5 ff ff       	call   f0108c20 <tlb_invalidate>
f01096ed:	83 c4 10             	add    $0x10,%esp
	}
}
f01096f0:	90                   	nop
f01096f1:	c9                   	leave  
f01096f2:	c3                   	ret    

f01096f3 <loadtime_map_frame>:
// RETURNS:
//   0 on success
//
//
int loadtime_map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f01096f3:	55                   	push   %ebp
f01096f4:	89 e5                	mov    %esp,%ebp
f01096f6:	83 ec 28             	sub    $0x28,%esp
	uint32 physical_address = to_physical_address(ptr_frame_info);
f01096f9:	ff 75 0c             	pushl  0xc(%ebp)
f01096fc:	e8 c5 f4 ff ff       	call   f0108bc6 <to_physical_address>
f0109701:	83 c4 04             	add    $0x4,%esp
f0109704:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 *ptr_page_table;

	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0109707:	8b 45 10             	mov    0x10(%ebp),%eax
f010970a:	c1 e8 16             	shr    $0x16,%eax
f010970d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109714:	8b 45 08             	mov    0x8(%ebp),%eax
f0109717:	01 d0                	add    %edx,%eax
f0109719:	8b 00                	mov    (%eax),%eax
f010971b:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f010971e:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f0109725:	77 19                	ja     f0109740 <loadtime_map_frame+0x4d>
	{
		ptr_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f0109727:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010972a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010972f:	83 ec 0c             	sub    $0xc,%esp
f0109732:	50                   	push   %eax
f0109733:	e8 32 04 00 00       	call   f0109b6a <kheap_virtual_address>
f0109738:	83 c4 10             	add    $0x10,%esp
f010973b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010973e:	eb 40                	jmp    f0109780 <loadtime_map_frame+0x8d>
	}
	else
	{
		ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f0109740:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109743:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109748:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010974b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010974e:	c1 e8 0c             	shr    $0xc,%eax
f0109751:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0109754:	a1 b8 e9 83 f0       	mov    0xf083e9b8,%eax
f0109759:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010975c:	72 17                	jb     f0109775 <loadtime_map_frame+0x82>
f010975e:	ff 75 e8             	pushl  -0x18(%ebp)
f0109761:	68 a0 e9 12 f0       	push   $0xf012e9a0
f0109766:	68 0c 02 00 00       	push   $0x20c
f010976b:	68 e3 e8 12 f0       	push   $0xf012e8e3
f0109770:	e8 3a 77 ff ff       	call   f0100eaf <_panic>
f0109775:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109778:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010977d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	//if page table not exist, create it in memory and link it with the directory
	if (page_directory_entry == 0)
f0109780:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109784:	75 14                	jne    f010979a <loadtime_map_frame+0xa7>
	{
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, virtual_address);
f0109786:	83 ec 08             	sub    $0x8,%esp
f0109789:	ff 75 10             	pushl  0x10(%ebp)
f010978c:	ff 75 08             	pushl  0x8(%ebp)
f010978f:	e8 15 fc ff ff       	call   f01093a9 <create_page_table>
f0109794:	83 c4 10             	add    $0x10,%esp
f0109797:	89 45 f4             	mov    %eax,-0xc(%ebp)
			__static_cpt(ptr_page_directory, virtual_address, &ptr_page_table);
		}
#endif
	}

	ptr_frame_info->references++;
f010979a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010979d:	8b 40 08             	mov    0x8(%eax),%eax
f01097a0:	40                   	inc    %eax
f01097a1:	8b 55 0c             	mov    0xc(%ebp),%edx
f01097a4:	66 89 42 08          	mov    %ax,0x8(%edx)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , perm | PERM_PRESENT);
f01097a8:	8b 45 10             	mov    0x10(%ebp),%eax
f01097ab:	c1 e8 0c             	shr    $0xc,%eax
f01097ae:	25 ff 03 00 00       	and    $0x3ff,%eax
f01097b3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01097ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01097bd:	01 c2                	add    %eax,%edx
f01097bf:	8b 45 14             	mov    0x14(%ebp),%eax
f01097c2:	0b 45 f0             	or     -0x10(%ebp),%eax
f01097c5:	83 c8 01             	or     $0x1,%eax
f01097c8:	89 02                	mov    %eax,(%edx)

	return 0;
f01097ca:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01097cf:	c9                   	leave  
f01097d0:	c3                   	ret    

f01097d1 <calculate_available_frames>:



// calculate_available_frames:
struct freeFramesCounters calculate_available_frames()
{
f01097d1:	55                   	push   %ebp
f01097d2:	89 e5                	mov    %esp,%ebp
f01097d4:	57                   	push   %edi
f01097d5:	56                   	push   %esi
f01097d6:	53                   	push   %ebx
f01097d7:	83 ec 2c             	sub    $0x2c,%esp
	struct FrameInfo *ptr;
	uint32 totalFreeUnBuffered = 0 ;
f01097da:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint32 totalFreeBuffered = 0 ;
f01097e1:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	uint32 totalModified = 0 ;
f01097e8:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	bool lock_is_held = holding_kspinlock(&MemFrameLists.mfllock);
f01097ef:	83 ec 0c             	sub    $0xc,%esp
f01097f2:	68 e0 e7 83 f0       	push   $0xf083e7e0
f01097f7:	e8 d4 67 00 00       	call   f010ffd0 <holding_kspinlock>
f01097fc:	83 c4 10             	add    $0x10,%esp
f01097ff:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	if (!lock_is_held)
f0109802:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0109806:	75 10                	jne    f0109818 <calculate_available_frames+0x47>
	{
		acquire_kspinlock(&MemFrameLists.mfllock);
f0109808:	83 ec 0c             	sub    $0xc,%esp
f010980b:	68 e0 e7 83 f0       	push   $0xf083e7e0
f0109810:	e8 66 65 00 00       	call   f010fd7b <acquire_kspinlock>
f0109815:	83 c4 10             	add    $0x10,%esp
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f0109818:	a1 c0 e7 83 f0       	mov    0xf083e7c0,%eax
f010981d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0109820:	eb 1a                	jmp    f010983c <calculate_available_frames+0x6b>
		{
			if (ptr->isBuffered)
f0109822:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109825:	8a 40 10             	mov    0x10(%eax),%al
f0109828:	84 c0                	test   %al,%al
f010982a:	74 05                	je     f0109831 <calculate_available_frames+0x60>
				totalFreeBuffered++ ;
f010982c:	ff 45 dc             	incl   -0x24(%ebp)
f010982f:	eb 03                	jmp    f0109834 <calculate_available_frames+0x63>
			else
				totalFreeUnBuffered++ ;
f0109831:	ff 45 e0             	incl   -0x20(%ebp)
		acquire_kspinlock(&MemFrameLists.mfllock);
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f0109834:	a1 c8 e7 83 f0       	mov    0xf083e7c8,%eax
f0109839:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010983c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0109840:	74 07                	je     f0109849 <calculate_available_frames+0x78>
f0109842:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109845:	8b 00                	mov    (%eax),%eax
f0109847:	eb 05                	jmp    f010984e <calculate_available_frames+0x7d>
f0109849:	b8 00 00 00 00       	mov    $0x0,%eax
f010984e:	a3 c8 e7 83 f0       	mov    %eax,0xf083e7c8
f0109853:	a1 c8 e7 83 f0       	mov    0xf083e7c8,%eax
f0109858:	85 c0                	test   %eax,%eax
f010985a:	75 c6                	jne    f0109822 <calculate_available_frames+0x51>
f010985c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0109860:	75 c0                	jne    f0109822 <calculate_available_frames+0x51>
			else
				totalFreeUnBuffered++ ;
		}

		/*2023: UPDATE based on suggestion from T112 2023.Term1*/
		totalModified= LIST_SIZE(&MemFrameLists.modified_frame_list);
f0109862:	a1 dc e7 83 f0       	mov    0xf083e7dc,%eax
f0109867:	89 45 d8             	mov    %eax,-0x28(%ebp)
		//	LIST_FOREACH(ptr, &modified_frame_list)
		//	{
		//		totalModified++ ;
		//	}
	}
	if (!lock_is_held)
f010986a:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010986e:	75 10                	jne    f0109880 <calculate_available_frames+0xaf>
	{
		release_kspinlock(&MemFrameLists.mfllock);
f0109870:	83 ec 0c             	sub    $0xc,%esp
f0109873:	68 e0 e7 83 f0       	push   $0xf083e7e0
f0109878:	e8 a3 65 00 00       	call   f010fe20 <release_kspinlock>
f010987d:	83 c4 10             	add    $0x10,%esp
	}
	struct freeFramesCounters counters ;
	counters.freeBuffered = totalFreeBuffered ;
f0109880:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109883:	89 45 c8             	mov    %eax,-0x38(%ebp)
	counters.freeNotBuffered = totalFreeUnBuffered ;
f0109886:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109889:	89 45 cc             	mov    %eax,-0x34(%ebp)
	counters.modified = totalModified;
f010988c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010988f:	89 45 d0             	mov    %eax,-0x30(%ebp)
	return counters;
f0109892:	8b 45 08             	mov    0x8(%ebp),%eax
f0109895:	89 c3                	mov    %eax,%ebx
f0109897:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010989a:	ba 03 00 00 00       	mov    $0x3,%edx
f010989f:	89 df                	mov    %ebx,%edi
f01098a1:	89 c6                	mov    %eax,%esi
f01098a3:	89 d1                	mov    %edx,%ecx
f01098a5:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f01098a7:	8b 45 08             	mov    0x8(%ebp),%eax
f01098aa:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01098ad:	5b                   	pop    %ebx
f01098ae:	5e                   	pop    %esi
f01098af:	5f                   	pop    %edi
f01098b0:	5d                   	pop    %ebp
f01098b1:	c2 04 00             	ret    $0x4

f01098b4 <sharing_init>:
//===========================
// [1] INITIALIZE SHARES:
//===========================
//Initialize the list and the corresponding lock
void sharing_init()
{
f01098b4:	55                   	push   %ebp
f01098b5:	89 e5                	mov    %esp,%ebp
f01098b7:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	LIST_INIT(&AllShares.shares_list) ;
f01098ba:	c7 05 80 e6 83 f0 00 	movl   $0x0,0xf083e680
f01098c1:	00 00 00 
f01098c4:	c7 05 84 e6 83 f0 00 	movl   $0x0,0xf083e684
f01098cb:	00 00 00 
f01098ce:	c7 05 8c e6 83 f0 00 	movl   $0x0,0xf083e68c
f01098d5:	00 00 00 
	init_kspinlock(&AllShares.shareslock, "shares lock");
f01098d8:	83 ec 08             	sub    $0x8,%esp
f01098db:	68 1c ea 12 f0       	push   $0xf012ea1c
f01098e0:	68 90 e6 83 f0       	push   $0xf083e690
f01098e5:	e8 60 64 00 00       	call   f010fd4a <init_kspinlock>
f01098ea:	83 c4 10             	add    $0x10,%esp
	//init_sleeplock(&AllShares.sharessleeplock, "shares sleep lock");
#else
	panic("not handled when KERN HEAP is disabled");
#endif
}
f01098ed:	90                   	nop
f01098ee:	c9                   	leave  
f01098ef:	c3                   	ret    

f01098f0 <find_share>:
//Search for the given shared object in the "shares_list"
//Return:
//	a) if found: ptr to Share object
//	b) else: NULL
struct Share* find_share(int32 ownerID, char* name)
{
f01098f0:	55                   	push   %ebp
f01098f1:	89 e5                	mov    %esp,%ebp
f01098f3:	83 ec 18             	sub    $0x18,%esp
#if USE_KHEAP
	struct Share * ret = NULL;
f01098f6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool wasHeld = holding_kspinlock(&(AllShares.shareslock));
f01098fd:	83 ec 0c             	sub    $0xc,%esp
f0109900:	68 90 e6 83 f0       	push   $0xf083e690
f0109905:	e8 c6 66 00 00       	call   f010ffd0 <holding_kspinlock>
f010990a:	83 c4 10             	add    $0x10,%esp
f010990d:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (!wasHeld)
f0109910:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109914:	75 10                	jne    f0109926 <find_share+0x36>
	{
		acquire_kspinlock(&(AllShares.shareslock));
f0109916:	83 ec 0c             	sub    $0xc,%esp
f0109919:	68 90 e6 83 f0       	push   $0xf083e690
f010991e:	e8 58 64 00 00       	call   f010fd7b <acquire_kspinlock>
f0109923:	83 c4 10             	add    $0x10,%esp
	}
	{
		struct Share * shr ;
		LIST_FOREACH(shr, &(AllShares.shares_list))
f0109926:	a1 80 e6 83 f0       	mov    0xf083e680,%eax
f010992b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010992e:	eb 34                	jmp    f0109964 <find_share+0x74>
		{
			//cprintf("shared var name = %s compared with %s\n", name, shr->name);
			if(shr->ownerID == ownerID && strcmp(name, shr->name)==0)
f0109930:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109933:	8b 40 04             	mov    0x4(%eax),%eax
f0109936:	3b 45 08             	cmp    0x8(%ebp),%eax
f0109939:	75 21                	jne    f010995c <find_share+0x6c>
f010993b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010993e:	83 c0 08             	add    $0x8,%eax
f0109941:	83 ec 08             	sub    $0x8,%esp
f0109944:	50                   	push   %eax
f0109945:	ff 75 0c             	pushl  0xc(%ebp)
f0109948:	e8 3a 12 01 00       	call   f011ab87 <strcmp>
f010994d:	83 c4 10             	add    $0x10,%esp
f0109950:	85 c0                	test   %eax,%eax
f0109952:	75 08                	jne    f010995c <find_share+0x6c>
			{
				//cprintf("%s found\n", name);
				ret = shr;
f0109954:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109957:	89 45 f4             	mov    %eax,-0xc(%ebp)
				break;
f010995a:	eb 2f                	jmp    f010998b <find_share+0x9b>
	{
		acquire_kspinlock(&(AllShares.shareslock));
	}
	{
		struct Share * shr ;
		LIST_FOREACH(shr, &(AllShares.shares_list))
f010995c:	a1 88 e6 83 f0       	mov    0xf083e688,%eax
f0109961:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109964:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109968:	74 08                	je     f0109972 <find_share+0x82>
f010996a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010996d:	8b 40 58             	mov    0x58(%eax),%eax
f0109970:	eb 05                	jmp    f0109977 <find_share+0x87>
f0109972:	b8 00 00 00 00       	mov    $0x0,%eax
f0109977:	a3 88 e6 83 f0       	mov    %eax,0xf083e688
f010997c:	a1 88 e6 83 f0       	mov    0xf083e688,%eax
f0109981:	85 c0                	test   %eax,%eax
f0109983:	75 ab                	jne    f0109930 <find_share+0x40>
f0109985:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109989:	75 a5                	jne    f0109930 <find_share+0x40>
				ret = shr;
				break;
			}
		}
	}
	if (!wasHeld)
f010998b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010998f:	75 10                	jne    f01099a1 <find_share+0xb1>
	{
		release_kspinlock(&(AllShares.shareslock));
f0109991:	83 ec 0c             	sub    $0xc,%esp
f0109994:	68 90 e6 83 f0       	push   $0xf083e690
f0109999:	e8 82 64 00 00       	call   f010fe20 <release_kspinlock>
f010999e:	83 c4 10             	add    $0x10,%esp
	}
	return ret;
f01099a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
#else
	panic("not handled when KERN HEAP is disabled");
#endif
}
f01099a4:	c9                   	leave  
f01099a5:	c3                   	ret    

f01099a6 <size_of_shared_object>:

//==============================
// [3] Get Size of Share Object:
//==============================
int size_of_shared_object(int32 ownerID, char* shareName)
{
f01099a6:	55                   	push   %ebp
f01099a7:	89 e5                	mov    %esp,%ebp
f01099a9:	83 ec 18             	sub    $0x18,%esp
	// This function should return the size of the given shared object
	// RETURN:
	//	a) If found, return size of shared object
	//	b) Else, return E_SHARED_MEM_NOT_EXISTS
	//
	struct Share* ptr_share = find_share(ownerID, shareName);
f01099ac:	83 ec 08             	sub    $0x8,%esp
f01099af:	ff 75 0c             	pushl  0xc(%ebp)
f01099b2:	ff 75 08             	pushl  0x8(%ebp)
f01099b5:	e8 36 ff ff ff       	call   f01098f0 <find_share>
f01099ba:	83 c4 10             	add    $0x10,%esp
f01099bd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_share == NULL)
f01099c0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01099c4:	75 07                	jne    f01099cd <size_of_shared_object+0x27>
		return E_SHARED_MEM_NOT_EXISTS;
f01099c6:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f01099cb:	eb 06                	jmp    f01099d3 <size_of_shared_object+0x2d>
	else
		return ptr_share->size;
f01099cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01099d0:	8b 40 48             	mov    0x48(%eax),%eax

	return 0;
}
f01099d3:	c9                   	leave  
f01099d4:	c3                   	ret    

f01099d5 <alloc_share>:
//=====================================
//Allocates a new shared object and initialize its member
//It dynamically creates the "framesStorage"
//Return: allocatedObject (pointer to struct Share) passed by reference
struct Share* alloc_share(int32 ownerID, char* shareName, uint32 size, uint8 isWritable)
{
f01099d5:	55                   	push   %ebp
f01099d6:	89 e5                	mov    %esp,%ebp
f01099d8:	83 ec 18             	sub    $0x18,%esp
f01099db:	8b 45 14             	mov    0x14(%ebp),%eax
f01099de:	88 45 f4             	mov    %al,-0xc(%ebp)
	//TODO: [PROJECT'25.IM#3] SHARED MEMORY - #1 alloc_share
	//Your code is here
	//Comment the following line
	panic("alloc_share() is not implemented yet...!!");
f01099e1:	83 ec 04             	sub    $0x4,%esp
f01099e4:	68 28 ea 12 f0       	push   $0xf012ea28
f01099e9:	6a 6e                	push   $0x6e
f01099eb:	68 54 ea 12 f0       	push   $0xf012ea54
f01099f0:	e8 ba 74 ff ff       	call   f0100eaf <_panic>

f01099f5 <create_shared_object>:

//=========================
// [4] Create Share Object:
//=========================
int create_shared_object(int32 ownerID, char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f01099f5:	55                   	push   %ebp
f01099f6:	89 e5                	mov    %esp,%ebp
f01099f8:	83 ec 18             	sub    $0x18,%esp
f01099fb:	8b 45 14             	mov    0x14(%ebp),%eax
f01099fe:	88 45 f4             	mov    %al,-0xc(%ebp)
	//TODO: [PROJECT'25.IM#3] SHARED MEMORY - #3 create_shared_object
	//Your code is here
	//Comment the following line
	panic("create_shared_object() is not implemented yet...!!");
f0109a01:	83 ec 04             	sub    $0x4,%esp
f0109a04:	68 78 ea 12 f0       	push   $0xf012ea78
f0109a09:	6a 7a                	push   $0x7a
f0109a0b:	68 54 ea 12 f0       	push   $0xf012ea54
f0109a10:	e8 9a 74 ff ff       	call   f0100eaf <_panic>

f0109a15 <get_shared_object>:

//======================
// [5] Get Share Object:
//======================
int get_shared_object(int32 ownerID, char* shareName, void* virtual_address)
{
f0109a15:	55                   	push   %ebp
f0109a16:	89 e5                	mov    %esp,%ebp
f0109a18:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#3] SHARED MEMORY - #5 get_shared_object
	//Your code is here
	//Comment the following line
	panic("get_shared_object() is not implemented yet...!!");
f0109a1b:	83 ec 04             	sub    $0x4,%esp
f0109a1e:	68 ac ea 12 f0       	push   $0xf012eaac
f0109a23:	68 8f 00 00 00       	push   $0x8f
f0109a28:	68 54 ea 12 f0       	push   $0xf012ea54
f0109a2d:	e8 7d 74 ff ff       	call   f0100eaf <_panic>

f0109a32 <free_share>:
// [1] Delete Share Object:
//=========================
//delete the given shared object from the "shares_list"
//it should free its framesStorage and the share object itself
void free_share(struct Share* ptrShare)
{
f0109a32:	55                   	push   %ebp
f0109a33:	89 e5                	mov    %esp,%ebp
f0109a35:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.BONUS#5] EXIT #2 - free_share
	//Your code is here
	//Comment the following line
	panic("free_share() is not implemented yet...!!");
f0109a38:	83 ec 04             	sub    $0x4,%esp
f0109a3b:	68 dc ea 12 f0       	push   $0xf012eadc
f0109a40:	68 a9 00 00 00       	push   $0xa9
f0109a45:	68 54 ea 12 f0       	push   $0xf012ea54
f0109a4a:	e8 60 74 ff ff       	call   f0100eaf <_panic>

f0109a4f <delete_shared_object>:

//=========================
// [2] Free Share Object:
//=========================
int delete_shared_object(int32 sharedObjectID, void *startVA)
{
f0109a4f:	55                   	push   %ebp
f0109a50:	89 e5                	mov    %esp,%ebp
f0109a52:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.BONUS#5] EXIT #2 - delete_shared_object
	//Your code is here
	//Comment the following line
	panic("delete_shared_object() is not implemented yet...!!");
f0109a55:	83 ec 04             	sub    $0x4,%esp
f0109a58:	68 08 eb 12 f0       	push   $0xf012eb08
f0109a5d:	68 b5 00 00 00       	push   $0xb5
f0109a62:	68 54 ea 12 f0       	push   $0xf012ea54
f0109a67:	e8 43 74 ff ff       	call   f0100eaf <_panic>

f0109a6c <set_kheap_strategy>:
uint32 kheapPageAllocStart ;
uint32 kheapPageAllocBreak ;
uint32 kheapPlacementStrategy;

/*2025*/ //Replaced by setter & getter function
static inline void set_kheap_strategy(uint32 strategy){kheapPlacementStrategy = strategy;}
f0109a6c:	55                   	push   %ebp
f0109a6d:	89 e5                	mov    %esp,%ebp
f0109a6f:	8b 45 08             	mov    0x8(%ebp),%eax
f0109a72:	a3 c4 69 85 f0       	mov    %eax,0xf08569c4
f0109a77:	90                   	nop
f0109a78:	5d                   	pop    %ebp
f0109a79:	c3                   	ret    

f0109a7a <kheap_init>:
// [1] INITIALIZE KERNEL HEAP:
//==============================================
//TODO: [PROJECT'25.GM#2] KERNEL HEAP - #0 kheap_init [GIVEN]
//Remember to initialize locks (if any)
void kheap_init()
{
f0109a7a:	55                   	push   %ebp
f0109a7b:	89 e5                	mov    %esp,%ebp
f0109a7d:	83 ec 08             	sub    $0x8,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		initialize_dynamic_allocator(KERNEL_HEAP_START, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
f0109a80:	83 ec 08             	sub    $0x8,%esp
f0109a83:	68 00 00 00 f8       	push   $0xf8000000
f0109a88:	68 00 00 00 f6       	push   $0xf6000000
f0109a8d:	e8 8b 1b 01 00       	call   f011b61d <initialize_dynamic_allocator>
f0109a92:	83 c4 10             	add    $0x10,%esp
		set_kheap_strategy(KHP_PLACE_CUSTOMFIT);
f0109a95:	83 ec 0c             	sub    $0xc,%esp
f0109a98:	6a 05                	push   $0x5
f0109a9a:	e8 cd ff ff ff       	call   f0109a6c <set_kheap_strategy>
f0109a9f:	83 c4 10             	add    $0x10,%esp
		kheapPageAllocStart = dynAllocEnd + PAGE_SIZE;
f0109aa2:	a1 40 e5 83 f0       	mov    0xf083e540,%eax
f0109aa7:	05 00 10 00 00       	add    $0x1000,%eax
f0109aac:	a3 fc e8 83 f0       	mov    %eax,0xf083e8fc
		kheapPageAllocBreak = kheapPageAllocStart;
f0109ab1:	a1 fc e8 83 f0       	mov    0xf083e8fc,%eax
f0109ab6:	a3 10 6b 85 f0       	mov    %eax,0xf0856b10
	}
	//==================================================================================
	//==================================================================================
}
f0109abb:	90                   	nop
f0109abc:	c9                   	leave  
f0109abd:	c3                   	ret    

f0109abe <get_page>:

//==============================================
// [2] GET A PAGE FROM THE KERNEL FOR DA:
//==============================================
int get_page(void* va)
{
f0109abe:	55                   	push   %ebp
f0109abf:	89 e5                	mov    %esp,%ebp
f0109ac1:	83 ec 18             	sub    $0x18,%esp
	int ret = alloc_page(ptr_page_directory, ROUNDDOWN((uint32)va, PAGE_SIZE), PERM_WRITEABLE, 1);
f0109ac4:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ac7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109aca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109acd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109ad2:	89 c2                	mov    %eax,%edx
f0109ad4:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0109ad9:	6a 01                	push   $0x1
f0109adb:	6a 02                	push   $0x2
f0109add:	52                   	push   %edx
f0109ade:	50                   	push   %eax
f0109adf:	e8 6a 02 00 00       	call   f0109d4e <alloc_page>
f0109ae4:	83 c4 10             	add    $0x10,%esp
f0109ae7:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret < 0)
f0109aea:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109aee:	79 14                	jns    f0109b04 <get_page+0x46>
		panic("get_page() in kern: failed to allocate page from the kernel");
f0109af0:	83 ec 04             	sub    $0x4,%esp
f0109af3:	68 3c eb 12 f0       	push   $0xf012eb3c
f0109af8:	6a 29                	push   $0x29
f0109afa:	68 78 eb 12 f0       	push   $0xf012eb78
f0109aff:	e8 ab 73 ff ff       	call   f0100eaf <_panic>
	return 0;
f0109b04:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0109b09:	c9                   	leave  
f0109b0a:	c3                   	ret    

f0109b0b <return_page>:

//==============================================
// [3] RETURN A PAGE FROM THE DA TO KERNEL:
//==============================================
void return_page(void* va)
{
f0109b0b:	55                   	push   %ebp
f0109b0c:	89 e5                	mov    %esp,%ebp
f0109b0e:	83 ec 18             	sub    $0x18,%esp
	unmap_frame(ptr_page_directory, ROUNDDOWN((uint32)va, PAGE_SIZE));
f0109b11:	8b 45 08             	mov    0x8(%ebp),%eax
f0109b14:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109b17:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109b1a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109b1f:	89 c2                	mov    %eax,%edx
f0109b21:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0109b26:	83 ec 08             	sub    $0x8,%esp
f0109b29:	52                   	push   %edx
f0109b2a:	50                   	push   %eax
f0109b2b:	e8 1f fb ff ff       	call   f010964f <unmap_frame>
f0109b30:	83 c4 10             	add    $0x10,%esp
}
f0109b33:	90                   	nop
f0109b34:	c9                   	leave  
f0109b35:	c3                   	ret    

f0109b36 <kmalloc>:
//==================================================================================//
//===================================
// [1] ALLOCATE SPACE IN KERNEL HEAP:
//===================================
void* kmalloc(unsigned int size)
{
f0109b36:	55                   	push   %ebp
f0109b37:	89 e5                	mov    %esp,%ebp
f0109b39:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.GM#2] KERNEL HEAP - #1 kmalloc
	//Your code is here
	//Comment the following line
	kpanic_into_prompt("kmalloc() is not implemented yet...!!");
f0109b3c:	83 ec 04             	sub    $0x4,%esp
f0109b3f:	68 8c eb 12 f0       	push   $0xf012eb8c
f0109b44:	6a 40                	push   $0x40
f0109b46:	68 78 eb 12 f0       	push   $0xf012eb78
f0109b4b:	e8 93 74 ff ff       	call   f0100fe3 <_panic_into_prompt>

f0109b50 <kfree>:

//=================================
// [2] FREE SPACE FROM KERNEL HEAP:
//=================================
void kfree(void* virtual_address)
{
f0109b50:	55                   	push   %ebp
f0109b51:	89 e5                	mov    %esp,%ebp
f0109b53:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.GM#2] KERNEL HEAP - #2 kfree
	//Your code is here
	//Comment the following line
	panic("kfree() is not implemented yet...!!");
f0109b56:	83 ec 04             	sub    $0x4,%esp
f0109b59:	68 b4 eb 12 f0       	push   $0xf012ebb4
f0109b5e:	6a 4d                	push   $0x4d
f0109b60:	68 78 eb 12 f0       	push   $0xf012eb78
f0109b65:	e8 45 73 ff ff       	call   f0100eaf <_panic>

f0109b6a <kheap_virtual_address>:

//=================================
// [3] FIND VA OF GIVEN PA:
//=================================
unsigned int kheap_virtual_address(unsigned int physical_address)
{
f0109b6a:	55                   	push   %ebp
f0109b6b:	89 e5                	mov    %esp,%ebp
f0109b6d:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.GM#2] KERNEL HEAP - #3 kheap_virtual_address
	//Your code is here
	//Comment the following line
	panic("kheap_virtual_address() is not implemented yet...!!");
f0109b70:	83 ec 04             	sub    $0x4,%esp
f0109b73:	68 d8 eb 12 f0       	push   $0xf012ebd8
f0109b78:	6a 58                	push   $0x58
f0109b7a:	68 78 eb 12 f0       	push   $0xf012eb78
f0109b7f:	e8 2b 73 ff ff       	call   f0100eaf <_panic>

f0109b84 <kheap_physical_address>:

//=================================
// [4] FIND PA OF GIVEN VA:
//=================================
unsigned int kheap_physical_address(unsigned int virtual_address)
{
f0109b84:	55                   	push   %ebp
f0109b85:	89 e5                	mov    %esp,%ebp
f0109b87:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.GM#2] KERNEL HEAP - #4 kheap_physical_address
	//Your code is here
	//Comment the following line
	panic("kheap_physical_address() is not implemented yet...!!");
f0109b8a:	83 ec 04             	sub    $0x4,%esp
f0109b8d:	68 0c ec 12 f0       	push   $0xf012ec0c
f0109b92:	6a 65                	push   $0x65
f0109b94:	68 78 eb 12 f0       	push   $0xf012eb78
f0109b99:	e8 11 73 ff ff       	call   f0100eaf <_panic>

f0109b9e <krealloc>:
//	A call with new_size = zero is equivalent to kfree().

extern __inline__ uint32 get_block_size(void *va);

void *krealloc(void *virtual_address, uint32 new_size)
{
f0109b9e:	55                   	push   %ebp
f0109b9f:	89 e5                	mov    %esp,%ebp
f0109ba1:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.BONUS#2] KERNEL REALLOC - krealloc
	//Your code is here
	//Comment the following line
	panic("krealloc() is not implemented yet...!!");
f0109ba4:	83 ec 04             	sub    $0x4,%esp
f0109ba7:	68 44 ec 12 f0       	push   $0xf012ec44
f0109bac:	6a 7e                	push   $0x7e
f0109bae:	68 78 eb 12 f0       	push   $0xf012eb78
f0109bb3:	e8 f7 72 ff ff       	call   f0100eaf <_panic>

f0109bb8 <to_frame_info>:
{
	return to_frame_number(ptr_frame_info) << PGSHIFT;
}

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0109bb8:	55                   	push   %ebp
f0109bb9:	89 e5                	mov    %esp,%ebp
f0109bbb:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0109bbe:	8b 45 08             	mov    0x8(%ebp),%eax
f0109bc1:	c1 e8 0c             	shr    $0xc,%eax
f0109bc4:	89 c2                	mov    %eax,%edx
f0109bc6:	a1 b8 e9 83 f0       	mov    0xf083e9b8,%eax
f0109bcb:	39 c2                	cmp    %eax,%edx
f0109bcd:	72 14                	jb     f0109be3 <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f0109bcf:	83 ec 04             	sub    $0x4,%esp
f0109bd2:	68 6c ec 12 f0       	push   $0xf012ec6c
f0109bd7:	6a 4e                	push   $0x4e
f0109bd9:	68 91 ec 12 f0       	push   $0xf012ec91
f0109bde:	e8 cc 72 ff ff       	call   f0100eaf <_panic>
	return &frames_info[PPN(physical_address)];
f0109be3:	8b 15 08 6b 85 f0    	mov    0xf0856b08,%edx
f0109be9:	8b 45 08             	mov    0x8(%ebp),%eax
f0109bec:	c1 e8 0c             	shr    $0xc,%eax
f0109bef:	89 c1                	mov    %eax,%ecx
f0109bf1:	89 c8                	mov    %ecx,%eax
f0109bf3:	c1 e0 02             	shl    $0x2,%eax
f0109bf6:	01 c8                	add    %ecx,%eax
f0109bf8:	c1 e0 02             	shl    $0x2,%eax
f0109bfb:	01 d0                	add    %edx,%eax
}
f0109bfd:	c9                   	leave  
f0109bfe:	c3                   	ret    

f0109bff <pt_set_page_permissions>:
//	1. Set to 1 all "permissions_to_set"
//	2. Set to 0 all "permissions_to_reset"
//It's expected that the page table already exist. If not, the function should panic
//REMEMBER: to invalidate the TLB cache
inline void pt_set_page_permissions(uint32* directory, uint32 virtual_address, uint32 permissions_to_set, uint32 permissions_to_clear)
{
f0109bff:	55                   	push   %ebp
f0109c00:	89 e5                	mov    %esp,%ebp
f0109c02:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(directory, virtual_address, &ptr_page_table);
f0109c05:	83 ec 04             	sub    $0x4,%esp
f0109c08:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0109c0b:	50                   	push   %eax
f0109c0c:	ff 75 0c             	pushl  0xc(%ebp)
f0109c0f:	ff 75 08             	pushl  0x8(%ebp)
f0109c12:	e8 3c f6 ff ff       	call   f0109253 <get_page_table>
f0109c17:	83 c4 10             	add    $0x10,%esp
f0109c1a:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f0109c1d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109c20:	85 c0                	test   %eax,%eax
f0109c22:	74 64                	je     f0109c88 <pt_set_page_permissions+0x89>
	{
		ptr_page_table[PTX(virtual_address)] |= (permissions_to_set);
f0109c24:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109c27:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109c2a:	c1 ea 0c             	shr    $0xc,%edx
f0109c2d:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109c33:	c1 e2 02             	shl    $0x2,%edx
f0109c36:	01 c2                	add    %eax,%edx
f0109c38:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109c3b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0109c3e:	c1 e9 0c             	shr    $0xc,%ecx
f0109c41:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0109c47:	c1 e1 02             	shl    $0x2,%ecx
f0109c4a:	01 c8                	add    %ecx,%eax
f0109c4c:	8b 00                	mov    (%eax),%eax
f0109c4e:	0b 45 10             	or     0x10(%ebp),%eax
f0109c51:	89 02                	mov    %eax,(%edx)
		ptr_page_table[PTX(virtual_address)] &= (~permissions_to_clear);
f0109c53:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109c56:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109c59:	c1 ea 0c             	shr    $0xc,%edx
f0109c5c:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109c62:	c1 e2 02             	shl    $0x2,%edx
f0109c65:	01 d0                	add    %edx,%eax
f0109c67:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109c6a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0109c6d:	c1 e9 0c             	shr    $0xc,%ecx
f0109c70:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0109c76:	c1 e1 02             	shl    $0x2,%ecx
f0109c79:	01 ca                	add    %ecx,%edx
f0109c7b:	8b 12                	mov    (%edx),%edx
f0109c7d:	8b 4d 14             	mov    0x14(%ebp),%ecx
f0109c80:	f7 d1                	not    %ecx
f0109c82:	21 ca                	and    %ecx,%edx
f0109c84:	89 10                	mov    %edx,(%eax)
f0109c86:	eb 27                	jmp    f0109caf <pt_set_page_permissions+0xb0>

	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		cprintf("va=%x not exist and has no page table\n", virtual_address);
f0109c88:	83 ec 08             	sub    $0x8,%esp
f0109c8b:	ff 75 0c             	pushl  0xc(%ebp)
f0109c8e:	68 ac ec 12 f0       	push   $0xf012ecac
f0109c93:	e8 c4 7e ff ff       	call   f0101b5c <cprintf>
f0109c98:	83 c4 10             	add    $0x10,%esp
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_set_page_permissions() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f0109c9b:	83 ec 04             	sub    $0x4,%esp
f0109c9e:	68 d4 ec 12 f0       	push   $0xf012ecd4
f0109ca3:	6a 27                	push   $0x27
f0109ca5:	68 48 ed 12 f0       	push   $0xf012ed48
f0109caa:	e8 00 72 ff ff       	call   f0100eaf <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	//tlb_invalidate(NULL, (void *)virtual_address);
	tlb_invalidate(directory, (void *)virtual_address);
f0109caf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109cb2:	83 ec 08             	sub    $0x8,%esp
f0109cb5:	50                   	push   %eax
f0109cb6:	ff 75 08             	pushl  0x8(%ebp)
f0109cb9:	e8 62 ef ff ff       	call   f0108c20 <tlb_invalidate>
f0109cbe:	83 c4 10             	add    $0x10,%esp
}
f0109cc1:	90                   	nop
f0109cc2:	c9                   	leave  
f0109cc3:	c3                   	ret    

f0109cc4 <pt_get_page_permissions>:
//2) GET PAGE PERMISSIONS
//===============================
//Should get ALL page permissions of the given VA
//If the page table not exist, return -1
inline int pt_get_page_permissions(uint32* directory, uint32 virtual_address )
{
f0109cc4:	55                   	push   %ebp
f0109cc5:	89 e5                	mov    %esp,%ebp
f0109cc7:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("pt_get_page_permissions() is not implemented yet!");
f0109cca:	83 ec 04             	sub    $0x4,%esp
f0109ccd:	68 64 ed 12 f0       	push   $0xf012ed64
f0109cd2:	6a 38                	push   $0x38
f0109cd4:	68 48 ed 12 f0       	push   $0xf012ed48
f0109cd9:	e8 d1 71 ff ff       	call   f0100eaf <_panic>

f0109cde <pt_clear_page_table_entry>:
//Should clear the entire entry of the page table for the given VA
//If the page table not exist, return -1
//It's expected that the page table already exist. If not, the function should panic
//REMEMBER: to invalidate the TLB cache
inline void pt_clear_page_table_entry(uint32* directory, uint32 virtual_address)
{
f0109cde:	55                   	push   %ebp
f0109cdf:	89 e5                	mov    %esp,%ebp
f0109ce1:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("pt_clear_page_table_entry() is not implemented yet!");
f0109ce4:	83 ec 04             	sub    $0x4,%esp
f0109ce7:	68 98 ed 12 f0       	push   $0xf012ed98
f0109cec:	6a 46                	push   $0x46
f0109cee:	68 48 ed 12 f0       	push   $0xf012ed48
f0109cf3:	e8 b7 71 ff ff       	call   f0100eaf <_panic>

f0109cf8 <virtual_to_physical>:
//1) ADDRESS CONVERTION (VA->PA)
//===============================
//return the physical address corresponding to given virtual_address
//If the page or the page table is not present, return -1
inline uint32 virtual_to_physical(uint32* directory, uint32 virtual_address)
{
f0109cf8:	55                   	push   %ebp
f0109cf9:	89 e5                	mov    %esp,%ebp
f0109cfb:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("Function is not implemented yet!");
f0109cfe:	83 ec 04             	sub    $0x4,%esp
f0109d01:	68 cc ed 12 f0       	push   $0xf012edcc
f0109d06:	6a 58                	push   $0x58
f0109d08:	68 48 ed 12 f0       	push   $0xf012ed48
f0109d0d:	e8 9d 71 ff ff       	call   f0100eaf <_panic>

f0109d12 <physical_to_virtual>:
//===============================
//return the VIRTUAL address corresponding to given physical address
//If multiple VA's, return the first occurrence
//If not found, return 0xFFFFFFFF
inline uint32 physical_to_virtual(uint32* directory, uint32 physical_address)
{
f0109d12:	55                   	push   %ebp
f0109d13:	89 e5                	mov    %esp,%ebp
f0109d15:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("Function is not implemented yet!");
f0109d18:	83 ec 04             	sub    $0x4,%esp
f0109d1b:	68 cc ed 12 f0       	push   $0xf012edcc
f0109d20:	6a 65                	push   $0x65
f0109d22:	68 48 ed 12 f0       	push   $0xf012ed48
f0109d27:	e8 83 71 ff ff       	call   f0100eaf <_panic>

f0109d2c <num_of_references>:
//===============================
//3) NUMBER OF REFERENCES
//===============================
//return the number of page references on the frame at the given physical address
inline uint32 num_of_references(uint32 physical_address)
{
f0109d2c:	55                   	push   %ebp
f0109d2d:	89 e5                	mov    %esp,%ebp
f0109d2f:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB4 Example#1: fill this function.
	//Comment the following line
//	panic("Function is not implemented yet!");
	struct FrameInfo* ptr_fi = to_frame_info(physical_address);
f0109d32:	83 ec 0c             	sub    $0xc,%esp
f0109d35:	ff 75 08             	pushl  0x8(%ebp)
f0109d38:	e8 7b fe ff ff       	call   f0109bb8 <to_frame_info>
f0109d3d:	83 c4 10             	add    $0x10,%esp
f0109d40:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return ptr_fi->references;
f0109d43:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109d46:	8b 40 08             	mov    0x8(%eax),%eax
f0109d49:	0f b7 c0             	movzwl %ax,%eax
}
f0109d4c:	c9                   	leave  
f0109d4d:	c3                   	ret    

f0109d4e <alloc_page>:
//	0 on success,
//	1 if already mapped
//  E_NO_MEM if no memory
//HINT: remember to free the allocated frame if there is no space for the necessary page table
inline int alloc_page(uint32* directory, uint32 va, uint32 perms, bool set_to_zero)
{
f0109d4e:	55                   	push   %ebp
f0109d4f:	89 e5                	mov    %esp,%ebp
f0109d51:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB4 Example#2: fill this function.
	//Comment the following line
	//panic("Function is not implemented yet!");
	uint32* ptr_table ;
	struct FrameInfo* ptr_fi = get_frame_info(directory, va, &ptr_table);
f0109d54:	83 ec 04             	sub    $0x4,%esp
f0109d57:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0109d5a:	50                   	push   %eax
f0109d5b:	ff 75 0c             	pushl  0xc(%ebp)
f0109d5e:	ff 75 08             	pushl  0x8(%ebp)
f0109d61:	e8 67 f8 ff ff       	call   f01095cd <get_frame_info>
f0109d66:	83 c4 10             	add    $0x10,%esp
f0109d69:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (ptr_fi != NULL) {
f0109d6c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109d6f:	85 c0                	test   %eax,%eax
f0109d71:	74 07                	je     f0109d7a <alloc_page+0x2c>
		return 1;
f0109d73:	b8 01 00 00 00       	mov    $0x1,%eax
f0109d78:	eb 75                	jmp    f0109def <alloc_page+0xa1>
	}
	else {
		int ret = allocate_frame(&ptr_fi);
f0109d7a:	83 ec 0c             	sub    $0xc,%esp
f0109d7d:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0109d80:	50                   	push   %eax
f0109d81:	e8 bc f2 ff ff       	call   f0109042 <allocate_frame>
f0109d86:	83 c4 10             	add    $0x10,%esp
f0109d89:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (ret == E_NO_MEM) {
f0109d8c:	83 7d f4 fc          	cmpl   $0xfffffffc,-0xc(%ebp)
f0109d90:	75 07                	jne    f0109d99 <alloc_page+0x4b>
			return E_NO_MEM;
f0109d92:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
f0109d97:	eb 56                	jmp    f0109def <alloc_page+0xa1>
		}
		ret = map_frame(directory, ptr_fi, va, perms);
f0109d99:	8b 55 10             	mov    0x10(%ebp),%edx
f0109d9c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109d9f:	52                   	push   %edx
f0109da0:	ff 75 0c             	pushl  0xc(%ebp)
f0109da3:	50                   	push   %eax
f0109da4:	ff 75 08             	pushl  0x8(%ebp)
f0109da7:	e8 37 f7 ff ff       	call   f01094e3 <map_frame>
f0109dac:	83 c4 10             	add    $0x10,%esp
f0109daf:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (ret == E_NO_MEM) {
f0109db2:	83 7d f4 fc          	cmpl   $0xfffffffc,-0xc(%ebp)
f0109db6:	75 16                	jne    f0109dce <alloc_page+0x80>
			free_frame(ptr_fi);
f0109db8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109dbb:	83 ec 0c             	sub    $0xc,%esp
f0109dbe:	50                   	push   %eax
f0109dbf:	e8 a6 f3 ff ff       	call   f010916a <free_frame>
f0109dc4:	83 c4 10             	add    $0x10,%esp
			return E_NO_MEM;
f0109dc7:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
f0109dcc:	eb 21                	jmp    f0109def <alloc_page+0xa1>
		}
		if (set_to_zero) {
f0109dce:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f0109dd2:	74 16                	je     f0109dea <alloc_page+0x9c>
			memset((void*)va, 0, PAGE_SIZE);
f0109dd4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109dd7:	83 ec 04             	sub    $0x4,%esp
f0109dda:	68 00 10 00 00       	push   $0x1000
f0109ddf:	6a 00                	push   $0x0
f0109de1:	50                   	push   %eax
f0109de2:	e8 82 0e 01 00       	call   f011ac69 <memset>
f0109de7:	83 c4 10             	add    $0x10,%esp
		}
		return 0;
f0109dea:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0109def:	c9                   	leave  
f0109df0:	c3                   	ret    

f0109df1 <alloc_shared_page>:
//Return
//	0 on success,
//  E_NO_MEM if no memory
//HINT: remember to free the allocated frame if there is no space for the necessary page table
inline int alloc_shared_page(uint32* page_dir1, uint32 va1,uint32* page_dir2, uint32 va2, uint32 perms)
{
f0109df1:	55                   	push   %ebp
f0109df2:	89 e5                	mov    %esp,%ebp
f0109df4:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("Function is not implemented yet!");
f0109df7:	83 ec 04             	sub    $0x4,%esp
f0109dfa:	68 cc ed 12 f0       	push   $0xf012edcc
f0109dff:	68 a9 00 00 00       	push   $0xa9
f0109e04:	68 48 ed 12 f0       	push   $0xf012ed48
f0109e09:	e8 a1 70 ff ff       	call   f0100eaf <_panic>

f0109e0e <del_page_table>:
//	1. removing the link between the directory and the table and
//	2. adding the frame of the table to the free frame list.

//REMEMBER: to invalidate the TLB cache
inline void del_page_table(uint32* page_dir, uint32 va)
{
f0109e0e:	55                   	push   %ebp
f0109e0f:	89 e5                	mov    %esp,%ebp
f0109e11:	83 ec 18             	sub    $0x18,%esp
	//Comment the following line
	//panic("Function is not implemented yet!");

	// get the page table of the given virtual address
	uint32 * ptr_page_table ;
	get_page_table(ptr_page_directory, va, &ptr_page_table);
f0109e14:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0109e19:	83 ec 04             	sub    $0x4,%esp
f0109e1c:	8d 55 ec             	lea    -0x14(%ebp),%edx
f0109e1f:	52                   	push   %edx
f0109e20:	ff 75 0c             	pushl  0xc(%ebp)
f0109e23:	50                   	push   %eax
f0109e24:	e8 2a f4 ff ff       	call   f0109253 <get_page_table>
f0109e29:	83 c4 10             	add    $0x10,%esp

	if (ptr_page_table == NULL)
f0109e2c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109e2f:	85 c0                	test   %eax,%eax
f0109e31:	74 39                	je     f0109e6c <del_page_table+0x5e>
		return ;

#if USE_KHEAP
	// directly remove the page table from the kernel heap
	kfree(ptr_page_table);
f0109e33:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109e36:	83 ec 0c             	sub    $0xc,%esp
f0109e39:	50                   	push   %eax
f0109e3a:	e8 11 fd ff ff       	call   f0109b50 <kfree>
f0109e3f:	83 c4 10             	add    $0x10,%esp
	table_frame_info->references = 0;
	free_frame(table_frame_info);
#endif

	// set the corresponding entry in the directory to 0
	uint32 dir_index = PDX(va);
f0109e42:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109e45:	c1 e8 16             	shr    $0x16,%eax
f0109e48:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_page_directory[dir_index] = 0;
f0109e4b:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0109e50:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109e53:	c1 e2 02             	shl    $0x2,%edx
f0109e56:	01 d0                	add    %edx,%eax
f0109e58:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0109e5e:	0f 20 d8             	mov    %cr3,%eax
f0109e61:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0109e64:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109e67:	0f 22 d8             	mov    %eax,%cr3
f0109e6a:	eb 01                	jmp    f0109e6d <del_page_table+0x5f>
	// get the page table of the given virtual address
	uint32 * ptr_page_table ;
	get_page_table(ptr_page_directory, va, &ptr_page_table);

	if (ptr_page_table == NULL)
		return ;
f0109e6c:	90                   	nop
	uint32 dir_index = PDX(va);
	ptr_page_directory[dir_index] = 0;

	//clear the TLB cache
	tlbflush();
}
f0109e6d:	c9                   	leave  
f0109e6e:	c3                   	ret    

f0109e6f <pd_is_table_used>:

///============================================================================================
/// Dealing with page directory entry flags

inline uint32 pd_is_table_used(uint32* directory, uint32 virtual_address)
{
f0109e6f:	55                   	push   %ebp
f0109e70:	89 e5                	mov    %esp,%ebp
	return ( (directory[PDX(virtual_address)] & PERM_USED) == PERM_USED ? 1 : 0);
f0109e72:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109e75:	c1 e8 16             	shr    $0x16,%eax
f0109e78:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109e7f:	8b 45 08             	mov    0x8(%ebp),%eax
f0109e82:	01 d0                	add    %edx,%eax
f0109e84:	8b 00                	mov    (%eax),%eax
f0109e86:	83 e0 20             	and    $0x20,%eax
f0109e89:	85 c0                	test   %eax,%eax
f0109e8b:	0f 95 c0             	setne  %al
f0109e8e:	0f b6 c0             	movzbl %al,%eax
}
f0109e91:	5d                   	pop    %ebp
f0109e92:	c3                   	ret    

f0109e93 <pd_set_table_unused>:

inline void pd_set_table_unused(uint32* directory, uint32 virtual_address)
{
f0109e93:	55                   	push   %ebp
f0109e94:	89 e5                	mov    %esp,%ebp
f0109e96:	83 ec 08             	sub    $0x8,%esp
	directory[PDX(virtual_address)] &= (~PERM_USED);
f0109e99:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109e9c:	c1 e8 16             	shr    $0x16,%eax
f0109e9f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109ea6:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ea9:	01 d0                	add    %edx,%eax
f0109eab:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109eae:	c1 ea 16             	shr    $0x16,%edx
f0109eb1:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
f0109eb8:	8b 55 08             	mov    0x8(%ebp),%edx
f0109ebb:	01 ca                	add    %ecx,%edx
f0109ebd:	8b 12                	mov    (%edx),%edx
f0109ebf:	83 e2 df             	and    $0xffffffdf,%edx
f0109ec2:	89 10                	mov    %edx,(%eax)
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0109ec4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109ec7:	83 ec 08             	sub    $0x8,%esp
f0109eca:	50                   	push   %eax
f0109ecb:	6a 00                	push   $0x0
f0109ecd:	e8 4e ed ff ff       	call   f0108c20 <tlb_invalidate>
f0109ed2:	83 c4 10             	add    $0x10,%esp
}
f0109ed5:	90                   	nop
f0109ed6:	c9                   	leave  
f0109ed7:	c3                   	ret    

f0109ed8 <pd_clear_page_dir_entry>:

inline void pd_clear_page_dir_entry(uint32* directory, uint32 virtual_address)
{
f0109ed8:	55                   	push   %ebp
f0109ed9:	89 e5                	mov    %esp,%ebp
f0109edb:	83 ec 10             	sub    $0x10,%esp
	directory[PDX(virtual_address)] = 0 ;
f0109ede:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109ee1:	c1 e8 16             	shr    $0x16,%eax
f0109ee4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109eeb:	8b 45 08             	mov    0x8(%ebp),%eax
f0109eee:	01 d0                	add    %edx,%eax
f0109ef0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0109ef6:	0f 20 d8             	mov    %cr3,%eax
f0109ef9:	89 45 fc             	mov    %eax,-0x4(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0109efc:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0109eff:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f0109f02:	90                   	nop
f0109f03:	c9                   	leave  
f0109f04:	c3                   	ret    

f0109f05 <env_page_ws_list_create_element>:
//==============================
// [1] CREATE A NEW WS ELEMENT
//==============================
//If failed to create a new one, kernel should panic()!
inline struct WorkingSetElement* env_page_ws_list_create_element(struct Env* e, uint32 virtual_address)
{
f0109f05:	55                   	push   %ebp
f0109f06:	89 e5                	mov    %esp,%ebp
f0109f08:	83 ec 18             	sub    $0x18,%esp
	assert(virtual_address >= 0 && virtual_address < USER_TOP);
f0109f0b:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0109f12:	76 16                	jbe    f0109f2a <env_page_ws_list_create_element+0x25>
f0109f14:	68 f0 ed 12 f0       	push   $0xf012edf0
f0109f19:	68 23 ee 12 f0       	push   $0xf012ee23
f0109f1e:	6a 16                	push   $0x16
f0109f20:	68 38 ee 12 f0       	push   $0xf012ee38
f0109f25:	e8 85 6f ff ff       	call   f0100eaf <_panic>
	struct WorkingSetElement *wse = kmalloc(sizeof(struct WorkingSetElement)) ;
f0109f2a:	83 ec 0c             	sub    $0xc,%esp
f0109f2d:	6a 18                	push   $0x18
f0109f2f:	e8 02 fc ff ff       	call   f0109b36 <kmalloc>
f0109f34:	83 c4 10             	add    $0x10,%esp
f0109f37:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (wse == NULL)
f0109f3a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109f3e:	75 14                	jne    f0109f54 <env_page_ws_list_create_element+0x4f>
	{
		panic("can't create a new WS element");
f0109f40:	83 ec 04             	sub    $0x4,%esp
f0109f43:	68 57 ee 12 f0       	push   $0xf012ee57
f0109f48:	6a 1a                	push   $0x1a
f0109f4a:	68 38 ee 12 f0       	push   $0xf012ee38
f0109f4f:	e8 5b 6f ff ff       	call   f0100eaf <_panic>
	}
	wse->virtual_address = ROUNDDOWN(virtual_address,PAGE_SIZE);
f0109f54:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109f57:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109f5a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109f5d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109f62:	89 c2                	mov    %eax,%edx
f0109f64:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109f67:	89 10                	mov    %edx,(%eax)
	wse->sweeps_counter = 0;
f0109f69:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109f6c:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	wse->time_stamp = 0x00000000;
f0109f73:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109f76:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	return wse;
f0109f7d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0109f80:	c9                   	leave  
f0109f81:	c3                   	ret    

f0109f82 <env_page_ws_invalidate>:
inline void env_page_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f0109f82:	55                   	push   %ebp
f0109f83:	89 e5                	mov    %esp,%ebp
f0109f85:	83 ec 38             	sub    $0x38,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0109f88:	83 ec 0c             	sub    $0xc,%esp
f0109f8b:	6a 02                	push   $0x2
f0109f8d:	e8 91 58 00 00       	call   f010f823 <isPageReplacmentAlgorithmLRU>
f0109f92:	83 c4 10             	add    $0x10,%esp
f0109f95:	85 c0                	test   %eax,%eax
f0109f97:	0f 84 e5 03 00 00    	je     f010a382 <env_page_ws_invalidate+0x400>
	{
		bool found = 0;
f0109f9d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct WorkingSetElement *ptr_WS_element = NULL;
f0109fa4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f0109fab:	8b 45 08             	mov    0x8(%ebp),%eax
f0109fae:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0109fb4:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109fb7:	e9 3b 02 00 00       	jmp    f010a1f7 <env_page_ws_invalidate+0x275>
		{
			if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f0109fbc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109fbf:	8b 00                	mov    (%eax),%eax
f0109fc1:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0109fc4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109fc7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109fcc:	89 c2                	mov    %eax,%edx
f0109fce:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109fd1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0109fd4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109fd7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109fdc:	39 c2                	cmp    %eax,%edx
f0109fde:	0f 85 07 02 00 00    	jne    f010a1eb <env_page_ws_invalidate+0x269>
			{
				struct WorkingSetElement* ptr_tmp_WS_element = LIST_FIRST(&(e->SecondList));
f0109fe4:	8b 45 08             	mov    0x8(%ebp),%eax
f0109fe7:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0109fed:	89 45 e0             	mov    %eax,-0x20(%ebp)
				unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f0109ff0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109ff3:	8b 10                	mov    (%eax),%edx
f0109ff5:	8b 45 08             	mov    0x8(%ebp),%eax
f0109ff8:	8b 40 64             	mov    0x64(%eax),%eax
f0109ffb:	83 ec 08             	sub    $0x8,%esp
f0109ffe:	52                   	push   %edx
f0109fff:	50                   	push   %eax
f010a000:	e8 4a f6 ff ff       	call   f010964f <unmap_frame>
f010a005:	83 c4 10             	add    $0x10,%esp

				LIST_REMOVE(&(e->ActiveList), ptr_WS_element);
f010a008:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a00c:	75 14                	jne    f010a022 <env_page_ws_invalidate+0xa0>
f010a00e:	83 ec 04             	sub    $0x4,%esp
f010a011:	68 75 ee 12 f0       	push   $0xf012ee75
f010a016:	6a 2e                	push   $0x2e
f010a018:	68 38 ee 12 f0       	push   $0xf012ee38
f010a01d:	e8 8d 6e ff ff       	call   f0100eaf <_panic>
f010a022:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a025:	8b 40 10             	mov    0x10(%eax),%eax
f010a028:	85 c0                	test   %eax,%eax
f010a02a:	74 11                	je     f010a03d <env_page_ws_invalidate+0xbb>
f010a02c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a02f:	8b 40 10             	mov    0x10(%eax),%eax
f010a032:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a035:	8b 52 14             	mov    0x14(%edx),%edx
f010a038:	89 50 14             	mov    %edx,0x14(%eax)
f010a03b:	eb 0f                	jmp    f010a04c <env_page_ws_invalidate+0xca>
f010a03d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a040:	8b 50 14             	mov    0x14(%eax),%edx
f010a043:	8b 45 08             	mov    0x8(%ebp),%eax
f010a046:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010a04c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a04f:	8b 40 14             	mov    0x14(%eax),%eax
f010a052:	85 c0                	test   %eax,%eax
f010a054:	74 11                	je     f010a067 <env_page_ws_invalidate+0xe5>
f010a056:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a059:	8b 40 14             	mov    0x14(%eax),%eax
f010a05c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a05f:	8b 52 10             	mov    0x10(%edx),%edx
f010a062:	89 50 10             	mov    %edx,0x10(%eax)
f010a065:	eb 0f                	jmp    f010a076 <env_page_ws_invalidate+0xf4>
f010a067:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a06a:	8b 50 10             	mov    0x10(%eax),%edx
f010a06d:	8b 45 08             	mov    0x8(%ebp),%eax
f010a070:	89 90 68 05 00 00    	mov    %edx,0x568(%eax)
f010a076:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a079:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a080:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a083:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a08a:	8b 45 08             	mov    0x8(%ebp),%eax
f010a08d:	8b 80 74 05 00 00    	mov    0x574(%eax),%eax
f010a093:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a096:	8b 45 08             	mov    0x8(%ebp),%eax
f010a099:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)

				/*EDIT*/kfree(ptr_WS_element);
f010a09f:	83 ec 0c             	sub    $0xc,%esp
f010a0a2:	ff 75 f0             	pushl  -0x10(%ebp)
f010a0a5:	e8 a6 fa ff ff       	call   f0109b50 <kfree>
f010a0aa:	83 c4 10             	add    $0x10,%esp

				if(ptr_tmp_WS_element != NULL)
f010a0ad:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a0b1:	0f 84 2b 01 00 00    	je     f010a1e2 <env_page_ws_invalidate+0x260>
				{
					LIST_REMOVE(&(e->SecondList), ptr_tmp_WS_element);
f010a0b7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a0bb:	75 14                	jne    f010a0d1 <env_page_ws_invalidate+0x14f>
f010a0bd:	83 ec 04             	sub    $0x4,%esp
f010a0c0:	68 75 ee 12 f0       	push   $0xf012ee75
f010a0c5:	6a 34                	push   $0x34
f010a0c7:	68 38 ee 12 f0       	push   $0xf012ee38
f010a0cc:	e8 de 6d ff ff       	call   f0100eaf <_panic>
f010a0d1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a0d4:	8b 40 10             	mov    0x10(%eax),%eax
f010a0d7:	85 c0                	test   %eax,%eax
f010a0d9:	74 11                	je     f010a0ec <env_page_ws_invalidate+0x16a>
f010a0db:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a0de:	8b 40 10             	mov    0x10(%eax),%eax
f010a0e1:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a0e4:	8b 52 14             	mov    0x14(%edx),%edx
f010a0e7:	89 50 14             	mov    %edx,0x14(%eax)
f010a0ea:	eb 0f                	jmp    f010a0fb <env_page_ws_invalidate+0x179>
f010a0ec:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a0ef:	8b 50 14             	mov    0x14(%eax),%edx
f010a0f2:	8b 45 08             	mov    0x8(%ebp),%eax
f010a0f5:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
f010a0fb:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a0fe:	8b 40 14             	mov    0x14(%eax),%eax
f010a101:	85 c0                	test   %eax,%eax
f010a103:	74 11                	je     f010a116 <env_page_ws_invalidate+0x194>
f010a105:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a108:	8b 40 14             	mov    0x14(%eax),%eax
f010a10b:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a10e:	8b 52 10             	mov    0x10(%edx),%edx
f010a111:	89 50 10             	mov    %edx,0x10(%eax)
f010a114:	eb 0f                	jmp    f010a125 <env_page_ws_invalidate+0x1a3>
f010a116:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a119:	8b 50 10             	mov    0x10(%eax),%edx
f010a11c:	8b 45 08             	mov    0x8(%ebp),%eax
f010a11f:	89 90 78 05 00 00    	mov    %edx,0x578(%eax)
f010a125:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a128:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a12f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a132:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a139:	8b 45 08             	mov    0x8(%ebp),%eax
f010a13c:	8b 80 84 05 00 00    	mov    0x584(%eax),%eax
f010a142:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a145:	8b 45 08             	mov    0x8(%ebp),%eax
f010a148:	89 90 84 05 00 00    	mov    %edx,0x584(%eax)
					LIST_INSERT_TAIL(&(e->ActiveList), ptr_tmp_WS_element);
f010a14e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a152:	75 14                	jne    f010a168 <env_page_ws_invalidate+0x1e6>
f010a154:	83 ec 04             	sub    $0x4,%esp
f010a157:	68 94 ee 12 f0       	push   $0xf012ee94
f010a15c:	6a 35                	push   $0x35
f010a15e:	68 38 ee 12 f0       	push   $0xf012ee38
f010a163:	e8 47 6d ff ff       	call   f0100eaf <_panic>
f010a168:	8b 45 08             	mov    0x8(%ebp),%eax
f010a16b:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010a171:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a174:	89 50 14             	mov    %edx,0x14(%eax)
f010a177:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a17a:	8b 40 14             	mov    0x14(%eax),%eax
f010a17d:	85 c0                	test   %eax,%eax
f010a17f:	74 11                	je     f010a192 <env_page_ws_invalidate+0x210>
f010a181:	8b 45 08             	mov    0x8(%ebp),%eax
f010a184:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010a18a:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a18d:	89 50 10             	mov    %edx,0x10(%eax)
f010a190:	eb 0c                	jmp    f010a19e <env_page_ws_invalidate+0x21c>
f010a192:	8b 45 08             	mov    0x8(%ebp),%eax
f010a195:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a198:	89 90 68 05 00 00    	mov    %edx,0x568(%eax)
f010a19e:	8b 45 08             	mov    0x8(%ebp),%eax
f010a1a1:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a1a4:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010a1aa:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a1ad:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a1b4:	8b 45 08             	mov    0x8(%ebp),%eax
f010a1b7:	8b 80 74 05 00 00    	mov    0x574(%eax),%eax
f010a1bd:	8d 50 01             	lea    0x1(%eax),%edx
f010a1c0:	8b 45 08             	mov    0x8(%ebp),%eax
f010a1c3:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
					pt_set_page_permissions(e->env_page_directory, ptr_tmp_WS_element->virtual_address, PERM_PRESENT, 0);
f010a1c9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a1cc:	8b 10                	mov    (%eax),%edx
f010a1ce:	8b 45 08             	mov    0x8(%ebp),%eax
f010a1d1:	8b 40 64             	mov    0x64(%eax),%eax
f010a1d4:	6a 00                	push   $0x0
f010a1d6:	6a 01                	push   $0x1
f010a1d8:	52                   	push   %edx
f010a1d9:	50                   	push   %eax
f010a1da:	e8 20 fa ff ff       	call   f0109bff <pt_set_page_permissions>
f010a1df:	83 c4 10             	add    $0x10,%esp
				}
				found = 1;
f010a1e2:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f010a1e9:	eb 43                	jmp    f010a22e <env_page_ws_invalidate+0x2ac>
{
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		bool found = 0;
		struct WorkingSetElement *ptr_WS_element = NULL;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a1eb:	8b 45 08             	mov    0x8(%ebp),%eax
f010a1ee:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010a1f4:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a1f7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a1fb:	74 08                	je     f010a205 <env_page_ws_invalidate+0x283>
f010a1fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a200:	8b 40 10             	mov    0x10(%eax),%eax
f010a203:	eb 05                	jmp    f010a20a <env_page_ws_invalidate+0x288>
f010a205:	b8 00 00 00 00       	mov    $0x0,%eax
f010a20a:	8b 55 08             	mov    0x8(%ebp),%edx
f010a20d:	89 82 70 05 00 00    	mov    %eax,0x570(%edx)
f010a213:	8b 45 08             	mov    0x8(%ebp),%eax
f010a216:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010a21c:	85 c0                	test   %eax,%eax
f010a21e:	0f 85 98 fd ff ff    	jne    f0109fbc <env_page_ws_invalidate+0x3a>
f010a224:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a228:	0f 85 8e fd ff ff    	jne    f0109fbc <env_page_ws_invalidate+0x3a>
				found = 1;
				break;
			}
		}

		if (!found)
f010a22e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a232:	0f 85 a4 02 00 00    	jne    f010a4dc <env_page_ws_invalidate+0x55a>
		{
			ptr_WS_element = NULL;
f010a238:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a23f:	8b 45 08             	mov    0x8(%ebp),%eax
f010a242:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a248:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a24b:	e9 f6 00 00 00       	jmp    f010a346 <env_page_ws_invalidate+0x3c4>
			{
				if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010a250:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a253:	8b 00                	mov    (%eax),%eax
f010a255:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010a258:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a25b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a260:	89 c2                	mov    %eax,%edx
f010a262:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a265:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010a268:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010a26b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a270:	39 c2                	cmp    %eax,%edx
f010a272:	0f 85 c2 00 00 00    	jne    f010a33a <env_page_ws_invalidate+0x3b8>
				{
					unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f010a278:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a27b:	8b 10                	mov    (%eax),%edx
f010a27d:	8b 45 08             	mov    0x8(%ebp),%eax
f010a280:	8b 40 64             	mov    0x64(%eax),%eax
f010a283:	83 ec 08             	sub    $0x8,%esp
f010a286:	52                   	push   %edx
f010a287:	50                   	push   %eax
f010a288:	e8 c2 f3 ff ff       	call   f010964f <unmap_frame>
f010a28d:	83 c4 10             	add    $0x10,%esp
					LIST_REMOVE(&(e->SecondList), ptr_WS_element);
f010a290:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a294:	75 14                	jne    f010a2aa <env_page_ws_invalidate+0x328>
f010a296:	83 ec 04             	sub    $0x4,%esp
f010a299:	68 75 ee 12 f0       	push   $0xf012ee75
f010a29e:	6a 45                	push   $0x45
f010a2a0:	68 38 ee 12 f0       	push   $0xf012ee38
f010a2a5:	e8 05 6c ff ff       	call   f0100eaf <_panic>
f010a2aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a2ad:	8b 40 10             	mov    0x10(%eax),%eax
f010a2b0:	85 c0                	test   %eax,%eax
f010a2b2:	74 11                	je     f010a2c5 <env_page_ws_invalidate+0x343>
f010a2b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a2b7:	8b 40 10             	mov    0x10(%eax),%eax
f010a2ba:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a2bd:	8b 52 14             	mov    0x14(%edx),%edx
f010a2c0:	89 50 14             	mov    %edx,0x14(%eax)
f010a2c3:	eb 0f                	jmp    f010a2d4 <env_page_ws_invalidate+0x352>
f010a2c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a2c8:	8b 50 14             	mov    0x14(%eax),%edx
f010a2cb:	8b 45 08             	mov    0x8(%ebp),%eax
f010a2ce:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
f010a2d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a2d7:	8b 40 14             	mov    0x14(%eax),%eax
f010a2da:	85 c0                	test   %eax,%eax
f010a2dc:	74 11                	je     f010a2ef <env_page_ws_invalidate+0x36d>
f010a2de:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a2e1:	8b 40 14             	mov    0x14(%eax),%eax
f010a2e4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a2e7:	8b 52 10             	mov    0x10(%edx),%edx
f010a2ea:	89 50 10             	mov    %edx,0x10(%eax)
f010a2ed:	eb 0f                	jmp    f010a2fe <env_page_ws_invalidate+0x37c>
f010a2ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a2f2:	8b 50 10             	mov    0x10(%eax),%edx
f010a2f5:	8b 45 08             	mov    0x8(%ebp),%eax
f010a2f8:	89 90 78 05 00 00    	mov    %edx,0x578(%eax)
f010a2fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a301:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a308:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a30b:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a312:	8b 45 08             	mov    0x8(%ebp),%eax
f010a315:	8b 80 84 05 00 00    	mov    0x584(%eax),%eax
f010a31b:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a31e:	8b 45 08             	mov    0x8(%ebp),%eax
f010a321:	89 90 84 05 00 00    	mov    %edx,0x584(%eax)

					kfree(ptr_WS_element);
f010a327:	83 ec 0c             	sub    $0xc,%esp
f010a32a:	ff 75 f0             	pushl  -0x10(%ebp)
f010a32d:	e8 1e f8 ff ff       	call   f0109b50 <kfree>
f010a332:	83 c4 10             	add    $0x10,%esp

					/*EDIT*/break;
f010a335:	e9 a2 01 00 00       	jmp    f010a4dc <env_page_ws_invalidate+0x55a>
		}

		if (!found)
		{
			ptr_WS_element = NULL;
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a33a:	8b 45 08             	mov    0x8(%ebp),%eax
f010a33d:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010a343:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a346:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a34a:	74 08                	je     f010a354 <env_page_ws_invalidate+0x3d2>
f010a34c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a34f:	8b 40 10             	mov    0x10(%eax),%eax
f010a352:	eb 05                	jmp    f010a359 <env_page_ws_invalidate+0x3d7>
f010a354:	b8 00 00 00 00       	mov    $0x0,%eax
f010a359:	8b 55 08             	mov    0x8(%ebp),%edx
f010a35c:	89 82 80 05 00 00    	mov    %eax,0x580(%edx)
f010a362:	8b 45 08             	mov    0x8(%ebp),%eax
f010a365:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010a36b:	85 c0                	test   %eax,%eax
f010a36d:	0f 85 dd fe ff ff    	jne    f010a250 <env_page_ws_invalidate+0x2ce>
f010a373:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a377:	0f 85 d3 fe ff ff    	jne    f010a250 <env_page_ws_invalidate+0x2ce>

				break;
			}
		}
	}
}
f010a37d:	e9 5a 01 00 00       	jmp    f010a4dc <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a382:	8b 45 08             	mov    0x8(%ebp),%eax
f010a385:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010a38b:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a38e:	e9 10 01 00 00       	jmp    f010a4a3 <env_page_ws_invalidate+0x521>
		{
			if(ROUNDDOWN(wse->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010a393:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a396:	8b 00                	mov    (%eax),%eax
f010a398:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010a39b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a39e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a3a3:	89 c2                	mov    %eax,%edx
f010a3a5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a3a8:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010a3ab:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010a3ae:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a3b3:	39 c2                	cmp    %eax,%edx
f010a3b5:	0f 85 dc 00 00 00    	jne    f010a497 <env_page_ws_invalidate+0x515>
			{
				unmap_frame(e->env_page_directory, wse->virtual_address);
f010a3bb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a3be:	8b 10                	mov    (%eax),%edx
f010a3c0:	8b 45 08             	mov    0x8(%ebp),%eax
f010a3c3:	8b 40 64             	mov    0x64(%eax),%eax
f010a3c6:	83 ec 08             	sub    $0x8,%esp
f010a3c9:	52                   	push   %edx
f010a3ca:	50                   	push   %eax
f010a3cb:	e8 7f f2 ff ff       	call   f010964f <unmap_frame>
f010a3d0:	83 c4 10             	add    $0x10,%esp

				if (e->page_last_WS_element == wse)
f010a3d3:	8b 45 08             	mov    0x8(%ebp),%eax
f010a3d6:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010a3dc:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010a3df:	75 0f                	jne    f010a3f0 <env_page_ws_invalidate+0x46e>
				{
					e->page_last_WS_element = LIST_NEXT(wse);
f010a3e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a3e4:	8b 50 10             	mov    0x10(%eax),%edx
f010a3e7:	8b 45 08             	mov    0x8(%ebp),%eax
f010a3ea:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
				}
				LIST_REMOVE(&(e->page_WS_list), wse);
f010a3f0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a3f4:	75 14                	jne    f010a40a <env_page_ws_invalidate+0x488>
f010a3f6:	83 ec 04             	sub    $0x4,%esp
f010a3f9:	68 75 ee 12 f0       	push   $0xf012ee75
f010a3fe:	6a 5b                	push   $0x5b
f010a400:	68 38 ee 12 f0       	push   $0xf012ee38
f010a405:	e8 a5 6a ff ff       	call   f0100eaf <_panic>
f010a40a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a40d:	8b 40 10             	mov    0x10(%eax),%eax
f010a410:	85 c0                	test   %eax,%eax
f010a412:	74 11                	je     f010a425 <env_page_ws_invalidate+0x4a3>
f010a414:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a417:	8b 40 10             	mov    0x10(%eax),%eax
f010a41a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010a41d:	8b 52 14             	mov    0x14(%edx),%edx
f010a420:	89 50 14             	mov    %edx,0x14(%eax)
f010a423:	eb 0f                	jmp    f010a434 <env_page_ws_invalidate+0x4b2>
f010a425:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a428:	8b 50 14             	mov    0x14(%eax),%edx
f010a42b:	8b 45 08             	mov    0x8(%ebp),%eax
f010a42e:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f010a434:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a437:	8b 40 14             	mov    0x14(%eax),%eax
f010a43a:	85 c0                	test   %eax,%eax
f010a43c:	74 11                	je     f010a44f <env_page_ws_invalidate+0x4cd>
f010a43e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a441:	8b 40 14             	mov    0x14(%eax),%eax
f010a444:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010a447:	8b 52 10             	mov    0x10(%edx),%edx
f010a44a:	89 50 10             	mov    %edx,0x10(%eax)
f010a44d:	eb 0f                	jmp    f010a45e <env_page_ws_invalidate+0x4dc>
f010a44f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a452:	8b 50 10             	mov    0x10(%eax),%edx
f010a455:	8b 45 08             	mov    0x8(%ebp),%eax
f010a458:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010a45e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a461:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a468:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a46b:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a472:	8b 45 08             	mov    0x8(%ebp),%eax
f010a475:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010a47b:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a47e:	8b 45 08             	mov    0x8(%ebp),%eax
f010a481:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)

				kfree(wse);
f010a487:	83 ec 0c             	sub    $0xc,%esp
f010a48a:	ff 75 ec             	pushl  -0x14(%ebp)
f010a48d:	e8 be f6 ff ff       	call   f0109b50 <kfree>
f010a492:	83 c4 10             	add    $0x10,%esp

				break;
f010a495:	eb 45                	jmp    f010a4dc <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a497:	8b 45 08             	mov    0x8(%ebp),%eax
f010a49a:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010a4a0:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a4a3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a4a7:	74 08                	je     f010a4b1 <env_page_ws_invalidate+0x52f>
f010a4a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a4ac:	8b 40 10             	mov    0x10(%eax),%eax
f010a4af:	eb 05                	jmp    f010a4b6 <env_page_ws_invalidate+0x534>
f010a4b1:	b8 00 00 00 00       	mov    $0x0,%eax
f010a4b6:	8b 55 08             	mov    0x8(%ebp),%edx
f010a4b9:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f010a4bf:	8b 45 08             	mov    0x8(%ebp),%eax
f010a4c2:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010a4c8:	85 c0                	test   %eax,%eax
f010a4ca:	0f 85 c3 fe ff ff    	jne    f010a393 <env_page_ws_invalidate+0x411>
f010a4d0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a4d4:	0f 85 b9 fe ff ff    	jne    f010a393 <env_page_ws_invalidate+0x411>

				break;
			}
		}
	}
}
f010a4da:	eb 00                	jmp    f010a4dc <env_page_ws_invalidate+0x55a>
f010a4dc:	90                   	nop
f010a4dd:	c9                   	leave  
f010a4de:	c3                   	ret    

f010a4df <env_page_ws_print>:
void env_page_ws_print(struct Env *e)
{
f010a4df:	55                   	push   %ebp
f010a4e0:	89 e5                	mov    %esp,%ebp
f010a4e2:	53                   	push   %ebx
f010a4e3:	83 ec 24             	sub    $0x24,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010a4e6:	83 ec 0c             	sub    $0xc,%esp
f010a4e9:	6a 02                	push   $0x2
f010a4eb:	e8 33 53 00 00       	call   f010f823 <isPageReplacmentAlgorithmLRU>
f010a4f0:	83 c4 10             	add    $0x10,%esp
f010a4f3:	85 c0                	test   %eax,%eax
f010a4f5:	0f 84 fe 00 00 00    	je     f010a5f9 <env_page_ws_print+0x11a>
	{
		int i = 0;
f010a4fb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		cprintf("ActiveList:\n============\n") ;
f010a502:	83 ec 0c             	sub    $0xc,%esp
f010a505:	68 b7 ee 12 f0       	push   $0xf012eeb7
f010a50a:	e8 4d 76 ff ff       	call   f0101b5c <cprintf>
f010a50f:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a512:	8b 45 08             	mov    0x8(%ebp),%eax
f010a515:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a51b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a51e:	eb 2c                	jmp    f010a54c <env_page_ws_print+0x6d>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f010a520:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a523:	8b 10                	mov    (%eax),%edx
f010a525:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a528:	8d 48 01             	lea    0x1(%eax),%ecx
f010a52b:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f010a52e:	83 ec 04             	sub    $0x4,%esp
f010a531:	52                   	push   %edx
f010a532:	50                   	push   %eax
f010a533:	68 d1 ee 12 f0       	push   $0xf012eed1
f010a538:	e8 1f 76 ff ff       	call   f0101b5c <cprintf>
f010a53d:	83 c4 10             	add    $0x10,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		int i = 0;
		cprintf("ActiveList:\n============\n") ;
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a540:	8b 45 08             	mov    0x8(%ebp),%eax
f010a543:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010a549:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a54c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a550:	74 08                	je     f010a55a <env_page_ws_print+0x7b>
f010a552:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a555:	8b 40 10             	mov    0x10(%eax),%eax
f010a558:	eb 05                	jmp    f010a55f <env_page_ws_print+0x80>
f010a55a:	b8 00 00 00 00       	mov    $0x0,%eax
f010a55f:	8b 55 08             	mov    0x8(%ebp),%edx
f010a562:	89 82 70 05 00 00    	mov    %eax,0x570(%edx)
f010a568:	8b 45 08             	mov    0x8(%ebp),%eax
f010a56b:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010a571:	85 c0                	test   %eax,%eax
f010a573:	75 ab                	jne    f010a520 <env_page_ws_print+0x41>
f010a575:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a579:	75 a5                	jne    f010a520 <env_page_ws_print+0x41>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
f010a57b:	83 ec 0c             	sub    $0xc,%esp
f010a57e:	68 d9 ee 12 f0       	push   $0xf012eed9
f010a583:	e8 d4 75 ff ff       	call   f0101b5c <cprintf>
f010a588:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a58b:	8b 45 08             	mov    0x8(%ebp),%eax
f010a58e:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a594:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a597:	eb 2c                	jmp    f010a5c5 <env_page_ws_print+0xe6>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f010a599:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a59c:	8b 10                	mov    (%eax),%edx
f010a59e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a5a1:	8d 48 01             	lea    0x1(%eax),%ecx
f010a5a4:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f010a5a7:	83 ec 04             	sub    $0x4,%esp
f010a5aa:	52                   	push   %edx
f010a5ab:	50                   	push   %eax
f010a5ac:	68 d1 ee 12 f0       	push   $0xf012eed1
f010a5b1:	e8 a6 75 ff ff       	call   f0101b5c <cprintf>
f010a5b6:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a5b9:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5bc:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010a5c2:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a5c5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a5c9:	74 08                	je     f010a5d3 <env_page_ws_print+0xf4>
f010a5cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a5ce:	8b 40 10             	mov    0x10(%eax),%eax
f010a5d1:	eb 05                	jmp    f010a5d8 <env_page_ws_print+0xf9>
f010a5d3:	b8 00 00 00 00       	mov    $0x0,%eax
f010a5d8:	8b 55 08             	mov    0x8(%ebp),%edx
f010a5db:	89 82 80 05 00 00    	mov    %eax,0x580(%edx)
f010a5e1:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5e4:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010a5ea:	85 c0                	test   %eax,%eax
f010a5ec:	75 ab                	jne    f010a599 <env_page_ws_print+0xba>
f010a5ee:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a5f2:	75 a5                	jne    f010a599 <env_page_ws_print+0xba>
		for (; i < e->page_WS_max_size; ++i)
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f010a5f4:	e9 5a 01 00 00       	jmp    f010a753 <env_page_ws_print+0x274>
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
	}
	else
	{
		uint32 i=0;
f010a5f9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		cprintf("PAGE WS:\n");
f010a600:	83 ec 0c             	sub    $0xc,%esp
f010a603:	68 f4 ee 12 f0       	push   $0xf012eef4
f010a608:	e8 4f 75 ff ff       	call   f0101b5c <cprintf>
f010a60d:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement *wse = NULL;
f010a610:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a617:	8b 45 08             	mov    0x8(%ebp),%eax
f010a61a:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010a620:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010a623:	e9 d1 00 00 00       	jmp    f010a6f9 <env_page_ws_print+0x21a>
		{
			uint32 virtual_address = wse->virtual_address;
f010a628:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a62b:	8b 00                	mov    (%eax),%eax
f010a62d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 time_stamp = wse->time_stamp;
f010a630:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a633:	8b 40 08             	mov    0x8(%eax),%eax
f010a636:	89 45 e0             	mov    %eax,-0x20(%ebp)

			uint32 perm = pt_get_page_permissions(e->env_page_directory, virtual_address) ;
f010a639:	8b 45 08             	mov    0x8(%ebp),%eax
f010a63c:	8b 40 64             	mov    0x64(%eax),%eax
f010a63f:	83 ec 08             	sub    $0x8,%esp
f010a642:	ff 75 e4             	pushl  -0x1c(%ebp)
f010a645:	50                   	push   %eax
f010a646:	e8 79 f6 ff ff       	call   f0109cc4 <pt_get_page_permissions>
f010a64b:	83 c4 10             	add    $0x10,%esp
f010a64e:	89 45 dc             	mov    %eax,-0x24(%ebp)
			char isModified = ((perm&PERM_MODIFIED) ? 1 : 0);
f010a651:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a654:	83 e0 40             	and    $0x40,%eax
f010a657:	85 c0                	test   %eax,%eax
f010a659:	0f 95 c0             	setne  %al
f010a65c:	88 45 db             	mov    %al,-0x25(%ebp)
			char isUsed= ((perm&PERM_USED) ? 1 : 0);
f010a65f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a662:	83 e0 20             	and    $0x20,%eax
f010a665:	85 c0                	test   %eax,%eax
f010a667:	0f 95 c0             	setne  %al
f010a66a:	88 45 da             	mov    %al,-0x26(%ebp)
			char isBuffered= ((perm&PERM_BUFFERED) ? 1 : 0);
f010a66d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a670:	25 00 02 00 00       	and    $0x200,%eax
f010a675:	85 c0                	test   %eax,%eax
f010a677:	0f 95 c0             	setne  %al
f010a67a:	88 45 d9             	mov    %al,-0x27(%ebp)

			cprintf("%d: %x",i, virtual_address);
f010a67d:	83 ec 04             	sub    $0x4,%esp
f010a680:	ff 75 e4             	pushl  -0x1c(%ebp)
f010a683:	ff 75 ec             	pushl  -0x14(%ebp)
f010a686:	68 fe ee 12 f0       	push   $0xf012eefe
f010a68b:	e8 cc 74 ff ff       	call   f0101b5c <cprintf>
f010a690:	83 c4 10             	add    $0x10,%esp

			//2021
			cprintf(", used= %d, modified= %d, buffered= %d, time stamp= %x, sweeps_cnt= %d",
f010a693:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a696:	8b 58 0c             	mov    0xc(%eax),%ebx
f010a699:	0f be 4d d9          	movsbl -0x27(%ebp),%ecx
f010a69d:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f010a6a1:	0f be 45 da          	movsbl -0x26(%ebp),%eax
f010a6a5:	83 ec 08             	sub    $0x8,%esp
f010a6a8:	53                   	push   %ebx
f010a6a9:	ff 75 e0             	pushl  -0x20(%ebp)
f010a6ac:	51                   	push   %ecx
f010a6ad:	52                   	push   %edx
f010a6ae:	50                   	push   %eax
f010a6af:	68 08 ef 12 f0       	push   $0xf012ef08
f010a6b4:	e8 a3 74 ff ff       	call   f0101b5c <cprintf>
f010a6b9:	83 c4 20             	add    $0x20,%esp
					isUsed, isModified, isBuffered, time_stamp, wse->sweeps_counter) ;

			if(wse == e->page_last_WS_element)
f010a6bc:	8b 45 08             	mov    0x8(%ebp),%eax
f010a6bf:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010a6c5:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010a6c8:	75 10                	jne    f010a6da <env_page_ws_print+0x1fb>
			{
				cprintf(" <--");
f010a6ca:	83 ec 0c             	sub    $0xc,%esp
f010a6cd:	68 4f ef 12 f0       	push   $0xf012ef4f
f010a6d2:	e8 85 74 ff ff       	call   f0101b5c <cprintf>
f010a6d7:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f010a6da:	83 ec 0c             	sub    $0xc,%esp
f010a6dd:	68 54 ef 12 f0       	push   $0xf012ef54
f010a6e2:	e8 75 74 ff ff       	call   f0101b5c <cprintf>
f010a6e7:	83 c4 10             	add    $0x10,%esp
			i++;
f010a6ea:	ff 45 ec             	incl   -0x14(%ebp)
	else
	{
		uint32 i=0;
		cprintf("PAGE WS:\n");
		struct WorkingSetElement *wse = NULL;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a6ed:	8b 45 08             	mov    0x8(%ebp),%eax
f010a6f0:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010a6f6:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010a6f9:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010a6fd:	74 08                	je     f010a707 <env_page_ws_print+0x228>
f010a6ff:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a702:	8b 40 10             	mov    0x10(%eax),%eax
f010a705:	eb 05                	jmp    f010a70c <env_page_ws_print+0x22d>
f010a707:	b8 00 00 00 00       	mov    $0x0,%eax
f010a70c:	8b 55 08             	mov    0x8(%ebp),%edx
f010a70f:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f010a715:	8b 45 08             	mov    0x8(%ebp),%eax
f010a718:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010a71e:	85 c0                	test   %eax,%eax
f010a720:	0f 85 02 ff ff ff    	jne    f010a628 <env_page_ws_print+0x149>
f010a726:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010a72a:	0f 85 f8 fe ff ff    	jne    f010a628 <env_page_ws_print+0x149>
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f010a730:	eb 13                	jmp    f010a745 <env_page_ws_print+0x266>
		{
			cprintf("EMPTY LOCATION\n");
f010a732:	83 ec 0c             	sub    $0xc,%esp
f010a735:	68 56 ef 12 f0       	push   $0xf012ef56
f010a73a:	e8 1d 74 ff ff       	call   f0101b5c <cprintf>
f010a73f:	83 c4 10             	add    $0x10,%esp
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f010a742:	ff 45 ec             	incl   -0x14(%ebp)
f010a745:	8b 45 08             	mov    0x8(%ebp),%eax
f010a748:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010a74e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010a751:	77 df                	ja     f010a732 <env_page_ws_print+0x253>
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f010a753:	90                   	nop
f010a754:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a757:	c9                   	leave  
f010a758:	c3                   	ret    

f010a759 <env_table_ws_print>:
}
#endif
// Table Working Set =========================================================

void env_table_ws_print(struct Env *e)
{
f010a759:	55                   	push   %ebp
f010a75a:	89 e5                	mov    %esp,%ebp
f010a75c:	53                   	push   %ebx
f010a75d:	83 ec 14             	sub    $0x14,%esp
	uint32 i;
	cprintf("---------------------------------------------------\n");
f010a760:	83 ec 0c             	sub    $0xc,%esp
f010a763:	68 68 ef 12 f0       	push   $0xf012ef68
f010a768:	e8 ef 73 ff ff       	call   f0101b5c <cprintf>
f010a76d:	83 c4 10             	add    $0x10,%esp
	cprintf("TABLE WS:\n");
f010a770:	83 ec 0c             	sub    $0xc,%esp
f010a773:	68 9d ef 12 f0       	push   $0xf012ef9d
f010a778:	e8 df 73 ff ff       	call   f0101b5c <cprintf>
f010a77d:	83 c4 10             	add    $0x10,%esp
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010a780:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010a787:	e9 16 01 00 00       	jmp    f010a8a2 <env_table_ws_print+0x149>
	{
		if (e->__ptr_tws[i].empty)
f010a78c:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a78f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a792:	89 d0                	mov    %edx,%eax
f010a794:	01 c0                	add    %eax,%eax
f010a796:	01 d0                	add    %edx,%eax
f010a798:	c1 e0 03             	shl    $0x3,%eax
f010a79b:	01 c8                	add    %ecx,%eax
f010a79d:	05 b8 00 00 00       	add    $0xb8,%eax
f010a7a2:	8a 00                	mov    (%eax),%al
f010a7a4:	84 c0                	test   %al,%al
f010a7a6:	74 43                	je     f010a7eb <env_table_ws_print+0x92>
		{
			cprintf("EMPTY LOCATION");
f010a7a8:	83 ec 0c             	sub    $0xc,%esp
f010a7ab:	68 a8 ef 12 f0       	push   $0xf012efa8
f010a7b0:	e8 a7 73 ff ff       	call   f0101b5c <cprintf>
f010a7b5:	83 c4 10             	add    $0x10,%esp
			if(i==e->table_last_WS_index )
f010a7b8:	8b 45 08             	mov    0x8(%ebp),%eax
f010a7bb:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010a7c1:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010a7c4:	75 10                	jne    f010a7d6 <env_table_ws_print+0x7d>
			{
				cprintf("		<--");
f010a7c6:	83 ec 0c             	sub    $0xc,%esp
f010a7c9:	68 b7 ef 12 f0       	push   $0xf012efb7
f010a7ce:	e8 89 73 ff ff       	call   f0101b5c <cprintf>
f010a7d3:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f010a7d6:	83 ec 0c             	sub    $0xc,%esp
f010a7d9:	68 54 ef 12 f0       	push   $0xf012ef54
f010a7de:	e8 79 73 ff ff       	call   f0101b5c <cprintf>
f010a7e3:	83 c4 10             	add    $0x10,%esp
			continue;
f010a7e6:	e9 b4 00 00 00       	jmp    f010a89f <env_table_ws_print+0x146>
		}
		uint32 virtual_address = e->__ptr_tws[i].virtual_address;
f010a7eb:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a7ee:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a7f1:	89 d0                	mov    %edx,%eax
f010a7f3:	01 c0                	add    %eax,%eax
f010a7f5:	01 d0                	add    %edx,%eax
f010a7f7:	c1 e0 03             	shl    $0x3,%eax
f010a7fa:	01 c8                	add    %ecx,%eax
f010a7fc:	05 b4 00 00 00       	add    $0xb4,%eax
f010a801:	8b 00                	mov    (%eax),%eax
f010a803:	89 45 f0             	mov    %eax,-0x10(%ebp)
		cprintf("env address at %d = %x",i, e->__ptr_tws[i].virtual_address);
f010a806:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a809:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a80c:	89 d0                	mov    %edx,%eax
f010a80e:	01 c0                	add    %eax,%eax
f010a810:	01 d0                	add    %edx,%eax
f010a812:	c1 e0 03             	shl    $0x3,%eax
f010a815:	01 c8                	add    %ecx,%eax
f010a817:	05 b4 00 00 00       	add    $0xb4,%eax
f010a81c:	8b 00                	mov    (%eax),%eax
f010a81e:	83 ec 04             	sub    $0x4,%esp
f010a821:	50                   	push   %eax
f010a822:	ff 75 f4             	pushl  -0xc(%ebp)
f010a825:	68 bd ef 12 f0       	push   $0xf012efbd
f010a82a:	e8 2d 73 ff ff       	call   f0101b5c <cprintf>
f010a82f:	83 c4 10             	add    $0x10,%esp

		cprintf(", used bit = %d, time stamp = %d", pd_is_table_used(e->env_page_directory, virtual_address), e->__ptr_tws[i].time_stamp);
f010a832:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a835:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a838:	89 d0                	mov    %edx,%eax
f010a83a:	01 c0                	add    %eax,%eax
f010a83c:	01 d0                	add    %edx,%eax
f010a83e:	c1 e0 03             	shl    $0x3,%eax
f010a841:	01 c8                	add    %ecx,%eax
f010a843:	05 bc 00 00 00       	add    $0xbc,%eax
f010a848:	8b 18                	mov    (%eax),%ebx
f010a84a:	8b 45 08             	mov    0x8(%ebp),%eax
f010a84d:	8b 40 64             	mov    0x64(%eax),%eax
f010a850:	83 ec 08             	sub    $0x8,%esp
f010a853:	ff 75 f0             	pushl  -0x10(%ebp)
f010a856:	50                   	push   %eax
f010a857:	e8 13 f6 ff ff       	call   f0109e6f <pd_is_table_used>
f010a85c:	83 c4 10             	add    $0x10,%esp
f010a85f:	83 ec 04             	sub    $0x4,%esp
f010a862:	53                   	push   %ebx
f010a863:	50                   	push   %eax
f010a864:	68 d4 ef 12 f0       	push   $0xf012efd4
f010a869:	e8 ee 72 ff ff       	call   f0101b5c <cprintf>
f010a86e:	83 c4 10             	add    $0x10,%esp
		if(i==e->table_last_WS_index )
f010a871:	8b 45 08             	mov    0x8(%ebp),%eax
f010a874:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010a87a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010a87d:	75 10                	jne    f010a88f <env_table_ws_print+0x136>
		{
			cprintf(" <--");
f010a87f:	83 ec 0c             	sub    $0xc,%esp
f010a882:	68 4f ef 12 f0       	push   $0xf012ef4f
f010a887:	e8 d0 72 ff ff       	call   f0101b5c <cprintf>
f010a88c:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("\n");
f010a88f:	83 ec 0c             	sub    $0xc,%esp
f010a892:	68 54 ef 12 f0       	push   $0xf012ef54
f010a897:	e8 c0 72 ff ff       	call   f0101b5c <cprintf>
f010a89c:	83 c4 10             	add    $0x10,%esp
void env_table_ws_print(struct Env *e)
{
	uint32 i;
	cprintf("---------------------------------------------------\n");
	cprintf("TABLE WS:\n");
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010a89f:	ff 45 f4             	incl   -0xc(%ebp)
f010a8a2:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010a8a6:	0f 86 e0 fe ff ff    	jbe    f010a78c <env_table_ws_print+0x33>
		{
			cprintf(" <--");
		}
		cprintf("\n");
	}
}
f010a8ac:	90                   	nop
f010a8ad:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a8b0:	c9                   	leave  
f010a8b1:	c3                   	ret    

f010a8b2 <env_table_ws_get_size>:

inline uint32 env_table_ws_get_size(struct Env *e)
{
f010a8b2:	55                   	push   %ebp
f010a8b3:	89 e5                	mov    %esp,%ebp
f010a8b5:	83 ec 10             	sub    $0x10,%esp
	int i=0, counter=0;
f010a8b8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f010a8bf:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;i<__TWS_MAX_SIZE; i++) if(e->__ptr_tws[i].empty == 0) counter++;
f010a8c6:	eb 22                	jmp    f010a8ea <env_table_ws_get_size+0x38>
f010a8c8:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a8cb:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010a8ce:	89 d0                	mov    %edx,%eax
f010a8d0:	01 c0                	add    %eax,%eax
f010a8d2:	01 d0                	add    %edx,%eax
f010a8d4:	c1 e0 03             	shl    $0x3,%eax
f010a8d7:	01 c8                	add    %ecx,%eax
f010a8d9:	05 b8 00 00 00       	add    $0xb8,%eax
f010a8de:	8a 00                	mov    (%eax),%al
f010a8e0:	84 c0                	test   %al,%al
f010a8e2:	75 03                	jne    f010a8e7 <env_table_ws_get_size+0x35>
f010a8e4:	ff 45 f8             	incl   -0x8(%ebp)
f010a8e7:	ff 45 fc             	incl   -0x4(%ebp)
f010a8ea:	83 7d fc 31          	cmpl   $0x31,-0x4(%ebp)
f010a8ee:	7e d8                	jle    f010a8c8 <env_table_ws_get_size+0x16>
	return counter;
f010a8f0:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f010a8f3:	c9                   	leave  
f010a8f4:	c3                   	ret    

f010a8f5 <env_table_ws_invalidate>:

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f010a8f5:	55                   	push   %ebp
f010a8f6:	89 e5                	mov    %esp,%ebp
f010a8f8:	83 ec 18             	sub    $0x18,%esp
	int i=0;
f010a8fb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<__TWS_MAX_SIZE; i++)
f010a902:	eb 4e                	jmp    f010a952 <env_table_ws_invalidate+0x5d>
	{
		if(ROUNDDOWN(e->__ptr_tws[i].virtual_address,PAGE_SIZE*1024) == ROUNDDOWN(virtual_address,PAGE_SIZE*1024))
f010a904:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a907:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a90a:	89 d0                	mov    %edx,%eax
f010a90c:	01 c0                	add    %eax,%eax
f010a90e:	01 d0                	add    %edx,%eax
f010a910:	c1 e0 03             	shl    $0x3,%eax
f010a913:	01 c8                	add    %ecx,%eax
f010a915:	05 b4 00 00 00       	add    $0xb4,%eax
f010a91a:	8b 00                	mov    (%eax),%eax
f010a91c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a91f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a922:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010a927:	89 c2                	mov    %eax,%edx
f010a929:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a92c:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a92f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a932:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010a937:	39 c2                	cmp    %eax,%edx
f010a939:	75 14                	jne    f010a94f <env_table_ws_invalidate+0x5a>
		{
			env_table_ws_clear_entry(e, i);
f010a93b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a93e:	83 ec 08             	sub    $0x8,%esp
f010a941:	50                   	push   %eax
f010a942:	ff 75 08             	pushl  0x8(%ebp)
f010a945:	e8 bc 00 00 00       	call   f010aa06 <env_table_ws_clear_entry>
f010a94a:	83 c4 10             	add    $0x10,%esp
			break;
f010a94d:	eb 09                	jmp    f010a958 <env_table_ws_invalidate+0x63>
}

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
	int i=0;
	for(;i<__TWS_MAX_SIZE; i++)
f010a94f:	ff 45 f4             	incl   -0xc(%ebp)
f010a952:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010a956:	7e ac                	jle    f010a904 <env_table_ws_invalidate+0xf>
		{
			env_table_ws_clear_entry(e, i);
			break;
		}
	}
}
f010a958:	90                   	nop
f010a959:	c9                   	leave  
f010a95a:	c3                   	ret    

f010a95b <env_table_ws_set_entry>:

inline void env_table_ws_set_entry(struct Env* e, uint32 entry_index, uint32 virtual_address)
{
f010a95b:	55                   	push   %ebp
f010a95c:	89 e5                	mov    %esp,%ebp
f010a95e:	53                   	push   %ebx
f010a95f:	83 ec 14             	sub    $0x14,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010a962:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010a966:	76 19                	jbe    f010a981 <env_table_ws_set_entry+0x26>
f010a968:	68 f8 ef 12 f0       	push   $0xf012eff8
f010a96d:	68 23 ee 12 f0       	push   $0xf012ee23
f010a972:	68 3e 01 00 00       	push   $0x13e
f010a977:	68 38 ee 12 f0       	push   $0xf012ee38
f010a97c:	e8 2e 65 ff ff       	call   f0100eaf <_panic>
	assert(virtual_address >= 0 && virtual_address < USER_TOP);
f010a981:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f010a988:	76 19                	jbe    f010a9a3 <env_table_ws_set_entry+0x48>
f010a98a:	68 f0 ed 12 f0       	push   $0xf012edf0
f010a98f:	68 23 ee 12 f0       	push   $0xf012ee23
f010a994:	68 3f 01 00 00       	push   $0x13f
f010a999:	68 38 ee 12 f0       	push   $0xf012ee38
f010a99e:	e8 0c 65 ff ff       	call   f0100eaf <_panic>
	e->__ptr_tws[entry_index].virtual_address = ROUNDDOWN(virtual_address,PAGE_SIZE*1024);
f010a9a3:	8b 45 10             	mov    0x10(%ebp),%eax
f010a9a6:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010a9a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a9ac:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010a9b1:	89 c1                	mov    %eax,%ecx
f010a9b3:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010a9b6:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a9b9:	89 d0                	mov    %edx,%eax
f010a9bb:	01 c0                	add    %eax,%eax
f010a9bd:	01 d0                	add    %edx,%eax
f010a9bf:	c1 e0 03             	shl    $0x3,%eax
f010a9c2:	01 d8                	add    %ebx,%eax
f010a9c4:	05 b4 00 00 00       	add    $0xb4,%eax
f010a9c9:	89 08                	mov    %ecx,(%eax)
	e->__ptr_tws[entry_index].empty = 0;
f010a9cb:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a9ce:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a9d1:	89 d0                	mov    %edx,%eax
f010a9d3:	01 c0                	add    %eax,%eax
f010a9d5:	01 d0                	add    %edx,%eax
f010a9d7:	c1 e0 03             	shl    $0x3,%eax
f010a9da:	01 c8                	add    %ecx,%eax
f010a9dc:	05 b8 00 00 00       	add    $0xb8,%eax
f010a9e1:	c6 00 00             	movb   $0x0,(%eax)

	//e->__ptr_tws[entry_index].time_stamp = time;
	e->__ptr_tws[entry_index].time_stamp = 0x00000000;
f010a9e4:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a9e7:	8b 55 0c             	mov    0xc(%ebp),%edx
f010a9ea:	89 d0                	mov    %edx,%eax
f010a9ec:	01 c0                	add    %eax,%eax
f010a9ee:	01 d0                	add    %edx,%eax
f010a9f0:	c1 e0 03             	shl    $0x3,%eax
f010a9f3:	01 c8                	add    %ecx,%eax
f010a9f5:	05 bc 00 00 00       	add    $0xbc,%eax
f010a9fa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return;
f010aa00:	90                   	nop
}
f010aa01:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010aa04:	c9                   	leave  
f010aa05:	c3                   	ret    

f010aa06 <env_table_ws_clear_entry>:

inline void env_table_ws_clear_entry(struct Env* e, uint32 entry_index)
{
f010aa06:	55                   	push   %ebp
f010aa07:	89 e5                	mov    %esp,%ebp
f010aa09:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010aa0c:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010aa10:	76 19                	jbe    f010aa2b <env_table_ws_clear_entry+0x25>
f010aa12:	68 f8 ef 12 f0       	push   $0xf012eff8
f010aa17:	68 23 ee 12 f0       	push   $0xf012ee23
f010aa1c:	68 4a 01 00 00       	push   $0x14a
f010aa21:	68 38 ee 12 f0       	push   $0xf012ee38
f010aa26:	e8 84 64 ff ff       	call   f0100eaf <_panic>
	e->__ptr_tws[entry_index].virtual_address = 0;
f010aa2b:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aa2e:	8b 55 0c             	mov    0xc(%ebp),%edx
f010aa31:	89 d0                	mov    %edx,%eax
f010aa33:	01 c0                	add    %eax,%eax
f010aa35:	01 d0                	add    %edx,%eax
f010aa37:	c1 e0 03             	shl    $0x3,%eax
f010aa3a:	01 c8                	add    %ecx,%eax
f010aa3c:	05 b4 00 00 00       	add    $0xb4,%eax
f010aa41:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	e->__ptr_tws[entry_index].empty = 1;
f010aa47:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aa4a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010aa4d:	89 d0                	mov    %edx,%eax
f010aa4f:	01 c0                	add    %eax,%eax
f010aa51:	01 d0                	add    %edx,%eax
f010aa53:	c1 e0 03             	shl    $0x3,%eax
f010aa56:	01 c8                	add    %ecx,%eax
f010aa58:	05 b8 00 00 00       	add    $0xb8,%eax
f010aa5d:	c6 00 01             	movb   $0x1,(%eax)
	e->__ptr_tws[entry_index].time_stamp = 0;
f010aa60:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aa63:	8b 55 0c             	mov    0xc(%ebp),%edx
f010aa66:	89 d0                	mov    %edx,%eax
f010aa68:	01 c0                	add    %eax,%eax
f010aa6a:	01 d0                	add    %edx,%eax
f010aa6c:	c1 e0 03             	shl    $0x3,%eax
f010aa6f:	01 c8                	add    %ecx,%eax
f010aa71:	05 bc 00 00 00       	add    $0xbc,%eax
f010aa76:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
f010aa7c:	90                   	nop
f010aa7d:	c9                   	leave  
f010aa7e:	c3                   	ret    

f010aa7f <env_table_ws_get_virtual_address>:

inline uint32 env_table_ws_get_virtual_address(struct Env* e, uint32 entry_index)
{
f010aa7f:	55                   	push   %ebp
f010aa80:	89 e5                	mov    %esp,%ebp
f010aa82:	83 ec 18             	sub    $0x18,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010aa85:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010aa89:	76 19                	jbe    f010aaa4 <env_table_ws_get_virtual_address+0x25>
f010aa8b:	68 f8 ef 12 f0       	push   $0xf012eff8
f010aa90:	68 23 ee 12 f0       	push   $0xf012ee23
f010aa95:	68 52 01 00 00       	push   $0x152
f010aa9a:	68 38 ee 12 f0       	push   $0xf012ee38
f010aa9f:	e8 0b 64 ff ff       	call   f0100eaf <_panic>
	return ROUNDDOWN(e->__ptr_tws[entry_index].virtual_address,PAGE_SIZE*1024);
f010aaa4:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aaa7:	8b 55 0c             	mov    0xc(%ebp),%edx
f010aaaa:	89 d0                	mov    %edx,%eax
f010aaac:	01 c0                	add    %eax,%eax
f010aaae:	01 d0                	add    %edx,%eax
f010aab0:	c1 e0 03             	shl    $0x3,%eax
f010aab3:	01 c8                	add    %ecx,%eax
f010aab5:	05 b4 00 00 00       	add    $0xb4,%eax
f010aaba:	8b 00                	mov    (%eax),%eax
f010aabc:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010aabf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aac2:	25 00 00 c0 ff       	and    $0xffc00000,%eax
}
f010aac7:	c9                   	leave  
f010aac8:	c3                   	ret    

f010aac9 <env_table_ws_get_time_stamp>:


inline uint32 env_table_ws_get_time_stamp(struct Env* e, uint32 entry_index)
{
f010aac9:	55                   	push   %ebp
f010aaca:	89 e5                	mov    %esp,%ebp
f010aacc:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010aacf:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010aad3:	76 19                	jbe    f010aaee <env_table_ws_get_time_stamp+0x25>
f010aad5:	68 f8 ef 12 f0       	push   $0xf012eff8
f010aada:	68 23 ee 12 f0       	push   $0xf012ee23
f010aadf:	68 59 01 00 00       	push   $0x159
f010aae4:	68 38 ee 12 f0       	push   $0xf012ee38
f010aae9:	e8 c1 63 ff ff       	call   f0100eaf <_panic>
	return e->__ptr_tws[entry_index].time_stamp;
f010aaee:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aaf1:	8b 55 0c             	mov    0xc(%ebp),%edx
f010aaf4:	89 d0                	mov    %edx,%eax
f010aaf6:	01 c0                	add    %eax,%eax
f010aaf8:	01 d0                	add    %edx,%eax
f010aafa:	c1 e0 03             	shl    $0x3,%eax
f010aafd:	01 c8                	add    %ecx,%eax
f010aaff:	05 bc 00 00 00       	add    $0xbc,%eax
f010ab04:	8b 00                	mov    (%eax),%eax
}
f010ab06:	c9                   	leave  
f010ab07:	c3                   	ret    

f010ab08 <env_table_ws_is_entry_empty>:

inline uint32 env_table_ws_is_entry_empty(struct Env* e, uint32 entry_index)
{
f010ab08:	55                   	push   %ebp
f010ab09:	89 e5                	mov    %esp,%ebp
	return e->__ptr_tws[entry_index].empty;
f010ab0b:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ab0e:	8b 55 0c             	mov    0xc(%ebp),%edx
f010ab11:	89 d0                	mov    %edx,%eax
f010ab13:	01 c0                	add    %eax,%eax
f010ab15:	01 d0                	add    %edx,%eax
f010ab17:	c1 e0 03             	shl    $0x3,%eax
f010ab1a:	01 c8                	add    %ecx,%eax
f010ab1c:	05 b8 00 00 00       	add    $0xb8,%eax
f010ab21:	8a 00                	mov    (%eax),%al
f010ab23:	0f b6 c0             	movzbl %al,%eax
}
f010ab26:	5d                   	pop    %ebp
f010ab27:	c3                   	ret    

f010ab28 <cut_paste_WS>:
///=================================================================================================

// Change WS Sizes For PRIORITY  =========================================================

void cut_paste_WS(struct WorkingSetElement* newWS, int newSize, struct Env* e)
{
f010ab28:	55                   	push   %ebp
f010ab29:	89 e5                	mov    %esp,%ebp
f010ab2b:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010ab2e:	83 ec 04             	sub    $0x4,%esp
f010ab31:	68 29 f0 12 f0       	push   $0xf012f029
f010ab36:	68 6b 01 00 00       	push   $0x16b
f010ab3b:	68 38 ee 12 f0       	push   $0xf012ee38
f010ab40:	e8 6a 63 ff ff       	call   f0100eaf <_panic>

f010ab45 <double_WS_Size>:
}

void double_WS_Size(struct Env* e, int isOneTimeOnly)
{
f010ab45:	55                   	push   %ebp
f010ab46:	89 e5                	mov    %esp,%ebp
f010ab48:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010ab4b:	83 ec 04             	sub    $0x4,%esp
f010ab4e:	68 29 f0 12 f0       	push   $0xf012f029
f010ab53:	68 70 01 00 00       	push   $0x170
f010ab58:	68 38 ee 12 f0       	push   $0xf012ee38
f010ab5d:	e8 4d 63 ff ff       	call   f0100eaf <_panic>

f010ab62 <half_WS_Size>:
}

void half_WS_Size(struct Env* e, int isImmidiate)
{
f010ab62:	55                   	push   %ebp
f010ab63:	89 e5                	mov    %esp,%ebp
f010ab65:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010ab68:	83 ec 04             	sub    $0x4,%esp
f010ab6b:	68 29 f0 12 f0       	push   $0xf012f029
f010ab70:	68 75 01 00 00       	push   $0x175
f010ab75:	68 38 ee 12 f0       	push   $0xf012ee38
f010ab7a:	e8 30 63 ff ff       	call   f0100eaf <_panic>

f010ab7f <cut_paste_pages>:
//	If the page table at any destination page in the range is not exist, it should create it
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, cut-paste the number of pages and return 0
//	ALL 12 permission bits of the destination should be TYPICAL to those of the source
//	The given addresses may be not aligned on 4 KB
int cut_paste_pages(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 num_of_pages)
{
f010ab7f:	55                   	push   %ebp
f010ab80:	89 e5                	mov    %esp,%ebp
f010ab82:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("cut_paste_pages() is not implemented yet...!!");
f010ab85:	83 ec 04             	sub    $0x4,%esp
f010ab88:	68 3c f0 12 f0       	push   $0xf012f03c
f010ab8d:	6a 21                	push   $0x21
f010ab8f:	68 6a f0 12 f0       	push   $0xf012f06a
f010ab94:	e8 16 63 ff ff       	call   f0100eaf <_panic>

f010ab99 <copy_paste_chunk>:
//	Otherwise, just copy!
//		1. WRITABLE permission
//		2. USER/SUPERVISOR permission must be SAME as the one of the source
//	The given range(s) may be not aligned on 4 KB
int copy_paste_chunk(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 size)
{
f010ab99:	55                   	push   %ebp
f010ab9a:	89 e5                	mov    %esp,%ebp
f010ab9c:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("copy_paste_chunk() is not implemented yet...!!");
f010ab9f:	83 ec 04             	sub    $0x4,%esp
f010aba2:	68 88 f0 12 f0       	push   $0xf012f088
f010aba7:	6a 34                	push   $0x34
f010aba9:	68 6a f0 12 f0       	push   $0xf012f06a
f010abae:	e8 fc 62 ff ff       	call   f0100eaf <_panic>

f010abb3 <share_chunk>:
//	Otherwise, share the required range and return 0
//	During the share process:
//		1. If the page table at any destination page in the range is not exist, it should create it
//	The given range(s) may be not aligned on 4 KB
int share_chunk(uint32* page_directory, uint32 source_va,uint32 dest_va, uint32 size, uint32 perms)
{
f010abb3:	55                   	push   %ebp
f010abb4:	89 e5                	mov    %esp,%ebp
f010abb6:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("share_chunk() is not implemented yet...!!");
f010abb9:	83 ec 04             	sub    $0x4,%esp
f010abbc:	68 b8 f0 12 f0       	push   $0xf012f0b8
f010abc1:	6a 46                	push   $0x46
f010abc3:	68 6a f0 12 f0       	push   $0xf012f06a
f010abc8:	e8 e2 62 ff ff       	call   f0100eaf <_panic>

f010abcd <allocate_chunk>:
//This function should allocate the given virtual range [<va>, <va> + <size>) in the given address space  <page_directory> with the given permissions <perms>.
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, allocate the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	Allocation should be aligned on page boundary. However, the given range may be not aligned.
int allocate_chunk(uint32* page_directory, uint32 va, uint32 size, uint32 perms)
{
f010abcd:	55                   	push   %ebp
f010abce:	89 e5                	mov    %esp,%ebp
f010abd0:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("allocate_chunk() is not implemented yet...!!");
f010abd3:	83 ec 04             	sub    $0x4,%esp
f010abd6:	68 e4 f0 12 f0       	push   $0xf012f0e4
f010abdb:	6a 54                	push   $0x54
f010abdd:	68 6a f0 12 f0       	push   $0xf012f06a
f010abe2:	e8 c8 62 ff ff       	call   f0100eaf <_panic>

f010abe7 <calculate_free_space>:
//=====================================
//It should count the number of free pages in the given range [va1, va2)
//(i.e. number of pages that are not mapped).
//Addresses may not be aligned on page boundaries
uint32 calculate_free_space(uint32* page_directory, uint32 sva, uint32 eva)
{
f010abe7:	55                   	push   %ebp
f010abe8:	89 e5                	mov    %esp,%ebp
f010abea:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("calculate_free_space() is not implemented yet...!!");
f010abed:	83 ec 04             	sub    $0x4,%esp
f010abf0:	68 14 f1 12 f0       	push   $0xf012f114
f010abf5:	6a 62                	push   $0x62
f010abf7:	68 6a f0 12 f0       	push   $0xf012f06a
f010abfc:	e8 ae 62 ff ff       	call   f0100eaf <_panic>

f010ac01 <calculate_allocated_space>:

//=====================================
// 6) CALCULATE ALLOCATED SPACE:
//=====================================
void calculate_allocated_space(uint32* page_directory, uint32 sva, uint32 eva, uint32 *num_tables, uint32 *num_pages)
{
f010ac01:	55                   	push   %ebp
f010ac02:	89 e5                	mov    %esp,%ebp
f010ac04:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("calculate_allocated_space() is not implemented yet...!!");
f010ac07:	83 ec 04             	sub    $0x4,%esp
f010ac0a:	68 48 f1 12 f0       	push   $0xf012f148
f010ac0f:	6a 6c                	push   $0x6c
f010ac11:	68 6a f0 12 f0       	push   $0xf012f06a
f010ac16:	e8 94 62 ff ff       	call   f0100eaf <_panic>

f010ac1b <calculate_required_frames>:
//=====================================
//This function should calculate the required number of pages for allocating and mapping the given range [start va, start va + size) (either for the pages themselves or for the page tables required for mapping)
//	Pages and/or page tables that are already exist in the range SHOULD NOT be counted.
//	The given range(s) may be not aligned on 4 KB
uint32 calculate_required_frames(uint32* page_directory, uint32 sva, uint32 size)
{
f010ac1b:	55                   	push   %ebp
f010ac1c:	89 e5                	mov    %esp,%ebp
f010ac1e:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("calculate_required_frames() is not implemented yet...!!");
f010ac21:	83 ec 04             	sub    $0x4,%esp
f010ac24:	68 80 f1 12 f0       	push   $0xf012f180
f010ac29:	6a 79                	push   $0x79
f010ac2b:	68 6a f0 12 f0       	push   $0xf012f06a
f010ac30:	e8 7a 62 ff ff       	call   f0100eaf <_panic>

f010ac35 <sys_sbrk>:
//=====================================
/* DYNAMIC ALLOCATOR SYSTEM CALLS */
//=====================================
/*2024*/
void* sys_sbrk(int numOfPages)
{
f010ac35:	55                   	push   %ebp
f010ac36:	89 e5                	mov    %esp,%ebp
f010ac38:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f010ac3b:	83 ec 04             	sub    $0x4,%esp
f010ac3e:	68 b8 f1 12 f0       	push   $0xf012f1b8
f010ac43:	68 8e 00 00 00       	push   $0x8e
f010ac48:	68 6a f0 12 f0       	push   $0xf012f06a
f010ac4d:	e8 5d 62 ff ff       	call   f0100eaf <_panic>

f010ac52 <allocate_user_mem>:

//=====================================
// 1) ALLOCATE USER MEMORY:
//=====================================
void allocate_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f010ac52:	55                   	push   %ebp
f010ac53:	89 e5                	mov    %esp,%ebp
f010ac55:	83 ec 08             	sub    $0x8,%esp
	/*====================================*/

	//TODO: [PROJECT'25.IM#2] USER HEAP - #2 allocate_user_mem
	//Your code is here
	//Comment the following line
	panic("allocate_user_mem() is not implemented yet...!!");
f010ac58:	83 ec 04             	sub    $0x4,%esp
f010ac5b:	68 d4 f1 12 f0       	push   $0xf012f1d4
f010ac60:	68 9f 00 00 00       	push   $0x9f
f010ac65:	68 6a f0 12 f0       	push   $0xf012f06a
f010ac6a:	e8 40 62 ff ff       	call   f0100eaf <_panic>

f010ac6f <free_user_mem>:

//=====================================
// 2) FREE USER MEMORY:
//=====================================
void free_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f010ac6f:	55                   	push   %ebp
f010ac70:	89 e5                	mov    %esp,%ebp
f010ac72:	83 ec 08             	sub    $0x8,%esp
	/*====================================*/

	//TODO: [PROJECT'25.IM#2] USER HEAP - #4 free_user_mem
	//Your code is here
	//Comment the following line
	panic("free_user_mem() is not implemented yet...!!");
f010ac75:	83 ec 04             	sub    $0x4,%esp
f010ac78:	68 04 f2 12 f0       	push   $0xf012f204
f010ac7d:	68 b0 00 00 00       	push   $0xb0
f010ac82:	68 6a f0 12 f0       	push   $0xf012f06a
f010ac87:	e8 23 62 ff ff       	call   f0100eaf <_panic>

f010ac8c <__free_user_mem_with_buffering>:

//=====================================
// 4) FREE USER MEMORY (BUFFERING):
//=====================================
void __free_user_mem_with_buffering(struct Env* e, uint32 virtual_address, uint32 size)
{
f010ac8c:	55                   	push   %ebp
f010ac8d:	89 e5                	mov    %esp,%ebp
f010ac8f:	83 ec 08             	sub    $0x8,%esp
	// your code is here, remove the panic and write your code
	panic("__free_user_mem_with_buffering() is not implemented yet...!!");
f010ac92:	83 ec 04             	sub    $0x4,%esp
f010ac95:	68 30 f2 12 f0       	push   $0xf012f230
f010ac9a:	68 b9 00 00 00       	push   $0xb9
f010ac9f:	68 6a f0 12 f0       	push   $0xf012f06a
f010aca4:	e8 06 62 ff ff       	call   f0100eaf <_panic>

f010aca9 <move_user_mem>:

//=====================================
// 3) MOVE USER MEMORY:
//=====================================
void move_user_mem(struct Env* e, uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010aca9:	55                   	push   %ebp
f010acaa:	89 e5                	mov    %esp,%ebp
f010acac:	83 ec 08             	sub    $0x8,%esp
	panic("move_user_mem() is not implemented yet...!!");
f010acaf:	83 ec 04             	sub    $0x4,%esp
f010acb2:	68 70 f2 12 f0       	push   $0xf012f270
f010acb7:	68 c1 00 00 00       	push   $0xc1
f010acbc:	68 6a f0 12 f0       	push   $0xf012f06a
f010acc1:	e8 e9 61 ff ff       	call   f0100eaf <_panic>

f010acc6 <env_init>:
// and insert them into the env_free_list.
// Insert in reverse order, so that the first call to allocate_environment()
// returns envs[0].
//
void env_init(void)
{
f010acc6:	55                   	push   %ebp
f010acc7:	89 e5                	mov    %esp,%ebp
f010acc9:	53                   	push   %ebx
f010acca:	83 ec 14             	sub    $0x14,%esp
	int iEnv = NENV-1;
f010accd:	c7 45 f4 c5 02 00 00 	movl   $0x2c5,-0xc(%ebp)
	for(; iEnv >= 0; iEnv--)
f010acd4:	e9 78 01 00 00       	jmp    f010ae51 <env_init+0x18b>
	{
		envs[iEnv].env_status = ENV_FREE;
f010acd9:	8b 0d 90 5b 81 f0    	mov    0xf0815b90,%ecx
f010acdf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ace2:	89 d0                	mov    %edx,%eax
f010ace4:	c1 e0 02             	shl    $0x2,%eax
f010ace7:	01 d0                	add    %edx,%eax
f010ace9:	c1 e0 03             	shl    $0x3,%eax
f010acec:	01 d0                	add    %edx,%eax
f010acee:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010acf5:	01 d0                	add    %edx,%eax
f010acf7:	c1 e0 02             	shl    $0x2,%eax
f010acfa:	01 c8                	add    %ecx,%eax
f010acfc:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
		envs[iEnv].env_id = 0;
f010ad03:	8b 0d 90 5b 81 f0    	mov    0xf0815b90,%ecx
f010ad09:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ad0c:	89 d0                	mov    %edx,%eax
f010ad0e:	c1 e0 02             	shl    $0x2,%eax
f010ad11:	01 d0                	add    %edx,%eax
f010ad13:	c1 e0 03             	shl    $0x3,%eax
f010ad16:	01 d0                	add    %edx,%eax
f010ad18:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010ad1f:	01 d0                	add    %edx,%eax
f010ad21:	c1 e0 02             	shl    $0x2,%eax
f010ad24:	01 c8                	add    %ecx,%eax
f010ad26:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
f010ad2d:	8b 0d 90 5b 81 f0    	mov    0xf0815b90,%ecx
f010ad33:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ad36:	89 d0                	mov    %edx,%eax
f010ad38:	c1 e0 02             	shl    $0x2,%eax
f010ad3b:	01 d0                	add    %edx,%eax
f010ad3d:	c1 e0 03             	shl    $0x3,%eax
f010ad40:	01 d0                	add    %edx,%eax
f010ad42:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010ad49:	01 d0                	add    %edx,%eax
f010ad4b:	c1 e0 02             	shl    $0x2,%eax
f010ad4e:	01 c8                	add    %ecx,%eax
f010ad50:	85 c0                	test   %eax,%eax
f010ad52:	75 14                	jne    f010ad68 <env_init+0xa2>
f010ad54:	83 ec 04             	sub    $0x4,%esp
f010ad57:	68 9c f2 12 f0       	push   $0xf012f29c
f010ad5c:	6a 65                	push   $0x65
f010ad5e:	68 bf f2 12 f0       	push   $0xf012f2bf
f010ad63:	e8 47 61 ff ff       	call   f0100eaf <_panic>
f010ad68:	8b 0d 90 5b 81 f0    	mov    0xf0815b90,%ecx
f010ad6e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ad71:	89 d0                	mov    %edx,%eax
f010ad73:	c1 e0 02             	shl    $0x2,%eax
f010ad76:	01 d0                	add    %edx,%eax
f010ad78:	c1 e0 03             	shl    $0x3,%eax
f010ad7b:	01 d0                	add    %edx,%eax
f010ad7d:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010ad84:	01 d0                	add    %edx,%eax
f010ad86:	c1 e0 02             	shl    $0x2,%eax
f010ad89:	01 c8                	add    %ecx,%eax
f010ad8b:	8b 15 94 5b 81 f0    	mov    0xf0815b94,%edx
f010ad91:	89 50 08             	mov    %edx,0x8(%eax)
f010ad94:	8b 40 08             	mov    0x8(%eax),%eax
f010ad97:	85 c0                	test   %eax,%eax
f010ad99:	74 2e                	je     f010adc9 <env_init+0x103>
f010ad9b:	8b 0d 94 5b 81 f0    	mov    0xf0815b94,%ecx
f010ada1:	8b 1d 90 5b 81 f0    	mov    0xf0815b90,%ebx
f010ada7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010adaa:	89 d0                	mov    %edx,%eax
f010adac:	c1 e0 02             	shl    $0x2,%eax
f010adaf:	01 d0                	add    %edx,%eax
f010adb1:	c1 e0 03             	shl    $0x3,%eax
f010adb4:	01 d0                	add    %edx,%eax
f010adb6:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010adbd:	01 d0                	add    %edx,%eax
f010adbf:	c1 e0 02             	shl    $0x2,%eax
f010adc2:	01 d8                	add    %ebx,%eax
f010adc4:	89 41 0c             	mov    %eax,0xc(%ecx)
f010adc7:	eb 28                	jmp    f010adf1 <env_init+0x12b>
f010adc9:	8b 0d 90 5b 81 f0    	mov    0xf0815b90,%ecx
f010adcf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010add2:	89 d0                	mov    %edx,%eax
f010add4:	c1 e0 02             	shl    $0x2,%eax
f010add7:	01 d0                	add    %edx,%eax
f010add9:	c1 e0 03             	shl    $0x3,%eax
f010addc:	01 d0                	add    %edx,%eax
f010adde:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010ade5:	01 d0                	add    %edx,%eax
f010ade7:	c1 e0 02             	shl    $0x2,%eax
f010adea:	01 c8                	add    %ecx,%eax
f010adec:	a3 98 5b 81 f0       	mov    %eax,0xf0815b98
f010adf1:	8b 0d 90 5b 81 f0    	mov    0xf0815b90,%ecx
f010adf7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010adfa:	89 d0                	mov    %edx,%eax
f010adfc:	c1 e0 02             	shl    $0x2,%eax
f010adff:	01 d0                	add    %edx,%eax
f010ae01:	c1 e0 03             	shl    $0x3,%eax
f010ae04:	01 d0                	add    %edx,%eax
f010ae06:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010ae0d:	01 d0                	add    %edx,%eax
f010ae0f:	c1 e0 02             	shl    $0x2,%eax
f010ae12:	01 c8                	add    %ecx,%eax
f010ae14:	a3 94 5b 81 f0       	mov    %eax,0xf0815b94
f010ae19:	8b 0d 90 5b 81 f0    	mov    0xf0815b90,%ecx
f010ae1f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ae22:	89 d0                	mov    %edx,%eax
f010ae24:	c1 e0 02             	shl    $0x2,%eax
f010ae27:	01 d0                	add    %edx,%eax
f010ae29:	c1 e0 03             	shl    $0x3,%eax
f010ae2c:	01 d0                	add    %edx,%eax
f010ae2e:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010ae35:	01 d0                	add    %edx,%eax
f010ae37:	c1 e0 02             	shl    $0x2,%eax
f010ae3a:	01 c8                	add    %ecx,%eax
f010ae3c:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010ae43:	a1 a0 5b 81 f0       	mov    0xf0815ba0,%eax
f010ae48:	40                   	inc    %eax
f010ae49:	a3 a0 5b 81 f0       	mov    %eax,0xf0815ba0
// returns envs[0].
//
void env_init(void)
{
	int iEnv = NENV-1;
	for(; iEnv >= 0; iEnv--)
f010ae4e:	ff 4d f4             	decl   -0xc(%ebp)
f010ae51:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ae55:	0f 89 7e fe ff ff    	jns    f010acd9 <env_init+0x13>
	{
		envs[iEnv].env_status = ENV_FREE;
		envs[iEnv].env_id = 0;
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
	}
}
f010ae5b:	90                   	nop
f010ae5c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010ae5f:	c9                   	leave  
f010ae60:	c3                   	ret    

f010ae61 <env_create>:
//===============================
// 1) CREATE NEW ENV & LOAD IT:
//===============================
// Allocates a new env and loads the named user program into it.
struct Env* env_create(char* user_program_name, unsigned int page_WS_size, unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010ae61:	55                   	push   %ebp
f010ae62:	89 e5                	mov    %esp,%ebp
f010ae64:	57                   	push   %edi
f010ae65:	56                   	push   %esi
f010ae66:	53                   	push   %ebx
f010ae67:	81 ec fc 00 00 00    	sub    $0xfc,%esp
	//[0] 2024: Disable the interrupt through the entire function to avoid concurrency issues while:
	//		1. switching the directories
	//		2. between allocate_environment and removing it later in complete_env..._initi...
	/*THANKS to T58 - 2024/2025*/

	struct Env* e = NULL;
f010ae6d:	c7 85 44 ff ff ff 00 	movl   $0x0,-0xbc(%ebp)
f010ae74:	00 00 00 

	pushcli();
f010ae77:	e8 b4 d1 ff ff       	call   f0108030 <pushcli>
	{
		//[1] get pointer to the start of the "user_program_name" program in memory
		// Hint: use "get_user_program_info" function,
		// you should set the following "ptr_program_start" by the start address of the user program
		uint8* ptr_program_start = 0;
f010ae7c:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)

		struct UserProgramInfo* ptr_user_program_info = get_user_program_info(user_program_name);
f010ae83:	83 ec 0c             	sub    $0xc,%esp
f010ae86:	ff 75 08             	pushl  0x8(%ebp)
f010ae89:	e8 f0 1e 00 00       	call   f010cd7e <get_user_program_info>
f010ae8e:	83 c4 10             	add    $0x10,%esp
f010ae91:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if(ptr_user_program_info == 0)
f010ae94:	83 7d ac 00          	cmpl   $0x0,-0x54(%ebp)
f010ae98:	75 0f                	jne    f010aea9 <env_create+0x48>
		{
			popcli();
f010ae9a:	e8 e3 d1 ff ff       	call   f0108082 <popcli>
			return NULL;
f010ae9f:	b8 00 00 00 00       	mov    $0x0,%eax
f010aea4:	e9 b6 0a 00 00       	jmp    f010b95f <env_create+0xafe>
		}
		ptr_program_start = ptr_user_program_info->ptr_start ;
f010aea9:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010aeac:	8b 40 08             	mov    0x8(%eax),%eax
f010aeaf:	89 45 b0             	mov    %eax,-0x50(%ebp)

		//[2] allocate new environment, (from the free environment list)
		//if there's no one, return NULL
		// Hint: use "allocate_environment" function
		if(allocate_environment(&e) < 0)
f010aeb2:	83 ec 0c             	sub    $0xc,%esp
f010aeb5:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
f010aebb:	50                   	push   %eax
f010aebc:	e8 bd 0f 00 00       	call   f010be7e <allocate_environment>
f010aec1:	83 c4 10             	add    $0x10,%esp
f010aec4:	85 c0                	test   %eax,%eax
f010aec6:	79 0f                	jns    f010aed7 <env_create+0x76>
		{
			popcli();
f010aec8:	e8 b5 d1 ff ff       	call   f0108082 <popcli>
			return NULL;
f010aecd:	b8 00 00 00 00       	mov    $0x0,%eax
f010aed2:	e9 88 0a 00 00       	jmp    f010b95f <env_create+0xafe>
		}

		//[2.5 - 2012] Set program name inside the environment
		//e->prog_name = ptr_user_program_info->name ;
		//2017: changed to fixed size array to be abale to access it from user side
		if (strlen(ptr_user_program_info->name) < PROGNAMELEN)
f010aed7:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010aeda:	8b 00                	mov    (%eax),%eax
f010aedc:	83 ec 0c             	sub    $0xc,%esp
f010aedf:	50                   	push   %eax
f010aee0:	e8 96 fb 00 00       	call   f011aa7b <strlen>
f010aee5:	83 c4 10             	add    $0x10,%esp
f010aee8:	83 f8 3f             	cmp    $0x3f,%eax
f010aeeb:	7f 1d                	jg     f010af0a <env_create+0xa9>
			strcpy(e->prog_name, ptr_user_program_info->name);
f010aeed:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010aef0:	8b 00                	mov    (%eax),%eax
f010aef2:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f010aef8:	83 c2 20             	add    $0x20,%edx
f010aefb:	83 ec 08             	sub    $0x8,%esp
f010aefe:	50                   	push   %eax
f010aeff:	52                   	push   %edx
f010af00:	e8 c5 fb 00 00       	call   f011aaca <strcpy>
f010af05:	83 c4 10             	add    $0x10,%esp
f010af08:	eb 1d                	jmp    f010af27 <env_create+0xc6>
		else
			strncpy(e->prog_name, ptr_user_program_info->name, PROGNAMELEN-1);
f010af0a:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010af0d:	8b 00                	mov    (%eax),%eax
f010af0f:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f010af15:	83 c2 20             	add    $0x20,%edx
f010af18:	83 ec 04             	sub    $0x4,%esp
f010af1b:	6a 3f                	push   $0x3f
f010af1d:	50                   	push   %eax
f010af1e:	52                   	push   %edx
f010af1f:	e8 d4 fb 00 00       	call   f011aaf8 <strncpy>
f010af24:	83 c4 10             	add    $0x10,%esp
		//REMEMBER: "allocate_frame" should always return a free frame
		uint32* ptr_user_page_directory;
		unsigned int phys_user_page_directory;
#if USE_KHEAP
		{
			ptr_user_page_directory = create_user_directory();
f010af27:	e8 1e 15 00 00       	call   f010c44a <create_user_directory>
f010af2c:	89 45 a8             	mov    %eax,-0x58(%ebp)
			phys_user_page_directory = kheap_physical_address((uint32)ptr_user_page_directory);
f010af2f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010af32:	83 ec 0c             	sub    $0xc,%esp
f010af35:	50                   	push   %eax
f010af36:	e8 49 ec ff ff       	call   f0109b84 <kheap_physical_address>
f010af3b:	83 c4 10             	add    $0x10,%esp
f010af3e:	89 45 a4             	mov    %eax,-0x5c(%ebp)
#endif
		//[4] initialize the new environment by the virtual address of the page directory
		// Hint: use "initialize_environment" function

		//2016
		e->page_WS_max_size = page_WS_size;
f010af41:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010af47:	8b 55 0c             	mov    0xc(%ebp),%edx
f010af4a:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)

		//2020
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010af50:	83 ec 0c             	sub    $0xc,%esp
f010af53:	6a 02                	push   $0x2
f010af55:	e8 c9 48 00 00       	call   f010f823 <isPageReplacmentAlgorithmLRU>
f010af5a:	83 c4 10             	add    $0x10,%esp
f010af5d:	85 c0                	test   %eax,%eax
f010af5f:	74 21                	je     f010af82 <env_create+0x121>
		{
			e->SecondListSize = LRU_second_list_size;
f010af61:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010af67:	8b 55 10             	mov    0x10(%ebp),%edx
f010af6a:	89 90 8c 05 00 00    	mov    %edx,0x58c(%eax)
			e->ActiveListSize = page_WS_size - LRU_second_list_size;
f010af70:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010af76:	8b 55 0c             	mov    0xc(%ebp),%edx
f010af79:	2b 55 10             	sub    0x10(%ebp),%edx
f010af7c:	89 90 88 05 00 00    	mov    %edx,0x588(%eax)
		}

		//2018
		if (percent_WS_pages_to_remove == 0)	// If not entered as input, 0 as default value
f010af82:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f010af86:	75 12                	jne    f010af9a <env_create+0x139>
			e->percentage_of_WS_pages_to_be_removed = DEFAULT_PERCENT_OF_PAGE_WS_TO_REMOVE;
f010af88:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010af8e:	c7 80 94 05 00 00 0a 	movl   $0xa,0x594(%eax)
f010af95:	00 00 00 
f010af98:	eb 0f                	jmp    f010afa9 <env_create+0x148>
		else
			e->percentage_of_WS_pages_to_be_removed = percent_WS_pages_to_remove;
f010af9a:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010afa0:	8b 55 14             	mov    0x14(%ebp),%edx
f010afa3:	89 90 94 05 00 00    	mov    %edx,0x594(%eax)

		initialize_environment(e, ptr_user_page_directory, phys_user_page_directory);
f010afa9:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010afaf:	83 ec 04             	sub    $0x4,%esp
f010afb2:	ff 75 a4             	pushl  -0x5c(%ebp)
f010afb5:	ff 75 a8             	pushl  -0x58(%ebp)
f010afb8:	50                   	push   %eax
f010afb9:	e8 01 15 00 00       	call   f010c4bf <initialize_environment>
f010afbe:	83 c4 10             	add    $0x10,%esp

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f010afc1:	0f 20 d8             	mov    %cr3,%eax
f010afc4:	89 45 98             	mov    %eax,-0x68(%ebp)
	return val;
f010afc7:	8b 45 98             	mov    -0x68(%ebp),%eax
		//	3- uint32 size_in_memory: actual size required by this segment in memory
		// 	usually size_in_file < or = size_in_memory
		//	4- uint8 *virtual_address: start virtual address that this segment should be copied to it

		//[6] switch to user page directory
		uint32 cur_phys_pgdir = rcr3() ;
f010afca:	89 45 9c             	mov    %eax,-0x64(%ebp)
		lcr3(e->env_cr3) ;
f010afcd:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010afd3:	8b 40 68             	mov    0x68(%eax),%eax
f010afd6:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010afdc:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f010afe2:	0f 22 d8             	mov    %eax,%cr3

		//[7] load each program segment into user virtual space
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
f010afe5:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		int segment_counter=0;
f010afec:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
f010aff3:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010aff9:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010afff:	48                   	dec    %eax
f010b000:	89 45 dc             	mov    %eax,-0x24(%ebp)
		uint32 lastTableNumber=0xffffffff;
f010b003:	c7 85 40 ff ff ff ff 	movl   $0xffffffff,-0xc0(%ebp)
f010b00a:	ff ff ff 

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010b00d:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
f010b013:	83 ec 08             	sub    $0x8,%esp
f010b016:	ff 75 b0             	pushl  -0x50(%ebp)
f010b019:	50                   	push   %eax
f010b01a:	e8 6e 1a 00 00       	call   f010ca8d <PROGRAM_SEGMENT_FIRST>
f010b01f:	83 c4 0c             	add    $0xc,%esp
f010b022:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
f010b028:	8d 95 f8 fe ff ff    	lea    -0x108(%ebp),%edx
f010b02e:	b9 05 00 00 00       	mov    $0x5,%ecx
f010b033:	89 c7                	mov    %eax,%edi
f010b035:	89 d6                	mov    %edx,%esi
f010b037:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010b039:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
f010b03f:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010b042:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010b045:	8b 40 10             	mov    0x10(%eax),%eax
f010b048:	83 f8 ff             	cmp    $0xffffffff,%eax
f010b04b:	75 07                	jne    f010b054 <env_create+0x1f3>
f010b04d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f010b054:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010b057:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010b05a:	e9 2d 03 00 00       	jmp    f010b38c <env_create+0x52b>
		{
			segment_counter++;
f010b05f:	ff 45 e0             	incl   -0x20(%ebp)
			LOG_STRING("===============================================================================");
			LOG_STATMENT(cprintf("SEGMENT #%d, size_in_file = %d, size_in_memory= %d, dest va = %x",segment_counter,seg->size_in_file,
					seg->size_in_memory, seg->virtual_address));
			LOG_STRING("===============================================================================");

			uint32 allocated_pages=0;
f010b062:	c7 85 28 ff ff ff 00 	movl   $0x0,-0xd8(%ebp)
f010b069:	00 00 00 
			program_segment_alloc_map_copy_workingset(e, seg, &allocated_pages, remaining_ws_pages, &lastTableNumber);
f010b06c:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b072:	83 ec 0c             	sub    $0xc,%esp
f010b075:	8d 95 40 ff ff ff    	lea    -0xc0(%ebp),%edx
f010b07b:	52                   	push   %edx
f010b07c:	ff 75 dc             	pushl  -0x24(%ebp)
f010b07f:	8d 95 28 ff ff ff    	lea    -0xd8(%ebp),%edx
f010b085:	52                   	push   %edx
f010b086:	ff 75 e4             	pushl  -0x1c(%ebp)
f010b089:	50                   	push   %eax
f010b08a:	e8 ad 0e 00 00       	call   f010bf3c <program_segment_alloc_map_copy_workingset>
f010b08f:	83 c4 20             	add    $0x20,%esp

			remaining_ws_pages -= allocated_pages;
f010b092:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
f010b098:	29 45 dc             	sub    %eax,-0x24(%ebp)
			LOG_STATMENT(cprintf("SEGMENT: allocated pages in WS = %d",allocated_pages));
			LOG_STATMENT(cprintf("SEGMENT: remaining WS pages after allocation = %d",remaining_ws_pages));


			/// 7.2) temporary initialize 1st page in memory then writing it on page file
			uint32 dataSrc_va = (uint32) seg->ptr_start;
f010b09b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b09e:	8b 00                	mov    (%eax),%eax
f010b0a0:	89 45 94             	mov    %eax,-0x6c(%ebp)
			uint32 seg_va = (uint32) seg->virtual_address ;
f010b0a3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b0a6:	8b 40 0c             	mov    0xc(%eax),%eax
f010b0a9:	89 45 90             	mov    %eax,-0x70(%ebp)

			uint32 start_first_page = ROUNDDOWN(seg_va , PAGE_SIZE);
f010b0ac:	8b 45 90             	mov    -0x70(%ebp),%eax
f010b0af:	89 45 8c             	mov    %eax,-0x74(%ebp)
f010b0b2:	8b 45 8c             	mov    -0x74(%ebp),%eax
f010b0b5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b0ba:	89 45 88             	mov    %eax,-0x78(%ebp)
			uint32 end_first_page = ROUNDUP(seg_va , PAGE_SIZE);
f010b0bd:	c7 45 84 00 10 00 00 	movl   $0x1000,-0x7c(%ebp)
f010b0c4:	8b 55 90             	mov    -0x70(%ebp),%edx
f010b0c7:	8b 45 84             	mov    -0x7c(%ebp),%eax
f010b0ca:	01 d0                	add    %edx,%eax
f010b0cc:	48                   	dec    %eax
f010b0cd:	89 45 80             	mov    %eax,-0x80(%ebp)
f010b0d0:	8b 45 80             	mov    -0x80(%ebp),%eax
f010b0d3:	ba 00 00 00 00       	mov    $0x0,%edx
f010b0d8:	f7 75 84             	divl   -0x7c(%ebp)
f010b0db:	8b 45 80             	mov    -0x80(%ebp),%eax
f010b0de:	29 d0                	sub    %edx,%eax
f010b0e0:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
			uint32 offset_first_page = seg_va  - start_first_page ;
f010b0e6:	8b 45 90             	mov    -0x70(%ebp),%eax
f010b0e9:	2b 45 88             	sub    -0x78(%ebp),%eax
f010b0ec:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

			uint8 *src_ptr =  (uint8*) dataSrc_va;
f010b0f2:	8b 45 94             	mov    -0x6c(%ebp),%eax
f010b0f5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
f010b0f8:	8b 15 64 6d 85 f0    	mov    0xf0856d64,%edx
f010b0fe:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f010b104:	01 d0                	add    %edx,%eax
f010b106:	89 45 d0             	mov    %eax,-0x30(%ebp)
			int i;
			if (offset_first_page)
f010b109:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f010b110:	74 76                	je     f010b188 <env_create+0x327>
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
f010b112:	a1 64 6d 85 f0       	mov    0xf0856d64,%eax
f010b117:	83 ec 04             	sub    $0x4,%esp
f010b11a:	68 00 10 00 00       	push   $0x1000
f010b11f:	6a 00                	push   $0x0
f010b121:	50                   	push   %eax
f010b122:	e8 42 fb 00 00       	call   f011ac69 <memset>
f010b127:	83 c4 10             	add    $0x10,%esp
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010b12a:	8b 45 90             	mov    -0x70(%ebp),%eax
f010b12d:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010b130:	eb 13                	jmp    f010b145 <env_create+0x2e4>
				{
					*dst_ptr = *src_ptr ;
f010b132:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b135:	8a 10                	mov    (%eax),%dl
f010b137:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010b13a:	88 10                	mov    %dl,(%eax)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
			int i;
			if (offset_first_page)
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010b13c:	ff 45 cc             	incl   -0x34(%ebp)
f010b13f:	ff 45 d4             	incl   -0x2c(%ebp)
f010b142:	ff 45 d0             	incl   -0x30(%ebp)
f010b145:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b148:	3b 85 7c ff ff ff    	cmp    -0x84(%ebp),%eax
f010b14e:	72 e2                	jb     f010b132 <env_create+0x2d1>
				{
					*dst_ptr = *src_ptr ;
				}

				if (pf_add_env_page(e, start_first_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010b150:	8b 15 64 6d 85 f0    	mov    0xf0856d64,%edx
f010b156:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b15c:	83 ec 04             	sub    $0x4,%esp
f010b15f:	52                   	push   %edx
f010b160:	ff 75 88             	pushl  -0x78(%ebp)
f010b163:	50                   	push   %eax
f010b164:	e8 8e a0 ff ff       	call   f01051f7 <pf_add_env_page>
f010b169:	83 c4 10             	add    $0x10,%esp
f010b16c:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b16f:	75 17                	jne    f010b188 <env_create+0x327>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b171:	83 ec 04             	sub    $0x4,%esp
f010b174:	68 dc f2 12 f0       	push   $0xf012f2dc
f010b179:	68 fe 00 00 00       	push   $0xfe
f010b17e:	68 bf f2 12 f0       	push   $0xf012f2bf
f010b183:	e8 27 5d ff ff       	call   f0100eaf <_panic>
				//LOG_STRING(" -------------------- PAGE FILE: 1st page is written");
			}

			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
f010b188:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b18b:	8b 50 04             	mov    0x4(%eax),%edx
f010b18e:	8b 45 90             	mov    -0x70(%ebp),%eax
f010b191:	01 d0                	add    %edx,%eax
f010b193:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f010b199:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f010b19f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b1a4:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			uint32 end_last_page = seg_va  + seg->size_in_file;
f010b1aa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b1ad:	8b 50 04             	mov    0x4(%eax),%edx
f010b1b0:	8b 45 90             	mov    -0x70(%ebp),%eax
f010b1b3:	01 d0                	add    %edx,%eax
f010b1b5:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010b1bb:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010b1c1:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010b1c4:	eb 43                	jmp    f010b209 <env_create+0x3a8>
			{
				if (pf_add_env_page(e, i, src_ptr) == E_NO_PAGE_FILE_SPACE)
f010b1c6:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b1c9:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b1cf:	83 ec 04             	sub    $0x4,%esp
f010b1d2:	ff 75 d4             	pushl  -0x2c(%ebp)
f010b1d5:	52                   	push   %edx
f010b1d6:	50                   	push   %eax
f010b1d7:	e8 1b a0 ff ff       	call   f01051f7 <pf_add_env_page>
f010b1dc:	83 c4 10             	add    $0x10,%esp
f010b1df:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b1e2:	75 17                	jne    f010b1fb <env_create+0x39a>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b1e4:	83 ec 04             	sub    $0x4,%esp
f010b1e7:	68 dc f2 12 f0       	push   $0xf012f2dc
f010b1ec:	68 0b 01 00 00       	push   $0x10b
f010b1f1:	68 bf f2 12 f0       	push   $0xf012f2bf
f010b1f6:	e8 b4 5c ff ff       	call   f0100eaf <_panic>
			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
			uint32 end_last_page = seg_va  + seg->size_in_file;

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010b1fb:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f010b202:	81 45 d4 00 10 00 00 	addl   $0x1000,-0x2c(%ebp)
f010b209:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b20c:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f010b212:	72 b2                	jb     f010b1c6 <env_create+0x365>
			}
			//LOG_STRING(" -------------------- PAGE FILE: 2nd page --> before last page are written");

			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
f010b214:	a1 64 6d 85 f0       	mov    0xf0856d64,%eax
f010b219:	89 45 d0             	mov    %eax,-0x30(%ebp)
			memset(dst_ptr, 0, PAGE_SIZE);
f010b21c:	83 ec 04             	sub    $0x4,%esp
f010b21f:	68 00 10 00 00       	push   $0x1000
f010b224:	6a 00                	push   $0x0
f010b226:	ff 75 d0             	pushl  -0x30(%ebp)
f010b229:	e8 3b fa 00 00       	call   f011ac69 <memset>
f010b22e:	83 c4 10             	add    $0x10,%esp

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010b231:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010b237:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010b23a:	eb 13                	jmp    f010b24f <env_create+0x3ee>
			{
				*dst_ptr = *src_ptr;
f010b23c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b23f:	8a 10                	mov    (%eax),%dl
f010b241:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010b244:	88 10                	mov    %dl,(%eax)
			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
			memset(dst_ptr, 0, PAGE_SIZE);

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010b246:	ff 45 cc             	incl   -0x34(%ebp)
f010b249:	ff 45 d4             	incl   -0x2c(%ebp)
f010b24c:	ff 45 d0             	incl   -0x30(%ebp)
f010b24f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b252:	3b 85 6c ff ff ff    	cmp    -0x94(%ebp),%eax
f010b258:	72 e2                	jb     f010b23c <env_create+0x3db>
			{
				*dst_ptr = *src_ptr;
			}
			if (pf_add_env_page(e, start_last_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010b25a:	8b 15 64 6d 85 f0    	mov    0xf0856d64,%edx
f010b260:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b266:	83 ec 04             	sub    $0x4,%esp
f010b269:	52                   	push   %edx
f010b26a:	ff b5 70 ff ff ff    	pushl  -0x90(%ebp)
f010b270:	50                   	push   %eax
f010b271:	e8 81 9f ff ff       	call   f01051f7 <pf_add_env_page>
f010b276:	83 c4 10             	add    $0x10,%esp
f010b279:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b27c:	75 17                	jne    f010b295 <env_create+0x434>
				panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b27e:	83 ec 04             	sub    $0x4,%esp
f010b281:	68 dc f2 12 f0       	push   $0xf012f2dc
f010b286:	68 1a 01 00 00       	push   $0x11a
f010b28b:	68 bf f2 12 f0       	push   $0xf012f2bf
f010b290:	e8 1a 5c ff ff       	call   f0100eaf <_panic>

			//LOG_STRING(" -------------------- PAGE FILE: last page is written");

			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
f010b295:	c7 85 68 ff ff ff 00 	movl   $0x1000,-0x98(%ebp)
f010b29c:	10 00 00 
f010b29f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b2a2:	8b 50 04             	mov    0x4(%eax),%edx
f010b2a5:	8b 45 90             	mov    -0x70(%ebp),%eax
f010b2a8:	01 c2                	add    %eax,%edx
f010b2aa:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
f010b2b0:	01 d0                	add    %edx,%eax
f010b2b2:	48                   	dec    %eax
f010b2b3:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
f010b2b9:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f010b2bf:	ba 00 00 00 00       	mov    $0x0,%edx
f010b2c4:	f7 b5 68 ff ff ff    	divl   -0x98(%ebp)
f010b2ca:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f010b2d0:	29 d0                	sub    %edx,%eax
f010b2d2:	89 45 c8             	mov    %eax,-0x38(%ebp)
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;
f010b2d5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b2d8:	8b 50 08             	mov    0x8(%eax),%edx
f010b2db:	8b 45 90             	mov    -0x70(%ebp),%eax
f010b2de:	01 d0                	add    %edx,%eax
f010b2e0:	2b 45 c8             	sub    -0x38(%ebp),%eax
f010b2e3:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010b2e9:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f010b2f0:	eb 41                	jmp    f010b333 <env_create+0x4d2>
			{
				if (pf_add_empty_env_page(e, start_remaining_area, 1) == E_NO_PAGE_FILE_SPACE)
f010b2f2:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b2f8:	83 ec 04             	sub    $0x4,%esp
f010b2fb:	6a 01                	push   $0x1
f010b2fd:	ff 75 c8             	pushl  -0x38(%ebp)
f010b300:	50                   	push   %eax
f010b301:	e8 c3 9d ff ff       	call   f01050c9 <pf_add_empty_env_page>
f010b306:	83 c4 10             	add    $0x10,%esp
f010b309:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b30c:	75 17                	jne    f010b325 <env_create+0x4c4>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b30e:	83 ec 04             	sub    $0x4,%esp
f010b311:	68 dc f2 12 f0       	push   $0xf012f2dc
f010b316:	68 27 01 00 00       	push   $0x127
f010b31b:	68 bf f2 12 f0       	push   $0xf012f2bf
f010b320:	e8 8a 5b ff ff       	call   f0100eaf <_panic>
			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010b325:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f010b32c:	81 45 c8 00 10 00 00 	addl   $0x1000,-0x38(%ebp)
f010b333:	c7 85 5c ff ff ff 00 	movl   $0x1000,-0xa4(%ebp)
f010b33a:	10 00 00 
f010b33d:	8b 95 60 ff ff ff    	mov    -0xa0(%ebp),%edx
f010b343:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b349:	01 d0                	add    %edx,%eax
f010b34b:	48                   	dec    %eax
f010b34c:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
f010b352:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f010b358:	ba 00 00 00 00       	mov    $0x0,%edx
f010b35d:	f7 b5 5c ff ff ff    	divl   -0xa4(%ebp)
f010b363:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f010b369:	29 d0                	sub    %edx,%eax
f010b36b:	89 c2                	mov    %eax,%edx
f010b36d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b370:	39 c2                	cmp    %eax,%edx
f010b372:	0f 87 7a ff ff ff    	ja     f010b2f2 <env_create+0x491>
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
		int segment_counter=0;
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
		uint32 lastTableNumber=0xffffffff;

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010b378:	83 ec 08             	sub    $0x8,%esp
f010b37b:	ff 75 b0             	pushl  -0x50(%ebp)
f010b37e:	ff 75 e4             	pushl  -0x1c(%ebp)
f010b381:	e8 fc 15 00 00       	call   f010c982 <PROGRAM_SEGMENT_NEXT>
f010b386:	83 c4 10             	add    $0x10,%esp
f010b389:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010b38c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010b390:	0f 85 c9 fc ff ff    	jne    f010b05f <env_create+0x1fe>


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010b396:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b39c:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010b3a2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010b3a5:	eb 77                	jmp    f010b41e <env_create+0x5bd>
		{
			uint32 virtual_address = wse->virtual_address;
f010b3a7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b3aa:	8b 00                	mov    (%eax),%eax
f010b3ac:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
			uint32* ptr_page_table;

			//Here, page tables of all working set pages should be exist in memory
			//So, get_page_table should return the existing table
			get_page_table(e->env_page_directory, virtual_address, &ptr_page_table);
f010b3b2:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b3b8:	8b 40 64             	mov    0x64(%eax),%eax
f010b3bb:	83 ec 04             	sub    $0x4,%esp
f010b3be:	8d 95 24 ff ff ff    	lea    -0xdc(%ebp),%edx
f010b3c4:	52                   	push   %edx
f010b3c5:	ff b5 54 ff ff ff    	pushl  -0xac(%ebp)
f010b3cb:	50                   	push   %eax
f010b3cc:	e8 82 de ff ff       	call   f0109253 <get_page_table>
f010b3d1:	83 c4 10             	add    $0x10,%esp
			ptr_page_table[PTX(virtual_address)] &= (~PERM_MODIFIED);
f010b3d4:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f010b3da:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
f010b3e0:	c1 ea 0c             	shr    $0xc,%edx
f010b3e3:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010b3e9:	c1 e2 02             	shl    $0x2,%edx
f010b3ec:	01 d0                	add    %edx,%eax
f010b3ee:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
f010b3f4:	8b 8d 54 ff ff ff    	mov    -0xac(%ebp),%ecx
f010b3fa:	c1 e9 0c             	shr    $0xc,%ecx
f010b3fd:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010b403:	c1 e1 02             	shl    $0x2,%ecx
f010b406:	01 ca                	add    %ecx,%edx
f010b408:	8b 12                	mov    (%edx),%edx
f010b40a:	83 e2 bf             	and    $0xffffffbf,%edx
f010b40d:	89 10                	mov    %edx,(%eax)


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010b40f:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b415:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010b41b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010b41e:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b424:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010b428:	74 08                	je     f010b432 <env_create+0x5d1>
f010b42a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b42d:	8b 52 10             	mov    0x10(%edx),%edx
f010b430:	eb 05                	jmp    f010b437 <env_create+0x5d6>
f010b432:	ba 00 00 00 00       	mov    $0x0,%edx
f010b437:	89 90 90 00 00 00    	mov    %edx,0x90(%eax)
f010b43d:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010b443:	85 c0                	test   %eax,%eax
f010b445:	0f 85 5c ff ff ff    	jne    f010b3a7 <env_create+0x546>
f010b44b:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010b44f:	0f 85 52 ff ff ff    	jne    f010b3a7 <env_create+0x546>
			}
		}
#endif

		//[9] now set the entry point of the environment
		set_environment_entry_point(e, ptr_user_program_info->ptr_start);
f010b455:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010b458:	8b 50 08             	mov    0x8(%eax),%edx
f010b45b:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b461:	83 ec 08             	sub    $0x8,%esp
f010b464:	52                   	push   %edx
f010b465:	50                   	push   %eax
f010b466:	e8 d7 14 00 00       	call   f010c942 <set_environment_entry_point>
f010b46b:	83 c4 10             	add    $0x10,%esp

		//[10] Allocate and map ONE page for the program's initial stack
		// at virtual address USTACKTOP - PAGE_SIZE.
		// we assume that the stack is counted in the environment working set

		e->initNumStackPages = 1;
f010b46e:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b474:	c7 40 6c 01 00 00 00 	movl   $0x1,0x6c(%eax)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);
f010b47b:	c7 85 50 ff ff ff 00 	movl   $0xeebfd000,-0xb0(%ebp)
f010b482:	d0 bf ee 

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
f010b485:	c7 45 c0 00 d0 bf ee 	movl   $0xeebfd000,-0x40(%ebp)
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010b48c:	e9 42 03 00 00       	jmp    f010b7d3 <env_create+0x972>
		{
			//allocate and map
			struct FrameInfo *pp = NULL;
f010b491:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f010b498:	00 00 00 
			allocate_frame(&pp);
f010b49b:	83 ec 0c             	sub    $0xc,%esp
f010b49e:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f010b4a4:	50                   	push   %eax
f010b4a5:	e8 98 db ff ff       	call   f0109042 <allocate_frame>
f010b4aa:	83 c4 10             	add    $0x10,%esp
			loadtime_map_frame(e->env_page_directory, pp, stackVa, PERM_USER | PERM_WRITEABLE);
f010b4ad:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
f010b4b3:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b4b9:	8b 40 64             	mov    0x64(%eax),%eax
f010b4bc:	6a 06                	push   $0x6
f010b4be:	ff 75 c0             	pushl  -0x40(%ebp)
f010b4c1:	52                   	push   %edx
f010b4c2:	50                   	push   %eax
f010b4c3:	e8 2b e2 ff ff       	call   f01096f3 <loadtime_map_frame>
f010b4c8:	83 c4 10             	add    $0x10,%esp

			//initialize new page by 0's
			memset((void*)stackVa, 0, PAGE_SIZE);
f010b4cb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010b4ce:	83 ec 04             	sub    $0x4,%esp
f010b4d1:	68 00 10 00 00       	push   $0x1000
f010b4d6:	6a 00                	push   $0x0
f010b4d8:	50                   	push   %eax
f010b4d9:	e8 8b f7 00 00       	call   f011ac69 <memset>
f010b4de:	83 c4 10             	add    $0x10,%esp

			//now add it to the working set and the page table
			{
#if USE_KHEAP
				wse = env_page_ws_list_create_element(e, (uint32) stackVa);
f010b4e1:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b4e7:	83 ec 08             	sub    $0x8,%esp
f010b4ea:	ff 75 c0             	pushl  -0x40(%ebp)
f010b4ed:	50                   	push   %eax
f010b4ee:	e8 12 ea ff ff       	call   f0109f05 <env_page_ws_list_create_element>
f010b4f3:	83 c4 10             	add    $0x10,%esp
f010b4f6:	89 45 c4             	mov    %eax,-0x3c(%ebp)
				LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010b4f9:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010b4fd:	75 17                	jne    f010b516 <env_create+0x6b5>
f010b4ff:	83 ec 04             	sub    $0x4,%esp
f010b502:	68 24 f3 12 f0       	push   $0xf012f324
f010b507:	68 66 01 00 00       	push   $0x166
f010b50c:	68 bf f2 12 f0       	push   $0xf012f2bf
f010b511:	e8 99 59 ff ff       	call   f0100eaf <_panic>
f010b516:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b51c:	8b 90 8c 00 00 00    	mov    0x8c(%eax),%edx
f010b522:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b525:	89 50 14             	mov    %edx,0x14(%eax)
f010b528:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b52b:	8b 40 14             	mov    0x14(%eax),%eax
f010b52e:	85 c0                	test   %eax,%eax
f010b530:	74 14                	je     f010b546 <env_create+0x6e5>
f010b532:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b538:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
f010b53e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b541:	89 50 10             	mov    %edx,0x10(%eax)
f010b544:	eb 0f                	jmp    f010b555 <env_create+0x6f4>
f010b546:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b54c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b54f:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010b555:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b55b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b55e:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f010b564:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b567:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010b56e:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b574:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010b57a:	42                   	inc    %edx
f010b57b:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
				if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010b581:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b587:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010b58d:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b593:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010b599:	39 c2                	cmp    %eax,%edx
f010b59b:	75 1a                	jne    f010b5b7 <env_create+0x756>
				{
					e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010b59d:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b5a3:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f010b5a9:	8b 92 88 00 00 00    	mov    0x88(%edx),%edx
f010b5af:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010b5b5:	eb 10                	jmp    f010b5c7 <env_create+0x766>
				}
				else
				{
					e->page_last_WS_element = NULL;
f010b5b7:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b5bd:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
f010b5c4:	00 00 00 
				}
				//2020
				if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b5c7:	83 ec 0c             	sub    $0xc,%esp
f010b5ca:	6a 02                	push   $0x2
f010b5cc:	e8 52 42 00 00       	call   f010f823 <isPageReplacmentAlgorithmLRU>
f010b5d1:	83 c4 10             	add    $0x10,%esp
f010b5d4:	85 c0                	test   %eax,%eax
f010b5d6:	0f 84 d3 01 00 00    	je     f010b7af <env_create+0x94e>
				{
					//Remove wse from page_WS_list
					LIST_REMOVE(&(e->page_WS_list), wse);
f010b5dc:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010b5e0:	75 17                	jne    f010b5f9 <env_create+0x798>
f010b5e2:	83 ec 04             	sub    $0x4,%esp
f010b5e5:	68 47 f3 12 f0       	push   $0xf012f347
f010b5ea:	68 73 01 00 00       	push   $0x173
f010b5ef:	68 bf f2 12 f0       	push   $0xf012f2bf
f010b5f4:	e8 b6 58 ff ff       	call   f0100eaf <_panic>
f010b5f9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b5fc:	8b 40 10             	mov    0x10(%eax),%eax
f010b5ff:	85 c0                	test   %eax,%eax
f010b601:	74 11                	je     f010b614 <env_create+0x7b3>
f010b603:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b606:	8b 40 10             	mov    0x10(%eax),%eax
f010b609:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b60c:	8b 52 14             	mov    0x14(%edx),%edx
f010b60f:	89 50 14             	mov    %edx,0x14(%eax)
f010b612:	eb 12                	jmp    f010b626 <env_create+0x7c5>
f010b614:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b61a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b61d:	8b 52 14             	mov    0x14(%edx),%edx
f010b620:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f010b626:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b629:	8b 40 14             	mov    0x14(%eax),%eax
f010b62c:	85 c0                	test   %eax,%eax
f010b62e:	74 11                	je     f010b641 <env_create+0x7e0>
f010b630:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b633:	8b 40 14             	mov    0x14(%eax),%eax
f010b636:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b639:	8b 52 10             	mov    0x10(%edx),%edx
f010b63c:	89 50 10             	mov    %edx,0x10(%eax)
f010b63f:	eb 12                	jmp    f010b653 <env_create+0x7f2>
f010b641:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b647:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b64a:	8b 52 10             	mov    0x10(%edx),%edx
f010b64d:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010b653:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b656:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010b65d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b660:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b667:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b66d:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010b673:	4a                   	dec    %edx
f010b674:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
					//Now: we are sure that at least the top page in the stack will be added to Active list
					//Since we left 1 empty location in the Active list when we loaded the program segments
					if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize)
f010b67a:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b680:	8b 90 74 05 00 00    	mov    0x574(%eax),%edx
f010b686:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b68c:	8b 80 88 05 00 00    	mov    0x588(%eax),%eax
f010b692:	39 c2                	cmp    %eax,%edx
f010b694:	0f 83 8d 00 00 00    	jae    f010b727 <env_create+0x8c6>
					{
						LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010b69a:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010b69e:	75 17                	jne    f010b6b7 <env_create+0x856>
f010b6a0:	83 ec 04             	sub    $0x4,%esp
f010b6a3:	68 9c f2 12 f0       	push   $0xf012f29c
f010b6a8:	68 78 01 00 00       	push   $0x178
f010b6ad:	68 bf f2 12 f0       	push   $0xf012f2bf
f010b6b2:	e8 f8 57 ff ff       	call   f0100eaf <_panic>
f010b6b7:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b6bd:	8b 90 68 05 00 00    	mov    0x568(%eax),%edx
f010b6c3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b6c6:	89 50 10             	mov    %edx,0x10(%eax)
f010b6c9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b6cc:	8b 40 10             	mov    0x10(%eax),%eax
f010b6cf:	85 c0                	test   %eax,%eax
f010b6d1:	74 14                	je     f010b6e7 <env_create+0x886>
f010b6d3:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b6d9:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010b6df:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b6e2:	89 50 14             	mov    %edx,0x14(%eax)
f010b6e5:	eb 0f                	jmp    f010b6f6 <env_create+0x895>
f010b6e7:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b6ed:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b6f0:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010b6f6:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b6fc:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b6ff:	89 90 68 05 00 00    	mov    %edx,0x568(%eax)
f010b705:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b708:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b70f:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b715:	8b 90 74 05 00 00    	mov    0x574(%eax),%edx
f010b71b:	42                   	inc    %edx
f010b71c:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010b722:	e9 88 00 00 00       	jmp    f010b7af <env_create+0x94e>
					}
					else
					{
						LIST_INSERT_HEAD(&(e->SecondList), wse);
f010b727:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010b72b:	75 17                	jne    f010b744 <env_create+0x8e3>
f010b72d:	83 ec 04             	sub    $0x4,%esp
f010b730:	68 9c f2 12 f0       	push   $0xf012f29c
f010b735:	68 7c 01 00 00       	push   $0x17c
f010b73a:	68 bf f2 12 f0       	push   $0xf012f2bf
f010b73f:	e8 6b 57 ff ff       	call   f0100eaf <_panic>
f010b744:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b74a:	8b 90 78 05 00 00    	mov    0x578(%eax),%edx
f010b750:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b753:	89 50 10             	mov    %edx,0x10(%eax)
f010b756:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b759:	8b 40 10             	mov    0x10(%eax),%eax
f010b75c:	85 c0                	test   %eax,%eax
f010b75e:	74 14                	je     f010b774 <env_create+0x913>
f010b760:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b766:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010b76c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b76f:	89 50 14             	mov    %edx,0x14(%eax)
f010b772:	eb 0f                	jmp    f010b783 <env_create+0x922>
f010b774:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b77a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b77d:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
f010b783:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b789:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b78c:	89 90 78 05 00 00    	mov    %edx,0x578(%eax)
f010b792:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b795:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b79c:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b7a2:	8b 90 84 05 00 00    	mov    0x584(%eax),%edx
f010b7a8:	42                   	inc    %edx
f010b7a9:	89 90 84 05 00 00    	mov    %edx,0x584(%eax)

				//addTableToTableWorkingSet(e, ROUNDDOWN((uint32)stackVa, PAGE_SIZE*1024));
			}

			//add this page to the page file
			int success = pf_add_empty_env_page(e, (uint32)stackVa, 1);
f010b7af:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b7b5:	83 ec 04             	sub    $0x4,%esp
f010b7b8:	6a 01                	push   $0x1
f010b7ba:	ff 75 c0             	pushl  -0x40(%ebp)
f010b7bd:	50                   	push   %eax
f010b7be:	e8 06 99 ff ff       	call   f01050c9 <pf_add_empty_env_page>
f010b7c3:	83 c4 10             	add    $0x10,%esp
f010b7c6:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010b7cc:	81 6d c0 00 10 00 00 	subl   $0x1000,-0x40(%ebp)
f010b7d3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010b7d6:	3b 85 50 ff ff ff    	cmp    -0xb0(%ebp),%eax
f010b7dc:	0f 83 af fc ff ff    	jae    f010b491 <env_create+0x630>
			//if(success == 0) LOG_STATMENT(cprintf("STACK Page added to page file successfully\n"));
		}

		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b7e2:	83 ec 0c             	sub    $0xc,%esp
f010b7e5:	6a 02                	push   $0x2
f010b7e7:	e8 37 40 00 00       	call   f010f823 <isPageReplacmentAlgorithmLRU>
f010b7ec:	83 c4 10             	add    $0x10,%esp
f010b7ef:	85 c0                	test   %eax,%eax
f010b7f1:	74 72                	je     f010b865 <env_create+0xa04>
		{
			struct WorkingSetElement * elm = NULL;
f010b7f3:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
			LIST_FOREACH(elm, &(e->SecondList))
f010b7fa:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b800:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010b806:	89 45 bc             	mov    %eax,-0x44(%ebp)
f010b809:	eb 2b                	jmp    f010b836 <env_create+0x9d5>
			{
				//set it's PRESENT bit to 0
				pt_set_page_permissions(e->env_page_directory, elm->virtual_address, 0, PERM_PRESENT);
f010b80b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f010b80e:	8b 10                	mov    (%eax),%edx
f010b810:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b816:	8b 40 64             	mov    0x64(%eax),%eax
f010b819:	6a 01                	push   $0x1
f010b81b:	6a 00                	push   $0x0
f010b81d:	52                   	push   %edx
f010b81e:	50                   	push   %eax
f010b81f:	e8 db e3 ff ff       	call   f0109bff <pt_set_page_permissions>
f010b824:	83 c4 10             	add    $0x10,%esp
		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
		{
			struct WorkingSetElement * elm = NULL;
			LIST_FOREACH(elm, &(e->SecondList))
f010b827:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b82d:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010b833:	89 45 bc             	mov    %eax,-0x44(%ebp)
f010b836:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b83c:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
f010b840:	74 08                	je     f010b84a <env_create+0x9e9>
f010b842:	8b 55 bc             	mov    -0x44(%ebp),%edx
f010b845:	8b 52 10             	mov    0x10(%edx),%edx
f010b848:	eb 05                	jmp    f010b84f <env_create+0x9ee>
f010b84a:	ba 00 00 00 00       	mov    $0x0,%edx
f010b84f:	89 90 80 05 00 00    	mov    %edx,0x580(%eax)
f010b855:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010b85b:	85 c0                	test   %eax,%eax
f010b85d:	75 ac                	jne    f010b80b <env_create+0x9aa>
f010b85f:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
f010b863:	75 a6                	jne    f010b80b <env_create+0x9aa>
f010b865:	8b 45 9c             	mov    -0x64(%ebp),%eax
f010b868:	89 45 a0             	mov    %eax,-0x60(%ebp)
f010b86b:	8b 45 a0             	mov    -0x60(%ebp),%eax
f010b86e:	0f 22 d8             	mov    %eax,%cr3

		///[11] switch back to the page directory exists before segment loading
		lcr3(cur_phys_pgdir) ;
	}
	//[12] Re-enable the interrupt (if it was too)
	popcli();
f010b871:	e8 0c c8 ff ff       	call   f0108082 <popcli>

	//[13] Copy the prepaged VAs into the corresponding array
#if USE_KHEAP
	e->numOfPrepagedVAs = LIST_SIZE(&(e->page_WS_list));
f010b876:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b87c:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f010b882:	8b 92 94 00 00 00    	mov    0x94(%edx),%edx
f010b888:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
	e->prepagedVAs = kmalloc(sizeof(uint32) * e->numOfPrepagedVAs);
f010b88e:	8b 9d 44 ff ff ff    	mov    -0xbc(%ebp),%ebx
f010b894:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b89a:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010b8a0:	c1 e0 02             	shl    $0x2,%eax
f010b8a3:	83 ec 0c             	sub    $0xc,%esp
f010b8a6:	50                   	push   %eax
f010b8a7:	e8 8a e2 ff ff       	call   f0109b36 <kmalloc>
f010b8ac:	83 c4 10             	add    $0x10,%esp
f010b8af:	89 83 ac 00 00 00    	mov    %eax,0xac(%ebx)
	struct WorkingSetElement *ptrWSE;
	int w = 0;
f010b8b5:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
	LIST_FOREACH(ptrWSE, &(e->page_WS_list))
f010b8bc:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b8c2:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010b8c8:	89 45 b8             	mov    %eax,-0x48(%ebp)
f010b8cb:	eb 31                	jmp    f010b8fe <env_create+0xa9d>
	{
		e->prepagedVAs[w++] = ptrWSE->virtual_address;
f010b8cd:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b8d3:	8b 88 ac 00 00 00    	mov    0xac(%eax),%ecx
f010b8d9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010b8dc:	8d 50 01             	lea    0x1(%eax),%edx
f010b8df:	89 55 b4             	mov    %edx,-0x4c(%ebp)
f010b8e2:	c1 e0 02             	shl    $0x2,%eax
f010b8e5:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f010b8e8:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010b8eb:	8b 00                	mov    (%eax),%eax
f010b8ed:	89 02                	mov    %eax,(%edx)
#if USE_KHEAP
	e->numOfPrepagedVAs = LIST_SIZE(&(e->page_WS_list));
	e->prepagedVAs = kmalloc(sizeof(uint32) * e->numOfPrepagedVAs);
	struct WorkingSetElement *ptrWSE;
	int w = 0;
	LIST_FOREACH(ptrWSE, &(e->page_WS_list))
f010b8ef:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b8f5:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010b8fb:	89 45 b8             	mov    %eax,-0x48(%ebp)
f010b8fe:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b904:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
f010b908:	74 08                	je     f010b912 <env_create+0xab1>
f010b90a:	8b 55 b8             	mov    -0x48(%ebp),%edx
f010b90d:	8b 52 10             	mov    0x10(%edx),%edx
f010b910:	eb 05                	jmp    f010b917 <env_create+0xab6>
f010b912:	ba 00 00 00 00       	mov    $0x0,%edx
f010b917:	89 90 90 00 00 00    	mov    %edx,0x90(%eax)
f010b91d:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010b923:	85 c0                	test   %eax,%eax
f010b925:	75 a6                	jne    f010b8cd <env_create+0xa6c>
f010b927:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
f010b92b:	75 a0                	jne    f010b8cd <env_create+0xa6c>
	{
		e->prepagedVAs[w++] = ptrWSE->virtual_address;
	}
	assert(w == e->numOfPrepagedVAs);
f010b92d:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b933:	8b 90 b0 00 00 00    	mov    0xb0(%eax),%edx
f010b939:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010b93c:	39 c2                	cmp    %eax,%edx
f010b93e:	74 19                	je     f010b959 <env_create+0xaf8>
f010b940:	68 65 f3 12 f0       	push   $0xf012f365
f010b945:	68 7e f3 12 f0       	push   $0xf012f37e
f010b94a:	68 b9 01 00 00       	push   $0x1b9
f010b94f:	68 bf f2 12 f0       	push   $0xf012f2bf
f010b954:	e8 56 55 ff ff       	call   f0100eaf <_panic>
		//env_page_ws_print(e);

		//	cprintf("Table working set after loading the program...\n");
		//	env_table_ws_print(e);
	}
	return e;
f010b959:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
}
f010b95f:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010b962:	5b                   	pop    %ebx
f010b963:	5e                   	pop    %esi
f010b964:	5f                   	pop    %edi
f010b965:	5d                   	pop    %ebp
f010b966:	c3                   	ret    

f010b967 <env_start>:
// 2) START EXECUTING THE PROCESS:
//===============================
// called only at the very first scheduling by scheduler()
// will context_switch() here.  "Return" to user space.
void env_start(void)
{
f010b967:	55                   	push   %ebp
f010b968:	89 e5                	mov    %esp,%ebp
f010b96a:	83 ec 18             	sub    $0x18,%esp
	static int first = 1;
	// Still holding q.lock from scheduler.
	release_kspinlock(&ProcessQueues.qlock);
f010b96d:	83 ec 0c             	sub    $0xc,%esp
f010b970:	68 20 e7 83 f0       	push   $0xf083e720
f010b975:	e8 a6 44 00 00       	call   f010fe20 <release_kspinlock>
f010b97a:	83 c4 10             	add    $0x10,%esp

	if (first)
f010b97d:	a1 c4 fb 17 f0       	mov    0xf017fbc4,%eax
f010b982:	85 c0                	test   %eax,%eax
f010b984:	74 30                	je     f010b9b6 <env_start+0x4f>
	{
		struct Env* p = get_cpu_proc();
f010b986:	e8 8d 00 00 00       	call   f010ba18 <get_cpu_proc>
f010b98b:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cprintf("\n[ENV_START] %s - %d\n", p->prog_name, p->env_id);
f010b98e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b991:	8b 40 10             	mov    0x10(%eax),%eax
f010b994:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b997:	83 c2 20             	add    $0x20,%edx
f010b99a:	83 ec 04             	sub    $0x4,%esp
f010b99d:	50                   	push   %eax
f010b99e:	52                   	push   %edx
f010b99f:	68 93 f3 12 f0       	push   $0xf012f393
f010b9a4:	e8 b3 61 ff ff       	call   f0101b5c <cprintf>
f010b9a9:	83 c4 10             	add    $0x10,%esp

		// Some initialization functions must be run in the context
		// of a regular process (e.g., they call sleep), and thus cannot
		// be run from main().
		first = 0;
f010b9ac:	c7 05 c4 fb 17 f0 00 	movl   $0x0,0xf017fbc4
f010b9b3:	00 00 00 
	}

	// Return to "caller", actually trapret (see initialize_environment()).
}
f010b9b6:	90                   	nop
f010b9b7:	c9                   	leave  
f010b9b8:	c3                   	ret    

f010b9b9 <env_free>:
// 3) FREE ENV FROM THE SYSTEM:
//===============================
// Frees environment "e" and all memory it uses.
//
void env_free(struct Env *e)
{
f010b9b9:	55                   	push   %ebp
f010b9ba:	89 e5                	mov    %esp,%ebp
f010b9bc:	83 ec 08             	sub    $0x8,%esp
#endif
	/*****************************************/
	//TODO: [PROJECT'25.BONUS#4] EXIT #1 & #2 - env_free
	//Your code is here
	//Comment the following line
	panic("env_free() is not implemented yet...!!");
f010b9bf:	83 ec 04             	sub    $0x4,%esp
f010b9c2:	68 ac f3 12 f0       	push   $0xf012f3ac
f010b9c7:	68 f3 01 00 00       	push   $0x1f3
f010b9cc:	68 bf f2 12 f0       	push   $0xf012f2bf
f010b9d1:	e8 d9 54 ff ff       	call   f0100eaf <_panic>

f010b9d6 <env_exit>:
//============================
// 4) PLACE ENV IN EXIT QUEUE:
//============================
//Just add the "curenv" to the EXIT list, then reinvoke the scheduler
void env_exit(void)
{
f010b9d6:	55                   	push   %ebp
f010b9d7:	89 e5                	mov    %esp,%ebp
f010b9d9:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010b9dc:	e8 37 00 00 00       	call   f010ba18 <get_cpu_proc>
f010b9e1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010b9e4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b9e8:	75 19                	jne    f010ba03 <env_exit+0x2d>
f010b9ea:	68 d3 f3 12 f0       	push   $0xf012f3d3
f010b9ef:	68 7e f3 12 f0       	push   $0xf012f37e
f010b9f4:	68 0e 02 00 00       	push   $0x20e
f010b9f9:	68 bf f2 12 f0       	push   $0xf012f2bf
f010b9fe:	e8 ac 54 ff ff       	call   f0100eaf <_panic>
	sched_exit_env(cur_env->env_id);
f010ba03:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ba06:	8b 40 10             	mov    0x10(%eax),%eax
f010ba09:	83 ec 0c             	sub    $0xc,%esp
f010ba0c:	50                   	push   %eax
f010ba0d:	e8 84 ad ff ff       	call   f0106796 <sched_exit_env>
f010ba12:	83 c4 10             	add    $0x10,%esp
	//2024: Replaced by context switch in the sched() function which will be called in sched_exit_env()
	//fos_scheduler();
}
f010ba15:	90                   	nop
f010ba16:	c9                   	leave  
f010ba17:	c3                   	ret    

f010ba18 <get_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while reading proc from the cpu structure
// Ref: xv6-x86 OS
struct Env* get_cpu_proc(void)
{
f010ba18:	55                   	push   %ebp
f010ba19:	89 e5                	mov    %esp,%ebp
f010ba1b:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	struct Env *p;
	pushcli();
f010ba1e:	e8 0d c6 ff ff       	call   f0108030 <pushcli>
	c = mycpu();
f010ba23:	e8 48 c5 ff ff       	call   f0107f70 <mycpu>
f010ba28:	89 45 f4             	mov    %eax,-0xc(%ebp)
	p = c->proc;
f010ba2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ba2e:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010ba34:	89 45 f0             	mov    %eax,-0x10(%ebp)
	popcli();
f010ba37:	e8 46 c6 ff ff       	call   f0108082 <popcli>
	return p;
f010ba3c:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f010ba3f:	c9                   	leave  
f010ba40:	c3                   	ret    

f010ba41 <set_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while setting proc into the cpu structure
// Ref: xv6-x86 OS
void set_cpu_proc(struct Env* p)
{
f010ba41:	55                   	push   %ebp
f010ba42:	89 e5                	mov    %esp,%ebp
f010ba44:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	pushcli();
f010ba47:	e8 e4 c5 ff ff       	call   f0108030 <pushcli>
	c = mycpu();
f010ba4c:	e8 1f c5 ff ff       	call   f0107f70 <mycpu>
f010ba51:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = p;
f010ba54:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ba57:	8b 55 08             	mov    0x8(%ebp),%edx
f010ba5a:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
	popcli();
f010ba60:	e8 1d c6 ff ff       	call   f0108082 <popcli>
}
f010ba65:	90                   	nop
f010ba66:	c9                   	leave  
f010ba67:	c3                   	ret    

f010ba68 <envid2env>:
//   0 on success, -E_BAD_ENV on error.
//   On success, sets *penv to the environment.
//   On error, sets *penv to NULL.
//
int envid2env(int32  envid, struct Env **env_store, bool checkperm)
{
f010ba68:	55                   	push   %ebp
f010ba69:	89 e5                	mov    %esp,%ebp
f010ba6b:	53                   	push   %ebx
f010ba6c:	83 ec 14             	sub    $0x14,%esp
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
f010ba6f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ba73:	75 16                	jne    f010ba8b <envid2env+0x23>
		*env_store = get_cpu_proc();
f010ba75:	e8 9e ff ff ff       	call   f010ba18 <get_cpu_proc>
f010ba7a:	89 c2                	mov    %eax,%edx
f010ba7c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ba7f:	89 10                	mov    %edx,(%eax)
		return 0;
f010ba81:	b8 00 00 00 00       	mov    $0x0,%eax
f010ba86:	e9 a3 00 00 00       	jmp    f010bb2e <envid2env+0xc6>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
f010ba8b:	8b 1d 90 5b 81 f0    	mov    0xf0815b90,%ebx
f010ba91:	83 ec 0c             	sub    $0xc,%esp
f010ba94:	68 c6 02 00 00       	push   $0x2c6
f010ba99:	e8 7d d0 00 00       	call   f0118b1b <nearest_pow2_ceil>
f010ba9e:	83 c4 10             	add    $0x10,%esp
f010baa1:	8d 50 ff             	lea    -0x1(%eax),%edx
f010baa4:	8b 45 08             	mov    0x8(%ebp),%eax
f010baa7:	21 c2                	and    %eax,%edx
f010baa9:	89 d0                	mov    %edx,%eax
f010baab:	c1 e0 02             	shl    $0x2,%eax
f010baae:	01 d0                	add    %edx,%eax
f010bab0:	c1 e0 03             	shl    $0x3,%eax
f010bab3:	01 d0                	add    %edx,%eax
f010bab5:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010babc:	01 d0                	add    %edx,%eax
f010babe:	c1 e0 02             	shl    $0x2,%eax
f010bac1:	01 d8                	add    %ebx,%eax
f010bac3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
f010bac6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bac9:	8b 40 18             	mov    0x18(%eax),%eax
f010bacc:	85 c0                	test   %eax,%eax
f010bace:	74 0b                	je     f010badb <envid2env+0x73>
f010bad0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bad3:	8b 40 10             	mov    0x10(%eax),%eax
f010bad6:	3b 45 08             	cmp    0x8(%ebp),%eax
f010bad9:	74 10                	je     f010baeb <envid2env+0x83>
		*env_store = 0;
f010badb:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bade:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010bae4:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010bae9:	eb 43                	jmp    f010bb2e <envid2env+0xc6>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	struct Env* cur_env = get_cpu_proc();
f010baeb:	e8 28 ff ff ff       	call   f010ba18 <get_cpu_proc>
f010baf0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (checkperm && e != cur_env && e->env_parent_id != cur_env->env_id) {
f010baf3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010baf7:	74 28                	je     f010bb21 <envid2env+0xb9>
f010baf9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bafc:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010baff:	74 20                	je     f010bb21 <envid2env+0xb9>
f010bb01:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb04:	8b 50 14             	mov    0x14(%eax),%edx
f010bb07:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bb0a:	8b 40 10             	mov    0x10(%eax),%eax
f010bb0d:	39 c2                	cmp    %eax,%edx
f010bb0f:	74 10                	je     f010bb21 <envid2env+0xb9>
		*env_store = 0;
f010bb11:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bb14:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010bb1a:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010bb1f:	eb 0d                	jmp    f010bb2e <envid2env+0xc6>
	}

	*env_store = e;
f010bb21:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bb24:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bb27:	89 10                	mov    %edx,(%eax)
	return 0;
f010bb29:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010bb2e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010bb31:	c9                   	leave  
f010bb32:	c3                   	ret    

f010bb33 <yield>:
// 7) GIVE-UP CPU TO THE SCHEDULER:
//=================================
// Give up the CPU for one scheduling round.
// Ref: xv6-x86 OS
void yield(void)
{
f010bb33:	55                   	push   %ebp
f010bb34:	89 e5                	mov    %esp,%ebp
f010bb36:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\n[YIELD] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_kspinlock(&ProcessQueues.qlock);  //lock: to protect process Qs in multi-CPU
f010bb39:	83 ec 0c             	sub    $0xc,%esp
f010bb3c:	68 20 e7 83 f0       	push   $0xf083e720
f010bb41:	e8 35 42 00 00       	call   f010fd7b <acquire_kspinlock>
f010bb46:	83 c4 10             	add    $0x10,%esp
	{
		struct Env* p = get_cpu_proc();
f010bb49:	e8 ca fe ff ff       	call   f010ba18 <get_cpu_proc>
f010bb4e:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(p != NULL);
f010bb51:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bb55:	75 19                	jne    f010bb70 <yield+0x3d>
f010bb57:	68 e3 f3 12 f0       	push   $0xf012f3e3
f010bb5c:	68 7e f3 12 f0       	push   $0xf012f37e
f010bb61:	68 6c 02 00 00       	push   $0x26c
f010bb66:	68 bf f2 12 f0       	push   $0xf012f2bf
f010bb6b:	e8 3f 53 ff ff       	call   f0100eaf <_panic>
		p->env_status = ENV_READY;
f010bb70:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb73:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		sched();
f010bb7a:	e8 13 00 00 00       	call   f010bb92 <sched>
	}
	release_kspinlock(&ProcessQueues.qlock); ////release lock
f010bb7f:	83 ec 0c             	sub    $0xc,%esp
f010bb82:	68 20 e7 83 f0       	push   $0xf083e720
f010bb87:	e8 94 42 00 00       	call   f010fe20 <release_kspinlock>
f010bb8c:	83 c4 10             	add    $0x10,%esp
	//cprintf("\n[YIELD] release: lock status after release = %d\n", qlock.locked);
}
f010bb8f:	90                   	nop
f010bb90:	c9                   	leave  
f010bb91:	c3                   	ret    

f010bb92 <sched>:
// Saves and restores intena because intena is a property of this kernel thread, not this CPU.
// It should be proc->intena and proc->ncli, but that would break in the few places
// where a lock is held but there's no process.
// Ref: xv6-x86 OS
void sched(void)
{
f010bb92:	55                   	push   %ebp
f010bb93:	89 e5                	mov    %esp,%ebp
f010bb95:	83 ec 18             	sub    $0x18,%esp
	int intena;
	struct Env *p = get_cpu_proc();
f010bb98:	e8 7b fe ff ff       	call   f010ba18 <get_cpu_proc>
f010bb9d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(p != NULL);
f010bba0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bba4:	75 19                	jne    f010bbbf <sched+0x2d>
f010bba6:	68 e3 f3 12 f0       	push   $0xf012f3e3
f010bbab:	68 7e f3 12 f0       	push   $0xf012f37e
f010bbb0:	68 80 02 00 00       	push   $0x280
f010bbb5:	68 bf f2 12 f0       	push   $0xf012f2bf
f010bbba:	e8 f0 52 ff ff       	call   f0100eaf <_panic>

	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f010bbbf:	83 ec 0c             	sub    $0xc,%esp
f010bbc2:	68 20 e7 83 f0       	push   $0xf083e720
f010bbc7:	e8 04 44 00 00       	call   f010ffd0 <holding_kspinlock>
f010bbcc:	83 c4 10             	add    $0x10,%esp
f010bbcf:	85 c0                	test   %eax,%eax
f010bbd1:	75 17                	jne    f010bbea <sched+0x58>
		panic("sched: q.lock is not held by this CPU while it's expected to be. ");
f010bbd3:	83 ec 04             	sub    $0x4,%esp
f010bbd6:	68 f0 f3 12 f0       	push   $0xf012f3f0
f010bbdb:	68 84 02 00 00       	push   $0x284
f010bbe0:	68 bf f2 12 f0       	push   $0xf012f2bf
f010bbe5:	e8 c5 52 ff ff       	call   f0100eaf <_panic>
	/*Should ensure that the ncli = 1 so that the interrupt will be released after scheduling the next proc*/
	if(mycpu()->ncli != 1)
f010bbea:	e8 81 c3 ff ff       	call   f0107f70 <mycpu>
f010bbef:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010bbf5:	83 f8 01             	cmp    $0x1,%eax
f010bbf8:	74 20                	je     f010bc1a <sched+0x88>
		panic("sched locks: ncli = %d", mycpu()->ncli);
f010bbfa:	e8 71 c3 ff ff       	call   f0107f70 <mycpu>
f010bbff:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010bc05:	50                   	push   %eax
f010bc06:	68 32 f4 12 f0       	push   $0xf012f432
f010bc0b:	68 87 02 00 00       	push   $0x287
f010bc10:	68 bf f2 12 f0       	push   $0xf012f2bf
f010bc15:	e8 95 52 ff ff       	call   f0100eaf <_panic>
	/*********************************************************************/
	if(p->env_status == ENV_RUNNING)
f010bc1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bc1d:	8b 40 18             	mov    0x18(%eax),%eax
f010bc20:	83 f8 02             	cmp    $0x2,%eax
f010bc23:	75 17                	jne    f010bc3c <sched+0xaa>
		panic("sched a running process");
f010bc25:	83 ec 04             	sub    $0x4,%esp
f010bc28:	68 49 f4 12 f0       	push   $0xf012f449
f010bc2d:	68 8a 02 00 00       	push   $0x28a
f010bc32:	68 bf f2 12 f0       	push   $0xf012f2bf
f010bc37:	e8 73 52 ff ff       	call   f0100eaf <_panic>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010bc3c:	9c                   	pushf  
f010bc3d:	58                   	pop    %eax
f010bc3e:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010bc41:	8b 45 ec             	mov    -0x14(%ebp),%eax
	if(read_eflags()&FL_IF)
f010bc44:	25 00 02 00 00       	and    $0x200,%eax
f010bc49:	85 c0                	test   %eax,%eax
f010bc4b:	74 17                	je     f010bc64 <sched+0xd2>
		panic("sched is interruptible!");
f010bc4d:	83 ec 04             	sub    $0x4,%esp
f010bc50:	68 61 f4 12 f0       	push   $0xf012f461
f010bc55:	68 8c 02 00 00       	push   $0x28c
f010bc5a:	68 bf f2 12 f0       	push   $0xf012f2bf
f010bc5f:	e8 4b 52 ff ff       	call   f0100eaf <_panic>
	intena = mycpu()->intena;
f010bc64:	e8 07 c3 ff ff       	call   f0107f70 <mycpu>
f010bc69:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f010bc6f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	context_switch(&(p->context), mycpu()->scheduler);
f010bc72:	e8 f9 c2 ff ff       	call   f0107f70 <mycpu>
f010bc77:	8b 40 04             	mov    0x4(%eax),%eax
f010bc7a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bc7d:	83 c2 04             	add    $0x4,%edx
f010bc80:	83 ec 08             	sub    $0x8,%esp
f010bc83:	50                   	push   %eax
f010bc84:	52                   	push   %edx
f010bc85:	e8 48 9e ff ff       	call   f0105ad2 <context_switch>
f010bc8a:	83 c4 10             	add    $0x10,%esp
	mycpu()->intena = intena;
f010bc8d:	e8 de c2 ff ff       	call   f0107f70 <mycpu>
f010bc92:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010bc95:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
}
f010bc9b:	90                   	nop
f010bc9c:	c9                   	leave  
f010bc9d:	c3                   	ret    

f010bc9e <switchkvm>:
// 9) SWITCH VIRTUAL MEMORYs:
//===============================
// [9.1] Switch h/w page table register to the kernel-only page table,
// for when no process is running.
void switchkvm(void)
{
f010bc9e:	55                   	push   %ebp
f010bc9f:	89 e5                	mov    %esp,%ebp
f010bca1:	83 ec 10             	sub    $0x10,%esp
	lcr3(phys_page_directory);   // switch to the kernel page table
f010bca4:	a1 e0 6d 85 f0       	mov    0xf0856de0,%eax
f010bca9:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010bcac:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010bcaf:	0f 22 d8             	mov    %eax,%cr3
}
f010bcb2:	90                   	nop
f010bcb3:	c9                   	leave  
f010bcb4:	c3                   	ret    

f010bcb5 <switchuvm>:

// [9.2] Switch TSS and h/w page table to correspond to process p.
void switchuvm(struct Env *proc)
{
f010bcb5:	55                   	push   %ebp
f010bcb6:	89 e5                	mov    %esp,%ebp
f010bcb8:	53                   	push   %ebx
f010bcb9:	83 ec 14             	sub    $0x14,%esp
	if(proc == 0)
f010bcbc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010bcc0:	75 17                	jne    f010bcd9 <switchuvm+0x24>
		panic("switchuvm: no process");
f010bcc2:	83 ec 04             	sub    $0x4,%esp
f010bcc5:	68 79 f4 12 f0       	push   $0xf012f479
f010bcca:	68 a1 02 00 00       	push   $0x2a1
f010bccf:	68 bf f2 12 f0       	push   $0xf012f2bf
f010bcd4:	e8 d6 51 ff ff       	call   f0100eaf <_panic>
	if(proc->kstack == 0)
f010bcd9:	8b 45 08             	mov    0x8(%ebp),%eax
f010bcdc:	8b 40 70             	mov    0x70(%eax),%eax
f010bcdf:	85 c0                	test   %eax,%eax
f010bce1:	75 17                	jne    f010bcfa <switchuvm+0x45>
		panic("switchuvm: no kstack");
f010bce3:	83 ec 04             	sub    $0x4,%esp
f010bce6:	68 8f f4 12 f0       	push   $0xf012f48f
f010bceb:	68 a3 02 00 00       	push   $0x2a3
f010bcf0:	68 bf f2 12 f0       	push   $0xf012f2bf
f010bcf5:	e8 b5 51 ff ff       	call   f0100eaf <_panic>
	if(proc->env_page_directory == 0)
f010bcfa:	8b 45 08             	mov    0x8(%ebp),%eax
f010bcfd:	8b 40 64             	mov    0x64(%eax),%eax
f010bd00:	85 c0                	test   %eax,%eax
f010bd02:	75 17                	jne    f010bd1b <switchuvm+0x66>
		panic("switchuvm: no pgdir");
f010bd04:	83 ec 04             	sub    $0x4,%esp
f010bd07:	68 a4 f4 12 f0       	push   $0xf012f4a4
f010bd0c:	68 a5 02 00 00       	push   $0x2a5
f010bd11:	68 bf f2 12 f0       	push   $0xf012f2bf
f010bd16:	e8 94 51 ff ff       	call   f0100eaf <_panic>

	pushcli();	//disable interrupt - lock: to protect CPU info
f010bd1b:	e8 10 c3 ff ff       	call   f0108030 <pushcli>
	struct cpu* c = mycpu();
f010bd20:	e8 4b c2 ff ff       	call   f0107f70 <mycpu>
f010bd25:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = proc;
f010bd28:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd2b:	8b 55 08             	mov    0x8(%ebp),%edx
f010bd2e:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010bd34:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd37:	83 c0 0c             	add    $0xc,%eax
f010bd3a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bd3d:	83 c2 0c             	add    $0xc,%edx
f010bd40:	c1 ea 10             	shr    $0x10,%edx
f010bd43:	88 d3                	mov    %dl,%bl
f010bd45:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bd48:	83 c2 0c             	add    $0xc,%edx
f010bd4b:	c1 ea 18             	shr    $0x18,%edx
f010bd4e:	88 d1                	mov    %dl,%cl
f010bd50:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bd53:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010bd5a:	68 00 
f010bd5c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bd5f:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010bd66:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd69:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010bd6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd72:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010bd78:	83 e2 f0             	and    $0xfffffff0,%edx
f010bd7b:	83 ca 09             	or     $0x9,%edx
f010bd7e:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010bd84:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd87:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010bd8d:	83 ca 10             	or     $0x10,%edx
f010bd90:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010bd96:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd99:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010bd9f:	83 e2 9f             	and    $0xffffff9f,%edx
f010bda2:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010bda8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdab:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010bdb1:	83 ca 80             	or     $0xffffff80,%edx
f010bdb4:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010bdba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdbd:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010bdc3:	83 e2 f0             	and    $0xfffffff0,%edx
f010bdc6:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010bdcc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdcf:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010bdd5:	83 e2 ef             	and    $0xffffffef,%edx
f010bdd8:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010bdde:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bde1:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010bde7:	83 e2 df             	and    $0xffffffdf,%edx
f010bdea:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010bdf0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdf3:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010bdf9:	83 ca 40             	or     $0x40,%edx
f010bdfc:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010be02:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be05:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010be0b:	83 e2 7f             	and    $0x7f,%edx
f010be0e:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010be14:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be17:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010be1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be20:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010be26:	83 e2 ef             	and    $0xffffffef,%edx
f010be29:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	//adjust the default stack for the trap to be the user kernel stack
	c->ts.ts_esp0 = (uint32)(c->proc->kstack + KERNEL_STACK_SIZE);
f010be2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be32:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010be38:	8b 40 70             	mov    0x70(%eax),%eax
f010be3b:	05 00 80 00 00       	add    $0x8000,%eax
f010be40:	89 c2                	mov    %eax,%edx
f010be42:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be45:	89 50 10             	mov    %edx,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010be48:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be4b:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)
f010be51:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010be57:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010be5b:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);

	//load the user page directory
	lcr3(c->proc->env_cr3) ;
f010be5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be61:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010be67:	8b 40 68             	mov    0x68(%eax),%eax
f010be6a:	89 45 ec             	mov    %eax,-0x14(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010be6d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010be70:	0f 22 d8             	mov    %eax,%cr3

	popcli();	//enable interrupt
f010be73:	e8 0a c2 ff ff       	call   f0108082 <popcli>
}
f010be78:	90                   	nop
f010be79:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010be7c:	c9                   	leave  
f010be7d:	c3                   	ret    

f010be7e <allocate_environment>:
//
// Returns 0 on success, < 0 on failure.  Errors include:
//	E_NO_FREE_ENV if all NENVS environments are allocated
//
int allocate_environment(struct Env** e)
{
f010be7e:	55                   	push   %ebp
f010be7f:	89 e5                	mov    %esp,%ebp
	if (!(*e = LIST_FIRST(&env_free_list)))
f010be81:	8b 15 94 5b 81 f0    	mov    0xf0815b94,%edx
f010be87:	8b 45 08             	mov    0x8(%ebp),%eax
f010be8a:	89 10                	mov    %edx,(%eax)
f010be8c:	8b 45 08             	mov    0x8(%ebp),%eax
f010be8f:	8b 00                	mov    (%eax),%eax
f010be91:	85 c0                	test   %eax,%eax
f010be93:	75 07                	jne    f010be9c <allocate_environment+0x1e>
		return E_NO_FREE_ENV;
f010be95:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
f010be9a:	eb 11                	jmp    f010bead <allocate_environment+0x2f>
	(*e)->env_status = ENV_UNKNOWN;
f010be9c:	8b 45 08             	mov    0x8(%ebp),%eax
f010be9f:	8b 00                	mov    (%eax),%eax
f010bea1:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%eax)
	return 0;
f010bea8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010bead:	5d                   	pop    %ebp
f010beae:	c3                   	ret    

f010beaf <free_environment>:
//===============================
// 3) FREE ENV STRUCT:
//===============================
// Free the given environment "e", simply by adding it to the free environment list.
void free_environment(struct Env* e)
{
f010beaf:	55                   	push   %ebp
f010beb0:	89 e5                	mov    %esp,%ebp
f010beb2:	83 ec 08             	sub    $0x8,%esp
	memset(e, 0, sizeof(*e));
f010beb5:	83 ec 04             	sub    $0x4,%esp
f010beb8:	68 c4 05 00 00       	push   $0x5c4
f010bebd:	6a 00                	push   $0x0
f010bebf:	ff 75 08             	pushl  0x8(%ebp)
f010bec2:	e8 a2 ed 00 00       	call   f011ac69 <memset>
f010bec7:	83 c4 10             	add    $0x10,%esp
	e->env_status = ENV_FREE;
f010beca:	8b 45 08             	mov    0x8(%ebp),%eax
f010becd:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	LIST_INSERT_HEAD(&env_free_list, e);
f010bed4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010bed8:	75 17                	jne    f010bef1 <free_environment+0x42>
f010beda:	83 ec 04             	sub    $0x4,%esp
f010bedd:	68 9c f2 12 f0       	push   $0xf012f29c
f010bee2:	68 e4 02 00 00       	push   $0x2e4
f010bee7:	68 bf f2 12 f0       	push   $0xf012f2bf
f010beec:	e8 be 4f ff ff       	call   f0100eaf <_panic>
f010bef1:	8b 15 94 5b 81 f0    	mov    0xf0815b94,%edx
f010bef7:	8b 45 08             	mov    0x8(%ebp),%eax
f010befa:	89 50 08             	mov    %edx,0x8(%eax)
f010befd:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf00:	8b 40 08             	mov    0x8(%eax),%eax
f010bf03:	85 c0                	test   %eax,%eax
f010bf05:	74 0d                	je     f010bf14 <free_environment+0x65>
f010bf07:	a1 94 5b 81 f0       	mov    0xf0815b94,%eax
f010bf0c:	8b 55 08             	mov    0x8(%ebp),%edx
f010bf0f:	89 50 0c             	mov    %edx,0xc(%eax)
f010bf12:	eb 08                	jmp    f010bf1c <free_environment+0x6d>
f010bf14:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf17:	a3 98 5b 81 f0       	mov    %eax,0xf0815b98
f010bf1c:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf1f:	a3 94 5b 81 f0       	mov    %eax,0xf0815b94
f010bf24:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf27:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010bf2e:	a1 a0 5b 81 f0       	mov    0xf0815ba0,%eax
f010bf33:	40                   	inc    %eax
f010bf34:	a3 a0 5b 81 f0       	mov    %eax,0xf0815ba0
}
f010bf39:	90                   	nop
f010bf3a:	c9                   	leave  
f010bf3b:	c3                   	ret    

f010bf3c <program_segment_alloc_map_copy_workingset>:
//
// The allocation shouldn't failed
// return 0
//
static int program_segment_alloc_map_copy_workingset(struct Env *e, struct ProgramSegment* seg, uint32* allocated_pages, uint32 remaining_ws_pages, uint32* lastTableNumber)
{
f010bf3c:	55                   	push   %ebp
f010bf3d:	89 e5                	mov    %esp,%ebp
f010bf3f:	53                   	push   %ebx
f010bf40:	83 ec 44             	sub    $0x44,%esp
	void *vaddr = seg->virtual_address;
f010bf43:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bf46:	8b 40 0c             	mov    0xc(%eax),%eax
f010bf49:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 length = seg->size_in_memory;
f010bf4c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bf4f:	8b 40 08             	mov    0x8(%eax),%eax
f010bf52:	89 45 e0             	mov    %eax,-0x20(%ebp)

	uint32 end_vaddr = ROUNDUP((uint32)vaddr + length,PAGE_SIZE) ;
f010bf55:	c7 45 dc 00 10 00 00 	movl   $0x1000,-0x24(%ebp)
f010bf5c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010bf5f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010bf62:	01 c2                	add    %eax,%edx
f010bf64:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010bf67:	01 d0                	add    %edx,%eax
f010bf69:	48                   	dec    %eax
f010bf6a:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010bf6d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010bf70:	ba 00 00 00 00       	mov    $0x0,%edx
f010bf75:	f7 75 dc             	divl   -0x24(%ebp)
f010bf78:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010bf7b:	29 d0                	sub    %edx,%eax
f010bf7d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	uint32 iVA = ROUNDDOWN((uint32)vaddr,PAGE_SIZE) ;
f010bf80:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010bf83:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010bf86:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010bf89:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010bf8e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int r ;
	uint32 i = 0 ;
f010bf91:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct FrameInfo *p = NULL;
f010bf98:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)

	*allocated_pages = 0;
f010bf9f:	8b 45 10             	mov    0x10(%ebp),%eax
f010bfa2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
f010bfa8:	81 7d f4 00 00 20 00 	cmpl   $0x200000,-0xc(%ebp)
f010bfaf:	0f 85 f5 03 00 00    	jne    f010c3aa <program_segment_alloc_map_copy_workingset+0x46e>
f010bfb5:	8b 45 08             	mov    0x8(%ebp),%eax
f010bfb8:	83 c0 20             	add    $0x20,%eax
f010bfbb:	83 ec 08             	sub    $0x8,%esp
f010bfbe:	68 b8 f4 12 f0       	push   $0xf012f4b8
f010bfc3:	50                   	push   %eax
f010bfc4:	e8 be eb 00 00       	call   f011ab87 <strcmp>
f010bfc9:	83 c4 10             	add    $0x10,%esp
f010bfcc:	85 c0                	test   %eax,%eax
f010bfce:	0f 84 d6 03 00 00    	je     f010c3aa <program_segment_alloc_map_copy_workingset+0x46e>
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
f010bfd4:	8b 45 14             	mov    0x14(%ebp),%eax
f010bfd7:	83 f8 06             	cmp    $0x6,%eax
f010bfda:	76 05                	jbe    f010bfe1 <program_segment_alloc_map_copy_workingset+0xa5>
f010bfdc:	b8 06 00 00 00       	mov    $0x6,%eax
f010bfe1:	89 45 14             	mov    %eax,0x14(%ebp)
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010bfe4:	e9 c1 03 00 00       	jmp    f010c3aa <program_segment_alloc_map_copy_workingset+0x46e>
	{
		// Allocate a page
		allocate_frame(&p) ;
f010bfe9:	83 ec 0c             	sub    $0xc,%esp
f010bfec:	8d 45 bc             	lea    -0x44(%ebp),%eax
f010bfef:	50                   	push   %eax
f010bff0:	e8 4d d0 ff ff       	call   f0109042 <allocate_frame>
f010bff5:	83 c4 10             	add    $0x10,%esp

		LOG_STRING("segment page allocated");
		loadtime_map_frame(e->env_page_directory, p, iVA, PERM_USER | PERM_WRITEABLE);
f010bff8:	8b 55 bc             	mov    -0x44(%ebp),%edx
f010bffb:	8b 45 08             	mov    0x8(%ebp),%eax
f010bffe:	8b 40 64             	mov    0x64(%eax),%eax
f010c001:	6a 06                	push   $0x6
f010c003:	ff 75 f4             	pushl  -0xc(%ebp)
f010c006:	52                   	push   %edx
f010c007:	50                   	push   %eax
f010c008:	e8 e6 d6 ff ff       	call   f01096f3 <loadtime_map_frame>
f010c00d:	83 c4 10             	add    $0x10,%esp
		LOG_STRING("segment page mapped");

#if USE_KHEAP
		struct WorkingSetElement* wse = env_page_ws_list_create_element(e, iVA);
f010c010:	83 ec 08             	sub    $0x8,%esp
f010c013:	ff 75 f4             	pushl  -0xc(%ebp)
f010c016:	ff 75 08             	pushl  0x8(%ebp)
f010c019:	e8 e7 de ff ff       	call   f0109f05 <env_page_ws_list_create_element>
f010c01e:	83 c4 10             	add    $0x10,%esp
f010c021:	89 45 cc             	mov    %eax,-0x34(%ebp)
		wse->time_stamp = 0;
f010c024:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c027:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010c02e:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c032:	75 17                	jne    f010c04b <program_segment_alloc_map_copy_workingset+0x10f>
f010c034:	83 ec 04             	sub    $0x4,%esp
f010c037:	68 24 f3 12 f0       	push   $0xf012f324
f010c03c:	68 0e 03 00 00       	push   $0x30e
f010c041:	68 bf f2 12 f0       	push   $0xf012f2bf
f010c046:	e8 64 4e ff ff       	call   f0100eaf <_panic>
f010c04b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c04e:	8b 90 8c 00 00 00    	mov    0x8c(%eax),%edx
f010c054:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c057:	89 50 14             	mov    %edx,0x14(%eax)
f010c05a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c05d:	8b 40 14             	mov    0x14(%eax),%eax
f010c060:	85 c0                	test   %eax,%eax
f010c062:	74 11                	je     f010c075 <program_segment_alloc_map_copy_workingset+0x139>
f010c064:	8b 45 08             	mov    0x8(%ebp),%eax
f010c067:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
f010c06d:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c070:	89 50 10             	mov    %edx,0x10(%eax)
f010c073:	eb 0c                	jmp    f010c081 <program_segment_alloc_map_copy_workingset+0x145>
f010c075:	8b 45 08             	mov    0x8(%ebp),%eax
f010c078:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c07b:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010c081:	8b 45 08             	mov    0x8(%ebp),%eax
f010c084:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c087:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f010c08d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c090:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010c097:	8b 45 08             	mov    0x8(%ebp),%eax
f010c09a:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010c0a0:	8d 50 01             	lea    0x1(%eax),%edx
f010c0a3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0a6:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
		e->ptr_pageWorkingSet[e->page_last_WS_index].virtual_address = iVA;
		e->ptr_pageWorkingSet[e->page_last_WS_index].empty = 0;
		e->ptr_pageWorkingSet[e->page_last_WS_index].time_stamp = 0;
#endif
		//2020
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010c0ac:	83 ec 0c             	sub    $0xc,%esp
f010c0af:	6a 02                	push   $0x2
f010c0b1:	e8 6d 37 00 00       	call   f010f823 <isPageReplacmentAlgorithmLRU>
f010c0b6:	83 c4 10             	add    $0x10,%esp
f010c0b9:	85 c0                	test   %eax,%eax
f010c0bb:	0f 84 b3 01 00 00    	je     f010c274 <program_segment_alloc_map_copy_workingset+0x338>
		{
#if USE_KHEAP
			//Remove wse from page_WS_list
			LIST_REMOVE(&(e->page_WS_list), wse);
f010c0c1:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c0c5:	75 17                	jne    f010c0de <program_segment_alloc_map_copy_workingset+0x1a2>
f010c0c7:	83 ec 04             	sub    $0x4,%esp
f010c0ca:	68 47 f3 12 f0       	push   $0xf012f347
f010c0cf:	68 1b 03 00 00       	push   $0x31b
f010c0d4:	68 bf f2 12 f0       	push   $0xf012f2bf
f010c0d9:	e8 d1 4d ff ff       	call   f0100eaf <_panic>
f010c0de:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c0e1:	8b 40 10             	mov    0x10(%eax),%eax
f010c0e4:	85 c0                	test   %eax,%eax
f010c0e6:	74 11                	je     f010c0f9 <program_segment_alloc_map_copy_workingset+0x1bd>
f010c0e8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c0eb:	8b 40 10             	mov    0x10(%eax),%eax
f010c0ee:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c0f1:	8b 52 14             	mov    0x14(%edx),%edx
f010c0f4:	89 50 14             	mov    %edx,0x14(%eax)
f010c0f7:	eb 0f                	jmp    f010c108 <program_segment_alloc_map_copy_workingset+0x1cc>
f010c0f9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c0fc:	8b 50 14             	mov    0x14(%eax),%edx
f010c0ff:	8b 45 08             	mov    0x8(%ebp),%eax
f010c102:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f010c108:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c10b:	8b 40 14             	mov    0x14(%eax),%eax
f010c10e:	85 c0                	test   %eax,%eax
f010c110:	74 11                	je     f010c123 <program_segment_alloc_map_copy_workingset+0x1e7>
f010c112:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c115:	8b 40 14             	mov    0x14(%eax),%eax
f010c118:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c11b:	8b 52 10             	mov    0x10(%edx),%edx
f010c11e:	89 50 10             	mov    %edx,0x10(%eax)
f010c121:	eb 0f                	jmp    f010c132 <program_segment_alloc_map_copy_workingset+0x1f6>
f010c123:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c126:	8b 50 10             	mov    0x10(%eax),%edx
f010c129:	8b 45 08             	mov    0x8(%ebp),%eax
f010c12c:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010c132:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c135:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010c13c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c13f:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c146:	8b 45 08             	mov    0x8(%ebp),%eax
f010c149:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010c14f:	8d 50 ff             	lea    -0x1(%eax),%edx
f010c152:	8b 45 08             	mov    0x8(%ebp),%eax
f010c155:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
			//Always leave 1 page in Active list for the stack
			if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize - 1)
f010c15b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c15e:	8b 90 74 05 00 00    	mov    0x574(%eax),%edx
f010c164:	8b 45 08             	mov    0x8(%ebp),%eax
f010c167:	8b 80 88 05 00 00    	mov    0x588(%eax),%eax
f010c16d:	48                   	dec    %eax
f010c16e:	39 c2                	cmp    %eax,%edx
f010c170:	0f 83 80 00 00 00    	jae    f010c1f6 <program_segment_alloc_map_copy_workingset+0x2ba>
			{
				LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010c176:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c17a:	75 17                	jne    f010c193 <program_segment_alloc_map_copy_workingset+0x257>
f010c17c:	83 ec 04             	sub    $0x4,%esp
f010c17f:	68 9c f2 12 f0       	push   $0xf012f29c
f010c184:	68 1f 03 00 00       	push   $0x31f
f010c189:	68 bf f2 12 f0       	push   $0xf012f2bf
f010c18e:	e8 1c 4d ff ff       	call   f0100eaf <_panic>
f010c193:	8b 45 08             	mov    0x8(%ebp),%eax
f010c196:	8b 90 68 05 00 00    	mov    0x568(%eax),%edx
f010c19c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c19f:	89 50 10             	mov    %edx,0x10(%eax)
f010c1a2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c1a5:	8b 40 10             	mov    0x10(%eax),%eax
f010c1a8:	85 c0                	test   %eax,%eax
f010c1aa:	74 11                	je     f010c1bd <program_segment_alloc_map_copy_workingset+0x281>
f010c1ac:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1af:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010c1b5:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c1b8:	89 50 14             	mov    %edx,0x14(%eax)
f010c1bb:	eb 0c                	jmp    f010c1c9 <program_segment_alloc_map_copy_workingset+0x28d>
f010c1bd:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1c0:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c1c3:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010c1c9:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1cc:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c1cf:	89 90 68 05 00 00    	mov    %edx,0x568(%eax)
f010c1d5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c1d8:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c1df:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1e2:	8b 80 74 05 00 00    	mov    0x574(%eax),%eax
f010c1e8:	8d 50 01             	lea    0x1(%eax),%edx
f010c1eb:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1ee:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010c1f4:	eb 7e                	jmp    f010c274 <program_segment_alloc_map_copy_workingset+0x338>
			}
			else
			{
				//Add to LRU Second list
				LIST_INSERT_HEAD(&(e->SecondList), wse);
f010c1f6:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c1fa:	75 17                	jne    f010c213 <program_segment_alloc_map_copy_workingset+0x2d7>
f010c1fc:	83 ec 04             	sub    $0x4,%esp
f010c1ff:	68 9c f2 12 f0       	push   $0xf012f29c
f010c204:	68 24 03 00 00       	push   $0x324
f010c209:	68 bf f2 12 f0       	push   $0xf012f2bf
f010c20e:	e8 9c 4c ff ff       	call   f0100eaf <_panic>
f010c213:	8b 45 08             	mov    0x8(%ebp),%eax
f010c216:	8b 90 78 05 00 00    	mov    0x578(%eax),%edx
f010c21c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c21f:	89 50 10             	mov    %edx,0x10(%eax)
f010c222:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c225:	8b 40 10             	mov    0x10(%eax),%eax
f010c228:	85 c0                	test   %eax,%eax
f010c22a:	74 11                	je     f010c23d <program_segment_alloc_map_copy_workingset+0x301>
f010c22c:	8b 45 08             	mov    0x8(%ebp),%eax
f010c22f:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010c235:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c238:	89 50 14             	mov    %edx,0x14(%eax)
f010c23b:	eb 0c                	jmp    f010c249 <program_segment_alloc_map_copy_workingset+0x30d>
f010c23d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c240:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c243:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
f010c249:	8b 45 08             	mov    0x8(%ebp),%eax
f010c24c:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c24f:	89 90 78 05 00 00    	mov    %edx,0x578(%eax)
f010c255:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c258:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c25f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c262:	8b 80 84 05 00 00    	mov    0x584(%eax),%eax
f010c268:	8d 50 01             	lea    0x1(%eax),%edx
f010c26b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c26e:	89 90 84 05 00 00    	mov    %edx,0x584(%eax)
			}
#endif
		}
		//=======================
#if USE_KHEAP
		if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010c274:	8b 45 08             	mov    0x8(%ebp),%eax
f010c277:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010c27d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c280:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010c286:	39 c2                	cmp    %eax,%edx
f010c288:	75 14                	jne    f010c29e <program_segment_alloc_map_copy_workingset+0x362>
		{
			e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010c28a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c28d:	8b 90 88 00 00 00    	mov    0x88(%eax),%edx
f010c293:	8b 45 08             	mov    0x8(%ebp),%eax
f010c296:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010c29c:	eb 0d                	jmp    f010c2ab <program_segment_alloc_map_copy_workingset+0x36f>
		}
		else
		{
			e->page_last_WS_element = NULL;
f010c29e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2a1:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
f010c2a8:	00 00 00 
#else
		e->page_last_WS_index ++;
		e->page_last_WS_index %= (e->page_WS_max_size);
#endif
		//if a new table is created during the mapping, add it to the table working set
		if(PDX(iVA) != (*lastTableNumber))
f010c2ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c2ae:	c1 e8 16             	shr    $0x16,%eax
f010c2b1:	89 c2                	mov    %eax,%edx
f010c2b3:	8b 45 18             	mov    0x18(%ebp),%eax
f010c2b6:	8b 00                	mov    (%eax),%eax
f010c2b8:	39 c2                	cmp    %eax,%edx
f010c2ba:	0f 84 d3 00 00 00    	je     f010c393 <program_segment_alloc_map_copy_workingset+0x457>
		{
			e->__ptr_tws[e->table_last_WS_index].virtual_address = ROUNDDOWN(iVA, PAGE_SIZE*1024);;
f010c2c0:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2c3:	8b 90 64 05 00 00    	mov    0x564(%eax),%edx
f010c2c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c2cc:	89 45 c8             	mov    %eax,-0x38(%ebp)
f010c2cf:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010c2d2:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010c2d7:	89 c1                	mov    %eax,%ecx
f010c2d9:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010c2dc:	89 d0                	mov    %edx,%eax
f010c2de:	01 c0                	add    %eax,%eax
f010c2e0:	01 d0                	add    %edx,%eax
f010c2e2:	c1 e0 03             	shl    $0x3,%eax
f010c2e5:	01 d8                	add    %ebx,%eax
f010c2e7:	05 b4 00 00 00       	add    $0xb4,%eax
f010c2ec:	89 08                	mov    %ecx,(%eax)
			e->__ptr_tws[e->table_last_WS_index].empty = 0;
f010c2ee:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2f1:	8b 90 64 05 00 00    	mov    0x564(%eax),%edx
f010c2f7:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c2fa:	89 d0                	mov    %edx,%eax
f010c2fc:	01 c0                	add    %eax,%eax
f010c2fe:	01 d0                	add    %edx,%eax
f010c300:	c1 e0 03             	shl    $0x3,%eax
f010c303:	01 c8                	add    %ecx,%eax
f010c305:	05 b8 00 00 00       	add    $0xb8,%eax
f010c30a:	c6 00 00             	movb   $0x0,(%eax)
			e->__ptr_tws[e->table_last_WS_index].time_stamp = 0x00000000;
f010c30d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c310:	8b 90 64 05 00 00    	mov    0x564(%eax),%edx
f010c316:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c319:	89 d0                	mov    %edx,%eax
f010c31b:	01 c0                	add    %eax,%eax
f010c31d:	01 d0                	add    %edx,%eax
f010c31f:	c1 e0 03             	shl    $0x3,%eax
f010c322:	01 c8                	add    %ecx,%eax
f010c324:	05 bc 00 00 00       	add    $0xbc,%eax
f010c329:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			e->table_last_WS_index ++;
f010c32f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c332:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010c338:	8d 50 01             	lea    0x1(%eax),%edx
f010c33b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c33e:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
			e->table_last_WS_index %= __TWS_MAX_SIZE;
f010c344:	8b 45 08             	mov    0x8(%ebp),%eax
f010c347:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010c34d:	b9 32 00 00 00       	mov    $0x32,%ecx
f010c352:	ba 00 00 00 00       	mov    $0x0,%edx
f010c357:	f7 f1                	div    %ecx
f010c359:	8b 45 08             	mov    0x8(%ebp),%eax
f010c35c:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
			if (e->table_last_WS_index == 0)
f010c362:	8b 45 08             	mov    0x8(%ebp),%eax
f010c365:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010c36b:	85 c0                	test   %eax,%eax
f010c36d:	75 17                	jne    f010c386 <program_segment_alloc_map_copy_workingset+0x44a>
				panic("\nenv_create: Table working set become FULL during the application loading. Please increase the table working set size to be able to load the program successfully\n");
f010c36f:	83 ec 04             	sub    $0x4,%esp
f010c372:	68 bc f4 12 f0       	push   $0xf012f4bc
f010c377:	68 4b 03 00 00       	push   $0x34b
f010c37c:	68 bf f2 12 f0       	push   $0xf012f2bf
f010c381:	e8 29 4b ff ff       	call   f0100eaf <_panic>
			(*lastTableNumber) = PDX(iVA);
f010c386:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c389:	c1 e8 16             	shr    $0x16,%eax
f010c38c:	89 c2                	mov    %eax,%edx
f010c38e:	8b 45 18             	mov    0x18(%ebp),%eax
f010c391:	89 10                	mov    %edx,(%eax)
		}

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
f010c393:	8b 45 10             	mov    0x10(%ebp),%eax
f010c396:	8b 00                	mov    (%eax),%eax
f010c398:	8d 50 01             	lea    0x1(%eax),%edx
f010c39b:	8b 45 10             	mov    0x10(%ebp),%eax
f010c39e:	89 10                	mov    %edx,(%eax)
	*allocated_pages = 0;
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010c3a0:	ff 45 f0             	incl   -0x10(%ebp)
f010c3a3:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f010c3aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c3ad:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010c3b0:	73 0c                	jae    f010c3be <program_segment_alloc_map_copy_workingset+0x482>
f010c3b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c3b5:	3b 45 14             	cmp    0x14(%ebp),%eax
f010c3b8:	0f 82 2b fc ff ff    	jb     f010bfe9 <program_segment_alloc_map_copy_workingset+0xad>

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
	}
	uint8 *src_ptr = (uint8 *)(seg->ptr_start) ;
f010c3be:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c3c1:	8b 00                	mov    (%eax),%eax
f010c3c3:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;
f010c3c6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c3c9:	8b 40 0c             	mov    0xc(%eax),%eax
f010c3cc:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c3cf:	eb 10                	jmp    f010c3e1 <program_segment_alloc_map_copy_workingset+0x4a5>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
	{
		*dst_ptr = *src_ptr ;
f010c3d1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c3d4:	8a 10                	mov    (%eax),%dl
f010c3d6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c3d9:	88 10                	mov    %dl,(%eax)
		dst_ptr++ ;
f010c3db:	ff 45 e8             	incl   -0x18(%ebp)
		src_ptr++ ;
f010c3de:	ff 45 ec             	incl   -0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c3e1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c3e4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010c3e7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010c3ea:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010c3ef:	89 c2                	mov    %eax,%edx
f010c3f1:	8b 45 10             	mov    0x10(%ebp),%eax
f010c3f4:	8b 00                	mov    (%eax),%eax
f010c3f6:	c1 e0 0c             	shl    $0xc,%eax
f010c3f9:	01 c2                	add    %eax,%edx
f010c3fb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c3fe:	39 c2                	cmp    %eax,%edx
f010c400:	76 1d                	jbe    f010c41f <program_segment_alloc_map_copy_workingset+0x4e3>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
f010c402:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c405:	8b 50 04             	mov    0x4(%eax),%edx
f010c408:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c40b:	01 c2                	add    %eax,%edx
f010c40d:	8b 45 e8             	mov    -0x18(%ebp),%eax
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c410:	39 c2                	cmp    %eax,%edx
f010c412:	77 bd                	ja     f010c3d1 <program_segment_alloc_map_copy_workingset+0x495>
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010c414:	eb 09                	jmp    f010c41f <program_segment_alloc_map_copy_workingset+0x4e3>
	{
		*dst_ptr = 0;
f010c416:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c419:	c6 00 00             	movb   $0x0,(%eax)
		dst_ptr++ ;
f010c41c:	ff 45 e8             	incl   -0x18(%ebp)
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010c41f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c422:	89 45 c0             	mov    %eax,-0x40(%ebp)
f010c425:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010c428:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010c42d:	89 c2                	mov    %eax,%edx
f010c42f:	8b 45 10             	mov    0x10(%ebp),%eax
f010c432:	8b 00                	mov    (%eax),%eax
f010c434:	c1 e0 0c             	shl    $0xc,%eax
f010c437:	01 c2                	add    %eax,%edx
f010c439:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c43c:	39 c2                	cmp    %eax,%edx
f010c43e:	77 d6                	ja     f010c416 <program_segment_alloc_map_copy_workingset+0x4da>
	{
		*dst_ptr = 0;
		dst_ptr++ ;
	}

	return 0;
f010c440:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010c445:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010c448:	c9                   	leave  
f010c449:	c3                   	ret    

f010c44a <create_user_directory>:

//==================================================
// 5) DYNAMICALLY ALLOCATE SPACE FOR USER DIRECTORY:
//==================================================
void * create_user_directory()
{
f010c44a:	55                   	push   %ebp
f010c44b:	89 e5                	mov    %esp,%ebp
f010c44d:	83 ec 18             	sub    $0x18,%esp
	//panic("create_user_directory() is not implemented yet...!!");

	//Use kmalloc() to allocate a new directory

	//change this "return" according to your answer
	uint32* ptr_user_page_directory = kmalloc(PAGE_SIZE);
f010c450:	83 ec 0c             	sub    $0xc,%esp
f010c453:	68 00 10 00 00       	push   $0x1000
f010c458:	e8 d9 d6 ff ff       	call   f0109b36 <kmalloc>
f010c45d:	83 c4 10             	add    $0x10,%esp
f010c460:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_user_page_directory == NULL)
f010c463:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c467:	75 17                	jne    f010c480 <create_user_directory+0x36>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f010c469:	83 ec 04             	sub    $0x4,%esp
f010c46c:	68 5f f5 12 f0       	push   $0xf012f55f
f010c471:	68 7b 03 00 00       	push   $0x37b
f010c476:	68 bf f2 12 f0       	push   $0xf012f2bf
f010c47b:	e8 2f 4a ff ff       	call   f0100eaf <_panic>
	}
	return ptr_user_page_directory;
f010c480:	8b 45 f4             	mov    -0xc(%ebp),%eax
	//return 0;
}
f010c483:	c9                   	leave  
f010c484:	c3                   	ret    

f010c485 <create_user_kern_stack>:
uint32 __cur_k_stk = KERNEL_HEAP_START;
//===========================================================
// 6) ALLOCATE SPACE FOR USER KERNEL STACK (One Per Process):
//===========================================================
void* create_user_kern_stack(uint32* ptr_user_page_directory)
{
f010c485:	55                   	push   %ebp
f010c486:	89 e5                	mov    %esp,%ebp
f010c488:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.GM#3] FAULT HANDLER I - #1 create_user_kern_stack
	//Your code is here
	//Comment the following line
	panic("create_user_kern_stack() is not implemented yet...!!");
f010c48b:	83 ec 04             	sub    $0x4,%esp
f010c48e:	68 7c f5 12 f0       	push   $0xf012f57c
f010c493:	68 8b 03 00 00       	push   $0x38b
f010c498:	68 bf f2 12 f0       	push   $0xf012f2bf
f010c49d:	e8 0d 4a ff ff       	call   f0100eaf <_panic>

f010c4a2 <delete_user_kern_stack>:
/*2024*/
//===========================================================
// 6) DELETE USER KERNEL STACK (One Per Process):
//===========================================================
void delete_user_kern_stack(struct Env* e)
{
f010c4a2:	55                   	push   %ebp
f010c4a3:	89 e5                	mov    %esp,%ebp
f010c4a5:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	//TODO: [PROJECT'25.BONUS#4] EXIT #1 & #2 - delete_user_kern_stack
	// Write your code here, remove the panic and write your code
	panic("delete_user_kern_stack() is not implemented yet...!!");
f010c4a8:	83 ec 04             	sub    $0x4,%esp
f010c4ab:	68 b4 f5 12 f0       	push   $0xf012f5b4
f010c4b0:	68 9b 03 00 00       	push   $0x39b
f010c4b5:	68 bf f2 12 f0       	push   $0xf012f2bf
f010c4ba:	e8 f0 49 ff ff       	call   f0100eaf <_panic>

f010c4bf <initialize_environment>:
//	  3.3 Setup the context to return to env_start() at the early first run from the scheduler
// 4. Initialize the working set
// 5. Initialize the user dynamic allocator
//
void initialize_environment(struct Env* e, uint32* ptr_user_page_directory, unsigned int phys_user_page_directory)
{
f010c4bf:	55                   	push   %ebp
f010c4c0:	89 e5                	mov    %esp,%ebp
f010c4c2:	83 ec 18             	sub    $0x18,%esp
	//panic("initialize_environment function is not completed yet") ;
	// [1] initialize the kernel portion of the new environment's address space.
	// [2] set e->env_pgdir and e->env_cr3 accordingly,
	int i;
	e->env_page_directory = ptr_user_page_directory;
f010c4c5:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4c8:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c4cb:	89 50 64             	mov    %edx,0x64(%eax)
	e->env_cr3 = phys_user_page_directory;
f010c4ce:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4d1:	8b 55 10             	mov    0x10(%ebp),%edx
f010c4d4:	89 50 68             	mov    %edx,0x68(%eax)

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010c4d7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c4de:	eb 17                	jmp    f010c4f7 <initialize_environment+0x38>
	{
		e->env_page_directory[i] = 0 ;
f010c4e0:	8b 45 08             	mov    0x8(%ebp),%eax
f010c4e3:	8b 40 64             	mov    0x64(%eax),%eax
f010c4e6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c4e9:	c1 e2 02             	shl    $0x2,%edx
f010c4ec:	01 d0                	add    %edx,%eax
f010c4ee:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	int i;
	e->env_page_directory = ptr_user_page_directory;
	e->env_cr3 = phys_user_page_directory;

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010c4f4:	ff 45 f4             	incl   -0xc(%ebp)
f010c4f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c4fa:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f010c4ff:	76 df                	jbe    f010c4e0 <initialize_environment+0x21>
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010c501:	c7 45 f4 bb 03 00 00 	movl   $0x3bb,-0xc(%ebp)
f010c508:	eb 22                	jmp    f010c52c <initialize_environment+0x6d>
	{
		e->env_page_directory[i] = ptr_page_directory[i] ;
f010c50a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c50d:	8b 40 64             	mov    0x64(%eax),%eax
f010c510:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c513:	c1 e2 02             	shl    $0x2,%edx
f010c516:	01 c2                	add    %eax,%edx
f010c518:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f010c51d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010c520:	c1 e1 02             	shl    $0x2,%ecx
f010c523:	01 c8                	add    %ecx,%eax
f010c525:	8b 00                	mov    (%eax),%eax
f010c527:	89 02                	mov    %eax,(%edx)
	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010c529:	ff 45 f4             	incl   -0xc(%ebp)
f010c52c:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f010c533:	7e d5                	jle    f010c50a <initialize_environment+0x4b>
	 * Setup the new context to start executing at the env_start() to do some initializations then
	 * returns to trapret() to pop the trap frame and invoke iret
	 */
	{
		//[1] Create the stack
		e->kstack = create_user_kern_stack(e->env_page_directory);
f010c535:	8b 45 08             	mov    0x8(%ebp),%eax
f010c538:	8b 40 64             	mov    0x64(%eax),%eax
f010c53b:	83 ec 0c             	sub    $0xc,%esp
f010c53e:	50                   	push   %eax
f010c53f:	e8 41 ff ff ff       	call   f010c485 <create_user_kern_stack>
f010c544:	83 c4 10             	add    $0x10,%esp
f010c547:	89 c2                	mov    %eax,%edx
f010c549:	8b 45 08             	mov    0x8(%ebp),%eax
f010c54c:	89 50 70             	mov    %edx,0x70(%eax)

		//[2] Leave room for the trap frame
		void* sp = e->kstack + KERNEL_STACK_SIZE;
f010c54f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c552:	8b 40 70             	mov    0x70(%eax),%eax
f010c555:	05 00 80 00 00       	add    $0x8000,%eax
f010c55a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sp -= sizeof(struct Trapframe);
f010c55d:	83 6d f0 44          	subl   $0x44,-0x10(%ebp)
		e->env_tf = (struct Trapframe *) sp;
f010c561:	8b 45 08             	mov    0x8(%ebp),%eax
f010c564:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010c567:	89 10                	mov    %edx,(%eax)

		//[3] Set the address of trapret() first - to return on it after env_start() is returned,
		sp -= 4;
f010c569:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
		*(uint32*)sp = (uint32)trapret;
f010c56d:	ba 68 e6 10 f0       	mov    $0xf010e668,%edx
f010c572:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c575:	89 10                	mov    %edx,(%eax)

		//[4] Place the context next
		sp -= sizeof(struct Context);
f010c577:	83 6d f0 20          	subl   $0x20,-0x10(%ebp)
		e->context = (struct Context *) sp;
f010c57b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c57e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010c581:	89 50 04             	mov    %edx,0x4(%eax)

		//[4] Setup the context to return to env_start() at the early first run from the scheduler
		memset(e->context, 0, sizeof(*(e->context)));
f010c584:	8b 45 08             	mov    0x8(%ebp),%eax
f010c587:	8b 40 04             	mov    0x4(%eax),%eax
f010c58a:	83 ec 04             	sub    $0x4,%esp
f010c58d:	6a 20                	push   $0x20
f010c58f:	6a 00                	push   $0x0
f010c591:	50                   	push   %eax
f010c592:	e8 d2 e6 00 00       	call   f011ac69 <memset>
f010c597:	83 c4 10             	add    $0x10,%esp
		e->context->eip = (uint32) (env_start);
f010c59a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c59d:	8b 40 04             	mov    0x4(%eax),%eax
f010c5a0:	ba 67 b9 10 f0       	mov    $0xf010b967,%edx
f010c5a5:	89 50 1c             	mov    %edx,0x1c(%eax)
	}

	// Allocate the page working set
#if USE_KHEAP == 1
	{
		LIST_INIT(&(e->page_WS_list));
f010c5a8:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5ab:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
f010c5b2:	00 00 00 
f010c5b5:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5b8:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
f010c5bf:	00 00 00 
f010c5c2:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5c5:	c7 80 94 00 00 00 00 	movl   $0x0,0x94(%eax)
f010c5cc:	00 00 00 
		LIST_INIT(&(e->referenceStreamList));
f010c5cf:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5d2:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
f010c5d9:	00 00 00 
f010c5dc:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5df:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f010c5e6:	00 00 00 
f010c5e9:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5ec:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f010c5f3:	00 00 00 
	}
#endif

	//2020
	// Add its elements to the "e->PageWorkingSetList"
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010c5f6:	83 ec 0c             	sub    $0xc,%esp
f010c5f9:	6a 02                	push   $0x2
f010c5fb:	e8 23 32 00 00       	call   f010f823 <isPageReplacmentAlgorithmLRU>
f010c600:	83 c4 10             	add    $0x10,%esp
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010c603:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c60a:	eb 54                	jmp    f010c660 <initialize_environment+0x1a1>
	{
		e->__ptr_tws[i].virtual_address = 0;
f010c60c:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c60f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c612:	89 d0                	mov    %edx,%eax
f010c614:	01 c0                	add    %eax,%eax
f010c616:	01 d0                	add    %edx,%eax
f010c618:	c1 e0 03             	shl    $0x3,%eax
f010c61b:	01 c8                	add    %ecx,%eax
f010c61d:	05 b4 00 00 00       	add    $0xb4,%eax
f010c622:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->__ptr_tws[i].empty = 1;
f010c628:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c62b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c62e:	89 d0                	mov    %edx,%eax
f010c630:	01 c0                	add    %eax,%eax
f010c632:	01 d0                	add    %edx,%eax
f010c634:	c1 e0 03             	shl    $0x3,%eax
f010c637:	01 c8                	add    %ecx,%eax
f010c639:	05 b8 00 00 00       	add    $0xb8,%eax
f010c63e:	c6 00 01             	movb   $0x1,(%eax)
		e->__ptr_tws[i].time_stamp = 0 ;
f010c641:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c644:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c647:	89 d0                	mov    %edx,%eax
f010c649:	01 c0                	add    %eax,%eax
f010c64b:	01 d0                	add    %edx,%eax
f010c64d:	c1 e0 03             	shl    $0x3,%eax
f010c650:	01 c8                	add    %ecx,%eax
f010c652:	05 bc 00 00 00       	add    $0xbc,%eax
f010c657:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010c65d:	ff 45 f4             	incl   -0xc(%ebp)
f010c660:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010c664:	7e a6                	jle    f010c60c <initialize_environment+0x14d>
		e->__ptr_tws[i].virtual_address = 0;
		e->__ptr_tws[i].empty = 1;
		e->__ptr_tws[i].time_stamp = 0 ;
	}

	e->table_last_WS_index = 0;
f010c666:	8b 45 08             	mov    0x8(%ebp),%eax
f010c669:	c7 80 64 05 00 00 00 	movl   $0x0,0x564(%eax)
f010c670:	00 00 00 

	e->pageFaultsCounter=0;
f010c673:	8b 45 08             	mov    0x8(%ebp),%eax
f010c676:	c7 80 98 05 00 00 00 	movl   $0x0,0x598(%eax)
f010c67d:	00 00 00 
	e->tableFaultsCounter=0;
f010c680:	8b 45 08             	mov    0x8(%ebp),%eax
f010c683:	c7 80 9c 05 00 00 00 	movl   $0x0,0x59c(%eax)
f010c68a:	00 00 00 

	e->freeingFullWSCounter = 0;
f010c68d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c690:	c7 80 a0 05 00 00 00 	movl   $0x0,0x5a0(%eax)
f010c697:	00 00 00 
	e->freeingScarceMemCounter = 0;
f010c69a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c69d:	c7 80 a4 05 00 00 00 	movl   $0x0,0x5a4(%eax)
f010c6a4:	00 00 00 

	e->nModifiedPages=0;
f010c6a7:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6aa:	c7 80 a8 05 00 00 00 	movl   $0x0,0x5a8(%eax)
f010c6b1:	00 00 00 
	e->nNotModifiedPages=0;
f010c6b4:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6b7:	c7 80 ac 05 00 00 00 	movl   $0x0,0x5ac(%eax)
f010c6be:	00 00 00 
	e->nClocks = 0;
f010c6c1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6c4:	c7 80 c0 05 00 00 00 	movl   $0x0,0x5c0(%eax)
f010c6cb:	00 00 00 

	//2020
	e->nPageIn = 0;
f010c6ce:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6d1:	c7 80 b4 05 00 00 00 	movl   $0x0,0x5b4(%eax)
f010c6d8:	00 00 00 
	e->nPageOut = 0;
f010c6db:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6de:	c7 80 b8 05 00 00 00 	movl   $0x0,0x5b8(%eax)
f010c6e5:	00 00 00 
	e->nNewPageAdded = 0;
f010c6e8:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6eb:	c7 80 bc 05 00 00 00 	movl   $0x0,0x5bc(%eax)
f010c6f2:	00 00 00 

	//e->shared_free_address = USER_SHARED_MEM_START;

	//Completes other environment initializations, (envID, status and most of registers)
	complete_environment_initialization(e);
f010c6f5:	83 ec 0c             	sub    $0xc,%esp
f010c6f8:	ff 75 08             	pushl  0x8(%ebp)
f010c6fb:	e8 06 00 00 00       	call   f010c706 <complete_environment_initialization>
f010c700:	83 c4 10             	add    $0x10,%esp
}
f010c703:	90                   	nop
f010c704:	c9                   	leave  
f010c705:	c3                   	ret    

f010c706 <complete_environment_initialization>:

//========================================================
// 9) COMPLETE INITIALIZATION [OTHERS: ID, REGS, STATUS...):
//========================================================
void complete_environment_initialization(struct Env* e)
{
f010c706:	55                   	push   %ebp
f010c707:	89 e5                	mov    %esp,%ebp
f010c709:	53                   	push   %ebx
f010c70a:	83 ec 14             	sub    $0x14,%esp
	//VPT and UVPT map the env's own page table, with
	//different permissions.
	e->env_page_directory[PDX(VPT)]  = e->env_cr3 | PERM_PRESENT | PERM_WRITEABLE;
f010c70d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c710:	8b 40 64             	mov    0x64(%eax),%eax
f010c713:	8d 90 fc 0e 00 00    	lea    0xefc(%eax),%edx
f010c719:	8b 45 08             	mov    0x8(%ebp),%eax
f010c71c:	8b 40 68             	mov    0x68(%eax),%eax
f010c71f:	83 c8 03             	or     $0x3,%eax
f010c722:	89 02                	mov    %eax,(%edx)
	e->env_page_directory[PDX(UVPT)] = e->env_cr3 | PERM_PRESENT | PERM_USER;
f010c724:	8b 45 08             	mov    0x8(%ebp),%eax
f010c727:	8b 40 64             	mov    0x64(%eax),%eax
f010c72a:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f010c730:	8b 45 08             	mov    0x8(%ebp),%eax
f010c733:	8b 40 68             	mov    0x68(%eax),%eax
f010c736:	83 c8 05             	or     $0x5,%eax
f010c739:	89 02                	mov    %eax,(%edx)

	// page file directory initialization
	e->disk_env_pgdir= 0;
f010c73b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c73e:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
	e->disk_env_pgdir_PA= 0;
f010c745:	8b 45 08             	mov    0x8(%ebp),%eax
f010c748:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)
	e->disk_env_tabledir = 0;
f010c74f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c752:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
	e->disk_env_tabledir_PA = 0;
f010c759:	8b 45 08             	mov    0x8(%ebp),%eax
f010c75c:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f010c763:	00 00 00 

	int32 generation;
	// Generate an env_id for this environment.
	/*2022: UPDATED*/generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NEARPOW2NENV - 1);
f010c766:	8b 45 08             	mov    0x8(%ebp),%eax
f010c769:	8b 58 10             	mov    0x10(%eax),%ebx
f010c76c:	83 ec 0c             	sub    $0xc,%esp
f010c76f:	68 c6 02 00 00       	push   $0x2c6
f010c774:	e8 d7 c3 00 00       	call   f0118b50 <log2_ceil>
f010c779:	83 c4 10             	add    $0x10,%esp
f010c77c:	ba 01 00 00 00       	mov    $0x1,%edx
f010c781:	88 c1                	mov    %al,%cl
f010c783:	d3 e2                	shl    %cl,%edx
f010c785:	89 d0                	mov    %edx,%eax
f010c787:	01 d8                	add    %ebx,%eax
f010c789:	89 c3                	mov    %eax,%ebx
f010c78b:	83 ec 0c             	sub    $0xc,%esp
f010c78e:	68 c6 02 00 00       	push   $0x2c6
f010c793:	e8 83 c3 00 00       	call   f0118b1b <nearest_pow2_ceil>
f010c798:	83 c4 10             	add    $0x10,%esp
f010c79b:	f7 d8                	neg    %eax
f010c79d:	21 d8                	and    %ebx,%eax
f010c79f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (generation <= 0)	// Don't create a negative env_id.
f010c7a2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c7a6:	7f 1e                	jg     f010c7c6 <complete_environment_initialization+0xc0>
		generation = 1 << ENVGENSHIFT;
f010c7a8:	83 ec 0c             	sub    $0xc,%esp
f010c7ab:	68 c6 02 00 00       	push   $0x2c6
f010c7b0:	e8 9b c3 00 00       	call   f0118b50 <log2_ceil>
f010c7b5:	83 c4 10             	add    $0x10,%esp
f010c7b8:	ba 01 00 00 00       	mov    $0x1,%edx
f010c7bd:	88 c1                	mov    %al,%cl
f010c7bf:	d3 e2                	shl    %cl,%edx
f010c7c1:	89 d0                	mov    %edx,%eax
f010c7c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	e->env_id = generation | (e - envs);
f010c7c6:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7c9:	8b 15 90 5b 81 f0    	mov    0xf0815b90,%edx
f010c7cf:	29 d0                	sub    %edx,%eax
f010c7d1:	c1 f8 02             	sar    $0x2,%eax
f010c7d4:	89 c1                	mov    %eax,%ecx
f010c7d6:	89 ca                	mov    %ecx,%edx
f010c7d8:	c1 e2 02             	shl    $0x2,%edx
f010c7db:	01 ca                	add    %ecx,%edx
f010c7dd:	c1 e2 02             	shl    $0x2,%edx
f010c7e0:	01 ca                	add    %ecx,%edx
f010c7e2:	c1 e2 03             	shl    $0x3,%edx
f010c7e5:	01 ca                	add    %ecx,%edx
f010c7e7:	89 d0                	mov    %edx,%eax
f010c7e9:	c1 e0 05             	shl    $0x5,%eax
f010c7ec:	29 d0                	sub    %edx,%eax
f010c7ee:	c1 e0 02             	shl    $0x2,%eax
f010c7f1:	01 c8                	add    %ecx,%eax
f010c7f3:	c1 e0 02             	shl    $0x2,%eax
f010c7f6:	01 c8                	add    %ecx,%eax
f010c7f8:	c1 e0 02             	shl    $0x2,%eax
f010c7fb:	01 c8                	add    %ecx,%eax
f010c7fd:	c1 e0 06             	shl    $0x6,%eax
f010c800:	29 c8                	sub    %ecx,%eax
f010c802:	c1 e0 03             	shl    $0x3,%eax
f010c805:	01 c8                	add    %ecx,%eax
f010c807:	c1 e0 04             	shl    $0x4,%eax
f010c80a:	01 c8                	add    %ecx,%eax
f010c80c:	0b 45 f4             	or     -0xc(%ebp),%eax
f010c80f:	89 c2                	mov    %eax,%edx
f010c811:	8b 45 08             	mov    0x8(%ebp),%eax
f010c814:	89 50 10             	mov    %edx,0x10(%eax)
	//cprintf("\n[%d] user kernel stack located in [%x,%x)\n", e->env_id, e->kstack, e->kstack + KERNEL_STACK_SIZE);
	//cprintf("ENV_CREATE: envID = %d, orig index in envs = %d, calc index using ENVX = %d\n", e->env_id, (e - envs), ENVX(e->env_id));

	// Set the basic status variables.
	//2017====================================================
	struct Env* cur_env = get_cpu_proc();
f010c817:	e8 fc f1 ff ff       	call   f010ba18 <get_cpu_proc>
f010c81c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env == NULL)
f010c81f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010c823:	75 0c                	jne    f010c831 <complete_environment_initialization+0x12b>
		e->env_parent_id = 0;//no parent;
f010c825:	8b 45 08             	mov    0x8(%ebp),%eax
f010c828:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c82f:	eb 0c                	jmp    f010c83d <complete_environment_initialization+0x137>
	else
		e->env_parent_id = cur_env->env_id;//curenv is the parent;
f010c831:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c834:	8b 50 10             	mov    0x10(%eax),%edx
f010c837:	8b 45 08             	mov    0x8(%ebp),%eax
f010c83a:	89 50 14             	mov    %edx,0x14(%eax)
	//========================================================
	e->env_status = ENV_NEW;
f010c83d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c840:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
	e->env_runs = 0;
f010c847:	8b 45 08             	mov    0x8(%ebp),%eax
f010c84a:	c7 80 b0 05 00 00 00 	movl   $0x0,0x5b0(%eax)
f010c851:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(e->env_tf, 0, sizeof(*(e->env_tf)));
f010c854:	8b 45 08             	mov    0x8(%ebp),%eax
f010c857:	8b 00                	mov    (%eax),%eax
f010c859:	83 ec 04             	sub    $0x4,%esp
f010c85c:	6a 44                	push   $0x44
f010c85e:	6a 00                	push   $0x0
f010c860:	50                   	push   %eax
f010c861:	e8 03 e4 00 00       	call   f011ac69 <memset>
f010c866:	83 c4 10             	add    $0x10,%esp
	// GD_UD is the user data segment selector in the GDT, and
	// GD_UT is the user text segment selector (see inc/memlayout.h).
	// The low 2 bits of each segment register contains the
	// Requester Privilege Level (RPL); 3 means user mode.

	e->env_tf->tf_ds = GD_UD | 3;
f010c869:	8b 45 08             	mov    0x8(%ebp),%eax
f010c86c:	8b 00                	mov    (%eax),%eax
f010c86e:	66 c7 40 24 23 00    	movw   $0x23,0x24(%eax)
	e->env_tf->tf_es = GD_UD | 3;
f010c874:	8b 45 08             	mov    0x8(%ebp),%eax
f010c877:	8b 00                	mov    (%eax),%eax
f010c879:	66 c7 40 20 23 00    	movw   $0x23,0x20(%eax)
	e->env_tf->tf_ss = GD_UD | 3;
f010c87f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c882:	8b 00                	mov    (%eax),%eax
f010c884:	66 c7 40 40 23 00    	movw   $0x23,0x40(%eax)
	e->env_tf->tf_esp = (uint32*)USTACKTOP;
f010c88a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c88d:	8b 00                	mov    (%eax),%eax
f010c88f:	c7 40 3c 00 e0 bf ee 	movl   $0xeebfe000,0x3c(%eax)
	e->env_tf->tf_cs = GD_UT | 3;
f010c896:	8b 45 08             	mov    0x8(%ebp),%eax
f010c899:	8b 00                	mov    (%eax),%eax
f010c89b:	66 c7 40 34 1b 00    	movw   $0x1b,0x34(%eax)
	e->env_tf->tf_eflags |= FL_IF;
f010c8a1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8a4:	8b 00                	mov    (%eax),%eax
f010c8a6:	8b 55 08             	mov    0x8(%ebp),%edx
f010c8a9:	8b 12                	mov    (%edx),%edx
f010c8ab:	8b 52 38             	mov    0x38(%edx),%edx
f010c8ae:	80 ce 02             	or     $0x2,%dh
f010c8b1:	89 50 38             	mov    %edx,0x38(%eax)

	// You will set e->env_tf.tf_eip later.

	// commit the allocation
	LIST_REMOVE(&env_free_list ,e);
f010c8b4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010c8b8:	75 17                	jne    f010c8d1 <complete_environment_initialization+0x1cb>
f010c8ba:	83 ec 04             	sub    $0x4,%esp
f010c8bd:	68 47 f3 12 f0       	push   $0xf012f347
f010c8c2:	68 65 04 00 00       	push   $0x465
f010c8c7:	68 bf f2 12 f0       	push   $0xf012f2bf
f010c8cc:	e8 de 45 ff ff       	call   f0100eaf <_panic>
f010c8d1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8d4:	8b 40 08             	mov    0x8(%eax),%eax
f010c8d7:	85 c0                	test   %eax,%eax
f010c8d9:	74 11                	je     f010c8ec <complete_environment_initialization+0x1e6>
f010c8db:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8de:	8b 40 08             	mov    0x8(%eax),%eax
f010c8e1:	8b 55 08             	mov    0x8(%ebp),%edx
f010c8e4:	8b 52 0c             	mov    0xc(%edx),%edx
f010c8e7:	89 50 0c             	mov    %edx,0xc(%eax)
f010c8ea:	eb 0b                	jmp    f010c8f7 <complete_environment_initialization+0x1f1>
f010c8ec:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8ef:	8b 40 0c             	mov    0xc(%eax),%eax
f010c8f2:	a3 98 5b 81 f0       	mov    %eax,0xf0815b98
f010c8f7:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8fa:	8b 40 0c             	mov    0xc(%eax),%eax
f010c8fd:	85 c0                	test   %eax,%eax
f010c8ff:	74 11                	je     f010c912 <complete_environment_initialization+0x20c>
f010c901:	8b 45 08             	mov    0x8(%ebp),%eax
f010c904:	8b 40 0c             	mov    0xc(%eax),%eax
f010c907:	8b 55 08             	mov    0x8(%ebp),%edx
f010c90a:	8b 52 08             	mov    0x8(%edx),%edx
f010c90d:	89 50 08             	mov    %edx,0x8(%eax)
f010c910:	eb 0b                	jmp    f010c91d <complete_environment_initialization+0x217>
f010c912:	8b 45 08             	mov    0x8(%ebp),%eax
f010c915:	8b 40 08             	mov    0x8(%eax),%eax
f010c918:	a3 94 5b 81 f0       	mov    %eax,0xf0815b94
f010c91d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c920:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010c927:	8b 45 08             	mov    0x8(%ebp),%eax
f010c92a:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010c931:	a1 a0 5b 81 f0       	mov    0xf0815ba0,%eax
f010c936:	48                   	dec    %eax
f010c937:	a3 a0 5b 81 f0       	mov    %eax,0xf0815ba0
	return ;
f010c93c:	90                   	nop
}
f010c93d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010c940:	c9                   	leave  
f010c941:	c3                   	ret    

f010c942 <set_environment_entry_point>:

//===============================================
// 10) SET EIP REG VALUE BY ENV ENTRY POINT:
//===============================================
void set_environment_entry_point(struct Env* e, uint8* ptr_program_start)
{
f010c942:	55                   	push   %ebp
f010c943:	89 e5                	mov    %esp,%ebp
f010c945:	83 ec 18             	sub    $0x18,%esp
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010c948:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c94b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010c94e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c951:	8b 00                	mov    (%eax),%eax
f010c953:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010c958:	74 17                	je     f010c971 <set_environment_entry_point+0x2f>
		panic("Matafa2nash 3ala Keda");
f010c95a:	83 ec 04             	sub    $0x4,%esp
f010c95d:	68 e9 f5 12 f0       	push   $0xf012f5e9
f010c962:	68 71 04 00 00       	push   $0x471
f010c967:	68 bf f2 12 f0       	push   $0xf012f2bf
f010c96c:	e8 3e 45 ff ff       	call   f0100eaf <_panic>
	e->env_tf->tf_eip = (uint32*)pELFHDR->e_entry ;
f010c971:	8b 45 08             	mov    0x8(%ebp),%eax
f010c974:	8b 00                	mov    (%eax),%eax
f010c976:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c979:	8b 52 18             	mov    0x18(%edx),%edx
f010c97c:	89 50 30             	mov    %edx,0x30(%eax)
}
f010c97f:	90                   	nop
f010c980:	c9                   	leave  
f010c981:	c3                   	ret    

f010c982 <PROGRAM_SEGMENT_NEXT>:

//===============================================
// 13) SEG NEXT [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment* PROGRAM_SEGMENT_NEXT(struct ProgramSegment* seg, uint8* ptr_program_start)
{
f010c982:	55                   	push   %ebp
f010c983:	89 e5                	mov    %esp,%ebp
f010c985:	83 ec 18             	sub    $0x18,%esp
	int index = (*seg).segment_id++;
f010c988:	8b 45 08             	mov    0x8(%ebp),%eax
f010c98b:	8b 40 10             	mov    0x10(%eax),%eax
f010c98e:	8d 48 01             	lea    0x1(%eax),%ecx
f010c991:	8b 55 08             	mov    0x8(%ebp),%edx
f010c994:	89 4a 10             	mov    %ecx,0x10(%edx)
f010c997:	89 45 f4             	mov    %eax,-0xc(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010c99a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c99d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010c9a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c9a3:	8b 00                	mov    (%eax),%eax
f010c9a5:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010c9aa:	74 17                	je     f010c9c3 <PROGRAM_SEGMENT_NEXT+0x41>
		panic("Matafa2nash 3ala Keda");
f010c9ac:	83 ec 04             	sub    $0x4,%esp
f010c9af:	68 e9 f5 12 f0       	push   $0xf012f5e9
f010c9b4:	68 7f 04 00 00       	push   $0x47f
f010c9b9:	68 bf f2 12 f0       	push   $0xf012f2bf
f010c9be:	e8 ec 44 ff ff       	call   f0100eaf <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010c9c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c9c6:	8b 50 1c             	mov    0x1c(%eax),%edx
f010c9c9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c9cc:	01 d0                	add    %edx,%eax
f010c9ce:	89 45 ec             	mov    %eax,-0x14(%ebp)

	while (ph[(*seg).segment_id].p_type != ELF_PROG_LOAD && ((*seg).segment_id < pELFHDR->e_phnum)) (*seg).segment_id++;
f010c9d1:	eb 0f                	jmp    f010c9e2 <PROGRAM_SEGMENT_NEXT+0x60>
f010c9d3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9d6:	8b 40 10             	mov    0x10(%eax),%eax
f010c9d9:	8d 50 01             	lea    0x1(%eax),%edx
f010c9dc:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9df:	89 50 10             	mov    %edx,0x10(%eax)
f010c9e2:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9e5:	8b 40 10             	mov    0x10(%eax),%eax
f010c9e8:	c1 e0 05             	shl    $0x5,%eax
f010c9eb:	89 c2                	mov    %eax,%edx
f010c9ed:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c9f0:	01 d0                	add    %edx,%eax
f010c9f2:	8b 00                	mov    (%eax),%eax
f010c9f4:	83 f8 01             	cmp    $0x1,%eax
f010c9f7:	74 13                	je     f010ca0c <PROGRAM_SEGMENT_NEXT+0x8a>
f010c9f9:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9fc:	8b 50 10             	mov    0x10(%eax),%edx
f010c9ff:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ca02:	8b 40 2c             	mov    0x2c(%eax),%eax
f010ca05:	0f b7 c0             	movzwl %ax,%eax
f010ca08:	39 c2                	cmp    %eax,%edx
f010ca0a:	72 c7                	jb     f010c9d3 <PROGRAM_SEGMENT_NEXT+0x51>
	index = (*seg).segment_id;
f010ca0c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca0f:	8b 40 10             	mov    0x10(%eax),%eax
f010ca12:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(index < pELFHDR->e_phnum)
f010ca15:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ca18:	8b 40 2c             	mov    0x2c(%eax),%eax
f010ca1b:	0f b7 c0             	movzwl %ax,%eax
f010ca1e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010ca21:	7e 63                	jle    f010ca86 <PROGRAM_SEGMENT_NEXT+0x104>
	{
		(*seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010ca23:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ca26:	c1 e0 05             	shl    $0x5,%eax
f010ca29:	89 c2                	mov    %eax,%edx
f010ca2b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ca2e:	01 d0                	add    %edx,%eax
f010ca30:	8b 50 04             	mov    0x4(%eax),%edx
f010ca33:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ca36:	01 c2                	add    %eax,%edx
f010ca38:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca3b:	89 10                	mov    %edx,(%eax)
		(*seg).size_in_memory =  ph[index].p_memsz;
f010ca3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ca40:	c1 e0 05             	shl    $0x5,%eax
f010ca43:	89 c2                	mov    %eax,%edx
f010ca45:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ca48:	01 d0                	add    %edx,%eax
f010ca4a:	8b 50 14             	mov    0x14(%eax),%edx
f010ca4d:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca50:	89 50 08             	mov    %edx,0x8(%eax)
		(*seg).size_in_file = ph[index].p_filesz;
f010ca53:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ca56:	c1 e0 05             	shl    $0x5,%eax
f010ca59:	89 c2                	mov    %eax,%edx
f010ca5b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ca5e:	01 d0                	add    %edx,%eax
f010ca60:	8b 50 10             	mov    0x10(%eax),%edx
f010ca63:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca66:	89 50 04             	mov    %edx,0x4(%eax)
		(*seg).virtual_address = (uint8*)ph[index].p_va;
f010ca69:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ca6c:	c1 e0 05             	shl    $0x5,%eax
f010ca6f:	89 c2                	mov    %eax,%edx
f010ca71:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ca74:	01 d0                	add    %edx,%eax
f010ca76:	8b 40 08             	mov    0x8(%eax),%eax
f010ca79:	89 c2                	mov    %eax,%edx
f010ca7b:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca7e:	89 50 0c             	mov    %edx,0xc(%eax)
		return seg;
f010ca81:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca84:	eb 05                	jmp    f010ca8b <PROGRAM_SEGMENT_NEXT+0x109>
	}
	return 0;
f010ca86:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ca8b:	c9                   	leave  
f010ca8c:	c3                   	ret    

f010ca8d <PROGRAM_SEGMENT_FIRST>:

//===============================================
// 14) SEG FIRST [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment PROGRAM_SEGMENT_FIRST( uint8* ptr_program_start)
{
f010ca8d:	55                   	push   %ebp
f010ca8e:	89 e5                	mov    %esp,%ebp
f010ca90:	57                   	push   %edi
f010ca91:	56                   	push   %esi
f010ca92:	53                   	push   %ebx
f010ca93:	83 ec 2c             	sub    $0x2c,%esp
	struct ProgramSegment seg;
	seg.segment_id = 0;
f010ca96:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010ca9d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010caa0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010caa3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010caa6:	8b 00                	mov    (%eax),%eax
f010caa8:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010caad:	74 17                	je     f010cac6 <PROGRAM_SEGMENT_FIRST+0x39>
		panic("Matafa2nash 3ala Keda");
f010caaf:	83 ec 04             	sub    $0x4,%esp
f010cab2:	68 e9 f5 12 f0       	push   $0xf012f5e9
f010cab7:	68 9b 04 00 00       	push   $0x49b
f010cabc:	68 bf f2 12 f0       	push   $0xf012f2bf
f010cac1:	e8 e9 43 ff ff       	call   f0100eaf <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010cac6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cac9:	8b 50 1c             	mov    0x1c(%eax),%edx
f010cacc:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cacf:	01 d0                	add    %edx,%eax
f010cad1:	89 45 e0             	mov    %eax,-0x20(%ebp)
	while (ph[(seg).segment_id].p_type != ELF_PROG_LOAD && ((seg).segment_id < pELFHDR->e_phnum)) (seg).segment_id++;
f010cad4:	eb 07                	jmp    f010cadd <PROGRAM_SEGMENT_FIRST+0x50>
f010cad6:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010cad9:	40                   	inc    %eax
f010cada:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010cadd:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010cae0:	c1 e0 05             	shl    $0x5,%eax
f010cae3:	89 c2                	mov    %eax,%edx
f010cae5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cae8:	01 d0                	add    %edx,%eax
f010caea:	8b 00                	mov    (%eax),%eax
f010caec:	83 f8 01             	cmp    $0x1,%eax
f010caef:	74 10                	je     f010cb01 <PROGRAM_SEGMENT_FIRST+0x74>
f010caf1:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010caf4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010caf7:	8b 40 2c             	mov    0x2c(%eax),%eax
f010cafa:	0f b7 c0             	movzwl %ax,%eax
f010cafd:	39 c2                	cmp    %eax,%edx
f010caff:	72 d5                	jb     f010cad6 <PROGRAM_SEGMENT_FIRST+0x49>
	int index = (seg).segment_id;
f010cb01:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010cb04:	89 45 dc             	mov    %eax,-0x24(%ebp)

	if(index < pELFHDR->e_phnum)
f010cb07:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cb0a:	8b 40 2c             	mov    0x2c(%eax),%eax
f010cb0d:	0f b7 c0             	movzwl %ax,%eax
f010cb10:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f010cb13:	7e 68                	jle    f010cb7d <PROGRAM_SEGMENT_FIRST+0xf0>
	{
		(seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010cb15:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cb18:	c1 e0 05             	shl    $0x5,%eax
f010cb1b:	89 c2                	mov    %eax,%edx
f010cb1d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cb20:	01 d0                	add    %edx,%eax
f010cb22:	8b 50 04             	mov    0x4(%eax),%edx
f010cb25:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cb28:	01 d0                	add    %edx,%eax
f010cb2a:	89 45 c8             	mov    %eax,-0x38(%ebp)
		(seg).size_in_memory =  ph[index].p_memsz;
f010cb2d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cb30:	c1 e0 05             	shl    $0x5,%eax
f010cb33:	89 c2                	mov    %eax,%edx
f010cb35:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cb38:	01 d0                	add    %edx,%eax
f010cb3a:	8b 40 14             	mov    0x14(%eax),%eax
f010cb3d:	89 45 d0             	mov    %eax,-0x30(%ebp)
		(seg).size_in_file = ph[index].p_filesz;
f010cb40:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cb43:	c1 e0 05             	shl    $0x5,%eax
f010cb46:	89 c2                	mov    %eax,%edx
f010cb48:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cb4b:	01 d0                	add    %edx,%eax
f010cb4d:	8b 40 10             	mov    0x10(%eax),%eax
f010cb50:	89 45 cc             	mov    %eax,-0x34(%ebp)
		(seg).virtual_address = (uint8*)ph[index].p_va;
f010cb53:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cb56:	c1 e0 05             	shl    $0x5,%eax
f010cb59:	89 c2                	mov    %eax,%edx
f010cb5b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cb5e:	01 d0                	add    %edx,%eax
f010cb60:	8b 40 08             	mov    0x8(%eax),%eax
f010cb63:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		return seg;
f010cb66:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb69:	89 c3                	mov    %eax,%ebx
f010cb6b:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010cb6e:	ba 05 00 00 00       	mov    $0x5,%edx
f010cb73:	89 df                	mov    %ebx,%edi
f010cb75:	89 c6                	mov    %eax,%esi
f010cb77:	89 d1                	mov    %edx,%ecx
f010cb79:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010cb7b:	eb 1c                	jmp    f010cb99 <PROGRAM_SEGMENT_FIRST+0x10c>
	}
	seg.segment_id = -1;
f010cb7d:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
	return seg;
f010cb84:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb87:	89 c3                	mov    %eax,%ebx
f010cb89:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010cb8c:	ba 05 00 00 00       	mov    $0x5,%edx
f010cb91:	89 df                	mov    %ebx,%edi
f010cb93:	89 c6                	mov    %eax,%esi
f010cb95:	89 d1                	mov    %edx,%ecx
f010cb97:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f010cb99:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb9c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010cb9f:	5b                   	pop    %ebx
f010cba0:	5e                   	pop    %esi
f010cba1:	5f                   	pop    %edi
f010cba2:	5d                   	pop    %ebp
f010cba3:	c2 04 00             	ret    $0x4

f010cba6 <cleanup_buffers>:

//===============================================================================
// 15) CLEANUP MODIFIED BUFFER [TO BE USED AS LAST STEP WHEN ADD ENV TO EXIT Q]:
//===============================================================================
void cleanup_buffers(struct Env* e)
{
f010cba6:	55                   	push   %ebp
f010cba7:	89 e5                	mov    %esp,%ebp
f010cba9:	83 ec 18             	sub    $0x18,%esp
	//NEW !! 2016, remove remaining pages in the modified list
	struct FrameInfo *ptr_fi=NULL ;
f010cbac:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	//	cprintf("[%s] deleting modified at end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	bool lock_already_held = holding_kspinlock(&MemFrameLists.mfllock);
f010cbb3:	83 ec 0c             	sub    $0xc,%esp
f010cbb6:	68 e0 e7 83 f0       	push   $0xf083e7e0
f010cbbb:	e8 10 34 00 00       	call   f010ffd0 <holding_kspinlock>
f010cbc0:	83 c4 10             	add    $0x10,%esp
f010cbc3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (!lock_already_held)
f010cbc6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010cbca:	75 10                	jne    f010cbdc <cleanup_buffers+0x36>
	{
		acquire_kspinlock(&MemFrameLists.mfllock);
f010cbcc:	83 ec 0c             	sub    $0xc,%esp
f010cbcf:	68 e0 e7 83 f0       	push   $0xf083e7e0
f010cbd4:	e8 a2 31 00 00       	call   f010fd7b <acquire_kspinlock>
f010cbd9:	83 c4 10             	add    $0x10,%esp
	}
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010cbdc:	a1 d0 e7 83 f0       	mov    0xf083e7d0,%eax
f010cbe1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010cbe4:	e9 a7 00 00 00       	jmp    f010cc90 <cleanup_buffers+0xea>
						{
			if(ptr_fi->proc == e)
f010cbe9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cbec:	8b 40 0c             	mov    0xc(%eax),%eax
f010cbef:	3b 45 08             	cmp    0x8(%ebp),%eax
f010cbf2:	0f 85 90 00 00 00    	jne    f010cc88 <cleanup_buffers+0xe2>
				/*MUST UN-COMMENT THIS LINE*/
				//pt_clear_page_table_entry(ptr_fi->proc->env_page_directory,ptr_fi->va);

				//cprintf("==================\n");
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x \n",curenv->prog_name, ptr_fi, LIST_NEXT(ptr_fi));
				LIST_REMOVE(&MemFrameLists.modified_frame_list, ptr_fi);
f010cbf8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010cbfc:	75 17                	jne    f010cc15 <cleanup_buffers+0x6f>
f010cbfe:	83 ec 04             	sub    $0x4,%esp
f010cc01:	68 47 f3 12 f0       	push   $0xf012f347
f010cc06:	68 c9 04 00 00       	push   $0x4c9
f010cc0b:	68 bf f2 12 f0       	push   $0xf012f2bf
f010cc10:	e8 9a 42 ff ff       	call   f0100eaf <_panic>
f010cc15:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cc18:	8b 00                	mov    (%eax),%eax
f010cc1a:	85 c0                	test   %eax,%eax
f010cc1c:	74 10                	je     f010cc2e <cleanup_buffers+0x88>
f010cc1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cc21:	8b 00                	mov    (%eax),%eax
f010cc23:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cc26:	8b 52 04             	mov    0x4(%edx),%edx
f010cc29:	89 50 04             	mov    %edx,0x4(%eax)
f010cc2c:	eb 0b                	jmp    f010cc39 <cleanup_buffers+0x93>
f010cc2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cc31:	8b 40 04             	mov    0x4(%eax),%eax
f010cc34:	a3 d4 e7 83 f0       	mov    %eax,0xf083e7d4
f010cc39:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cc3c:	8b 40 04             	mov    0x4(%eax),%eax
f010cc3f:	85 c0                	test   %eax,%eax
f010cc41:	74 0f                	je     f010cc52 <cleanup_buffers+0xac>
f010cc43:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cc46:	8b 40 04             	mov    0x4(%eax),%eax
f010cc49:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cc4c:	8b 12                	mov    (%edx),%edx
f010cc4e:	89 10                	mov    %edx,(%eax)
f010cc50:	eb 0a                	jmp    f010cc5c <cleanup_buffers+0xb6>
f010cc52:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cc55:	8b 00                	mov    (%eax),%eax
f010cc57:	a3 d0 e7 83 f0       	mov    %eax,0xf083e7d0
f010cc5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cc5f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010cc65:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cc68:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010cc6f:	a1 dc e7 83 f0       	mov    0xf083e7dc,%eax
f010cc74:	48                   	dec    %eax
f010cc75:	a3 dc e7 83 f0       	mov    %eax,0xf083e7dc

				free_frame(ptr_fi);
f010cc7a:	83 ec 0c             	sub    $0xc,%esp
f010cc7d:	ff 75 f4             	pushl  -0xc(%ebp)
f010cc80:	e8 e5 c4 ff ff       	call   f010916a <free_frame>
f010cc85:	83 c4 10             	add    $0x10,%esp
	if (!lock_already_held)
	{
		acquire_kspinlock(&MemFrameLists.mfllock);
	}
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010cc88:	a1 d8 e7 83 f0       	mov    0xf083e7d8,%eax
f010cc8d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010cc90:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010cc94:	74 07                	je     f010cc9d <cleanup_buffers+0xf7>
f010cc96:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cc99:	8b 00                	mov    (%eax),%eax
f010cc9b:	eb 05                	jmp    f010cca2 <cleanup_buffers+0xfc>
f010cc9d:	b8 00 00 00 00       	mov    $0x0,%eax
f010cca2:	a3 d8 e7 83 f0       	mov    %eax,0xf083e7d8
f010cca7:	a1 d8 e7 83 f0       	mov    0xf083e7d8,%eax
f010ccac:	85 c0                	test   %eax,%eax
f010ccae:	0f 85 35 ff ff ff    	jne    f010cbe9 <cleanup_buffers+0x43>
f010ccb4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ccb8:	0f 85 2b ff ff ff    	jne    f010cbe9 <cleanup_buffers+0x43>
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x, saved next = %x \n", curenv->prog_name ,ptr_fi, LIST_NEXT(ptr_fi), ___ptr_next);
				//cprintf("==================\n");
			}
						}
	}
	if (!lock_already_held)
f010ccbe:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010ccc2:	75 10                	jne    f010ccd4 <cleanup_buffers+0x12e>
	{
		release_kspinlock(&MemFrameLists.mfllock);
f010ccc4:	83 ec 0c             	sub    $0xc,%esp
f010ccc7:	68 e0 e7 83 f0       	push   $0xf083e7e0
f010cccc:	e8 4f 31 00 00       	call   f010fe20 <release_kspinlock>
f010ccd1:	83 c4 10             	add    $0x10,%esp
	}
	//	cprintf("[%s] finished deleting modified frames at the end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc2 = calculate_available_frames();
	//	cprintf("[%s] aft, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc2.modified, ffc2.freeBuffered, ffc2.freeNotBuffered);
}
f010ccd4:	90                   	nop
f010ccd5:	c9                   	leave  
f010ccd6:	c3                   	ret    

f010ccd7 <set_program_priority>:
#include "../mem/kheap.h"
#include "../mem/memory_manager.h"


void set_program_priority(struct Env* env, int priority)
{
f010ccd7:	55                   	push   %ebp
f010ccd8:	89 e5                	mov    %esp,%ebp
f010ccda:	83 ec 08             	sub    $0x8,%esp
	//[PROGRAM PRIORITY] set_program_priority
	//[ALREADY IMPLEMENTED]

	if(priority < 1 || priority > 5)
f010ccdd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010cce1:	7e 06                	jle    f010cce9 <set_program_priority+0x12>
f010cce3:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010cce7:	7e 14                	jle    f010ccfd <set_program_priority+0x26>
	{
		panic("Please enter valid priority (1->5)\n");
f010cce9:	83 ec 04             	sub    $0x4,%esp
f010ccec:	68 00 f6 12 f0       	push   $0xf012f600
f010ccf1:	6a 11                	push   $0x11
f010ccf3:	68 24 f6 12 f0       	push   $0xf012f624
f010ccf8:	e8 b2 41 ff ff       	call   f0100eaf <_panic>
		return;
	}
	if(env == NULL)
f010ccfd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010cd01:	74 78                	je     f010cd7b <set_program_priority+0xa4>
		return;
	switch(priority)
f010cd03:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010cd07:	77 56                	ja     f010cd5f <set_program_priority+0x88>
f010cd09:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cd0c:	c1 e0 02             	shl    $0x2,%eax
f010cd0f:	05 60 f6 12 f0       	add    $0xf012f660,%eax
f010cd14:	8b 00                	mov    (%eax),%eax
f010cd16:	ff e0                	jmp    *%eax
	{
		case PRIORITY_LOW:
			half_WS_Size(env, 1);
f010cd18:	83 ec 08             	sub    $0x8,%esp
f010cd1b:	6a 01                	push   $0x1
f010cd1d:	ff 75 08             	pushl  0x8(%ebp)
f010cd20:	e8 3d de ff ff       	call   f010ab62 <half_WS_Size>
f010cd25:	83 c4 10             	add    $0x10,%esp
			break;
f010cd28:	eb 35                	jmp    f010cd5f <set_program_priority+0x88>
		case PRIORITY_BELOWNORMAL:
			half_WS_Size(env, 0);
f010cd2a:	83 ec 08             	sub    $0x8,%esp
f010cd2d:	6a 00                	push   $0x0
f010cd2f:	ff 75 08             	pushl  0x8(%ebp)
f010cd32:	e8 2b de ff ff       	call   f010ab62 <half_WS_Size>
f010cd37:	83 c4 10             	add    $0x10,%esp
			break;
f010cd3a:	eb 23                	jmp    f010cd5f <set_program_priority+0x88>
		case PRIORITY_NORMAL:
			// Do Nothing
			break;
		case PRIORITY_ABOVENORMAL:
			double_WS_Size(env, 1);
f010cd3c:	83 ec 08             	sub    $0x8,%esp
f010cd3f:	6a 01                	push   $0x1
f010cd41:	ff 75 08             	pushl  0x8(%ebp)
f010cd44:	e8 fc dd ff ff       	call   f010ab45 <double_WS_Size>
f010cd49:	83 c4 10             	add    $0x10,%esp
			break;
f010cd4c:	eb 11                	jmp    f010cd5f <set_program_priority+0x88>
		case PRIORITY_HIGH:
			double_WS_Size(env, 0);
f010cd4e:	83 ec 08             	sub    $0x8,%esp
f010cd51:	6a 00                	push   $0x0
f010cd53:	ff 75 08             	pushl  0x8(%ebp)
f010cd56:	e8 ea dd ff ff       	call   f010ab45 <double_WS_Size>
f010cd5b:	83 c4 10             	add    $0x10,%esp
			break;
f010cd5e:	90                   	nop
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
f010cd5f:	8b 45 08             	mov    0x8(%ebp),%eax
f010cd62:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010cd68:	83 ec 08             	sub    $0x8,%esp
f010cd6b:	50                   	push   %eax
f010cd6c:	68 41 f6 12 f0       	push   $0xf012f641
f010cd71:	e8 e6 4d ff ff       	call   f0101b5c <cprintf>
f010cd76:	83 c4 10             	add    $0x10,%esp
f010cd79:	eb 01                	jmp    f010cd7c <set_program_priority+0xa5>
	{
		panic("Please enter valid priority (1->5)\n");
		return;
	}
	if(env == NULL)
		return;
f010cd7b:	90                   	nop
			double_WS_Size(env, 0);
			break;
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
}
f010cd7c:	c9                   	leave  
f010cd7d:	c3                   	ret    

f010cd7e <get_user_program_info>:

// Number of user programs in the program table
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
f010cd7e:	55                   	push   %ebp
f010cd7f:	89 e5                	mov    %esp,%ebp
f010cd81:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010cd84:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010cd8b:	eb 29                	jmp    f010cdb6 <get_user_program_info+0x38>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
f010cd8d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cd90:	89 d0                	mov    %edx,%eax
f010cd92:	01 c0                	add    %eax,%eax
f010cd94:	01 d0                	add    %edx,%eax
f010cd96:	c1 e0 02             	shl    $0x2,%eax
f010cd99:	05 e0 fb 17 f0       	add    $0xf017fbe0,%eax
f010cd9e:	8b 00                	mov    (%eax),%eax
f010cda0:	83 ec 08             	sub    $0x8,%esp
f010cda3:	50                   	push   %eax
f010cda4:	ff 75 08             	pushl  0x8(%ebp)
f010cda7:	e8 db dd 00 00       	call   f011ab87 <strcmp>
f010cdac:	83 c4 10             	add    $0x10,%esp
f010cdaf:	85 c0                	test   %eax,%eax
f010cdb1:	74 0f                	je     f010cdc2 <get_user_program_info+0x44>
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010cdb3:	ff 45 f4             	incl   -0xc(%ebp)
f010cdb6:	a1 a0 00 18 f0       	mov    0xf01800a0,%eax
f010cdbb:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010cdbe:	7c cd                	jl     f010cd8d <get_user_program_info+0xf>
f010cdc0:	eb 01                	jmp    f010cdc3 <get_user_program_info+0x45>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
			break;
f010cdc2:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010cdc3:	a1 a0 00 18 f0       	mov    0xf01800a0,%eax
f010cdc8:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010cdcb:	75 1a                	jne    f010cde7 <get_user_program_info+0x69>
	{
		cprintf("Unknown user program '%s'\n", user_program_name);
f010cdcd:	83 ec 08             	sub    $0x8,%esp
f010cdd0:	ff 75 08             	pushl  0x8(%ebp)
f010cdd3:	68 c4 07 13 f0       	push   $0xf01307c4
f010cdd8:	e8 7f 4d ff ff       	call   f0101b5c <cprintf>
f010cddd:	83 c4 10             	add    $0x10,%esp
		return 0;
f010cde0:	b8 00 00 00 00       	mov    $0x0,%eax
f010cde5:	eb 11                	jmp    f010cdf8 <get_user_program_info+0x7a>
	}

	return &userPrograms[i];
f010cde7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cdea:	89 d0                	mov    %edx,%eax
f010cdec:	01 c0                	add    %eax,%eax
f010cdee:	01 d0                	add    %edx,%eax
f010cdf0:	c1 e0 02             	shl    $0x2,%eax
f010cdf3:	05 e0 fb 17 f0       	add    $0xf017fbe0,%eax
}
f010cdf8:	c9                   	leave  
f010cdf9:	c3                   	ret    

f010cdfa <get_user_program_info_by_env>:

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
f010cdfa:	55                   	push   %ebp
f010cdfb:	89 e5                	mov    %esp,%ebp
f010cdfd:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010ce00:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010ce07:	eb 2d                	jmp    f010ce36 <get_user_program_info_by_env+0x3c>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
f010ce09:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ce0c:	89 d0                	mov    %edx,%eax
f010ce0e:	01 c0                	add    %eax,%eax
f010ce10:	01 d0                	add    %edx,%eax
f010ce12:	c1 e0 02             	shl    $0x2,%eax
f010ce15:	05 e0 fb 17 f0       	add    $0xf017fbe0,%eax
f010ce1a:	8b 00                	mov    (%eax),%eax
f010ce1c:	8b 55 08             	mov    0x8(%ebp),%edx
f010ce1f:	83 c2 20             	add    $0x20,%edx
f010ce22:	83 ec 08             	sub    $0x8,%esp
f010ce25:	50                   	push   %eax
f010ce26:	52                   	push   %edx
f010ce27:	e8 5b dd 00 00       	call   f011ab87 <strcmp>
f010ce2c:	83 c4 10             	add    $0x10,%esp
f010ce2f:	85 c0                	test   %eax,%eax
f010ce31:	74 0f                	je     f010ce42 <get_user_program_info_by_env+0x48>
}

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010ce33:	ff 45 f4             	incl   -0xc(%ebp)
f010ce36:	a1 a0 00 18 f0       	mov    0xf01800a0,%eax
f010ce3b:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010ce3e:	7c c9                	jl     f010ce09 <get_user_program_info_by_env+0xf>
f010ce40:	eb 01                	jmp    f010ce43 <get_user_program_info_by_env+0x49>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
			break;
f010ce42:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010ce43:	a1 a0 00 18 f0       	mov    0xf01800a0,%eax
f010ce48:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010ce4b:	75 17                	jne    f010ce64 <get_user_program_info_by_env+0x6a>
	{
		cprintf("Unknown user program \n");
f010ce4d:	83 ec 0c             	sub    $0xc,%esp
f010ce50:	68 df 07 13 f0       	push   $0xf01307df
f010ce55:	e8 02 4d ff ff       	call   f0101b5c <cprintf>
f010ce5a:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ce5d:	b8 00 00 00 00       	mov    $0x0,%eax
f010ce62:	eb 11                	jmp    f010ce75 <get_user_program_info_by_env+0x7b>
	}

	return &userPrograms[i];
f010ce64:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ce67:	89 d0                	mov    %edx,%eax
f010ce69:	01 c0                	add    %eax,%eax
f010ce6b:	01 d0                	add    %edx,%eax
f010ce6d:	c1 e0 02             	shl    $0x2,%eax
f010ce70:	05 e0 fb 17 f0       	add    $0xf017fbe0,%eax
}
f010ce75:	c9                   	leave  
f010ce76:	c3                   	ret    

f010ce77 <trapname>:
extern  void (*ALL_FAULTS47)();



static const char *trapname(int trapno)
{
f010ce77:	55                   	push   %ebp
f010ce78:	89 e5                	mov    %esp,%ebp
			"Alignment Check",
			"Machine-Check",
			"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
f010ce7a:	8b 45 08             	mov    0x8(%ebp),%eax
f010ce7d:	83 f8 13             	cmp    $0x13,%eax
f010ce80:	77 0c                	ja     f010ce8e <trapname+0x17>
		return excnames[trapno];
f010ce82:	8b 45 08             	mov    0x8(%ebp),%eax
f010ce85:	8b 04 85 60 0c 13 f0 	mov    -0xfecf3a0(,%eax,4),%eax
f010ce8c:	eb 2c                	jmp    f010ceba <trapname+0x43>
	if (trapno == T_SYSCALL)
f010ce8e:	83 7d 08 30          	cmpl   $0x30,0x8(%ebp)
f010ce92:	75 07                	jne    f010ce9b <trapname+0x24>
		return "System call";
f010ce94:	b8 00 08 13 f0       	mov    $0xf0130800,%eax
f010ce99:	eb 1f                	jmp    f010ceba <trapname+0x43>
	else if (trapno == IRQ0_Clock)
f010ce9b:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
f010ce9f:	75 07                	jne    f010cea8 <trapname+0x31>
		return "Clock Interrupt";
f010cea1:	b8 0c 08 13 f0       	mov    $0xf013080c,%eax
f010cea6:	eb 12                	jmp    f010ceba <trapname+0x43>
	else if (trapno == IRQ1_KB)
f010cea8:	83 7d 08 21          	cmpl   $0x21,0x8(%ebp)
f010ceac:	75 07                	jne    f010ceb5 <trapname+0x3e>
		return "Keyboard Interrupt";
f010ceae:	b8 1c 08 13 f0       	mov    $0xf013081c,%eax
f010ceb3:	eb 05                	jmp    f010ceba <trapname+0x43>
	return "(unknown trap)";
f010ceb5:	b8 2f 08 13 f0       	mov    $0xf013082f,%eax
}
f010ceba:	5d                   	pop    %ebp
f010cebb:	c3                   	ret    

f010cebc <ts_init>:


void ts_init(void)
{
f010cebc:	55                   	push   %ebp
f010cebd:	89 e5                	mov    %esp,%ebp
f010cebf:	53                   	push   %ebx
f010cec0:	83 ec 14             	sub    $0x14,%esp
	pushcli();	//disable interrupt - lock: to protect CPU info in multi-CPU
f010cec3:	e8 68 b1 ff ff       	call   f0108030 <pushcli>

	struct cpu* c = mycpu();
f010cec8:	e8 a3 b0 ff ff       	call   f0107f70 <mycpu>
f010cecd:	89 45 f4             	mov    %eax,-0xc(%ebp)

	// Setup a TSS so that we get the right user kernel stack
	// when we trap to the kernel.
	// 2024: for now, temporarily set it to 0
	// since the scheduler will run first then switch to the first process
	c->ts.ts_esp0 = 0;
f010ced0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ced3:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010ceda:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cedd:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010cee3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cee6:	83 c0 0c             	add    $0xc,%eax
f010cee9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ceec:	83 c2 0c             	add    $0xc,%edx
f010ceef:	c1 ea 10             	shr    $0x10,%edx
f010cef2:	88 d3                	mov    %dl,%bl
f010cef4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cef7:	83 c2 0c             	add    $0xc,%edx
f010cefa:	c1 ea 18             	shr    $0x18,%edx
f010cefd:	88 d1                	mov    %dl,%cl
f010ceff:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cf02:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010cf09:	68 00 
f010cf0b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cf0e:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010cf15:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf18:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010cf1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf21:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010cf27:	83 e2 f0             	and    $0xfffffff0,%edx
f010cf2a:	83 ca 09             	or     $0x9,%edx
f010cf2d:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010cf33:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf36:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010cf3c:	83 ca 10             	or     $0x10,%edx
f010cf3f:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010cf45:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf48:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010cf4e:	83 e2 9f             	and    $0xffffff9f,%edx
f010cf51:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010cf57:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf5a:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010cf60:	83 ca 80             	or     $0xffffff80,%edx
f010cf63:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010cf69:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf6c:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010cf72:	83 e2 f0             	and    $0xfffffff0,%edx
f010cf75:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010cf7b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf7e:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010cf84:	83 e2 ef             	and    $0xffffffef,%edx
f010cf87:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010cf8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cf90:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010cf96:	83 e2 df             	and    $0xffffffdf,%edx
f010cf99:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010cf9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cfa2:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010cfa8:	83 ca 40             	or     $0x40,%edx
f010cfab:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010cfb1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cfb4:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010cfba:	83 e2 7f             	and    $0x7f,%edx
f010cfbd:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010cfc3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cfc6:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010cfcc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cfcf:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010cfd5:	83 e2 ef             	and    $0xffffffef,%edx
f010cfd8:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	popcli();	//enable interrupt - lock: to protect CPU info in multi-CPU
f010cfde:	e8 9f b0 ff ff       	call   f0108082 <popcli>
f010cfe3:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010cfe9:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010cfed:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);
}
f010cff0:	90                   	nop
f010cff1:	83 c4 14             	add    $0x14,%esp
f010cff4:	5b                   	pop    %ebx
f010cff5:	5d                   	pop    %ebp
f010cff6:	c3                   	ret    

f010cff7 <idt_init>:
/// shifted function addresses can't be represented in relocation records.)
///
struct Gatedesc idt[256] = { { 0 } };

void idt_init(void)
{
f010cff7:	55                   	push   %ebp
f010cff8:	89 e5                	mov    %esp,%ebp
f010cffa:	83 ec 10             	sub    $0x10,%esp
	//initialize idt
	SETGATE(idt[T_DBLFLT  ], 0, GD_KT , &DBL_FAULT, 0) ;		//8
f010cffd:	b8 62 e5 10 f0       	mov    $0xf010e562,%eax
f010d002:	66 a3 00 5c 81 f0    	mov    %ax,0xf0815c00
f010d008:	66 c7 05 02 5c 81 f0 	movw   $0x8,0xf0815c02
f010d00f:	08 00 
f010d011:	a0 04 5c 81 f0       	mov    0xf0815c04,%al
f010d016:	83 e0 e0             	and    $0xffffffe0,%eax
f010d019:	a2 04 5c 81 f0       	mov    %al,0xf0815c04
f010d01e:	a0 04 5c 81 f0       	mov    0xf0815c04,%al
f010d023:	83 e0 1f             	and    $0x1f,%eax
f010d026:	a2 04 5c 81 f0       	mov    %al,0xf0815c04
f010d02b:	a0 05 5c 81 f0       	mov    0xf0815c05,%al
f010d030:	83 e0 f0             	and    $0xfffffff0,%eax
f010d033:	83 c8 0e             	or     $0xe,%eax
f010d036:	a2 05 5c 81 f0       	mov    %al,0xf0815c05
f010d03b:	a0 05 5c 81 f0       	mov    0xf0815c05,%al
f010d040:	83 e0 ef             	and    $0xffffffef,%eax
f010d043:	a2 05 5c 81 f0       	mov    %al,0xf0815c05
f010d048:	a0 05 5c 81 f0       	mov    0xf0815c05,%al
f010d04d:	83 e0 9f             	and    $0xffffff9f,%eax
f010d050:	a2 05 5c 81 f0       	mov    %al,0xf0815c05
f010d055:	a0 05 5c 81 f0       	mov    0xf0815c05,%al
f010d05a:	83 c8 80             	or     $0xffffff80,%eax
f010d05d:	a2 05 5c 81 f0       	mov    %al,0xf0815c05
f010d062:	b8 62 e5 10 f0       	mov    $0xf010e562,%eax
f010d067:	c1 e8 10             	shr    $0x10,%eax
f010d06a:	66 a3 06 5c 81 f0    	mov    %ax,0xf0815c06
	SETGATE(idt[T_PGFLT   ], 0, GD_KT , &PAGE_FAULT, 0) ;		//14
f010d070:	b8 6a e5 10 f0       	mov    $0xf010e56a,%eax
f010d075:	66 a3 30 5c 81 f0    	mov    %ax,0xf0815c30
f010d07b:	66 c7 05 32 5c 81 f0 	movw   $0x8,0xf0815c32
f010d082:	08 00 
f010d084:	a0 34 5c 81 f0       	mov    0xf0815c34,%al
f010d089:	83 e0 e0             	and    $0xffffffe0,%eax
f010d08c:	a2 34 5c 81 f0       	mov    %al,0xf0815c34
f010d091:	a0 34 5c 81 f0       	mov    0xf0815c34,%al
f010d096:	83 e0 1f             	and    $0x1f,%eax
f010d099:	a2 34 5c 81 f0       	mov    %al,0xf0815c34
f010d09e:	a0 35 5c 81 f0       	mov    0xf0815c35,%al
f010d0a3:	83 e0 f0             	and    $0xfffffff0,%eax
f010d0a6:	83 c8 0e             	or     $0xe,%eax
f010d0a9:	a2 35 5c 81 f0       	mov    %al,0xf0815c35
f010d0ae:	a0 35 5c 81 f0       	mov    0xf0815c35,%al
f010d0b3:	83 e0 ef             	and    $0xffffffef,%eax
f010d0b6:	a2 35 5c 81 f0       	mov    %al,0xf0815c35
f010d0bb:	a0 35 5c 81 f0       	mov    0xf0815c35,%al
f010d0c0:	83 e0 9f             	and    $0xffffff9f,%eax
f010d0c3:	a2 35 5c 81 f0       	mov    %al,0xf0815c35
f010d0c8:	a0 35 5c 81 f0       	mov    0xf0815c35,%al
f010d0cd:	83 c8 80             	or     $0xffffff80,%eax
f010d0d0:	a2 35 5c 81 f0       	mov    %al,0xf0815c35
f010d0d5:	b8 6a e5 10 f0       	mov    $0xf010e56a,%eax
f010d0da:	c1 e8 10             	shr    $0x10,%eax
f010d0dd:	66 a3 36 5c 81 f0    	mov    %ax,0xf0815c36
	SETGATE(idt[IRQ0_Clock], 0, GD_KT , &IRQ0_CLK_HANDLER, 3) ;	//32
f010d0e3:	b8 72 e5 10 f0       	mov    $0xf010e572,%eax
f010d0e8:	66 a3 c0 5c 81 f0    	mov    %ax,0xf0815cc0
f010d0ee:	66 c7 05 c2 5c 81 f0 	movw   $0x8,0xf0815cc2
f010d0f5:	08 00 
f010d0f7:	a0 c4 5c 81 f0       	mov    0xf0815cc4,%al
f010d0fc:	83 e0 e0             	and    $0xffffffe0,%eax
f010d0ff:	a2 c4 5c 81 f0       	mov    %al,0xf0815cc4
f010d104:	a0 c4 5c 81 f0       	mov    0xf0815cc4,%al
f010d109:	83 e0 1f             	and    $0x1f,%eax
f010d10c:	a2 c4 5c 81 f0       	mov    %al,0xf0815cc4
f010d111:	a0 c5 5c 81 f0       	mov    0xf0815cc5,%al
f010d116:	83 e0 f0             	and    $0xfffffff0,%eax
f010d119:	83 c8 0e             	or     $0xe,%eax
f010d11c:	a2 c5 5c 81 f0       	mov    %al,0xf0815cc5
f010d121:	a0 c5 5c 81 f0       	mov    0xf0815cc5,%al
f010d126:	83 e0 ef             	and    $0xffffffef,%eax
f010d129:	a2 c5 5c 81 f0       	mov    %al,0xf0815cc5
f010d12e:	a0 c5 5c 81 f0       	mov    0xf0815cc5,%al
f010d133:	83 c8 60             	or     $0x60,%eax
f010d136:	a2 c5 5c 81 f0       	mov    %al,0xf0815cc5
f010d13b:	a0 c5 5c 81 f0       	mov    0xf0815cc5,%al
f010d140:	83 c8 80             	or     $0xffffff80,%eax
f010d143:	a2 c5 5c 81 f0       	mov    %al,0xf0815cc5
f010d148:	b8 72 e5 10 f0       	mov    $0xf010e572,%eax
f010d14d:	c1 e8 10             	shr    $0x10,%eax
f010d150:	66 a3 c6 5c 81 f0    	mov    %ax,0xf0815cc6
	SETGATE(idt[IRQ1_KB	  ], 0, GD_KT , &IRQ1_KBD_HANDLER, 3) ;	//33
f010d156:	b8 7c e5 10 f0       	mov    $0xf010e57c,%eax
f010d15b:	66 a3 c8 5c 81 f0    	mov    %ax,0xf0815cc8
f010d161:	66 c7 05 ca 5c 81 f0 	movw   $0x8,0xf0815cca
f010d168:	08 00 
f010d16a:	a0 cc 5c 81 f0       	mov    0xf0815ccc,%al
f010d16f:	83 e0 e0             	and    $0xffffffe0,%eax
f010d172:	a2 cc 5c 81 f0       	mov    %al,0xf0815ccc
f010d177:	a0 cc 5c 81 f0       	mov    0xf0815ccc,%al
f010d17c:	83 e0 1f             	and    $0x1f,%eax
f010d17f:	a2 cc 5c 81 f0       	mov    %al,0xf0815ccc
f010d184:	a0 cd 5c 81 f0       	mov    0xf0815ccd,%al
f010d189:	83 e0 f0             	and    $0xfffffff0,%eax
f010d18c:	83 c8 0e             	or     $0xe,%eax
f010d18f:	a2 cd 5c 81 f0       	mov    %al,0xf0815ccd
f010d194:	a0 cd 5c 81 f0       	mov    0xf0815ccd,%al
f010d199:	83 e0 ef             	and    $0xffffffef,%eax
f010d19c:	a2 cd 5c 81 f0       	mov    %al,0xf0815ccd
f010d1a1:	a0 cd 5c 81 f0       	mov    0xf0815ccd,%al
f010d1a6:	83 c8 60             	or     $0x60,%eax
f010d1a9:	a2 cd 5c 81 f0       	mov    %al,0xf0815ccd
f010d1ae:	a0 cd 5c 81 f0       	mov    0xf0815ccd,%al
f010d1b3:	83 c8 80             	or     $0xffffff80,%eax
f010d1b6:	a2 cd 5c 81 f0       	mov    %al,0xf0815ccd
f010d1bb:	b8 7c e5 10 f0       	mov    $0xf010e57c,%eax
f010d1c0:	c1 e8 10             	shr    $0x10,%eax
f010d1c3:	66 a3 ce 5c 81 f0    	mov    %ax,0xf0815cce
	SETGATE(idt[T_SYSCALL ], 0, GD_KT , &SYSCALL_HANDLER, 3) ;	//48
f010d1c9:	b8 86 e5 10 f0       	mov    $0xf010e586,%eax
f010d1ce:	66 a3 40 5d 81 f0    	mov    %ax,0xf0815d40
f010d1d4:	66 c7 05 42 5d 81 f0 	movw   $0x8,0xf0815d42
f010d1db:	08 00 
f010d1dd:	a0 44 5d 81 f0       	mov    0xf0815d44,%al
f010d1e2:	83 e0 e0             	and    $0xffffffe0,%eax
f010d1e5:	a2 44 5d 81 f0       	mov    %al,0xf0815d44
f010d1ea:	a0 44 5d 81 f0       	mov    0xf0815d44,%al
f010d1ef:	83 e0 1f             	and    $0x1f,%eax
f010d1f2:	a2 44 5d 81 f0       	mov    %al,0xf0815d44
f010d1f7:	a0 45 5d 81 f0       	mov    0xf0815d45,%al
f010d1fc:	83 e0 f0             	and    $0xfffffff0,%eax
f010d1ff:	83 c8 0e             	or     $0xe,%eax
f010d202:	a2 45 5d 81 f0       	mov    %al,0xf0815d45
f010d207:	a0 45 5d 81 f0       	mov    0xf0815d45,%al
f010d20c:	83 e0 ef             	and    $0xffffffef,%eax
f010d20f:	a2 45 5d 81 f0       	mov    %al,0xf0815d45
f010d214:	a0 45 5d 81 f0       	mov    0xf0815d45,%al
f010d219:	83 c8 60             	or     $0x60,%eax
f010d21c:	a2 45 5d 81 f0       	mov    %al,0xf0815d45
f010d221:	a0 45 5d 81 f0       	mov    0xf0815d45,%al
f010d226:	83 c8 80             	or     $0xffffff80,%eax
f010d229:	a2 45 5d 81 f0       	mov    %al,0xf0815d45
f010d22e:	b8 86 e5 10 f0       	mov    $0xf010e586,%eax
f010d233:	c1 e8 10             	shr    $0x10,%eax
f010d236:	66 a3 46 5d 81 f0    	mov    %ax,0xf0815d46

	//S/W Exceptions
	SETGATE(idt[T_DIVIDE   ], 0, GD_KT , &ALL_FAULTS0, 3) ;
f010d23c:	b8 90 e5 10 f0       	mov    $0xf010e590,%eax
f010d241:	66 a3 c0 5b 81 f0    	mov    %ax,0xf0815bc0
f010d247:	66 c7 05 c2 5b 81 f0 	movw   $0x8,0xf0815bc2
f010d24e:	08 00 
f010d250:	a0 c4 5b 81 f0       	mov    0xf0815bc4,%al
f010d255:	83 e0 e0             	and    $0xffffffe0,%eax
f010d258:	a2 c4 5b 81 f0       	mov    %al,0xf0815bc4
f010d25d:	a0 c4 5b 81 f0       	mov    0xf0815bc4,%al
f010d262:	83 e0 1f             	and    $0x1f,%eax
f010d265:	a2 c4 5b 81 f0       	mov    %al,0xf0815bc4
f010d26a:	a0 c5 5b 81 f0       	mov    0xf0815bc5,%al
f010d26f:	83 e0 f0             	and    $0xfffffff0,%eax
f010d272:	83 c8 0e             	or     $0xe,%eax
f010d275:	a2 c5 5b 81 f0       	mov    %al,0xf0815bc5
f010d27a:	a0 c5 5b 81 f0       	mov    0xf0815bc5,%al
f010d27f:	83 e0 ef             	and    $0xffffffef,%eax
f010d282:	a2 c5 5b 81 f0       	mov    %al,0xf0815bc5
f010d287:	a0 c5 5b 81 f0       	mov    0xf0815bc5,%al
f010d28c:	83 c8 60             	or     $0x60,%eax
f010d28f:	a2 c5 5b 81 f0       	mov    %al,0xf0815bc5
f010d294:	a0 c5 5b 81 f0       	mov    0xf0815bc5,%al
f010d299:	83 c8 80             	or     $0xffffff80,%eax
f010d29c:	a2 c5 5b 81 f0       	mov    %al,0xf0815bc5
f010d2a1:	b8 90 e5 10 f0       	mov    $0xf010e590,%eax
f010d2a6:	c1 e8 10             	shr    $0x10,%eax
f010d2a9:	66 a3 c6 5b 81 f0    	mov    %ax,0xf0815bc6
	SETGATE(idt[T_DEBUG    ], 1, GD_KT , &ALL_FAULTS1, 3) ;
f010d2af:	b8 9a e5 10 f0       	mov    $0xf010e59a,%eax
f010d2b4:	66 a3 c8 5b 81 f0    	mov    %ax,0xf0815bc8
f010d2ba:	66 c7 05 ca 5b 81 f0 	movw   $0x8,0xf0815bca
f010d2c1:	08 00 
f010d2c3:	a0 cc 5b 81 f0       	mov    0xf0815bcc,%al
f010d2c8:	83 e0 e0             	and    $0xffffffe0,%eax
f010d2cb:	a2 cc 5b 81 f0       	mov    %al,0xf0815bcc
f010d2d0:	a0 cc 5b 81 f0       	mov    0xf0815bcc,%al
f010d2d5:	83 e0 1f             	and    $0x1f,%eax
f010d2d8:	a2 cc 5b 81 f0       	mov    %al,0xf0815bcc
f010d2dd:	a0 cd 5b 81 f0       	mov    0xf0815bcd,%al
f010d2e2:	83 c8 0f             	or     $0xf,%eax
f010d2e5:	a2 cd 5b 81 f0       	mov    %al,0xf0815bcd
f010d2ea:	a0 cd 5b 81 f0       	mov    0xf0815bcd,%al
f010d2ef:	83 e0 ef             	and    $0xffffffef,%eax
f010d2f2:	a2 cd 5b 81 f0       	mov    %al,0xf0815bcd
f010d2f7:	a0 cd 5b 81 f0       	mov    0xf0815bcd,%al
f010d2fc:	83 c8 60             	or     $0x60,%eax
f010d2ff:	a2 cd 5b 81 f0       	mov    %al,0xf0815bcd
f010d304:	a0 cd 5b 81 f0       	mov    0xf0815bcd,%al
f010d309:	83 c8 80             	or     $0xffffff80,%eax
f010d30c:	a2 cd 5b 81 f0       	mov    %al,0xf0815bcd
f010d311:	b8 9a e5 10 f0       	mov    $0xf010e59a,%eax
f010d316:	c1 e8 10             	shr    $0x10,%eax
f010d319:	66 a3 ce 5b 81 f0    	mov    %ax,0xf0815bce
	SETGATE(idt[T_NMI      ], 0, GD_KT , &ALL_FAULTS2, 3) ;
f010d31f:	b8 a4 e5 10 f0       	mov    $0xf010e5a4,%eax
f010d324:	66 a3 d0 5b 81 f0    	mov    %ax,0xf0815bd0
f010d32a:	66 c7 05 d2 5b 81 f0 	movw   $0x8,0xf0815bd2
f010d331:	08 00 
f010d333:	a0 d4 5b 81 f0       	mov    0xf0815bd4,%al
f010d338:	83 e0 e0             	and    $0xffffffe0,%eax
f010d33b:	a2 d4 5b 81 f0       	mov    %al,0xf0815bd4
f010d340:	a0 d4 5b 81 f0       	mov    0xf0815bd4,%al
f010d345:	83 e0 1f             	and    $0x1f,%eax
f010d348:	a2 d4 5b 81 f0       	mov    %al,0xf0815bd4
f010d34d:	a0 d5 5b 81 f0       	mov    0xf0815bd5,%al
f010d352:	83 e0 f0             	and    $0xfffffff0,%eax
f010d355:	83 c8 0e             	or     $0xe,%eax
f010d358:	a2 d5 5b 81 f0       	mov    %al,0xf0815bd5
f010d35d:	a0 d5 5b 81 f0       	mov    0xf0815bd5,%al
f010d362:	83 e0 ef             	and    $0xffffffef,%eax
f010d365:	a2 d5 5b 81 f0       	mov    %al,0xf0815bd5
f010d36a:	a0 d5 5b 81 f0       	mov    0xf0815bd5,%al
f010d36f:	83 c8 60             	or     $0x60,%eax
f010d372:	a2 d5 5b 81 f0       	mov    %al,0xf0815bd5
f010d377:	a0 d5 5b 81 f0       	mov    0xf0815bd5,%al
f010d37c:	83 c8 80             	or     $0xffffff80,%eax
f010d37f:	a2 d5 5b 81 f0       	mov    %al,0xf0815bd5
f010d384:	b8 a4 e5 10 f0       	mov    $0xf010e5a4,%eax
f010d389:	c1 e8 10             	shr    $0x10,%eax
f010d38c:	66 a3 d6 5b 81 f0    	mov    %ax,0xf0815bd6
	SETGATE(idt[T_BRKPT    ], 1, GD_KT , &ALL_FAULTS3, 3) ;
f010d392:	b8 ae e5 10 f0       	mov    $0xf010e5ae,%eax
f010d397:	66 a3 d8 5b 81 f0    	mov    %ax,0xf0815bd8
f010d39d:	66 c7 05 da 5b 81 f0 	movw   $0x8,0xf0815bda
f010d3a4:	08 00 
f010d3a6:	a0 dc 5b 81 f0       	mov    0xf0815bdc,%al
f010d3ab:	83 e0 e0             	and    $0xffffffe0,%eax
f010d3ae:	a2 dc 5b 81 f0       	mov    %al,0xf0815bdc
f010d3b3:	a0 dc 5b 81 f0       	mov    0xf0815bdc,%al
f010d3b8:	83 e0 1f             	and    $0x1f,%eax
f010d3bb:	a2 dc 5b 81 f0       	mov    %al,0xf0815bdc
f010d3c0:	a0 dd 5b 81 f0       	mov    0xf0815bdd,%al
f010d3c5:	83 c8 0f             	or     $0xf,%eax
f010d3c8:	a2 dd 5b 81 f0       	mov    %al,0xf0815bdd
f010d3cd:	a0 dd 5b 81 f0       	mov    0xf0815bdd,%al
f010d3d2:	83 e0 ef             	and    $0xffffffef,%eax
f010d3d5:	a2 dd 5b 81 f0       	mov    %al,0xf0815bdd
f010d3da:	a0 dd 5b 81 f0       	mov    0xf0815bdd,%al
f010d3df:	83 c8 60             	or     $0x60,%eax
f010d3e2:	a2 dd 5b 81 f0       	mov    %al,0xf0815bdd
f010d3e7:	a0 dd 5b 81 f0       	mov    0xf0815bdd,%al
f010d3ec:	83 c8 80             	or     $0xffffff80,%eax
f010d3ef:	a2 dd 5b 81 f0       	mov    %al,0xf0815bdd
f010d3f4:	b8 ae e5 10 f0       	mov    $0xf010e5ae,%eax
f010d3f9:	c1 e8 10             	shr    $0x10,%eax
f010d3fc:	66 a3 de 5b 81 f0    	mov    %ax,0xf0815bde
	SETGATE(idt[T_OFLOW    ], 1, GD_KT , &ALL_FAULTS4, 3) ;
f010d402:	b8 b8 e5 10 f0       	mov    $0xf010e5b8,%eax
f010d407:	66 a3 e0 5b 81 f0    	mov    %ax,0xf0815be0
f010d40d:	66 c7 05 e2 5b 81 f0 	movw   $0x8,0xf0815be2
f010d414:	08 00 
f010d416:	a0 e4 5b 81 f0       	mov    0xf0815be4,%al
f010d41b:	83 e0 e0             	and    $0xffffffe0,%eax
f010d41e:	a2 e4 5b 81 f0       	mov    %al,0xf0815be4
f010d423:	a0 e4 5b 81 f0       	mov    0xf0815be4,%al
f010d428:	83 e0 1f             	and    $0x1f,%eax
f010d42b:	a2 e4 5b 81 f0       	mov    %al,0xf0815be4
f010d430:	a0 e5 5b 81 f0       	mov    0xf0815be5,%al
f010d435:	83 c8 0f             	or     $0xf,%eax
f010d438:	a2 e5 5b 81 f0       	mov    %al,0xf0815be5
f010d43d:	a0 e5 5b 81 f0       	mov    0xf0815be5,%al
f010d442:	83 e0 ef             	and    $0xffffffef,%eax
f010d445:	a2 e5 5b 81 f0       	mov    %al,0xf0815be5
f010d44a:	a0 e5 5b 81 f0       	mov    0xf0815be5,%al
f010d44f:	83 c8 60             	or     $0x60,%eax
f010d452:	a2 e5 5b 81 f0       	mov    %al,0xf0815be5
f010d457:	a0 e5 5b 81 f0       	mov    0xf0815be5,%al
f010d45c:	83 c8 80             	or     $0xffffff80,%eax
f010d45f:	a2 e5 5b 81 f0       	mov    %al,0xf0815be5
f010d464:	b8 b8 e5 10 f0       	mov    $0xf010e5b8,%eax
f010d469:	c1 e8 10             	shr    $0x10,%eax
f010d46c:	66 a3 e6 5b 81 f0    	mov    %ax,0xf0815be6
	SETGATE(idt[T_BOUND    ], 0, GD_KT , &ALL_FAULTS5, 3) ;
f010d472:	b8 c2 e5 10 f0       	mov    $0xf010e5c2,%eax
f010d477:	66 a3 e8 5b 81 f0    	mov    %ax,0xf0815be8
f010d47d:	66 c7 05 ea 5b 81 f0 	movw   $0x8,0xf0815bea
f010d484:	08 00 
f010d486:	a0 ec 5b 81 f0       	mov    0xf0815bec,%al
f010d48b:	83 e0 e0             	and    $0xffffffe0,%eax
f010d48e:	a2 ec 5b 81 f0       	mov    %al,0xf0815bec
f010d493:	a0 ec 5b 81 f0       	mov    0xf0815bec,%al
f010d498:	83 e0 1f             	and    $0x1f,%eax
f010d49b:	a2 ec 5b 81 f0       	mov    %al,0xf0815bec
f010d4a0:	a0 ed 5b 81 f0       	mov    0xf0815bed,%al
f010d4a5:	83 e0 f0             	and    $0xfffffff0,%eax
f010d4a8:	83 c8 0e             	or     $0xe,%eax
f010d4ab:	a2 ed 5b 81 f0       	mov    %al,0xf0815bed
f010d4b0:	a0 ed 5b 81 f0       	mov    0xf0815bed,%al
f010d4b5:	83 e0 ef             	and    $0xffffffef,%eax
f010d4b8:	a2 ed 5b 81 f0       	mov    %al,0xf0815bed
f010d4bd:	a0 ed 5b 81 f0       	mov    0xf0815bed,%al
f010d4c2:	83 c8 60             	or     $0x60,%eax
f010d4c5:	a2 ed 5b 81 f0       	mov    %al,0xf0815bed
f010d4ca:	a0 ed 5b 81 f0       	mov    0xf0815bed,%al
f010d4cf:	83 c8 80             	or     $0xffffff80,%eax
f010d4d2:	a2 ed 5b 81 f0       	mov    %al,0xf0815bed
f010d4d7:	b8 c2 e5 10 f0       	mov    $0xf010e5c2,%eax
f010d4dc:	c1 e8 10             	shr    $0x10,%eax
f010d4df:	66 a3 ee 5b 81 f0    	mov    %ax,0xf0815bee
	SETGATE(idt[T_ILLOP    ], 0, GD_KT , &ALL_FAULTS6, 3) ;
f010d4e5:	b8 cc e5 10 f0       	mov    $0xf010e5cc,%eax
f010d4ea:	66 a3 f0 5b 81 f0    	mov    %ax,0xf0815bf0
f010d4f0:	66 c7 05 f2 5b 81 f0 	movw   $0x8,0xf0815bf2
f010d4f7:	08 00 
f010d4f9:	a0 f4 5b 81 f0       	mov    0xf0815bf4,%al
f010d4fe:	83 e0 e0             	and    $0xffffffe0,%eax
f010d501:	a2 f4 5b 81 f0       	mov    %al,0xf0815bf4
f010d506:	a0 f4 5b 81 f0       	mov    0xf0815bf4,%al
f010d50b:	83 e0 1f             	and    $0x1f,%eax
f010d50e:	a2 f4 5b 81 f0       	mov    %al,0xf0815bf4
f010d513:	a0 f5 5b 81 f0       	mov    0xf0815bf5,%al
f010d518:	83 e0 f0             	and    $0xfffffff0,%eax
f010d51b:	83 c8 0e             	or     $0xe,%eax
f010d51e:	a2 f5 5b 81 f0       	mov    %al,0xf0815bf5
f010d523:	a0 f5 5b 81 f0       	mov    0xf0815bf5,%al
f010d528:	83 e0 ef             	and    $0xffffffef,%eax
f010d52b:	a2 f5 5b 81 f0       	mov    %al,0xf0815bf5
f010d530:	a0 f5 5b 81 f0       	mov    0xf0815bf5,%al
f010d535:	83 c8 60             	or     $0x60,%eax
f010d538:	a2 f5 5b 81 f0       	mov    %al,0xf0815bf5
f010d53d:	a0 f5 5b 81 f0       	mov    0xf0815bf5,%al
f010d542:	83 c8 80             	or     $0xffffff80,%eax
f010d545:	a2 f5 5b 81 f0       	mov    %al,0xf0815bf5
f010d54a:	b8 cc e5 10 f0       	mov    $0xf010e5cc,%eax
f010d54f:	c1 e8 10             	shr    $0x10,%eax
f010d552:	66 a3 f6 5b 81 f0    	mov    %ax,0xf0815bf6
	SETGATE(idt[T_DEVICE   ], 0, GD_KT , &ALL_FAULTS7, 3) ;
f010d558:	b8 d6 e5 10 f0       	mov    $0xf010e5d6,%eax
f010d55d:	66 a3 f8 5b 81 f0    	mov    %ax,0xf0815bf8
f010d563:	66 c7 05 fa 5b 81 f0 	movw   $0x8,0xf0815bfa
f010d56a:	08 00 
f010d56c:	a0 fc 5b 81 f0       	mov    0xf0815bfc,%al
f010d571:	83 e0 e0             	and    $0xffffffe0,%eax
f010d574:	a2 fc 5b 81 f0       	mov    %al,0xf0815bfc
f010d579:	a0 fc 5b 81 f0       	mov    0xf0815bfc,%al
f010d57e:	83 e0 1f             	and    $0x1f,%eax
f010d581:	a2 fc 5b 81 f0       	mov    %al,0xf0815bfc
f010d586:	a0 fd 5b 81 f0       	mov    0xf0815bfd,%al
f010d58b:	83 e0 f0             	and    $0xfffffff0,%eax
f010d58e:	83 c8 0e             	or     $0xe,%eax
f010d591:	a2 fd 5b 81 f0       	mov    %al,0xf0815bfd
f010d596:	a0 fd 5b 81 f0       	mov    0xf0815bfd,%al
f010d59b:	83 e0 ef             	and    $0xffffffef,%eax
f010d59e:	a2 fd 5b 81 f0       	mov    %al,0xf0815bfd
f010d5a3:	a0 fd 5b 81 f0       	mov    0xf0815bfd,%al
f010d5a8:	83 c8 60             	or     $0x60,%eax
f010d5ab:	a2 fd 5b 81 f0       	mov    %al,0xf0815bfd
f010d5b0:	a0 fd 5b 81 f0       	mov    0xf0815bfd,%al
f010d5b5:	83 c8 80             	or     $0xffffff80,%eax
f010d5b8:	a2 fd 5b 81 f0       	mov    %al,0xf0815bfd
f010d5bd:	b8 d6 e5 10 f0       	mov    $0xf010e5d6,%eax
f010d5c2:	c1 e8 10             	shr    $0x10,%eax
f010d5c5:	66 a3 fe 5b 81 f0    	mov    %ax,0xf0815bfe
	//SETGATE(idt[T_DBLFLT ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_TSS      ], 0, GD_KT , &ALL_FAULTS10, 3) ;
f010d5cb:	b8 dc e5 10 f0       	mov    $0xf010e5dc,%eax
f010d5d0:	66 a3 10 5c 81 f0    	mov    %ax,0xf0815c10
f010d5d6:	66 c7 05 12 5c 81 f0 	movw   $0x8,0xf0815c12
f010d5dd:	08 00 
f010d5df:	a0 14 5c 81 f0       	mov    0xf0815c14,%al
f010d5e4:	83 e0 e0             	and    $0xffffffe0,%eax
f010d5e7:	a2 14 5c 81 f0       	mov    %al,0xf0815c14
f010d5ec:	a0 14 5c 81 f0       	mov    0xf0815c14,%al
f010d5f1:	83 e0 1f             	and    $0x1f,%eax
f010d5f4:	a2 14 5c 81 f0       	mov    %al,0xf0815c14
f010d5f9:	a0 15 5c 81 f0       	mov    0xf0815c15,%al
f010d5fe:	83 e0 f0             	and    $0xfffffff0,%eax
f010d601:	83 c8 0e             	or     $0xe,%eax
f010d604:	a2 15 5c 81 f0       	mov    %al,0xf0815c15
f010d609:	a0 15 5c 81 f0       	mov    0xf0815c15,%al
f010d60e:	83 e0 ef             	and    $0xffffffef,%eax
f010d611:	a2 15 5c 81 f0       	mov    %al,0xf0815c15
f010d616:	a0 15 5c 81 f0       	mov    0xf0815c15,%al
f010d61b:	83 c8 60             	or     $0x60,%eax
f010d61e:	a2 15 5c 81 f0       	mov    %al,0xf0815c15
f010d623:	a0 15 5c 81 f0       	mov    0xf0815c15,%al
f010d628:	83 c8 80             	or     $0xffffff80,%eax
f010d62b:	a2 15 5c 81 f0       	mov    %al,0xf0815c15
f010d630:	b8 dc e5 10 f0       	mov    $0xf010e5dc,%eax
f010d635:	c1 e8 10             	shr    $0x10,%eax
f010d638:	66 a3 16 5c 81 f0    	mov    %ax,0xf0815c16
	SETGATE(idt[T_SEGNP    ], 0, GD_KT , &ALL_FAULTS11, 3) ;
f010d63e:	b8 e0 e5 10 f0       	mov    $0xf010e5e0,%eax
f010d643:	66 a3 18 5c 81 f0    	mov    %ax,0xf0815c18
f010d649:	66 c7 05 1a 5c 81 f0 	movw   $0x8,0xf0815c1a
f010d650:	08 00 
f010d652:	a0 1c 5c 81 f0       	mov    0xf0815c1c,%al
f010d657:	83 e0 e0             	and    $0xffffffe0,%eax
f010d65a:	a2 1c 5c 81 f0       	mov    %al,0xf0815c1c
f010d65f:	a0 1c 5c 81 f0       	mov    0xf0815c1c,%al
f010d664:	83 e0 1f             	and    $0x1f,%eax
f010d667:	a2 1c 5c 81 f0       	mov    %al,0xf0815c1c
f010d66c:	a0 1d 5c 81 f0       	mov    0xf0815c1d,%al
f010d671:	83 e0 f0             	and    $0xfffffff0,%eax
f010d674:	83 c8 0e             	or     $0xe,%eax
f010d677:	a2 1d 5c 81 f0       	mov    %al,0xf0815c1d
f010d67c:	a0 1d 5c 81 f0       	mov    0xf0815c1d,%al
f010d681:	83 e0 ef             	and    $0xffffffef,%eax
f010d684:	a2 1d 5c 81 f0       	mov    %al,0xf0815c1d
f010d689:	a0 1d 5c 81 f0       	mov    0xf0815c1d,%al
f010d68e:	83 c8 60             	or     $0x60,%eax
f010d691:	a2 1d 5c 81 f0       	mov    %al,0xf0815c1d
f010d696:	a0 1d 5c 81 f0       	mov    0xf0815c1d,%al
f010d69b:	83 c8 80             	or     $0xffffff80,%eax
f010d69e:	a2 1d 5c 81 f0       	mov    %al,0xf0815c1d
f010d6a3:	b8 e0 e5 10 f0       	mov    $0xf010e5e0,%eax
f010d6a8:	c1 e8 10             	shr    $0x10,%eax
f010d6ab:	66 a3 1e 5c 81 f0    	mov    %ax,0xf0815c1e
	SETGATE(idt[T_STACK    ], 0, GD_KT , &ALL_FAULTS12, 3) ;
f010d6b1:	b8 e4 e5 10 f0       	mov    $0xf010e5e4,%eax
f010d6b6:	66 a3 20 5c 81 f0    	mov    %ax,0xf0815c20
f010d6bc:	66 c7 05 22 5c 81 f0 	movw   $0x8,0xf0815c22
f010d6c3:	08 00 
f010d6c5:	a0 24 5c 81 f0       	mov    0xf0815c24,%al
f010d6ca:	83 e0 e0             	and    $0xffffffe0,%eax
f010d6cd:	a2 24 5c 81 f0       	mov    %al,0xf0815c24
f010d6d2:	a0 24 5c 81 f0       	mov    0xf0815c24,%al
f010d6d7:	83 e0 1f             	and    $0x1f,%eax
f010d6da:	a2 24 5c 81 f0       	mov    %al,0xf0815c24
f010d6df:	a0 25 5c 81 f0       	mov    0xf0815c25,%al
f010d6e4:	83 e0 f0             	and    $0xfffffff0,%eax
f010d6e7:	83 c8 0e             	or     $0xe,%eax
f010d6ea:	a2 25 5c 81 f0       	mov    %al,0xf0815c25
f010d6ef:	a0 25 5c 81 f0       	mov    0xf0815c25,%al
f010d6f4:	83 e0 ef             	and    $0xffffffef,%eax
f010d6f7:	a2 25 5c 81 f0       	mov    %al,0xf0815c25
f010d6fc:	a0 25 5c 81 f0       	mov    0xf0815c25,%al
f010d701:	83 c8 60             	or     $0x60,%eax
f010d704:	a2 25 5c 81 f0       	mov    %al,0xf0815c25
f010d709:	a0 25 5c 81 f0       	mov    0xf0815c25,%al
f010d70e:	83 c8 80             	or     $0xffffff80,%eax
f010d711:	a2 25 5c 81 f0       	mov    %al,0xf0815c25
f010d716:	b8 e4 e5 10 f0       	mov    $0xf010e5e4,%eax
f010d71b:	c1 e8 10             	shr    $0x10,%eax
f010d71e:	66 a3 26 5c 81 f0    	mov    %ax,0xf0815c26
	SETGATE(idt[T_GPFLT    ], 0, GD_KT , &ALL_FAULTS13, 3) ;
f010d724:	b8 e8 e5 10 f0       	mov    $0xf010e5e8,%eax
f010d729:	66 a3 28 5c 81 f0    	mov    %ax,0xf0815c28
f010d72f:	66 c7 05 2a 5c 81 f0 	movw   $0x8,0xf0815c2a
f010d736:	08 00 
f010d738:	a0 2c 5c 81 f0       	mov    0xf0815c2c,%al
f010d73d:	83 e0 e0             	and    $0xffffffe0,%eax
f010d740:	a2 2c 5c 81 f0       	mov    %al,0xf0815c2c
f010d745:	a0 2c 5c 81 f0       	mov    0xf0815c2c,%al
f010d74a:	83 e0 1f             	and    $0x1f,%eax
f010d74d:	a2 2c 5c 81 f0       	mov    %al,0xf0815c2c
f010d752:	a0 2d 5c 81 f0       	mov    0xf0815c2d,%al
f010d757:	83 e0 f0             	and    $0xfffffff0,%eax
f010d75a:	83 c8 0e             	or     $0xe,%eax
f010d75d:	a2 2d 5c 81 f0       	mov    %al,0xf0815c2d
f010d762:	a0 2d 5c 81 f0       	mov    0xf0815c2d,%al
f010d767:	83 e0 ef             	and    $0xffffffef,%eax
f010d76a:	a2 2d 5c 81 f0       	mov    %al,0xf0815c2d
f010d76f:	a0 2d 5c 81 f0       	mov    0xf0815c2d,%al
f010d774:	83 c8 60             	or     $0x60,%eax
f010d777:	a2 2d 5c 81 f0       	mov    %al,0xf0815c2d
f010d77c:	a0 2d 5c 81 f0       	mov    0xf0815c2d,%al
f010d781:	83 c8 80             	or     $0xffffff80,%eax
f010d784:	a2 2d 5c 81 f0       	mov    %al,0xf0815c2d
f010d789:	b8 e8 e5 10 f0       	mov    $0xf010e5e8,%eax
f010d78e:	c1 e8 10             	shr    $0x10,%eax
f010d791:	66 a3 2e 5c 81 f0    	mov    %ax,0xf0815c2e
	//SETGATE(idt[T_PGFLT    ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[ne T_RES   ], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_FPERR    ], 0, GD_KT , &ALL_FAULTS16, 3) ;
f010d797:	b8 ec e5 10 f0       	mov    $0xf010e5ec,%eax
f010d79c:	66 a3 40 5c 81 f0    	mov    %ax,0xf0815c40
f010d7a2:	66 c7 05 42 5c 81 f0 	movw   $0x8,0xf0815c42
f010d7a9:	08 00 
f010d7ab:	a0 44 5c 81 f0       	mov    0xf0815c44,%al
f010d7b0:	83 e0 e0             	and    $0xffffffe0,%eax
f010d7b3:	a2 44 5c 81 f0       	mov    %al,0xf0815c44
f010d7b8:	a0 44 5c 81 f0       	mov    0xf0815c44,%al
f010d7bd:	83 e0 1f             	and    $0x1f,%eax
f010d7c0:	a2 44 5c 81 f0       	mov    %al,0xf0815c44
f010d7c5:	a0 45 5c 81 f0       	mov    0xf0815c45,%al
f010d7ca:	83 e0 f0             	and    $0xfffffff0,%eax
f010d7cd:	83 c8 0e             	or     $0xe,%eax
f010d7d0:	a2 45 5c 81 f0       	mov    %al,0xf0815c45
f010d7d5:	a0 45 5c 81 f0       	mov    0xf0815c45,%al
f010d7da:	83 e0 ef             	and    $0xffffffef,%eax
f010d7dd:	a2 45 5c 81 f0       	mov    %al,0xf0815c45
f010d7e2:	a0 45 5c 81 f0       	mov    0xf0815c45,%al
f010d7e7:	83 c8 60             	or     $0x60,%eax
f010d7ea:	a2 45 5c 81 f0       	mov    %al,0xf0815c45
f010d7ef:	a0 45 5c 81 f0       	mov    0xf0815c45,%al
f010d7f4:	83 c8 80             	or     $0xffffff80,%eax
f010d7f7:	a2 45 5c 81 f0       	mov    %al,0xf0815c45
f010d7fc:	b8 ec e5 10 f0       	mov    $0xf010e5ec,%eax
f010d801:	c1 e8 10             	shr    $0x10,%eax
f010d804:	66 a3 46 5c 81 f0    	mov    %ax,0xf0815c46
	SETGATE(idt[T_ALIGN    ], 0, GD_KT , &ALL_FAULTS17, 3) ;
f010d80a:	b8 f2 e5 10 f0       	mov    $0xf010e5f2,%eax
f010d80f:	66 a3 48 5c 81 f0    	mov    %ax,0xf0815c48
f010d815:	66 c7 05 4a 5c 81 f0 	movw   $0x8,0xf0815c4a
f010d81c:	08 00 
f010d81e:	a0 4c 5c 81 f0       	mov    0xf0815c4c,%al
f010d823:	83 e0 e0             	and    $0xffffffe0,%eax
f010d826:	a2 4c 5c 81 f0       	mov    %al,0xf0815c4c
f010d82b:	a0 4c 5c 81 f0       	mov    0xf0815c4c,%al
f010d830:	83 e0 1f             	and    $0x1f,%eax
f010d833:	a2 4c 5c 81 f0       	mov    %al,0xf0815c4c
f010d838:	a0 4d 5c 81 f0       	mov    0xf0815c4d,%al
f010d83d:	83 e0 f0             	and    $0xfffffff0,%eax
f010d840:	83 c8 0e             	or     $0xe,%eax
f010d843:	a2 4d 5c 81 f0       	mov    %al,0xf0815c4d
f010d848:	a0 4d 5c 81 f0       	mov    0xf0815c4d,%al
f010d84d:	83 e0 ef             	and    $0xffffffef,%eax
f010d850:	a2 4d 5c 81 f0       	mov    %al,0xf0815c4d
f010d855:	a0 4d 5c 81 f0       	mov    0xf0815c4d,%al
f010d85a:	83 c8 60             	or     $0x60,%eax
f010d85d:	a2 4d 5c 81 f0       	mov    %al,0xf0815c4d
f010d862:	a0 4d 5c 81 f0       	mov    0xf0815c4d,%al
f010d867:	83 c8 80             	or     $0xffffff80,%eax
f010d86a:	a2 4d 5c 81 f0       	mov    %al,0xf0815c4d
f010d86f:	b8 f2 e5 10 f0       	mov    $0xf010e5f2,%eax
f010d874:	c1 e8 10             	shr    $0x10,%eax
f010d877:	66 a3 4e 5c 81 f0    	mov    %ax,0xf0815c4e
	SETGATE(idt[T_MCHK     ], 0, GD_KT , &ALL_FAULTS18, 3) ;
f010d87d:	b8 f6 e5 10 f0       	mov    $0xf010e5f6,%eax
f010d882:	66 a3 50 5c 81 f0    	mov    %ax,0xf0815c50
f010d888:	66 c7 05 52 5c 81 f0 	movw   $0x8,0xf0815c52
f010d88f:	08 00 
f010d891:	a0 54 5c 81 f0       	mov    0xf0815c54,%al
f010d896:	83 e0 e0             	and    $0xffffffe0,%eax
f010d899:	a2 54 5c 81 f0       	mov    %al,0xf0815c54
f010d89e:	a0 54 5c 81 f0       	mov    0xf0815c54,%al
f010d8a3:	83 e0 1f             	and    $0x1f,%eax
f010d8a6:	a2 54 5c 81 f0       	mov    %al,0xf0815c54
f010d8ab:	a0 55 5c 81 f0       	mov    0xf0815c55,%al
f010d8b0:	83 e0 f0             	and    $0xfffffff0,%eax
f010d8b3:	83 c8 0e             	or     $0xe,%eax
f010d8b6:	a2 55 5c 81 f0       	mov    %al,0xf0815c55
f010d8bb:	a0 55 5c 81 f0       	mov    0xf0815c55,%al
f010d8c0:	83 e0 ef             	and    $0xffffffef,%eax
f010d8c3:	a2 55 5c 81 f0       	mov    %al,0xf0815c55
f010d8c8:	a0 55 5c 81 f0       	mov    0xf0815c55,%al
f010d8cd:	83 c8 60             	or     $0x60,%eax
f010d8d0:	a2 55 5c 81 f0       	mov    %al,0xf0815c55
f010d8d5:	a0 55 5c 81 f0       	mov    0xf0815c55,%al
f010d8da:	83 c8 80             	or     $0xffffff80,%eax
f010d8dd:	a2 55 5c 81 f0       	mov    %al,0xf0815c55
f010d8e2:	b8 f6 e5 10 f0       	mov    $0xf010e5f6,%eax
f010d8e7:	c1 e8 10             	shr    $0x10,%eax
f010d8ea:	66 a3 56 5c 81 f0    	mov    %ax,0xf0815c56
	SETGATE(idt[T_SIMDERR  ], 0, GD_KT , &ALL_FAULTS19, 3) ;
f010d8f0:	b8 fc e5 10 f0       	mov    $0xf010e5fc,%eax
f010d8f5:	66 a3 58 5c 81 f0    	mov    %ax,0xf0815c58
f010d8fb:	66 c7 05 5a 5c 81 f0 	movw   $0x8,0xf0815c5a
f010d902:	08 00 
f010d904:	a0 5c 5c 81 f0       	mov    0xf0815c5c,%al
f010d909:	83 e0 e0             	and    $0xffffffe0,%eax
f010d90c:	a2 5c 5c 81 f0       	mov    %al,0xf0815c5c
f010d911:	a0 5c 5c 81 f0       	mov    0xf0815c5c,%al
f010d916:	83 e0 1f             	and    $0x1f,%eax
f010d919:	a2 5c 5c 81 f0       	mov    %al,0xf0815c5c
f010d91e:	a0 5d 5c 81 f0       	mov    0xf0815c5d,%al
f010d923:	83 e0 f0             	and    $0xfffffff0,%eax
f010d926:	83 c8 0e             	or     $0xe,%eax
f010d929:	a2 5d 5c 81 f0       	mov    %al,0xf0815c5d
f010d92e:	a0 5d 5c 81 f0       	mov    0xf0815c5d,%al
f010d933:	83 e0 ef             	and    $0xffffffef,%eax
f010d936:	a2 5d 5c 81 f0       	mov    %al,0xf0815c5d
f010d93b:	a0 5d 5c 81 f0       	mov    0xf0815c5d,%al
f010d940:	83 c8 60             	or     $0x60,%eax
f010d943:	a2 5d 5c 81 f0       	mov    %al,0xf0815c5d
f010d948:	a0 5d 5c 81 f0       	mov    0xf0815c5d,%al
f010d94d:	83 c8 80             	or     $0xffffff80,%eax
f010d950:	a2 5d 5c 81 f0       	mov    %al,0xf0815c5d
f010d955:	b8 fc e5 10 f0       	mov    $0xf010e5fc,%eax
f010d95a:	c1 e8 10             	shr    $0x10,%eax
f010d95d:	66 a3 5e 5c 81 f0    	mov    %ax,0xf0815c5e

	//IRQs
	SETGATE(idt[34], 0, GD_KT , &ALL_FAULTS34, 3) ;
f010d963:	b8 02 e6 10 f0       	mov    $0xf010e602,%eax
f010d968:	66 a3 d0 5c 81 f0    	mov    %ax,0xf0815cd0
f010d96e:	66 c7 05 d2 5c 81 f0 	movw   $0x8,0xf0815cd2
f010d975:	08 00 
f010d977:	a0 d4 5c 81 f0       	mov    0xf0815cd4,%al
f010d97c:	83 e0 e0             	and    $0xffffffe0,%eax
f010d97f:	a2 d4 5c 81 f0       	mov    %al,0xf0815cd4
f010d984:	a0 d4 5c 81 f0       	mov    0xf0815cd4,%al
f010d989:	83 e0 1f             	and    $0x1f,%eax
f010d98c:	a2 d4 5c 81 f0       	mov    %al,0xf0815cd4
f010d991:	a0 d5 5c 81 f0       	mov    0xf0815cd5,%al
f010d996:	83 e0 f0             	and    $0xfffffff0,%eax
f010d999:	83 c8 0e             	or     $0xe,%eax
f010d99c:	a2 d5 5c 81 f0       	mov    %al,0xf0815cd5
f010d9a1:	a0 d5 5c 81 f0       	mov    0xf0815cd5,%al
f010d9a6:	83 e0 ef             	and    $0xffffffef,%eax
f010d9a9:	a2 d5 5c 81 f0       	mov    %al,0xf0815cd5
f010d9ae:	a0 d5 5c 81 f0       	mov    0xf0815cd5,%al
f010d9b3:	83 c8 60             	or     $0x60,%eax
f010d9b6:	a2 d5 5c 81 f0       	mov    %al,0xf0815cd5
f010d9bb:	a0 d5 5c 81 f0       	mov    0xf0815cd5,%al
f010d9c0:	83 c8 80             	or     $0xffffff80,%eax
f010d9c3:	a2 d5 5c 81 f0       	mov    %al,0xf0815cd5
f010d9c8:	b8 02 e6 10 f0       	mov    $0xf010e602,%eax
f010d9cd:	c1 e8 10             	shr    $0x10,%eax
f010d9d0:	66 a3 d6 5c 81 f0    	mov    %ax,0xf0815cd6
	SETGATE(idt[35], 0, GD_KT , &ALL_FAULTS35, 3) ;
f010d9d6:	b8 08 e6 10 f0       	mov    $0xf010e608,%eax
f010d9db:	66 a3 d8 5c 81 f0    	mov    %ax,0xf0815cd8
f010d9e1:	66 c7 05 da 5c 81 f0 	movw   $0x8,0xf0815cda
f010d9e8:	08 00 
f010d9ea:	a0 dc 5c 81 f0       	mov    0xf0815cdc,%al
f010d9ef:	83 e0 e0             	and    $0xffffffe0,%eax
f010d9f2:	a2 dc 5c 81 f0       	mov    %al,0xf0815cdc
f010d9f7:	a0 dc 5c 81 f0       	mov    0xf0815cdc,%al
f010d9fc:	83 e0 1f             	and    $0x1f,%eax
f010d9ff:	a2 dc 5c 81 f0       	mov    %al,0xf0815cdc
f010da04:	a0 dd 5c 81 f0       	mov    0xf0815cdd,%al
f010da09:	83 e0 f0             	and    $0xfffffff0,%eax
f010da0c:	83 c8 0e             	or     $0xe,%eax
f010da0f:	a2 dd 5c 81 f0       	mov    %al,0xf0815cdd
f010da14:	a0 dd 5c 81 f0       	mov    0xf0815cdd,%al
f010da19:	83 e0 ef             	and    $0xffffffef,%eax
f010da1c:	a2 dd 5c 81 f0       	mov    %al,0xf0815cdd
f010da21:	a0 dd 5c 81 f0       	mov    0xf0815cdd,%al
f010da26:	83 c8 60             	or     $0x60,%eax
f010da29:	a2 dd 5c 81 f0       	mov    %al,0xf0815cdd
f010da2e:	a0 dd 5c 81 f0       	mov    0xf0815cdd,%al
f010da33:	83 c8 80             	or     $0xffffff80,%eax
f010da36:	a2 dd 5c 81 f0       	mov    %al,0xf0815cdd
f010da3b:	b8 08 e6 10 f0       	mov    $0xf010e608,%eax
f010da40:	c1 e8 10             	shr    $0x10,%eax
f010da43:	66 a3 de 5c 81 f0    	mov    %ax,0xf0815cde
	SETGATE(idt[36], 0, GD_KT , &ALL_FAULTS36, 3) ;
f010da49:	b8 0e e6 10 f0       	mov    $0xf010e60e,%eax
f010da4e:	66 a3 e0 5c 81 f0    	mov    %ax,0xf0815ce0
f010da54:	66 c7 05 e2 5c 81 f0 	movw   $0x8,0xf0815ce2
f010da5b:	08 00 
f010da5d:	a0 e4 5c 81 f0       	mov    0xf0815ce4,%al
f010da62:	83 e0 e0             	and    $0xffffffe0,%eax
f010da65:	a2 e4 5c 81 f0       	mov    %al,0xf0815ce4
f010da6a:	a0 e4 5c 81 f0       	mov    0xf0815ce4,%al
f010da6f:	83 e0 1f             	and    $0x1f,%eax
f010da72:	a2 e4 5c 81 f0       	mov    %al,0xf0815ce4
f010da77:	a0 e5 5c 81 f0       	mov    0xf0815ce5,%al
f010da7c:	83 e0 f0             	and    $0xfffffff0,%eax
f010da7f:	83 c8 0e             	or     $0xe,%eax
f010da82:	a2 e5 5c 81 f0       	mov    %al,0xf0815ce5
f010da87:	a0 e5 5c 81 f0       	mov    0xf0815ce5,%al
f010da8c:	83 e0 ef             	and    $0xffffffef,%eax
f010da8f:	a2 e5 5c 81 f0       	mov    %al,0xf0815ce5
f010da94:	a0 e5 5c 81 f0       	mov    0xf0815ce5,%al
f010da99:	83 c8 60             	or     $0x60,%eax
f010da9c:	a2 e5 5c 81 f0       	mov    %al,0xf0815ce5
f010daa1:	a0 e5 5c 81 f0       	mov    0xf0815ce5,%al
f010daa6:	83 c8 80             	or     $0xffffff80,%eax
f010daa9:	a2 e5 5c 81 f0       	mov    %al,0xf0815ce5
f010daae:	b8 0e e6 10 f0       	mov    $0xf010e60e,%eax
f010dab3:	c1 e8 10             	shr    $0x10,%eax
f010dab6:	66 a3 e6 5c 81 f0    	mov    %ax,0xf0815ce6
	SETGATE(idt[37], 0, GD_KT , &ALL_FAULTS37, 3) ;
f010dabc:	b8 14 e6 10 f0       	mov    $0xf010e614,%eax
f010dac1:	66 a3 e8 5c 81 f0    	mov    %ax,0xf0815ce8
f010dac7:	66 c7 05 ea 5c 81 f0 	movw   $0x8,0xf0815cea
f010dace:	08 00 
f010dad0:	a0 ec 5c 81 f0       	mov    0xf0815cec,%al
f010dad5:	83 e0 e0             	and    $0xffffffe0,%eax
f010dad8:	a2 ec 5c 81 f0       	mov    %al,0xf0815cec
f010dadd:	a0 ec 5c 81 f0       	mov    0xf0815cec,%al
f010dae2:	83 e0 1f             	and    $0x1f,%eax
f010dae5:	a2 ec 5c 81 f0       	mov    %al,0xf0815cec
f010daea:	a0 ed 5c 81 f0       	mov    0xf0815ced,%al
f010daef:	83 e0 f0             	and    $0xfffffff0,%eax
f010daf2:	83 c8 0e             	or     $0xe,%eax
f010daf5:	a2 ed 5c 81 f0       	mov    %al,0xf0815ced
f010dafa:	a0 ed 5c 81 f0       	mov    0xf0815ced,%al
f010daff:	83 e0 ef             	and    $0xffffffef,%eax
f010db02:	a2 ed 5c 81 f0       	mov    %al,0xf0815ced
f010db07:	a0 ed 5c 81 f0       	mov    0xf0815ced,%al
f010db0c:	83 c8 60             	or     $0x60,%eax
f010db0f:	a2 ed 5c 81 f0       	mov    %al,0xf0815ced
f010db14:	a0 ed 5c 81 f0       	mov    0xf0815ced,%al
f010db19:	83 c8 80             	or     $0xffffff80,%eax
f010db1c:	a2 ed 5c 81 f0       	mov    %al,0xf0815ced
f010db21:	b8 14 e6 10 f0       	mov    $0xf010e614,%eax
f010db26:	c1 e8 10             	shr    $0x10,%eax
f010db29:	66 a3 ee 5c 81 f0    	mov    %ax,0xf0815cee
	SETGATE(idt[38], 0, GD_KT , &ALL_FAULTS38, 3) ;
f010db2f:	b8 1a e6 10 f0       	mov    $0xf010e61a,%eax
f010db34:	66 a3 f0 5c 81 f0    	mov    %ax,0xf0815cf0
f010db3a:	66 c7 05 f2 5c 81 f0 	movw   $0x8,0xf0815cf2
f010db41:	08 00 
f010db43:	a0 f4 5c 81 f0       	mov    0xf0815cf4,%al
f010db48:	83 e0 e0             	and    $0xffffffe0,%eax
f010db4b:	a2 f4 5c 81 f0       	mov    %al,0xf0815cf4
f010db50:	a0 f4 5c 81 f0       	mov    0xf0815cf4,%al
f010db55:	83 e0 1f             	and    $0x1f,%eax
f010db58:	a2 f4 5c 81 f0       	mov    %al,0xf0815cf4
f010db5d:	a0 f5 5c 81 f0       	mov    0xf0815cf5,%al
f010db62:	83 e0 f0             	and    $0xfffffff0,%eax
f010db65:	83 c8 0e             	or     $0xe,%eax
f010db68:	a2 f5 5c 81 f0       	mov    %al,0xf0815cf5
f010db6d:	a0 f5 5c 81 f0       	mov    0xf0815cf5,%al
f010db72:	83 e0 ef             	and    $0xffffffef,%eax
f010db75:	a2 f5 5c 81 f0       	mov    %al,0xf0815cf5
f010db7a:	a0 f5 5c 81 f0       	mov    0xf0815cf5,%al
f010db7f:	83 c8 60             	or     $0x60,%eax
f010db82:	a2 f5 5c 81 f0       	mov    %al,0xf0815cf5
f010db87:	a0 f5 5c 81 f0       	mov    0xf0815cf5,%al
f010db8c:	83 c8 80             	or     $0xffffff80,%eax
f010db8f:	a2 f5 5c 81 f0       	mov    %al,0xf0815cf5
f010db94:	b8 1a e6 10 f0       	mov    $0xf010e61a,%eax
f010db99:	c1 e8 10             	shr    $0x10,%eax
f010db9c:	66 a3 f6 5c 81 f0    	mov    %ax,0xf0815cf6
	SETGATE(idt[39], 0, GD_KT , &ALL_FAULTS39, 3) ;
f010dba2:	b8 20 e6 10 f0       	mov    $0xf010e620,%eax
f010dba7:	66 a3 f8 5c 81 f0    	mov    %ax,0xf0815cf8
f010dbad:	66 c7 05 fa 5c 81 f0 	movw   $0x8,0xf0815cfa
f010dbb4:	08 00 
f010dbb6:	a0 fc 5c 81 f0       	mov    0xf0815cfc,%al
f010dbbb:	83 e0 e0             	and    $0xffffffe0,%eax
f010dbbe:	a2 fc 5c 81 f0       	mov    %al,0xf0815cfc
f010dbc3:	a0 fc 5c 81 f0       	mov    0xf0815cfc,%al
f010dbc8:	83 e0 1f             	and    $0x1f,%eax
f010dbcb:	a2 fc 5c 81 f0       	mov    %al,0xf0815cfc
f010dbd0:	a0 fd 5c 81 f0       	mov    0xf0815cfd,%al
f010dbd5:	83 e0 f0             	and    $0xfffffff0,%eax
f010dbd8:	83 c8 0e             	or     $0xe,%eax
f010dbdb:	a2 fd 5c 81 f0       	mov    %al,0xf0815cfd
f010dbe0:	a0 fd 5c 81 f0       	mov    0xf0815cfd,%al
f010dbe5:	83 e0 ef             	and    $0xffffffef,%eax
f010dbe8:	a2 fd 5c 81 f0       	mov    %al,0xf0815cfd
f010dbed:	a0 fd 5c 81 f0       	mov    0xf0815cfd,%al
f010dbf2:	83 c8 60             	or     $0x60,%eax
f010dbf5:	a2 fd 5c 81 f0       	mov    %al,0xf0815cfd
f010dbfa:	a0 fd 5c 81 f0       	mov    0xf0815cfd,%al
f010dbff:	83 c8 80             	or     $0xffffff80,%eax
f010dc02:	a2 fd 5c 81 f0       	mov    %al,0xf0815cfd
f010dc07:	b8 20 e6 10 f0       	mov    $0xf010e620,%eax
f010dc0c:	c1 e8 10             	shr    $0x10,%eax
f010dc0f:	66 a3 fe 5c 81 f0    	mov    %ax,0xf0815cfe
	SETGATE(idt[40], 0, GD_KT , &ALL_FAULTS40, 3) ;
f010dc15:	b8 26 e6 10 f0       	mov    $0xf010e626,%eax
f010dc1a:	66 a3 00 5d 81 f0    	mov    %ax,0xf0815d00
f010dc20:	66 c7 05 02 5d 81 f0 	movw   $0x8,0xf0815d02
f010dc27:	08 00 
f010dc29:	a0 04 5d 81 f0       	mov    0xf0815d04,%al
f010dc2e:	83 e0 e0             	and    $0xffffffe0,%eax
f010dc31:	a2 04 5d 81 f0       	mov    %al,0xf0815d04
f010dc36:	a0 04 5d 81 f0       	mov    0xf0815d04,%al
f010dc3b:	83 e0 1f             	and    $0x1f,%eax
f010dc3e:	a2 04 5d 81 f0       	mov    %al,0xf0815d04
f010dc43:	a0 05 5d 81 f0       	mov    0xf0815d05,%al
f010dc48:	83 e0 f0             	and    $0xfffffff0,%eax
f010dc4b:	83 c8 0e             	or     $0xe,%eax
f010dc4e:	a2 05 5d 81 f0       	mov    %al,0xf0815d05
f010dc53:	a0 05 5d 81 f0       	mov    0xf0815d05,%al
f010dc58:	83 e0 ef             	and    $0xffffffef,%eax
f010dc5b:	a2 05 5d 81 f0       	mov    %al,0xf0815d05
f010dc60:	a0 05 5d 81 f0       	mov    0xf0815d05,%al
f010dc65:	83 c8 60             	or     $0x60,%eax
f010dc68:	a2 05 5d 81 f0       	mov    %al,0xf0815d05
f010dc6d:	a0 05 5d 81 f0       	mov    0xf0815d05,%al
f010dc72:	83 c8 80             	or     $0xffffff80,%eax
f010dc75:	a2 05 5d 81 f0       	mov    %al,0xf0815d05
f010dc7a:	b8 26 e6 10 f0       	mov    $0xf010e626,%eax
f010dc7f:	c1 e8 10             	shr    $0x10,%eax
f010dc82:	66 a3 06 5d 81 f0    	mov    %ax,0xf0815d06
	SETGATE(idt[41], 0, GD_KT , &ALL_FAULTS41, 3) ;
f010dc88:	b8 2c e6 10 f0       	mov    $0xf010e62c,%eax
f010dc8d:	66 a3 08 5d 81 f0    	mov    %ax,0xf0815d08
f010dc93:	66 c7 05 0a 5d 81 f0 	movw   $0x8,0xf0815d0a
f010dc9a:	08 00 
f010dc9c:	a0 0c 5d 81 f0       	mov    0xf0815d0c,%al
f010dca1:	83 e0 e0             	and    $0xffffffe0,%eax
f010dca4:	a2 0c 5d 81 f0       	mov    %al,0xf0815d0c
f010dca9:	a0 0c 5d 81 f0       	mov    0xf0815d0c,%al
f010dcae:	83 e0 1f             	and    $0x1f,%eax
f010dcb1:	a2 0c 5d 81 f0       	mov    %al,0xf0815d0c
f010dcb6:	a0 0d 5d 81 f0       	mov    0xf0815d0d,%al
f010dcbb:	83 e0 f0             	and    $0xfffffff0,%eax
f010dcbe:	83 c8 0e             	or     $0xe,%eax
f010dcc1:	a2 0d 5d 81 f0       	mov    %al,0xf0815d0d
f010dcc6:	a0 0d 5d 81 f0       	mov    0xf0815d0d,%al
f010dccb:	83 e0 ef             	and    $0xffffffef,%eax
f010dcce:	a2 0d 5d 81 f0       	mov    %al,0xf0815d0d
f010dcd3:	a0 0d 5d 81 f0       	mov    0xf0815d0d,%al
f010dcd8:	83 c8 60             	or     $0x60,%eax
f010dcdb:	a2 0d 5d 81 f0       	mov    %al,0xf0815d0d
f010dce0:	a0 0d 5d 81 f0       	mov    0xf0815d0d,%al
f010dce5:	83 c8 80             	or     $0xffffff80,%eax
f010dce8:	a2 0d 5d 81 f0       	mov    %al,0xf0815d0d
f010dced:	b8 2c e6 10 f0       	mov    $0xf010e62c,%eax
f010dcf2:	c1 e8 10             	shr    $0x10,%eax
f010dcf5:	66 a3 0e 5d 81 f0    	mov    %ax,0xf0815d0e
	SETGATE(idt[42], 0, GD_KT , &ALL_FAULTS42, 3) ;
f010dcfb:	b8 32 e6 10 f0       	mov    $0xf010e632,%eax
f010dd00:	66 a3 10 5d 81 f0    	mov    %ax,0xf0815d10
f010dd06:	66 c7 05 12 5d 81 f0 	movw   $0x8,0xf0815d12
f010dd0d:	08 00 
f010dd0f:	a0 14 5d 81 f0       	mov    0xf0815d14,%al
f010dd14:	83 e0 e0             	and    $0xffffffe0,%eax
f010dd17:	a2 14 5d 81 f0       	mov    %al,0xf0815d14
f010dd1c:	a0 14 5d 81 f0       	mov    0xf0815d14,%al
f010dd21:	83 e0 1f             	and    $0x1f,%eax
f010dd24:	a2 14 5d 81 f0       	mov    %al,0xf0815d14
f010dd29:	a0 15 5d 81 f0       	mov    0xf0815d15,%al
f010dd2e:	83 e0 f0             	and    $0xfffffff0,%eax
f010dd31:	83 c8 0e             	or     $0xe,%eax
f010dd34:	a2 15 5d 81 f0       	mov    %al,0xf0815d15
f010dd39:	a0 15 5d 81 f0       	mov    0xf0815d15,%al
f010dd3e:	83 e0 ef             	and    $0xffffffef,%eax
f010dd41:	a2 15 5d 81 f0       	mov    %al,0xf0815d15
f010dd46:	a0 15 5d 81 f0       	mov    0xf0815d15,%al
f010dd4b:	83 c8 60             	or     $0x60,%eax
f010dd4e:	a2 15 5d 81 f0       	mov    %al,0xf0815d15
f010dd53:	a0 15 5d 81 f0       	mov    0xf0815d15,%al
f010dd58:	83 c8 80             	or     $0xffffff80,%eax
f010dd5b:	a2 15 5d 81 f0       	mov    %al,0xf0815d15
f010dd60:	b8 32 e6 10 f0       	mov    $0xf010e632,%eax
f010dd65:	c1 e8 10             	shr    $0x10,%eax
f010dd68:	66 a3 16 5d 81 f0    	mov    %ax,0xf0815d16
	SETGATE(idt[43], 0, GD_KT , &ALL_FAULTS43, 3) ;
f010dd6e:	b8 38 e6 10 f0       	mov    $0xf010e638,%eax
f010dd73:	66 a3 18 5d 81 f0    	mov    %ax,0xf0815d18
f010dd79:	66 c7 05 1a 5d 81 f0 	movw   $0x8,0xf0815d1a
f010dd80:	08 00 
f010dd82:	a0 1c 5d 81 f0       	mov    0xf0815d1c,%al
f010dd87:	83 e0 e0             	and    $0xffffffe0,%eax
f010dd8a:	a2 1c 5d 81 f0       	mov    %al,0xf0815d1c
f010dd8f:	a0 1c 5d 81 f0       	mov    0xf0815d1c,%al
f010dd94:	83 e0 1f             	and    $0x1f,%eax
f010dd97:	a2 1c 5d 81 f0       	mov    %al,0xf0815d1c
f010dd9c:	a0 1d 5d 81 f0       	mov    0xf0815d1d,%al
f010dda1:	83 e0 f0             	and    $0xfffffff0,%eax
f010dda4:	83 c8 0e             	or     $0xe,%eax
f010dda7:	a2 1d 5d 81 f0       	mov    %al,0xf0815d1d
f010ddac:	a0 1d 5d 81 f0       	mov    0xf0815d1d,%al
f010ddb1:	83 e0 ef             	and    $0xffffffef,%eax
f010ddb4:	a2 1d 5d 81 f0       	mov    %al,0xf0815d1d
f010ddb9:	a0 1d 5d 81 f0       	mov    0xf0815d1d,%al
f010ddbe:	83 c8 60             	or     $0x60,%eax
f010ddc1:	a2 1d 5d 81 f0       	mov    %al,0xf0815d1d
f010ddc6:	a0 1d 5d 81 f0       	mov    0xf0815d1d,%al
f010ddcb:	83 c8 80             	or     $0xffffff80,%eax
f010ddce:	a2 1d 5d 81 f0       	mov    %al,0xf0815d1d
f010ddd3:	b8 38 e6 10 f0       	mov    $0xf010e638,%eax
f010ddd8:	c1 e8 10             	shr    $0x10,%eax
f010dddb:	66 a3 1e 5d 81 f0    	mov    %ax,0xf0815d1e
	SETGATE(idt[44], 0, GD_KT , &ALL_FAULTS44, 3) ;
f010dde1:	b8 3e e6 10 f0       	mov    $0xf010e63e,%eax
f010dde6:	66 a3 20 5d 81 f0    	mov    %ax,0xf0815d20
f010ddec:	66 c7 05 22 5d 81 f0 	movw   $0x8,0xf0815d22
f010ddf3:	08 00 
f010ddf5:	a0 24 5d 81 f0       	mov    0xf0815d24,%al
f010ddfa:	83 e0 e0             	and    $0xffffffe0,%eax
f010ddfd:	a2 24 5d 81 f0       	mov    %al,0xf0815d24
f010de02:	a0 24 5d 81 f0       	mov    0xf0815d24,%al
f010de07:	83 e0 1f             	and    $0x1f,%eax
f010de0a:	a2 24 5d 81 f0       	mov    %al,0xf0815d24
f010de0f:	a0 25 5d 81 f0       	mov    0xf0815d25,%al
f010de14:	83 e0 f0             	and    $0xfffffff0,%eax
f010de17:	83 c8 0e             	or     $0xe,%eax
f010de1a:	a2 25 5d 81 f0       	mov    %al,0xf0815d25
f010de1f:	a0 25 5d 81 f0       	mov    0xf0815d25,%al
f010de24:	83 e0 ef             	and    $0xffffffef,%eax
f010de27:	a2 25 5d 81 f0       	mov    %al,0xf0815d25
f010de2c:	a0 25 5d 81 f0       	mov    0xf0815d25,%al
f010de31:	83 c8 60             	or     $0x60,%eax
f010de34:	a2 25 5d 81 f0       	mov    %al,0xf0815d25
f010de39:	a0 25 5d 81 f0       	mov    0xf0815d25,%al
f010de3e:	83 c8 80             	or     $0xffffff80,%eax
f010de41:	a2 25 5d 81 f0       	mov    %al,0xf0815d25
f010de46:	b8 3e e6 10 f0       	mov    $0xf010e63e,%eax
f010de4b:	c1 e8 10             	shr    $0x10,%eax
f010de4e:	66 a3 26 5d 81 f0    	mov    %ax,0xf0815d26
	SETGATE(idt[45], 0, GD_KT , &ALL_FAULTS45, 3) ;
f010de54:	b8 44 e6 10 f0       	mov    $0xf010e644,%eax
f010de59:	66 a3 28 5d 81 f0    	mov    %ax,0xf0815d28
f010de5f:	66 c7 05 2a 5d 81 f0 	movw   $0x8,0xf0815d2a
f010de66:	08 00 
f010de68:	a0 2c 5d 81 f0       	mov    0xf0815d2c,%al
f010de6d:	83 e0 e0             	and    $0xffffffe0,%eax
f010de70:	a2 2c 5d 81 f0       	mov    %al,0xf0815d2c
f010de75:	a0 2c 5d 81 f0       	mov    0xf0815d2c,%al
f010de7a:	83 e0 1f             	and    $0x1f,%eax
f010de7d:	a2 2c 5d 81 f0       	mov    %al,0xf0815d2c
f010de82:	a0 2d 5d 81 f0       	mov    0xf0815d2d,%al
f010de87:	83 e0 f0             	and    $0xfffffff0,%eax
f010de8a:	83 c8 0e             	or     $0xe,%eax
f010de8d:	a2 2d 5d 81 f0       	mov    %al,0xf0815d2d
f010de92:	a0 2d 5d 81 f0       	mov    0xf0815d2d,%al
f010de97:	83 e0 ef             	and    $0xffffffef,%eax
f010de9a:	a2 2d 5d 81 f0       	mov    %al,0xf0815d2d
f010de9f:	a0 2d 5d 81 f0       	mov    0xf0815d2d,%al
f010dea4:	83 c8 60             	or     $0x60,%eax
f010dea7:	a2 2d 5d 81 f0       	mov    %al,0xf0815d2d
f010deac:	a0 2d 5d 81 f0       	mov    0xf0815d2d,%al
f010deb1:	83 c8 80             	or     $0xffffff80,%eax
f010deb4:	a2 2d 5d 81 f0       	mov    %al,0xf0815d2d
f010deb9:	b8 44 e6 10 f0       	mov    $0xf010e644,%eax
f010debe:	c1 e8 10             	shr    $0x10,%eax
f010dec1:	66 a3 2e 5d 81 f0    	mov    %ax,0xf0815d2e
	SETGATE(idt[46], 0, GD_KT , &ALL_FAULTS46, 3) ;
f010dec7:	b8 4a e6 10 f0       	mov    $0xf010e64a,%eax
f010decc:	66 a3 30 5d 81 f0    	mov    %ax,0xf0815d30
f010ded2:	66 c7 05 32 5d 81 f0 	movw   $0x8,0xf0815d32
f010ded9:	08 00 
f010dedb:	a0 34 5d 81 f0       	mov    0xf0815d34,%al
f010dee0:	83 e0 e0             	and    $0xffffffe0,%eax
f010dee3:	a2 34 5d 81 f0       	mov    %al,0xf0815d34
f010dee8:	a0 34 5d 81 f0       	mov    0xf0815d34,%al
f010deed:	83 e0 1f             	and    $0x1f,%eax
f010def0:	a2 34 5d 81 f0       	mov    %al,0xf0815d34
f010def5:	a0 35 5d 81 f0       	mov    0xf0815d35,%al
f010defa:	83 e0 f0             	and    $0xfffffff0,%eax
f010defd:	83 c8 0e             	or     $0xe,%eax
f010df00:	a2 35 5d 81 f0       	mov    %al,0xf0815d35
f010df05:	a0 35 5d 81 f0       	mov    0xf0815d35,%al
f010df0a:	83 e0 ef             	and    $0xffffffef,%eax
f010df0d:	a2 35 5d 81 f0       	mov    %al,0xf0815d35
f010df12:	a0 35 5d 81 f0       	mov    0xf0815d35,%al
f010df17:	83 c8 60             	or     $0x60,%eax
f010df1a:	a2 35 5d 81 f0       	mov    %al,0xf0815d35
f010df1f:	a0 35 5d 81 f0       	mov    0xf0815d35,%al
f010df24:	83 c8 80             	or     $0xffffff80,%eax
f010df27:	a2 35 5d 81 f0       	mov    %al,0xf0815d35
f010df2c:	b8 4a e6 10 f0       	mov    $0xf010e64a,%eax
f010df31:	c1 e8 10             	shr    $0x10,%eax
f010df34:	66 a3 36 5d 81 f0    	mov    %ax,0xf0815d36
	SETGATE(idt[47], 0, GD_KT , &ALL_FAULTS47, 3) ;
f010df3a:	b8 50 e6 10 f0       	mov    $0xf010e650,%eax
f010df3f:	66 a3 38 5d 81 f0    	mov    %ax,0xf0815d38
f010df45:	66 c7 05 3a 5d 81 f0 	movw   $0x8,0xf0815d3a
f010df4c:	08 00 
f010df4e:	a0 3c 5d 81 f0       	mov    0xf0815d3c,%al
f010df53:	83 e0 e0             	and    $0xffffffe0,%eax
f010df56:	a2 3c 5d 81 f0       	mov    %al,0xf0815d3c
f010df5b:	a0 3c 5d 81 f0       	mov    0xf0815d3c,%al
f010df60:	83 e0 1f             	and    $0x1f,%eax
f010df63:	a2 3c 5d 81 f0       	mov    %al,0xf0815d3c
f010df68:	a0 3d 5d 81 f0       	mov    0xf0815d3d,%al
f010df6d:	83 e0 f0             	and    $0xfffffff0,%eax
f010df70:	83 c8 0e             	or     $0xe,%eax
f010df73:	a2 3d 5d 81 f0       	mov    %al,0xf0815d3d
f010df78:	a0 3d 5d 81 f0       	mov    0xf0815d3d,%al
f010df7d:	83 e0 ef             	and    $0xffffffef,%eax
f010df80:	a2 3d 5d 81 f0       	mov    %al,0xf0815d3d
f010df85:	a0 3d 5d 81 f0       	mov    0xf0815d3d,%al
f010df8a:	83 c8 60             	or     $0x60,%eax
f010df8d:	a2 3d 5d 81 f0       	mov    %al,0xf0815d3d
f010df92:	a0 3d 5d 81 f0       	mov    0xf0815d3d,%al
f010df97:	83 c8 80             	or     $0xffffff80,%eax
f010df9a:	a2 3d 5d 81 f0       	mov    %al,0xf0815d3d
f010df9f:	b8 50 e6 10 f0       	mov    $0xf010e650,%eax
f010dfa4:	c1 e8 10             	shr    $0x10,%eax
f010dfa7:	66 a3 3e 5d 81 f0    	mov    %ax,0xf0815d3e
f010dfad:	c7 45 fc c0 5b 81 f0 	movl   $0xf0815bc0,-0x4(%ebp)
f010dfb4:	c7 45 f8 00 08 00 00 	movl   $0x800,-0x8(%ebp)
//load IDT register
static __inline void lidt(struct Gatedesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f010dfbb:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010dfbe:	48                   	dec    %eax
f010dfbf:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
  pd[1] = (uint32)p;
f010dfc3:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010dfc6:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  pd[2] = (uint32)p >> 16;
f010dfca:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010dfcd:	c1 e8 10             	shr    $0x10,%eax
f010dfd0:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

  asm volatile("lidt (%0)" : : "r" (pd));
f010dfd4:	8d 45 f2             	lea    -0xe(%ebp),%eax
f010dfd7:	0f 01 18             	lidtl  (%eax)

	// Load the IDT
	//asm volatile("lidt idt_pd");
	lidt(idt, sizeof(idt));

}
f010dfda:	90                   	nop
f010dfdb:	c9                   	leave  
f010dfdc:	c3                   	ret    

f010dfdd <print_trapframe>:

void print_trapframe(struct Trapframe *tf)
{
f010dfdd:	55                   	push   %ebp
f010dfde:	89 e5                	mov    %esp,%ebp
f010dfe0:	53                   	push   %ebx
f010dfe1:	83 ec 04             	sub    $0x4,%esp
	cprintf("TRAP frame at %p\n", tf);
f010dfe4:	83 ec 08             	sub    $0x8,%esp
f010dfe7:	ff 75 08             	pushl  0x8(%ebp)
f010dfea:	68 3e 08 13 f0       	push   $0xf013083e
f010dfef:	e8 68 3b ff ff       	call   f0101b5c <cprintf>
f010dff4:	83 c4 10             	add    $0x10,%esp
	print_regs(&tf->tf_regs);
f010dff7:	8b 45 08             	mov    0x8(%ebp),%eax
f010dffa:	83 ec 0c             	sub    $0xc,%esp
f010dffd:	50                   	push   %eax
f010dffe:	e8 fd 00 00 00       	call   f010e100 <print_regs>
f010e003:	83 c4 10             	add    $0x10,%esp
	cprintf("  es   0x----%04x\n", tf->tf_es);
f010e006:	8b 45 08             	mov    0x8(%ebp),%eax
f010e009:	8b 40 20             	mov    0x20(%eax),%eax
f010e00c:	0f b7 c0             	movzwl %ax,%eax
f010e00f:	83 ec 08             	sub    $0x8,%esp
f010e012:	50                   	push   %eax
f010e013:	68 50 08 13 f0       	push   $0xf0130850
f010e018:	e8 3f 3b ff ff       	call   f0101b5c <cprintf>
f010e01d:	83 c4 10             	add    $0x10,%esp
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
f010e020:	8b 45 08             	mov    0x8(%ebp),%eax
f010e023:	8b 40 24             	mov    0x24(%eax),%eax
f010e026:	0f b7 c0             	movzwl %ax,%eax
f010e029:	83 ec 08             	sub    $0x8,%esp
f010e02c:	50                   	push   %eax
f010e02d:	68 63 08 13 f0       	push   $0xf0130863
f010e032:	e8 25 3b ff ff       	call   f0101b5c <cprintf>
f010e037:	83 c4 10             	add    $0x10,%esp
	cprintf("  trap 0x%08x %s - %d\n", tf->tf_trapno, trapname(tf->tf_trapno), tf->tf_trapno);
f010e03a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e03d:	8b 58 28             	mov    0x28(%eax),%ebx
f010e040:	8b 45 08             	mov    0x8(%ebp),%eax
f010e043:	8b 40 28             	mov    0x28(%eax),%eax
f010e046:	83 ec 0c             	sub    $0xc,%esp
f010e049:	50                   	push   %eax
f010e04a:	e8 28 ee ff ff       	call   f010ce77 <trapname>
f010e04f:	83 c4 10             	add    $0x10,%esp
f010e052:	89 c2                	mov    %eax,%edx
f010e054:	8b 45 08             	mov    0x8(%ebp),%eax
f010e057:	8b 40 28             	mov    0x28(%eax),%eax
f010e05a:	53                   	push   %ebx
f010e05b:	52                   	push   %edx
f010e05c:	50                   	push   %eax
f010e05d:	68 76 08 13 f0       	push   $0xf0130876
f010e062:	e8 f5 3a ff ff       	call   f0101b5c <cprintf>
f010e067:	83 c4 10             	add    $0x10,%esp
	cprintf("  err  0x%08x\n", tf->tf_err);
f010e06a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e06d:	8b 40 2c             	mov    0x2c(%eax),%eax
f010e070:	83 ec 08             	sub    $0x8,%esp
f010e073:	50                   	push   %eax
f010e074:	68 8d 08 13 f0       	push   $0xf013088d
f010e079:	e8 de 3a ff ff       	call   f0101b5c <cprintf>
f010e07e:	83 c4 10             	add    $0x10,%esp
	cprintf("  eip  0x%08x\n", tf->tf_eip);
f010e081:	8b 45 08             	mov    0x8(%ebp),%eax
f010e084:	8b 40 30             	mov    0x30(%eax),%eax
f010e087:	83 ec 08             	sub    $0x8,%esp
f010e08a:	50                   	push   %eax
f010e08b:	68 9c 08 13 f0       	push   $0xf013089c
f010e090:	e8 c7 3a ff ff       	call   f0101b5c <cprintf>
f010e095:	83 c4 10             	add    $0x10,%esp
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
f010e098:	8b 45 08             	mov    0x8(%ebp),%eax
f010e09b:	8b 40 34             	mov    0x34(%eax),%eax
f010e09e:	0f b7 c0             	movzwl %ax,%eax
f010e0a1:	83 ec 08             	sub    $0x8,%esp
f010e0a4:	50                   	push   %eax
f010e0a5:	68 ab 08 13 f0       	push   $0xf01308ab
f010e0aa:	e8 ad 3a ff ff       	call   f0101b5c <cprintf>
f010e0af:	83 c4 10             	add    $0x10,%esp
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
f010e0b2:	8b 45 08             	mov    0x8(%ebp),%eax
f010e0b5:	8b 40 38             	mov    0x38(%eax),%eax
f010e0b8:	83 ec 08             	sub    $0x8,%esp
f010e0bb:	50                   	push   %eax
f010e0bc:	68 be 08 13 f0       	push   $0xf01308be
f010e0c1:	e8 96 3a ff ff       	call   f0101b5c <cprintf>
f010e0c6:	83 c4 10             	add    $0x10,%esp
	cprintf("  esp  0x%08x\n", tf->tf_esp);
f010e0c9:	8b 45 08             	mov    0x8(%ebp),%eax
f010e0cc:	8b 40 3c             	mov    0x3c(%eax),%eax
f010e0cf:	83 ec 08             	sub    $0x8,%esp
f010e0d2:	50                   	push   %eax
f010e0d3:	68 cd 08 13 f0       	push   $0xf01308cd
f010e0d8:	e8 7f 3a ff ff       	call   f0101b5c <cprintf>
f010e0dd:	83 c4 10             	add    $0x10,%esp
	cprintf("  ss   0x----%04x\n", tf->tf_ss);
f010e0e0:	8b 45 08             	mov    0x8(%ebp),%eax
f010e0e3:	8b 40 40             	mov    0x40(%eax),%eax
f010e0e6:	0f b7 c0             	movzwl %ax,%eax
f010e0e9:	83 ec 08             	sub    $0x8,%esp
f010e0ec:	50                   	push   %eax
f010e0ed:	68 dc 08 13 f0       	push   $0xf01308dc
f010e0f2:	e8 65 3a ff ff       	call   f0101b5c <cprintf>
f010e0f7:	83 c4 10             	add    $0x10,%esp
}
f010e0fa:	90                   	nop
f010e0fb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010e0fe:	c9                   	leave  
f010e0ff:	c3                   	ret    

f010e100 <print_regs>:

void print_regs(struct PushRegs *regs)
{
f010e100:	55                   	push   %ebp
f010e101:	89 e5                	mov    %esp,%ebp
f010e103:	83 ec 08             	sub    $0x8,%esp
	cprintf("  edi  0x%08x\n", regs->reg_edi);
f010e106:	8b 45 08             	mov    0x8(%ebp),%eax
f010e109:	8b 00                	mov    (%eax),%eax
f010e10b:	83 ec 08             	sub    $0x8,%esp
f010e10e:	50                   	push   %eax
f010e10f:	68 ef 08 13 f0       	push   $0xf01308ef
f010e114:	e8 43 3a ff ff       	call   f0101b5c <cprintf>
f010e119:	83 c4 10             	add    $0x10,%esp
	cprintf("  esi  0x%08x\n", regs->reg_esi);
f010e11c:	8b 45 08             	mov    0x8(%ebp),%eax
f010e11f:	8b 40 04             	mov    0x4(%eax),%eax
f010e122:	83 ec 08             	sub    $0x8,%esp
f010e125:	50                   	push   %eax
f010e126:	68 fe 08 13 f0       	push   $0xf01308fe
f010e12b:	e8 2c 3a ff ff       	call   f0101b5c <cprintf>
f010e130:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebp  0x%08x\n", regs->reg_ebp);
f010e133:	8b 45 08             	mov    0x8(%ebp),%eax
f010e136:	8b 40 08             	mov    0x8(%eax),%eax
f010e139:	83 ec 08             	sub    $0x8,%esp
f010e13c:	50                   	push   %eax
f010e13d:	68 0d 09 13 f0       	push   $0xf013090d
f010e142:	e8 15 3a ff ff       	call   f0101b5c <cprintf>
f010e147:	83 c4 10             	add    $0x10,%esp
	cprintf("  oesp 0x%08x\n", regs->reg_oesp);
f010e14a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e14d:	8b 40 0c             	mov    0xc(%eax),%eax
f010e150:	83 ec 08             	sub    $0x8,%esp
f010e153:	50                   	push   %eax
f010e154:	68 1c 09 13 f0       	push   $0xf013091c
f010e159:	e8 fe 39 ff ff       	call   f0101b5c <cprintf>
f010e15e:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebx  0x%08x\n", regs->reg_ebx);
f010e161:	8b 45 08             	mov    0x8(%ebp),%eax
f010e164:	8b 40 10             	mov    0x10(%eax),%eax
f010e167:	83 ec 08             	sub    $0x8,%esp
f010e16a:	50                   	push   %eax
f010e16b:	68 2b 09 13 f0       	push   $0xf013092b
f010e170:	e8 e7 39 ff ff       	call   f0101b5c <cprintf>
f010e175:	83 c4 10             	add    $0x10,%esp
	cprintf("  edx  0x%08x\n", regs->reg_edx);
f010e178:	8b 45 08             	mov    0x8(%ebp),%eax
f010e17b:	8b 40 14             	mov    0x14(%eax),%eax
f010e17e:	83 ec 08             	sub    $0x8,%esp
f010e181:	50                   	push   %eax
f010e182:	68 3a 09 13 f0       	push   $0xf013093a
f010e187:	e8 d0 39 ff ff       	call   f0101b5c <cprintf>
f010e18c:	83 c4 10             	add    $0x10,%esp
	cprintf("  ecx  0x%08x\n", regs->reg_ecx);
f010e18f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e192:	8b 40 18             	mov    0x18(%eax),%eax
f010e195:	83 ec 08             	sub    $0x8,%esp
f010e198:	50                   	push   %eax
f010e199:	68 49 09 13 f0       	push   $0xf0130949
f010e19e:	e8 b9 39 ff ff       	call   f0101b5c <cprintf>
f010e1a3:	83 c4 10             	add    $0x10,%esp
	cprintf("  eax  0x%08x\n", regs->reg_eax);
f010e1a6:	8b 45 08             	mov    0x8(%ebp),%eax
f010e1a9:	8b 40 1c             	mov    0x1c(%eax),%eax
f010e1ac:	83 ec 08             	sub    $0x8,%esp
f010e1af:	50                   	push   %eax
f010e1b0:	68 58 09 13 f0       	push   $0xf0130958
f010e1b5:	e8 a2 39 ff ff       	call   f0101b5c <cprintf>
f010e1ba:	83 c4 10             	add    $0x10,%esp
}
f010e1bd:	90                   	nop
f010e1be:	c9                   	leave  
f010e1bf:	c3                   	ret    

f010e1c0 <irq_install_handler>:


void *irq_handlers[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} ;
void irq_install_handler(int irq, void (*handler)(struct Trapframe *tf))
{
f010e1c0:	55                   	push   %ebp
f010e1c1:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = handler;
f010e1c3:	8b 45 08             	mov    0x8(%ebp),%eax
f010e1c6:	8b 55 0c             	mov    0xc(%ebp),%edx
f010e1c9:	89 14 85 c0 63 81 f0 	mov    %edx,-0xf7e9c40(,%eax,4)
}
f010e1d0:	90                   	nop
f010e1d1:	5d                   	pop    %ebp
f010e1d2:	c3                   	ret    

f010e1d3 <irq_uninstall_handler>:
void irq_uninstall_handler(int irq)
{
f010e1d3:	55                   	push   %ebp
f010e1d4:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = NULL;
f010e1d6:	8b 45 08             	mov    0x8(%ebp),%eax
f010e1d9:	c7 04 85 c0 63 81 f0 	movl   $0x0,-0xf7e9c40(,%eax,4)
f010e1e0:	00 00 00 00 
}
f010e1e4:	90                   	nop
f010e1e5:	5d                   	pop    %ebp
f010e1e6:	c3                   	ret    

f010e1e7 <irq_dispatch>:
void irq_dispatch(struct Trapframe *tf)
{
f010e1e7:	55                   	push   %ebp
f010e1e8:	89 e5                	mov    %esp,%ebp
f010e1ea:	83 ec 18             	sub    $0x18,%esp
	void (*handler)(struct Trapframe *tf);
	int IRQNum = tf->tf_trapno - IRQ_OFFSET;
f010e1ed:	8b 45 08             	mov    0x8(%ebp),%eax
f010e1f0:	8b 40 28             	mov    0x28(%eax),%eax
f010e1f3:	83 e8 20             	sub    $0x20,%eax
f010e1f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	handler = irq_handlers[IRQNum] ;
f010e1f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e1fc:	8b 04 85 c0 63 81 f0 	mov    -0xf7e9c40(,%eax,4),%eax
f010e203:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (handler)
f010e206:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010e20a:	74 0e                	je     f010e21a <irq_dispatch+0x33>
	{
		handler(tf);
f010e20c:	83 ec 0c             	sub    $0xc,%esp
f010e20f:	ff 75 08             	pushl  0x8(%ebp)
f010e212:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e215:	ff d0                	call   *%eax
f010e217:	83 c4 10             	add    $0x10,%esp
	}

	//Send End Of Interrupt CMD to PIC
	pic_sendEOI(IRQNum);
f010e21a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e21d:	0f b6 c0             	movzbl %al,%eax
f010e220:	83 ec 0c             	sub    $0xc,%esp
f010e223:	50                   	push   %eax
f010e224:	e8 0e 9d ff ff       	call   f0107f37 <pic_sendEOI>
f010e229:	83 c4 10             	add    $0x10,%esp
}
f010e22c:	90                   	nop
f010e22d:	c9                   	leave  
f010e22e:	c3                   	ret    

f010e22f <trap_dispatch>:

static void trap_dispatch(struct Trapframe *tf)
{
f010e22f:	55                   	push   %ebp
f010e230:	89 e5                	mov    %esp,%ebp
f010e232:	57                   	push   %edi
f010e233:	56                   	push   %esi
f010e234:	53                   	push   %ebx
f010e235:	83 ec 1c             	sub    $0x1c,%esp
	// Handle processor exceptions.
	// LAB 3: Your code here.

	if(tf->tf_trapno == T_PGFLT)
f010e238:	8b 45 08             	mov    0x8(%ebp),%eax
f010e23b:	8b 40 28             	mov    0x28(%eax),%eax
f010e23e:	83 f8 0e             	cmp    $0xe,%eax
f010e241:	75 51                	jne    f010e294 <trap_dispatch+0x65>
	{
		//2016: Bypass the faulted instruction [used for some tests in which we need to resume the execution after an intended page fault]
		if (bypassInstrLength != 0)
f010e243:	a0 00 64 81 f0       	mov    0xf0816400,%al
f010e248:	84 c0                	test   %al,%al
f010e24a:	74 1f                	je     f010e26b <trap_dispatch+0x3c>
		{
			tf->tf_eip = (uint32*)((uint32)(tf->tf_eip) + bypassInstrLength);
f010e24c:	8b 45 08             	mov    0x8(%ebp),%eax
f010e24f:	8b 40 30             	mov    0x30(%eax),%eax
f010e252:	89 c2                	mov    %eax,%edx
f010e254:	a0 00 64 81 f0       	mov    0xf0816400,%al
f010e259:	0f b6 c0             	movzbl %al,%eax
f010e25c:	01 d0                	add    %edx,%eax
f010e25e:	89 c2                	mov    %eax,%edx
f010e260:	8b 45 08             	mov    0x8(%ebp),%eax
f010e263:	89 50 30             	mov    %edx,0x30(%eax)
			/*2024: commented. already will be returned to the trapret() in trapentry.S which return to the user/kernel caller code*/
			//kclock_resume();
			//env_pop_tf(tf);
			return;
f010e266:	e9 0c 01 00 00       	jmp    f010e377 <trap_dispatch+0x148>
		}

		//print_trapframe(tf);
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f010e26b:	83 ec 0c             	sub    $0xc,%esp
f010e26e:	6a 01                	push   $0x1
f010e270:	e8 ae 15 00 00       	call   f010f823 <isPageReplacmentAlgorithmLRU>
f010e275:	83 c4 10             	add    $0x10,%esp
f010e278:	85 c0                	test   %eax,%eax
f010e27a:	74 05                	je     f010e281 <trap_dispatch+0x52>
		{
			//cprintf("===========Table WS before updating time stamp========\n");
			//env_table_ws_print(curenv) ;
			update_WS_time_stamps();
f010e27c:	e8 c8 99 ff ff       	call   f0107c49 <update_WS_time_stamps>
		}
		fault_handler(tf);
f010e281:	83 ec 0c             	sub    $0xc,%esp
f010e284:	ff 75 08             	pushl  0x8(%ebp)
f010e287:	e8 c3 16 00 00       	call   f010f94f <fault_handler>
f010e28c:	83 c4 10             	add    $0x10,%esp
f010e28f:	e9 e3 00 00 00       	jmp    f010e377 <trap_dispatch+0x148>
	}
	else if (tf->tf_trapno == T_SYSCALL)
f010e294:	8b 45 08             	mov    0x8(%ebp),%eax
f010e297:	8b 40 28             	mov    0x28(%eax),%eax
f010e29a:	83 f8 30             	cmp    $0x30,%eax
f010e29d:	75 6e                	jne    f010e30d <trap_dispatch+0xde>
	{
		/* If the original status of the interrupt is ENABLED (before getting into kernel),
		 * Then, re-enable the interrupts & resume the clock during the system calls
		 * to allow switching between processes
		 */
		if (tf->tf_eflags & FL_IF)
f010e29f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2a2:	8b 40 38             	mov    0x38(%eax),%eax
f010e2a5:	25 00 02 00 00       	and    $0x200,%eax
f010e2aa:	85 c0                	test   %eax,%eax
f010e2ac:	74 06                	je     f010e2b4 <trap_dispatch+0x85>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f010e2ae:	fb                   	sti    
		{
			sti();
			kclock_resume();
f010e2af:	e8 8f 79 ff ff       	call   f0105c43 <kclock_resume>
		}
		//cprintf("\nserving system call #%d\n", tf->tf_regs.reg_eax);
		uint32 ret = syscall(tf->tf_regs.reg_eax
f010e2b4:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2b7:	8b 78 04             	mov    0x4(%eax),%edi
f010e2ba:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2bd:	8b 30                	mov    (%eax),%esi
f010e2bf:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2c2:	8b 58 10             	mov    0x10(%eax),%ebx
f010e2c5:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2c8:	8b 48 18             	mov    0x18(%eax),%ecx
f010e2cb:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2ce:	8b 50 14             	mov    0x14(%eax),%edx
f010e2d1:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2d4:	8b 40 1c             	mov    0x1c(%eax),%eax
f010e2d7:	83 ec 08             	sub    $0x8,%esp
f010e2da:	57                   	push   %edi
f010e2db:	56                   	push   %esi
f010e2dc:	53                   	push   %ebx
f010e2dd:	51                   	push   %ecx
f010e2de:	52                   	push   %edx
f010e2df:	50                   	push   %eax
f010e2e0:	e8 9d 0c 00 00       	call   f010ef82 <syscall>
f010e2e5:	83 c4 20             	add    $0x20,%esp
f010e2e8:	89 45 e0             	mov    %eax,-0x20(%ebp)
				,tf->tf_regs.reg_ecx
				,tf->tf_regs.reg_ebx
				,tf->tf_regs.reg_edi
				,tf->tf_regs.reg_esi);

		tf->tf_regs.reg_eax = ret;
f010e2eb:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2ee:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010e2f1:	89 50 1c             	mov    %edx,0x1c(%eax)

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e2f4:	9c                   	pushf  
f010e2f5:	58                   	pop    %eax
f010e2f6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f010e2f9:	8b 45 e4             	mov    -0x1c(%ebp),%eax

		/*If still enabled, Disable the interrupt & stop clock before getting into user again
		 */
		if (read_eflags() & FL_IF)
f010e2fc:	25 00 02 00 00       	and    $0x200,%eax
f010e301:	85 c0                	test   %eax,%eax
f010e303:	74 72                	je     f010e377 <trap_dispatch+0x148>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f010e305:	fa                   	cli    
		{
			cli();
			kclock_stop();
f010e306:	e8 10 79 ff ff       	call   f0105c1b <kclock_stop>
f010e30b:	eb 6a                	jmp    f010e377 <trap_dispatch+0x148>
		}
		//cprintf("ret val form syscall = %d\n", ret);
	}
	else if(tf->tf_trapno == T_DBLFLT)
f010e30d:	8b 45 08             	mov    0x8(%ebp),%eax
f010e310:	8b 40 28             	mov    0x28(%eax),%eax
f010e313:	83 f8 08             	cmp    $0x8,%eax
f010e316:	75 17                	jne    f010e32f <trap_dispatch+0x100>
	{
		panic("double fault!!");
f010e318:	83 ec 04             	sub    $0x4,%esp
f010e31b:	68 67 09 13 f0       	push   $0xf0130967
f010e320:	68 29 01 00 00       	push   $0x129
f010e325:	68 76 09 13 f0       	push   $0xf0130976
f010e32a:	e8 80 2b ff ff       	call   f0100eaf <_panic>
	}
	else
	{
		// Unexpected trap: The user process or the kernel has a bug.
		print_trapframe(tf);
f010e32f:	83 ec 0c             	sub    $0xc,%esp
f010e332:	ff 75 08             	pushl  0x8(%ebp)
f010e335:	e8 a3 fc ff ff       	call   f010dfdd <print_trapframe>
f010e33a:	83 c4 10             	add    $0x10,%esp
		if (tf->tf_cs == GD_KT)
f010e33d:	8b 45 08             	mov    0x8(%ebp),%eax
f010e340:	8b 40 34             	mov    0x34(%eax),%eax
f010e343:	66 83 f8 08          	cmp    $0x8,%ax
f010e347:	75 17                	jne    f010e360 <trap_dispatch+0x131>
		{
			panic("unhandled trap in kernel");
f010e349:	83 ec 04             	sub    $0x4,%esp
f010e34c:	68 87 09 13 f0       	push   $0xf0130987
f010e351:	68 31 01 00 00       	push   $0x131
f010e356:	68 76 09 13 f0       	push   $0xf0130976
f010e35b:	e8 4f 2b ff ff       	call   f0100eaf <_panic>
		}
		else
		{
			//env_destroy(curenv);
			panic("unhandled trap in user program");
f010e360:	83 ec 04             	sub    $0x4,%esp
f010e363:	68 a0 09 13 f0       	push   $0xf01309a0
f010e368:	68 36 01 00 00       	push   $0x136
f010e36d:	68 76 09 13 f0       	push   $0xf0130976
f010e372:	e8 38 2b ff ff       	call   f0100eaf <_panic>
		}
	}
}
f010e377:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010e37a:	5b                   	pop    %ebx
f010e37b:	5e                   	pop    %esi
f010e37c:	5f                   	pop    %edi
f010e37d:	5d                   	pop    %ebp
f010e37e:	c3                   	ret    

f010e37f <trap>:

void trap(struct Trapframe *tf)
{
f010e37f:	55                   	push   %ebp
f010e380:	89 e5                	mov    %esp,%ebp
f010e382:	57                   	push   %edi
f010e383:	56                   	push   %esi
f010e384:	53                   	push   %ebx
f010e385:	83 ec 3c             	sub    $0x3c,%esp
	/* to avoid counting down on the current process while handling exceptions
	 * This avoid pending clock interrupt after returning from the trap.
	 * NOTE: interrupt is automatically disabled by the interrupt cycle (by marking all traps as "Interrupt Gates").
	 * Resume the clock and Re-enable the interrupt whenever required (e.g. in system calls).
	 */
	kclock_stop();
f010e388:	e8 8e 78 ff ff       	call   f0105c1b <kclock_stop>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e38d:	9c                   	pushf  
f010e38e:	58                   	pop    %eax
f010e38f:	89 45 c8             	mov    %eax,-0x38(%ebp)
        return eflags;
f010e392:	8b 45 c8             	mov    -0x38(%ebp),%eax

	//[2] Some validations

	//2024 check if interrupt is enabled during the trap handler, then panic
	uint32 flags = read_eflags();
f010e395:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (flags & FL_IF)
f010e398:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e39b:	25 00 02 00 00       	and    $0x200,%eax
f010e3a0:	85 c0                	test   %eax,%eax
f010e3a2:	74 25                	je     f010e3c9 <trap+0x4a>
	{
		print_trapframe(tf);
f010e3a4:	83 ec 0c             	sub    $0xc,%esp
f010e3a7:	ff 75 08             	pushl  0x8(%ebp)
f010e3aa:	e8 2e fc ff ff       	call   f010dfdd <print_trapframe>
f010e3af:	83 c4 10             	add    $0x10,%esp
		panic("trap(): interrupt is enabled while it's expected to be disabled\n");
f010e3b2:	83 ec 04             	sub    $0x4,%esp
f010e3b5:	68 c0 09 13 f0       	push   $0xf01309c0
f010e3ba:	68 4c 01 00 00       	push   $0x14c
f010e3bf:	68 76 09 13 f0       	push   $0xf0130976
f010e3c4:	e8 e6 2a ff ff       	call   f0100eaf <_panic>
	}

	int userTrap = 0;
f010e3c9:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	struct Env* cur_env = get_cpu_proc(); //the current running Environment (if any)
f010e3d0:	e8 43 d6 ff ff       	call   f010ba18 <get_cpu_proc>
f010e3d5:	89 45 d8             	mov    %eax,-0x28(%ebp)

	if ((tf->tf_cs & 3) == 3)
f010e3d8:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3db:	8b 40 34             	mov    0x34(%eax),%eax
f010e3de:	0f b7 c0             	movzwl %ax,%eax
f010e3e1:	83 e0 03             	and    $0x3,%eax
f010e3e4:	83 f8 03             	cmp    $0x3,%eax
f010e3e7:	0f 85 03 01 00 00    	jne    f010e4f0 <trap+0x171>
	{
		userTrap = 1;
f010e3ed:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		assert(cur_env && cur_env->env_status == ENV_RUNNING);	//environment should be exist & run
f010e3f4:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f010e3f8:	74 0b                	je     f010e405 <trap+0x86>
f010e3fa:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e3fd:	8b 40 18             	mov    0x18(%eax),%eax
f010e400:	83 f8 02             	cmp    $0x2,%eax
f010e403:	74 19                	je     f010e41e <trap+0x9f>
f010e405:	68 04 0a 13 f0       	push   $0xf0130a04
f010e40a:	68 32 0a 13 f0       	push   $0xf0130a32
f010e40f:	68 55 01 00 00       	push   $0x155
f010e414:	68 76 09 13 f0       	push   $0xf0130976
f010e419:	e8 91 2a ff ff       	call   f0100eaf <_panic>
		//cprintf("curenv->env_tf @ %x, tf param @ %x\n", curenv->env_tf , tf);
		//assert(cur_env->env_tf == tf);	//tf should be placed in the kernel stack of this process (@e->env_tf)
		if (cur_env->env_tf != tf)
f010e41e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e421:	8b 00                	mov    (%eax),%eax
f010e423:	3b 45 08             	cmp    0x8(%ebp),%eax
f010e426:	0f 84 c4 00 00 00    	je     f010e4f0 <trap+0x171>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e42c:	9c                   	pushf  
f010e42d:	58                   	pop    %eax
f010e42e:	89 45 d0             	mov    %eax,-0x30(%ebp)
        return eflags;
f010e431:	8b 45 d0             	mov    -0x30(%ebp),%eax
		{
			cprintf("\n[%s - %d] trap #%d - %s (cr2 = %x) tf va = %x - eip = %x - IEN = %d\n", userTrap == 1? "USER" : "KERNEL", userTrap == 1? cur_env->env_id : 0, tf->tf_trapno, trapname(tf->tf_trapno), rcr2(), tf, tf->tf_eip, (read_eflags() & FL_IF) == 0? 0 : 1);
f010e434:	25 00 02 00 00       	and    $0x200,%eax
f010e439:	85 c0                	test   %eax,%eax
f010e43b:	0f 95 c0             	setne  %al
f010e43e:	0f b6 c0             	movzbl %al,%eax
f010e441:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010e444:	8b 45 08             	mov    0x8(%ebp),%eax
f010e447:	8b 78 30             	mov    0x30(%eax),%edi

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010e44a:	0f 20 d0             	mov    %cr2,%eax
f010e44d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	return val;
f010e450:	8b 75 e4             	mov    -0x1c(%ebp),%esi
f010e453:	8b 45 08             	mov    0x8(%ebp),%eax
f010e456:	8b 40 28             	mov    0x28(%eax),%eax
f010e459:	83 ec 0c             	sub    $0xc,%esp
f010e45c:	50                   	push   %eax
f010e45d:	e8 15 ea ff ff       	call   f010ce77 <trapname>
f010e462:	83 c4 10             	add    $0x10,%esp
f010e465:	89 c3                	mov    %eax,%ebx
f010e467:	8b 45 08             	mov    0x8(%ebp),%eax
f010e46a:	8b 48 28             	mov    0x28(%eax),%ecx
f010e46d:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
f010e471:	75 08                	jne    f010e47b <trap+0xfc>
f010e473:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e476:	8b 40 10             	mov    0x10(%eax),%eax
f010e479:	eb 05                	jmp    f010e480 <trap+0x101>
f010e47b:	b8 00 00 00 00       	mov    $0x0,%eax
f010e480:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
f010e484:	75 07                	jne    f010e48d <trap+0x10e>
f010e486:	ba 47 0a 13 f0       	mov    $0xf0130a47,%edx
f010e48b:	eb 05                	jmp    f010e492 <trap+0x113>
f010e48d:	ba 4c 0a 13 f0       	mov    $0xf0130a4c,%edx
f010e492:	83 ec 0c             	sub    $0xc,%esp
f010e495:	ff 75 c4             	pushl  -0x3c(%ebp)
f010e498:	57                   	push   %edi
f010e499:	ff 75 08             	pushl  0x8(%ebp)
f010e49c:	56                   	push   %esi
f010e49d:	53                   	push   %ebx
f010e49e:	51                   	push   %ecx
f010e49f:	50                   	push   %eax
f010e4a0:	52                   	push   %edx
f010e4a1:	68 54 0a 13 f0       	push   $0xf0130a54
f010e4a6:	e8 b1 36 ff ff       	call   f0101b5c <cprintf>
f010e4ab:	83 c4 30             	add    $0x30,%esp
			panic("USER TRAP [%d:%s]: unexpected trapframe! cur_env->env_tf (%x) != tf (%x). Kernel stack [%x, %x)",
f010e4ae:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e4b1:	8b 40 70             	mov    0x70(%eax),%eax
f010e4b4:	8d b0 00 80 00 00    	lea    0x8000(%eax),%esi
f010e4ba:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e4bd:	8b 48 70             	mov    0x70(%eax),%ecx
f010e4c0:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e4c3:	8b 10                	mov    (%eax),%edx
f010e4c5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e4c8:	8d 58 20             	lea    0x20(%eax),%ebx
f010e4cb:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e4ce:	8b 40 10             	mov    0x10(%eax),%eax
f010e4d1:	83 ec 0c             	sub    $0xc,%esp
f010e4d4:	56                   	push   %esi
f010e4d5:	51                   	push   %ecx
f010e4d6:	ff 75 08             	pushl  0x8(%ebp)
f010e4d9:	52                   	push   %edx
f010e4da:	53                   	push   %ebx
f010e4db:	50                   	push   %eax
f010e4dc:	68 9c 0a 13 f0       	push   $0xf0130a9c
f010e4e1:	68 5c 01 00 00       	push   $0x15c
f010e4e6:	68 76 09 13 f0       	push   $0xf0130976
f010e4eb:	e8 bf 29 ff ff       	call   f0100eaf <_panic>
	//	if (tf->tf_trapno == T_SYSCALL)
	//	{
	//		cprintf("System Call #%d\n", tf->tf_regs.reg_eax);
	//	}
	//[3] Handle the incoming trap/interrupt
	if (tf->tf_trapno >= IRQ_OFFSET && tf->tf_trapno < IRQ_OFFSET + MAX_IRQS)
f010e4f0:	8b 45 08             	mov    0x8(%ebp),%eax
f010e4f3:	8b 40 28             	mov    0x28(%eax),%eax
f010e4f6:	83 f8 1f             	cmp    $0x1f,%eax
f010e4f9:	76 1b                	jbe    f010e516 <trap+0x197>
f010e4fb:	8b 45 08             	mov    0x8(%ebp),%eax
f010e4fe:	8b 40 28             	mov    0x28(%eax),%eax
f010e501:	83 f8 2f             	cmp    $0x2f,%eax
f010e504:	77 10                	ja     f010e516 <trap+0x197>
	{
		irq_dispatch(tf);
f010e506:	83 ec 0c             	sub    $0xc,%esp
f010e509:	ff 75 08             	pushl  0x8(%ebp)
f010e50c:	e8 d6 fc ff ff       	call   f010e1e7 <irq_dispatch>
f010e511:	83 c4 10             	add    $0x10,%esp
f010e514:	eb 0e                	jmp    f010e524 <trap+0x1a5>
	}
	else
	{
		trap_dispatch(tf);
f010e516:	83 ec 0c             	sub    $0xc,%esp
f010e519:	ff 75 08             	pushl  0x8(%ebp)
f010e51c:	e8 0e fd ff ff       	call   f010e22f <trap_dispatch>
f010e521:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e524:	9c                   	pushf  
f010e525:	58                   	pop    %eax
f010e526:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        return eflags;
f010e529:	8b 45 d4             	mov    -0x2c(%ebp),%eax

	//cprintf("will be returned to the trapret() \n");
	/*2024: will be returned to the trapret() in trapentry.S which return to the caller*/

	//[4] Make sure that the interrupt is disabled before executing the trapret()
	uint32 IEN = read_eflags() & FL_IF;
f010e52c:	25 00 02 00 00       	and    $0x200,%eax
f010e531:	89 45 cc             	mov    %eax,-0x34(%ebp)
	assert(IEN == 0);
f010e534:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010e538:	74 19                	je     f010e553 <trap+0x1d4>
f010e53a:	68 fc 0a 13 f0       	push   $0xf0130afc
f010e53f:	68 32 0a 13 f0       	push   $0xf0130a32
f010e544:	68 73 01 00 00       	push   $0x173
f010e549:	68 76 09 13 f0       	push   $0xf0130976
f010e54e:	e8 5c 29 ff ff       	call   f0100eaf <_panic>

	//cprintf("will resume the clock\n");

	//[5] Resume the clock
	kclock_resume();
f010e553:	e8 eb 76 ff ff       	call   f0105c43 <kclock_resume>
	//cprintf("\nclock is resumed with counter = %d.\n", kclock_read_cnt0_latch());
	//	cprintf("[tf] tf @%x - tf.cs = %x - tf.eip = %x - tf.eax = %d\n", tf, tf->tf_cs,tf->tf_eip, tf->tf_regs.reg_eax );
}
f010e558:	90                   	nop
f010e559:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010e55c:	5b                   	pop    %ebx
f010e55d:	5e                   	pop    %esi
f010e55e:	5f                   	pop    %edi
f010e55f:	5d                   	pop    %ebp
f010e560:	c3                   	ret    
f010e561:	90                   	nop

f010e562 <DBL_FAULT>:
	jmp _alltraps

.text
/* Lab 3: Your code here for generating entry points for the different traps.
*/
TRAPHANDLER(DBL_FAULT, T_DBLFLT)					//8 double fault
f010e562:	6a 08                	push   $0x8
f010e564:	e9 ed 00 00 00       	jmp    f010e656 <_alltraps>
f010e569:	90                   	nop

f010e56a <PAGE_FAULT>:
TRAPHANDLER(PAGE_FAULT, T_PGFLT)					//14 page fault
f010e56a:	6a 0e                	push   $0xe
f010e56c:	e9 e5 00 00 00       	jmp    f010e656 <_alltraps>
f010e571:	90                   	nop

f010e572 <IRQ0_CLK_HANDLER>:
TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER, IRQ0_Clock)		//32 the first IRQ (clock iterrrupt)
f010e572:	6a 00                	push   $0x0
f010e574:	6a 20                	push   $0x20
f010e576:	e9 db 00 00 00       	jmp    f010e656 <_alltraps>
f010e57b:	90                   	nop

f010e57c <IRQ1_KBD_HANDLER>:
TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER, IRQ1_KB	)		//33 keyboard interrupt request
f010e57c:	6a 00                	push   $0x0
f010e57e:	6a 21                	push   $0x21
f010e580:	e9 d1 00 00 00       	jmp    f010e656 <_alltraps>
f010e585:	90                   	nop

f010e586 <SYSCALL_HANDLER>:
TRAPHANDLER_NOEC(SYSCALL_HANDLER, T_SYSCALL)		//48 SYSTEM CALLS
f010e586:	6a 00                	push   $0x0
f010e588:	6a 30                	push   $0x30
f010e58a:	e9 c7 00 00 00       	jmp    f010e656 <_alltraps>
f010e58f:	90                   	nop

f010e590 <ALL_FAULTS0>:

// FOS 2010
//TRAPHANDLER(GP_FAULT, T_GPFLT)

TRAPHANDLER_NOEC(ALL_FAULTS0, T_DIVIDE)		//0			// divide error
f010e590:	6a 00                	push   $0x0
f010e592:	6a 00                	push   $0x0
f010e594:	e9 bd 00 00 00       	jmp    f010e656 <_alltraps>
f010e599:	90                   	nop

f010e59a <ALL_FAULTS1>:
TRAPHANDLER_NOEC(ALL_FAULTS1, T_DEBUG   )	//1			// debug exception
f010e59a:	6a 00                	push   $0x0
f010e59c:	6a 01                	push   $0x1
f010e59e:	e9 b3 00 00 00       	jmp    f010e656 <_alltraps>
f010e5a3:	90                   	nop

f010e5a4 <ALL_FAULTS2>:
TRAPHANDLER_NOEC(ALL_FAULTS2,  T_NMI       )//2			// NMI: non-maskable interrupt
f010e5a4:	6a 00                	push   $0x0
f010e5a6:	6a 02                	push   $0x2
f010e5a8:	e9 a9 00 00 00       	jmp    f010e656 <_alltraps>
f010e5ad:	90                   	nop

f010e5ae <ALL_FAULTS3>:
TRAPHANDLER_NOEC(ALL_FAULTS3,  T_BRKPT     )//3			// breakpoint
f010e5ae:	6a 00                	push   $0x0
f010e5b0:	6a 03                	push   $0x3
f010e5b2:	e9 9f 00 00 00       	jmp    f010e656 <_alltraps>
f010e5b7:	90                   	nop

f010e5b8 <ALL_FAULTS4>:
TRAPHANDLER_NOEC(ALL_FAULTS4,  T_OFLOW     )//4			// overflow
f010e5b8:	6a 00                	push   $0x0
f010e5ba:	6a 04                	push   $0x4
f010e5bc:	e9 95 00 00 00       	jmp    f010e656 <_alltraps>
f010e5c1:	90                   	nop

f010e5c2 <ALL_FAULTS5>:
TRAPHANDLER_NOEC(ALL_FAULTS5,  T_BOUND     )//5			// bounds check
f010e5c2:	6a 00                	push   $0x0
f010e5c4:	6a 05                	push   $0x5
f010e5c6:	e9 8b 00 00 00       	jmp    f010e656 <_alltraps>
f010e5cb:	90                   	nop

f010e5cc <ALL_FAULTS6>:
TRAPHANDLER_NOEC(ALL_FAULTS6,  T_ILLOP     )//6			// illegal opcode
f010e5cc:	6a 00                	push   $0x0
f010e5ce:	6a 06                	push   $0x6
f010e5d0:	e9 81 00 00 00       	jmp    f010e656 <_alltraps>
f010e5d5:	90                   	nop

f010e5d6 <ALL_FAULTS7>:
TRAPHANDLER_NOEC(ALL_FAULTS7,  T_DEVICE    )//7			// device not available
f010e5d6:	6a 00                	push   $0x0
f010e5d8:	6a 07                	push   $0x7
f010e5da:	eb 7a                	jmp    f010e656 <_alltraps>

f010e5dc <ALL_FAULTS10>:
//TRAPHANDLER(ALL_FAULTS8,  T_DBLFLT)     	//8			// double fault
//TRAPHANDLER_NOEC(ALL_FAULTS9,  9   )		//9			// reserved (not generated by recent processors)
TRAPHANDLER(ALL_FAULTS10,  T_TSS       )	//10		// invalid task switch segment
f010e5dc:	6a 0a                	push   $0xa
f010e5de:	eb 76                	jmp    f010e656 <_alltraps>

f010e5e0 <ALL_FAULTS11>:
TRAPHANDLER(ALL_FAULTS11,  T_SEGNP     )	//11		// segment not present
f010e5e0:	6a 0b                	push   $0xb
f010e5e2:	eb 72                	jmp    f010e656 <_alltraps>

f010e5e4 <ALL_FAULTS12>:
TRAPHANDLER(ALL_FAULTS12,  T_STACK     )	//12		// stack exception
f010e5e4:	6a 0c                	push   $0xc
f010e5e6:	eb 6e                	jmp    f010e656 <_alltraps>

f010e5e8 <ALL_FAULTS13>:
TRAPHANDLER(ALL_FAULTS13,  T_GPFLT     )	//13		// General protection fault
f010e5e8:	6a 0d                	push   $0xd
f010e5ea:	eb 6a                	jmp    f010e656 <_alltraps>

f010e5ec <ALL_FAULTS16>:
//TRAPHANDLER(ALL_FAULTS14,  T_PGFLT)     	//14		// page fault
//TRAPHANDLER(ALL_FAULTS,  15    )			//15 		// reserved
TRAPHANDLER_NOEC(ALL_FAULTS16,  T_FPERR    )//16		// floating point error
f010e5ec:	6a 00                	push   $0x0
f010e5ee:	6a 10                	push   $0x10
f010e5f0:	eb 64                	jmp    f010e656 <_alltraps>

f010e5f2 <ALL_FAULTS17>:
TRAPHANDLER(ALL_FAULTS17,  T_ALIGN     )	//17		// Alignment check
f010e5f2:	6a 11                	push   $0x11
f010e5f4:	eb 60                	jmp    f010e656 <_alltraps>

f010e5f6 <ALL_FAULTS18>:
TRAPHANDLER_NOEC(ALL_FAULTS18,  T_MCHK     )//18		// machine check
f010e5f6:	6a 00                	push   $0x0
f010e5f8:	6a 12                	push   $0x12
f010e5fa:	eb 5a                	jmp    f010e656 <_alltraps>

f010e5fc <ALL_FAULTS19>:
TRAPHANDLER_NOEC(ALL_FAULTS19,  19      )	//19		// the last one
f010e5fc:	6a 00                	push   $0x0
f010e5fe:	6a 13                	push   $0x13
f010e600:	eb 54                	jmp    f010e656 <_alltraps>

f010e602 <ALL_FAULTS34>:

//TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER,IRQ0_Clock)			//32 the first IRQ (clock iterrrupt)
//TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER,IRQ1_KB	)			//33 keyboard interrupt request
TRAPHANDLER_NOEC(ALL_FAULTS34,      34		)//34
f010e602:	6a 00                	push   $0x0
f010e604:	6a 22                	push   $0x22
f010e606:	eb 4e                	jmp    f010e656 <_alltraps>

f010e608 <ALL_FAULTS35>:
TRAPHANDLER_NOEC(ALL_FAULTS35,		35		)//35
f010e608:	6a 00                	push   $0x0
f010e60a:	6a 23                	push   $0x23
f010e60c:	eb 48                	jmp    f010e656 <_alltraps>

f010e60e <ALL_FAULTS36>:
TRAPHANDLER_NOEC(ALL_FAULTS36,      36      )//36
f010e60e:	6a 00                	push   $0x0
f010e610:	6a 24                	push   $0x24
f010e612:	eb 42                	jmp    f010e656 <_alltraps>

f010e614 <ALL_FAULTS37>:
TRAPHANDLER_NOEC(ALL_FAULTS37,      37      )//37
f010e614:	6a 00                	push   $0x0
f010e616:	6a 25                	push   $0x25
f010e618:	eb 3c                	jmp    f010e656 <_alltraps>

f010e61a <ALL_FAULTS38>:
TRAPHANDLER_NOEC(ALL_FAULTS38,      38		)//38
f010e61a:	6a 00                	push   $0x0
f010e61c:	6a 26                	push   $0x26
f010e61e:	eb 36                	jmp    f010e656 <_alltraps>

f010e620 <ALL_FAULTS39>:
TRAPHANDLER_NOEC(ALL_FAULTS39,      39		)//39
f010e620:	6a 00                	push   $0x0
f010e622:	6a 27                	push   $0x27
f010e624:	eb 30                	jmp    f010e656 <_alltraps>

f010e626 <ALL_FAULTS40>:
TRAPHANDLER_NOEC(ALL_FAULTS40,      40		)//40
f010e626:	6a 00                	push   $0x0
f010e628:	6a 28                	push   $0x28
f010e62a:	eb 2a                	jmp    f010e656 <_alltraps>

f010e62c <ALL_FAULTS41>:
TRAPHANDLER_NOEC(ALL_FAULTS41,      41		)//41
f010e62c:	6a 00                	push   $0x0
f010e62e:	6a 29                	push   $0x29
f010e630:	eb 24                	jmp    f010e656 <_alltraps>

f010e632 <ALL_FAULTS42>:
TRAPHANDLER_NOEC(ALL_FAULTS42,      42		)//42
f010e632:	6a 00                	push   $0x0
f010e634:	6a 2a                	push   $0x2a
f010e636:	eb 1e                	jmp    f010e656 <_alltraps>

f010e638 <ALL_FAULTS43>:
TRAPHANDLER_NOEC(ALL_FAULTS43,      43		)//43
f010e638:	6a 00                	push   $0x0
f010e63a:	6a 2b                	push   $0x2b
f010e63c:	eb 18                	jmp    f010e656 <_alltraps>

f010e63e <ALL_FAULTS44>:
TRAPHANDLER_NOEC(ALL_FAULTS44,      44		)//44
f010e63e:	6a 00                	push   $0x0
f010e640:	6a 2c                	push   $0x2c
f010e642:	eb 12                	jmp    f010e656 <_alltraps>

f010e644 <ALL_FAULTS45>:
TRAPHANDLER_NOEC(ALL_FAULTS45,      45		)//45
f010e644:	6a 00                	push   $0x0
f010e646:	6a 2d                	push   $0x2d
f010e648:	eb 0c                	jmp    f010e656 <_alltraps>

f010e64a <ALL_FAULTS46>:
TRAPHANDLER_NOEC(ALL_FAULTS46,      46		)//46
f010e64a:	6a 00                	push   $0x0
f010e64c:	6a 2e                	push   $0x2e
f010e64e:	eb 06                	jmp    f010e656 <_alltraps>

f010e650 <ALL_FAULTS47>:
TRAPHANDLER_NOEC(ALL_FAULTS47,      47		)//47 		//the last IRQ
f010e650:	6a 00                	push   $0x0
f010e652:	6a 2f                	push   $0x2f
f010e654:	eb 00                	jmp    f010e656 <_alltraps>

f010e656 <_alltraps>:

/*
 * Lab 3: Your code here for _alltraps
 */
_alltraps:
push 	%ds
f010e656:	1e                   	push   %ds
push 	%es
f010e657:	06                   	push   %es
pushal
f010e658:	60                   	pusha  

mov 	$(GD_KD), %ax
f010e659:	66 b8 10 00          	mov    $0x10,%ax
mov 	%ax,%ds
f010e65d:	8e d8                	mov    %eax,%ds
mov 	%ax,%es
f010e65f:	8e c0                	mov    %eax,%es

push 	%esp /* push the pointer to the tf into the stack to be passed as a param to the trap()*/
f010e661:	54                   	push   %esp
call 	trap
f010e662:	e8 18 fd ff ff       	call   f010e37f <trap>

pop 	%ecx /* pop the pointer to the tf from the stack so that the stack top is at the beginning values of the registers pushed by pusha*/
f010e667:	59                   	pop    %ecx

f010e668 <trapret>:
.globl trapret
trapret:
popal
f010e668:	61                   	popa   
pop 	%es
f010e669:	07                   	pop    %es
pop 	%ds
f010e66a:	1f                   	pop    %ds
add 	$(8),%esp /*skipping the trap_no and the error code so that the stack top is at the old eip value*/
f010e66b:	83 c4 08             	add    $0x8,%esp
iret
f010e66e:	cf                   	iret   

f010e66f <sys_cputs>:

// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void sys_cputs(const char *s, uint32 len, uint8 printProgName, int color)
{
f010e66f:	55                   	push   %ebp
f010e670:	89 e5                	mov    %esp,%ebp
f010e672:	83 ec 28             	sub    $0x28,%esp
f010e675:	8b 45 10             	mov    0x10(%ebp),%eax
f010e678:	88 45 e4             	mov    %al,-0x1c(%ebp)
	struct Env* cur_env = get_cpu_proc();
f010e67b:	e8 98 d3 ff ff       	call   f010ba18 <get_cpu_proc>
f010e680:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010e683:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e687:	75 16                	jne    f010e69f <sys_cputs+0x30>
f010e689:	68 b0 0c 13 f0       	push   $0xf0130cb0
f010e68e:	68 c0 0c 13 f0       	push   $0xf0130cc0
f010e693:	6a 22                	push   $0x22
f010e695:	68 d5 0c 13 f0       	push   $0xf0130cd5
f010e69a:	e8 10 28 ff ff       	call   f0100eaf <_panic>

	pushcli();	//disable interrupts
f010e69f:	e8 8c 99 ff ff       	call   f0108030 <pushcli>
	{
		// Check that the user has permission to read memory [s, s+len).
		// Destroy the environment if not.
		current_text_color = color; // setting text color to be used in cga_putc()
f010e6a4:	8b 45 14             	mov    0x14(%ebp),%eax
f010e6a7:	a3 f0 6a 85 f0       	mov    %eax,0xf0856af0
		{
			// Print the string supplied by the user.
			if (printProgName)
f010e6ac:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
f010e6b0:	74 1e                	je     f010e6d0 <sys_cputs+0x61>
				cprintf("[%s %d] ",cur_env->prog_name, cur_env->env_id);
f010e6b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e6b5:	8b 40 10             	mov    0x10(%eax),%eax
f010e6b8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010e6bb:	83 c2 20             	add    $0x20,%edx
f010e6be:	83 ec 04             	sub    $0x4,%esp
f010e6c1:	50                   	push   %eax
f010e6c2:	52                   	push   %edx
f010e6c3:	68 e9 0c 13 f0       	push   $0xf0130ce9
f010e6c8:	e8 8f 34 ff ff       	call   f0101b5c <cprintf>
f010e6cd:	83 c4 10             	add    $0x10,%esp
			cprintf("%.*s",len, s);
f010e6d0:	83 ec 04             	sub    $0x4,%esp
f010e6d3:	ff 75 08             	pushl  0x8(%ebp)
f010e6d6:	ff 75 0c             	pushl  0xc(%ebp)
f010e6d9:	68 f2 0c 13 f0       	push   $0xf0130cf2
f010e6de:	e8 79 34 ff ff       	call   f0101b5c <cprintf>
f010e6e3:	83 c4 10             	add    $0x10,%esp
		}
		current_text_color = TEXT_DEFAULT_CLR; //restore default text color
f010e6e6:	c7 05 f0 6a 85 f0 00 	movl   $0x700,0xf0856af0
f010e6ed:	07 00 00 
	}
	popcli();	//enable interrupts
f010e6f0:	e8 8d 99 ff ff       	call   f0108082 <popcli>
}
f010e6f5:	90                   	nop
f010e6f6:	c9                   	leave  
f010e6f7:	c3                   	ret    

f010e6f8 <sys_cputc>:


// Print a char to the system console.
static void sys_cputc(const char c)
{
f010e6f8:	55                   	push   %ebp
f010e6f9:	89 e5                	mov    %esp,%ebp
f010e6fb:	83 ec 18             	sub    $0x18,%esp
f010e6fe:	8b 45 08             	mov    0x8(%ebp),%eax
f010e701:	88 45 f4             	mov    %al,-0xc(%ebp)
	// Print the char supplied by the user.
	cprintf("%c",c);
f010e704:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
f010e708:	83 ec 08             	sub    $0x8,%esp
f010e70b:	50                   	push   %eax
f010e70c:	68 f7 0c 13 f0       	push   $0xf0130cf7
f010e711:	e8 46 34 ff ff       	call   f0101b5c <cprintf>
f010e716:	83 c4 10             	add    $0x10,%esp
}
f010e719:	90                   	nop
f010e71a:	c9                   	leave  
f010e71b:	c3                   	ret    

f010e71c <sys_cgetc>:

// Read a character from the system console.
// Returns the character.
static int
sys_cgetc(void)
{
f010e71c:	55                   	push   %ebp
f010e71d:	89 e5                	mov    %esp,%ebp
f010e71f:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e722:	9c                   	pushf  
f010e723:	58                   	pop    %eax
f010e724:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010e727:	8b 45 ec             	mov    -0x14(%ebp),%eax
	int c;
	int IEN = read_eflags() & FL_IF;
f010e72a:	25 00 02 00 00       	and    $0x200,%eax
f010e72f:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (IEN) /*Interrupt-Enabled I/O*/
f010e732:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010e736:	74 10                	je     f010e748 <sys_cgetc+0x2c>
	{
		// The cons_getc2() primitive doesn't wait for a character
		while ((c = cons_getc2()) == 0)
f010e738:	e8 15 32 ff ff       	call   f0101952 <cons_getc2>
f010e73d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010e740:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e744:	74 f2                	je     f010e738 <sys_cgetc+0x1c>
f010e746:	eb 0e                	jmp    f010e756 <sys_cgetc+0x3a>
	else	/*Programmed I/O*/
	{
		//cprintf("\n(((((((Programmed I/O))))))\n");
		// The cons_getc() primitive doesn't wait for a character,
		// but the sys_cgetc() system call does.
		while ((c = cons_getc()) == 0)
f010e748:	e8 aa 31 ff ff       	call   f01018f7 <cons_getc>
f010e74d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010e750:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e754:	74 f2                	je     f010e748 <sys_cgetc+0x2c>
			/* do nothing */;
		}
	}
	//cprintf("\nCHAR %d is READ from KB, IEN = %d\n", c, read_eflags() & FL_IF);

	return c;
f010e756:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010e759:	c9                   	leave  
f010e75a:	c3                   	ret    

f010e75b <sys_lock_cons>:

//Lock the console so that no other processes can read from KB or output to the monitor
void sys_lock_cons(void)
{
f010e75b:	55                   	push   %ebp
f010e75c:	89 e5                	mov    %esp,%ebp
f010e75e:	83 ec 08             	sub    $0x8,%esp
	cons_lock();
f010e761:	e8 1b 33 ff ff       	call   f0101a81 <cons_lock>
}
f010e766:	90                   	nop
f010e767:	c9                   	leave  
f010e768:	c3                   	ret    

f010e769 <sys_unlock_cons>:
//Unlock the console so that other processes can read from KB or output to the monitor
void sys_unlock_cons(void)
{
f010e769:	55                   	push   %ebp
f010e76a:	89 e5                	mov    %esp,%ebp
f010e76c:	83 ec 08             	sub    $0x8,%esp
	cons_unlock();
f010e76f:	e8 54 33 ff ff       	call   f0101ac8 <cons_unlock>
}
f010e774:	90                   	nop
f010e775:	c9                   	leave  
f010e776:	c3                   	ret    

f010e777 <__sys_allocate_page>:
//	E_INVAL if va >= USER_TOP, or va is not page-aligned.
//	E_INVAL if perm is inappropriate (see above).
//	E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_allocate_page(void *va, int perm)
{
f010e777:	55                   	push   %ebp
f010e778:	89 e5                	mov    %esp,%ebp
f010e77a:	83 ec 18             	sub    $0x18,%esp
	//   map_frame() from kern/mem/memory_manager.c.
	//   Most of the new code you write should be to check the
	//   parameters for correctness.
	//   If map_frame() fails, remember to free the page you allocated!

	struct Env* cur_env = get_cpu_proc();
f010e77d:	e8 96 d2 ff ff       	call   f010ba18 <get_cpu_proc>
f010e782:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(cur_env == NULL)
f010e785:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e789:	75 07                	jne    f010e792 <__sys_allocate_page+0x1b>
		return E_BAD_ENV;
f010e78b:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010e790:	eb 5d                	jmp    f010e7ef <__sys_allocate_page+0x78>

	//check virtual address to be paged_aligned and < USER_TOP
	if ((uint32)va >= USER_TOP || (uint32)va % PAGE_SIZE != 0)
f010e792:	8b 45 08             	mov    0x8(%ebp),%eax
f010e795:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f010e79a:	77 0c                	ja     f010e7a8 <__sys_allocate_page+0x31>
f010e79c:	8b 45 08             	mov    0x8(%ebp),%eax
f010e79f:	25 ff 0f 00 00       	and    $0xfff,%eax
f010e7a4:	85 c0                	test   %eax,%eax
f010e7a6:	74 07                	je     f010e7af <__sys_allocate_page+0x38>
		return E_INVAL;
f010e7a8:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010e7ad:	eb 40                	jmp    f010e7ef <__sys_allocate_page+0x78>

	//check permissions to be appropriate
	if ((perm & (~PERM_AVAILABLE & ~PERM_WRITEABLE)) != (PERM_USER))
f010e7af:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e7b2:	25 fd f1 ff ff       	and    $0xfffff1fd,%eax
f010e7b7:	83 f8 04             	cmp    $0x4,%eax
f010e7ba:	74 07                	je     f010e7c3 <__sys_allocate_page+0x4c>
		return E_INVAL;
f010e7bc:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010e7c1:	eb 2c                	jmp    f010e7ef <__sys_allocate_page+0x78>

	int ret = alloc_page(cur_env->env_page_directory, (uint32)va, perm, 1);
f010e7c3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010e7c6:	8b 55 08             	mov    0x8(%ebp),%edx
f010e7c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e7cc:	8b 40 64             	mov    0x64(%eax),%eax
f010e7cf:	6a 01                	push   $0x1
f010e7d1:	51                   	push   %ecx
f010e7d2:	52                   	push   %edx
f010e7d3:	50                   	push   %eax
f010e7d4:	e8 75 b5 ff ff       	call   f0109d4e <alloc_page>
f010e7d9:	83 c4 10             	add    $0x10,%esp
f010e7dc:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret == E_NO_MEM)
f010e7df:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010e7e3:	75 05                	jne    f010e7ea <__sys_allocate_page+0x73>
		return ret ;
f010e7e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e7e8:	eb 05                	jmp    f010e7ef <__sys_allocate_page+0x78>

	return 0 ;
f010e7ea:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010e7ef:	c9                   	leave  
f010e7f0:	c3                   	ret    

f010e7f1 <__sys_map_frame>:
//	-E_INVAL if (perm & PTE_W), but srcva is read-only in srcenvid's
//		address space.
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_map_frame(int32 srcenvid, void *srcva, int32 dstenvid, void *dstva, int perm)
{
f010e7f1:	55                   	push   %ebp
f010e7f2:	89 e5                	mov    %esp,%ebp
f010e7f4:	83 ec 08             	sub    $0x8,%esp
	//   parameters for correctness.
	//   Use the third argument to page_lookup() to
	//   check the current permissions on the page.

	// LAB 4: Your code here.
	panic("sys_map_frame not implemented");
f010e7f7:	83 ec 04             	sub    $0x4,%esp
f010e7fa:	68 fa 0c 13 f0       	push   $0xf0130cfa
f010e7ff:	68 bb 00 00 00       	push   $0xbb
f010e804:	68 d5 0c 13 f0       	push   $0xf0130cd5
f010e809:	e8 a1 26 ff ff       	call   f0100eaf <_panic>

f010e80e <__sys_unmap_frame>:
//
// Return 0 on success, < 0 on error.  Errors are:
//	E_BAD_ENV if environment doesn't currently exist,
//	E_INVAL if va >= USER_TOP, or va is not page-aligned.
static int __sys_unmap_frame(uint32 va)
{
f010e80e:	55                   	push   %ebp
f010e80f:	89 e5                	mov    %esp,%ebp
f010e811:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010e814:	e8 ff d1 ff ff       	call   f010ba18 <get_cpu_proc>
f010e819:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(cur_env == NULL)
f010e81c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e820:	75 07                	jne    f010e829 <__sys_unmap_frame+0x1b>
		return E_BAD_ENV;
f010e822:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010e827:	eb 36                	jmp    f010e85f <__sys_unmap_frame+0x51>

	if (va >= USER_TOP || va % PAGE_SIZE != 0)
f010e829:	81 7d 08 ff ff bf ee 	cmpl   $0xeebfffff,0x8(%ebp)
f010e830:	77 0c                	ja     f010e83e <__sys_unmap_frame+0x30>
f010e832:	8b 45 08             	mov    0x8(%ebp),%eax
f010e835:	25 ff 0f 00 00       	and    $0xfff,%eax
f010e83a:	85 c0                	test   %eax,%eax
f010e83c:	74 07                	je     f010e845 <__sys_unmap_frame+0x37>
		return E_INVAL;
f010e83e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010e843:	eb 1a                	jmp    f010e85f <__sys_unmap_frame+0x51>

	unmap_frame(cur_env->env_page_directory, va);
f010e845:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e848:	8b 40 64             	mov    0x64(%eax),%eax
f010e84b:	83 ec 08             	sub    $0x8,%esp
f010e84e:	ff 75 08             	pushl  0x8(%ebp)
f010e851:	50                   	push   %eax
f010e852:	e8 f8 ad ff ff       	call   f010964f <unmap_frame>
f010e857:	83 c4 10             	add    $0x10,%esp
	return 0;
f010e85a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010e85f:	c9                   	leave  
f010e860:	c3                   	ret    

f010e861 <sys_calculate_required_frames>:

uint32 sys_calculate_required_frames(uint32 start_virtual_address, uint32 size)
{
f010e861:	55                   	push   %ebp
f010e862:	89 e5                	mov    %esp,%ebp
f010e864:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010e867:	e8 ac d1 ff ff       	call   f010ba18 <get_cpu_proc>
f010e86c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010e86f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e873:	75 19                	jne    f010e88e <sys_calculate_required_frames+0x2d>
f010e875:	68 b0 0c 13 f0       	push   $0xf0130cb0
f010e87a:	68 c0 0c 13 f0       	push   $0xf0130cc0
f010e87f:	68 d6 00 00 00       	push   $0xd6
f010e884:	68 d5 0c 13 f0       	push   $0xf0130cd5
f010e889:	e8 21 26 ff ff       	call   f0100eaf <_panic>

	return calculate_required_frames(cur_env->env_page_directory, start_virtual_address, size);
f010e88e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e891:	8b 40 64             	mov    0x64(%eax),%eax
f010e894:	83 ec 04             	sub    $0x4,%esp
f010e897:	ff 75 0c             	pushl  0xc(%ebp)
f010e89a:	ff 75 08             	pushl  0x8(%ebp)
f010e89d:	50                   	push   %eax
f010e89e:	e8 78 c3 ff ff       	call   f010ac1b <calculate_required_frames>
f010e8a3:	83 c4 10             	add    $0x10,%esp
}
f010e8a6:	c9                   	leave  
f010e8a7:	c3                   	ret    

f010e8a8 <sys_calculate_free_frames>:

uint32 sys_calculate_free_frames()
{
f010e8a8:	55                   	push   %ebp
f010e8a9:	89 e5                	mov    %esp,%ebp
f010e8ab:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010e8ae:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e8b1:	83 ec 0c             	sub    $0xc,%esp
f010e8b4:	50                   	push   %eax
f010e8b5:	e8 17 af ff ff       	call   f01097d1 <calculate_available_frames>
f010e8ba:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("Free Frames = %d : Buffered = %d, Not Buffered = %d\n", counters.freeBuffered + counters.freeNotBuffered, counters.freeBuffered ,counters.freeNotBuffered);
	return counters.freeBuffered + counters.freeNotBuffered;
f010e8bd:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e8c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e8c3:	01 d0                	add    %edx,%eax
}
f010e8c5:	c9                   	leave  
f010e8c6:	c3                   	ret    

f010e8c7 <sys_calculate_modified_frames>:
uint32 sys_calculate_modified_frames()
{
f010e8c7:	55                   	push   %ebp
f010e8c8:	89 e5                	mov    %esp,%ebp
f010e8ca:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010e8cd:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e8d0:	83 ec 0c             	sub    $0xc,%esp
f010e8d3:	50                   	push   %eax
f010e8d4:	e8 f8 ae ff ff       	call   f01097d1 <calculate_available_frames>
f010e8d9:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Modified Frames = %d\n", counters.modified) ;
	return counters.modified;
f010e8dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010e8df:	c9                   	leave  
f010e8e0:	c3                   	ret    

f010e8e1 <sys_calculate_notmod_frames>:

uint32 sys_calculate_notmod_frames()
{
f010e8e1:	55                   	push   %ebp
f010e8e2:	89 e5                	mov    %esp,%ebp
f010e8e4:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010e8e7:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e8ea:	83 ec 0c             	sub    $0xc,%esp
f010e8ed:	50                   	push   %eax
f010e8ee:	e8 de ae ff ff       	call   f01097d1 <calculate_available_frames>
f010e8f3:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Not Modified Frames = %d\n", counters.freeBuffered) ;
	return counters.freeBuffered;
f010e8f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f010e8f9:	c9                   	leave  
f010e8fa:	c3                   	ret    

f010e8fb <sys_calculate_pages_tobe_removed_ready_exit>:

int sys_calculate_pages_tobe_removed_ready_exit(uint32 WS_or_MEMORY_flag)
{
f010e8fb:	55                   	push   %ebp
f010e8fc:	89 e5                	mov    %esp,%ebp
f010e8fe:	83 ec 08             	sub    $0x8,%esp
	return calc_no_pages_tobe_removed_from_ready_exit_queues(WS_or_MEMORY_flag);
f010e901:	83 ec 0c             	sub    $0xc,%esp
f010e904:	ff 75 08             	pushl  0x8(%ebp)
f010e907:	e8 5e ae 00 00       	call   f011976a <calc_no_pages_tobe_removed_from_ready_exit_queues>
f010e90c:	83 c4 10             	add    $0x10,%esp
}
f010e90f:	c9                   	leave  
f010e910:	c3                   	ret    

f010e911 <sys_scarce_memory>:

void sys_scarce_memory(void)
{
f010e911:	55                   	push   %ebp
f010e912:	89 e5                	mov    %esp,%ebp
f010e914:	83 ec 08             	sub    $0x8,%esp
	scarce_memory();
f010e917:	e8 79 ad 00 00       	call   f0119695 <scarce_memory>
}
f010e91c:	90                   	nop
f010e91d:	c9                   	leave  
f010e91e:	c3                   	ret    

f010e91f <sys_clearFFL>:

void sys_clearFFL()
{
f010e91f:	55                   	push   %ebp
f010e920:	89 e5                	mov    %esp,%ebp
f010e922:	83 ec 18             	sub    $0x18,%esp
	int size;
	acquire_kspinlock(&MemFrameLists.mfllock);
f010e925:	83 ec 0c             	sub    $0xc,%esp
f010e928:	68 e0 e7 83 f0       	push   $0xf083e7e0
f010e92d:	e8 49 14 00 00       	call   f010fd7b <acquire_kspinlock>
f010e932:	83 c4 10             	add    $0x10,%esp
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
f010e935:	a1 cc e7 83 f0       	mov    0xf083e7cc,%eax
f010e93a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010e93d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010e944:	eb 12                	jmp    f010e958 <sys_clearFFL+0x39>
		{
			allocate_frame(&ptr_tmp_FI) ;
f010e946:	83 ec 0c             	sub    $0xc,%esp
f010e949:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e94c:	50                   	push   %eax
f010e94d:	e8 f0 a6 ff ff       	call   f0109042 <allocate_frame>
f010e952:	83 c4 10             	add    $0x10,%esp
	int size;
	acquire_kspinlock(&MemFrameLists.mfllock);
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010e955:	ff 45 f4             	incl   -0xc(%ebp)
f010e958:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e95b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010e95e:	7c e6                	jl     f010e946 <sys_clearFFL+0x27>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_kspinlock(&MemFrameLists.mfllock);
f010e960:	83 ec 0c             	sub    $0xc,%esp
f010e963:	68 e0 e7 83 f0       	push   $0xf083e7e0
f010e968:	e8 b3 14 00 00       	call   f010fe20 <release_kspinlock>
f010e96d:	83 c4 10             	add    $0x10,%esp
}
f010e970:	90                   	nop
f010e971:	c9                   	leave  
f010e972:	c3                   	ret    

f010e973 <sys_pf_calculate_allocated_pages>:

/*******************************/
/* PAGE FILE SYSTEM CALLS */
/*******************************/
int sys_pf_calculate_allocated_pages(void)
{
f010e973:	55                   	push   %ebp
f010e974:	89 e5                	mov    %esp,%ebp
f010e976:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010e979:	e8 9a d0 ff ff       	call   f010ba18 <get_cpu_proc>
f010e97e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010e981:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e985:	75 19                	jne    f010e9a0 <sys_pf_calculate_allocated_pages+0x2d>
f010e987:	68 b0 0c 13 f0       	push   $0xf0130cb0
f010e98c:	68 c0 0c 13 f0       	push   $0xf0130cc0
f010e991:	68 0e 01 00 00       	push   $0x10e
f010e996:	68 d5 0c 13 f0       	push   $0xf0130cd5
f010e99b:	e8 0f 25 ff ff       	call   f0100eaf <_panic>

	return pf_calculate_allocated_pages(cur_env);
f010e9a0:	83 ec 0c             	sub    $0xc,%esp
f010e9a3:	ff 75 f4             	pushl  -0xc(%ebp)
f010e9a6:	e8 de 6d ff ff       	call   f0105789 <pf_calculate_allocated_pages>
f010e9ab:	83 c4 10             	add    $0x10,%esp
}
f010e9ae:	c9                   	leave  
f010e9af:	c3                   	ret    

f010e9b0 <sys_free_user_mem>:

/*******************************/
/* USER HEAP SYSTEM CALLS */
/*******************************/
void sys_free_user_mem(uint32 virtual_address, uint32 size)
{
f010e9b0:	55                   	push   %ebp
f010e9b1:	89 e5                	mov    %esp,%ebp
f010e9b3:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010e9b6:	e8 5d d0 ff ff       	call   f010ba18 <get_cpu_proc>
f010e9bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010e9be:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e9c2:	75 19                	jne    f010e9dd <sys_free_user_mem+0x2d>
f010e9c4:	68 b0 0c 13 f0       	push   $0xf0130cb0
f010e9c9:	68 c0 0c 13 f0       	push   $0xf0130cc0
f010e9ce:	68 19 01 00 00       	push   $0x119
f010e9d3:	68 d5 0c 13 f0       	push   $0xf0130cd5
f010e9d8:	e8 d2 24 ff ff       	call   f0100eaf <_panic>

	if (virtual_address == 0 || (virtual_address >= USER_HEAP_MAX) || (virtual_address < USER_HEAP_START)
f010e9dd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010e9e1:	74 2b                	je     f010ea0e <sys_free_user_mem+0x5e>
f010e9e3:	81 7d 08 ff ff ff 9f 	cmpl   $0x9fffffff,0x8(%ebp)
f010e9ea:	77 22                	ja     f010ea0e <sys_free_user_mem+0x5e>
f010e9ec:	8b 45 08             	mov    0x8(%ebp),%eax
f010e9ef:	85 c0                	test   %eax,%eax
f010e9f1:	79 1b                	jns    f010ea0e <sys_free_user_mem+0x5e>
		|| (virtual_address + size >= USER_HEAP_MAX) || (virtual_address + size < USER_HEAP_START))
f010e9f3:	8b 55 08             	mov    0x8(%ebp),%edx
f010e9f6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e9f9:	01 d0                	add    %edx,%eax
f010e9fb:	3d ff ff ff 9f       	cmp    $0x9fffffff,%eax
f010ea00:	77 0c                	ja     f010ea0e <sys_free_user_mem+0x5e>
f010ea02:	8b 55 08             	mov    0x8(%ebp),%edx
f010ea05:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ea08:	01 d0                	add    %edx,%eax
f010ea0a:	85 c0                	test   %eax,%eax
f010ea0c:	78 15                	js     f010ea23 <sys_free_user_mem+0x73>
	{
		cprintf("\nsys_free_user_mem(): ILLEGAL ADDRESS! Process will be terminated...\n");
f010ea0e:	83 ec 0c             	sub    $0xc,%esp
f010ea11:	68 18 0d 13 f0       	push   $0xf0130d18
f010ea16:	e8 41 31 ff ff       	call   f0101b5c <cprintf>
f010ea1b:	83 c4 10             	add    $0x10,%esp
		env_exit();
f010ea1e:	e8 b3 cf ff ff       	call   f010b9d6 <env_exit>
	}

	if(isBufferingEnabled())
f010ea23:	e8 d9 0e 00 00       	call   f010f901 <isBufferingEnabled>
f010ea28:	84 c0                	test   %al,%al
f010ea2a:	74 16                	je     f010ea42 <sys_free_user_mem+0x92>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
f010ea2c:	83 ec 04             	sub    $0x4,%esp
f010ea2f:	ff 75 0c             	pushl  0xc(%ebp)
f010ea32:	ff 75 08             	pushl  0x8(%ebp)
f010ea35:	ff 75 f4             	pushl  -0xc(%ebp)
f010ea38:	e8 4f c2 ff ff       	call   f010ac8c <__free_user_mem_with_buffering>
f010ea3d:	83 c4 10             	add    $0x10,%esp
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
	}
	return;
f010ea40:	eb 15                	jmp    f010ea57 <sys_free_user_mem+0xa7>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
f010ea42:	83 ec 04             	sub    $0x4,%esp
f010ea45:	ff 75 0c             	pushl  0xc(%ebp)
f010ea48:	ff 75 08             	pushl  0x8(%ebp)
f010ea4b:	ff 75 f4             	pushl  -0xc(%ebp)
f010ea4e:	e8 1c c2 ff ff       	call   f010ac6f <free_user_mem>
f010ea53:	83 c4 10             	add    $0x10,%esp
	}
	return;
f010ea56:	90                   	nop
}
f010ea57:	c9                   	leave  
f010ea58:	c3                   	ret    

f010ea59 <sys_allocate_user_mem>:

void sys_allocate_user_mem(uint32 virtual_address, uint32 size)
{
f010ea59:	55                   	push   %ebp
f010ea5a:	89 e5                	mov    %esp,%ebp
f010ea5c:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010ea5f:	e8 b4 cf ff ff       	call   f010ba18 <get_cpu_proc>
f010ea64:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010ea67:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ea6b:	75 19                	jne    f010ea86 <sys_allocate_user_mem+0x2d>
f010ea6d:	68 b0 0c 13 f0       	push   $0xf0130cb0
f010ea72:	68 c0 0c 13 f0       	push   $0xf0130cc0
f010ea77:	68 30 01 00 00       	push   $0x130
f010ea7c:	68 d5 0c 13 f0       	push   $0xf0130cd5
f010ea81:	e8 29 24 ff ff       	call   f0100eaf <_panic>

	if (virtual_address == 0 || (virtual_address >= USER_HEAP_MAX) || (virtual_address < USER_HEAP_START)
f010ea86:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ea8a:	74 2b                	je     f010eab7 <sys_allocate_user_mem+0x5e>
f010ea8c:	81 7d 08 ff ff ff 9f 	cmpl   $0x9fffffff,0x8(%ebp)
f010ea93:	77 22                	ja     f010eab7 <sys_allocate_user_mem+0x5e>
f010ea95:	8b 45 08             	mov    0x8(%ebp),%eax
f010ea98:	85 c0                	test   %eax,%eax
f010ea9a:	79 1b                	jns    f010eab7 <sys_allocate_user_mem+0x5e>
		|| (virtual_address + size >= USER_HEAP_MAX) || (virtual_address + size < USER_HEAP_START))
f010ea9c:	8b 55 08             	mov    0x8(%ebp),%edx
f010ea9f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eaa2:	01 d0                	add    %edx,%eax
f010eaa4:	3d ff ff ff 9f       	cmp    $0x9fffffff,%eax
f010eaa9:	77 0c                	ja     f010eab7 <sys_allocate_user_mem+0x5e>
f010eaab:	8b 55 08             	mov    0x8(%ebp),%edx
f010eaae:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eab1:	01 d0                	add    %edx,%eax
f010eab3:	85 c0                	test   %eax,%eax
f010eab5:	78 15                	js     f010eacc <sys_allocate_user_mem+0x73>
	{
		cprintf("\nsys_free_user_mem(): ILLEGAL ADDRESS! Process will be terminated...\n");
f010eab7:	83 ec 0c             	sub    $0xc,%esp
f010eaba:	68 18 0d 13 f0       	push   $0xf0130d18
f010eabf:	e8 98 30 ff ff       	call   f0101b5c <cprintf>
f010eac4:	83 c4 10             	add    $0x10,%esp
		env_exit();
f010eac7:	e8 0a cf ff ff       	call   f010b9d6 <env_exit>
	}
	allocate_user_mem(cur_env, virtual_address, size);
f010eacc:	83 ec 04             	sub    $0x4,%esp
f010eacf:	ff 75 0c             	pushl  0xc(%ebp)
f010ead2:	ff 75 08             	pushl  0x8(%ebp)
f010ead5:	ff 75 f4             	pushl  -0xc(%ebp)
f010ead8:	e8 75 c1 ff ff       	call   f010ac52 <allocate_user_mem>
f010eadd:	83 c4 10             	add    $0x10,%esp
	return;
f010eae0:	90                   	nop
}
f010eae1:	c9                   	leave  
f010eae2:	c3                   	ret    

f010eae3 <sys_allocate_chunk>:

void sys_allocate_chunk(uint32 virtual_address, uint32 size, uint32 perms)
{
f010eae3:	55                   	push   %ebp
f010eae4:	89 e5                	mov    %esp,%ebp
f010eae6:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010eae9:	e8 2a cf ff ff       	call   f010ba18 <get_cpu_proc>
f010eaee:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010eaf1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010eaf5:	75 19                	jne    f010eb10 <sys_allocate_chunk+0x2d>
f010eaf7:	68 b0 0c 13 f0       	push   $0xf0130cb0
f010eafc:	68 c0 0c 13 f0       	push   $0xf0130cc0
f010eb01:	68 3f 01 00 00       	push   $0x13f
f010eb06:	68 d5 0c 13 f0       	push   $0xf0130cd5
f010eb0b:	e8 9f 23 ff ff       	call   f0100eaf <_panic>

	allocate_chunk(cur_env->env_page_directory, virtual_address, size, perms);
f010eb10:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010eb13:	8b 40 64             	mov    0x64(%eax),%eax
f010eb16:	ff 75 10             	pushl  0x10(%ebp)
f010eb19:	ff 75 0c             	pushl  0xc(%ebp)
f010eb1c:	ff 75 08             	pushl  0x8(%ebp)
f010eb1f:	50                   	push   %eax
f010eb20:	e8 a8 c0 ff ff       	call   f010abcd <allocate_chunk>
f010eb25:	83 c4 10             	add    $0x10,%esp
	return;
f010eb28:	90                   	nop
}
f010eb29:	c9                   	leave  
f010eb2a:	c3                   	ret    

f010eb2b <sys_move_user_mem>:

//2014
void sys_move_user_mem(uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010eb2b:	55                   	push   %ebp
f010eb2c:	89 e5                	mov    %esp,%ebp
f010eb2e:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010eb31:	e8 e2 ce ff ff       	call   f010ba18 <get_cpu_proc>
f010eb36:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010eb39:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010eb3d:	75 19                	jne    f010eb58 <sys_move_user_mem+0x2d>
f010eb3f:	68 b0 0c 13 f0       	push   $0xf0130cb0
f010eb44:	68 c0 0c 13 f0       	push   $0xf0130cc0
f010eb49:	68 49 01 00 00       	push   $0x149
f010eb4e:	68 d5 0c 13 f0       	push   $0xf0130cd5
f010eb53:	e8 57 23 ff ff       	call   f0100eaf <_panic>

	move_user_mem(cur_env, src_virtual_address, dst_virtual_address, size);
f010eb58:	ff 75 10             	pushl  0x10(%ebp)
f010eb5b:	ff 75 0c             	pushl  0xc(%ebp)
f010eb5e:	ff 75 08             	pushl  0x8(%ebp)
f010eb61:	ff 75 f4             	pushl  -0xc(%ebp)
f010eb64:	e8 40 c1 ff ff       	call   f010aca9 <move_user_mem>
f010eb69:	83 c4 10             	add    $0x10,%esp
	return;
f010eb6c:	90                   	nop
}
f010eb6d:	c9                   	leave  
f010eb6e:	c3                   	ret    

f010eb6f <sys_get_heap_strategy>:

//2015
uint32 sys_get_heap_strategy()
{
f010eb6f:	55                   	push   %ebp
f010eb70:	89 e5                	mov    %esp,%ebp
	return _UHeapPlacementStrategy ;
f010eb72:	a1 e8 6a 85 f0       	mov    0xf0856ae8,%eax
}
f010eb77:	5d                   	pop    %ebp
f010eb78:	c3                   	ret    

f010eb79 <sys_set_uheap_strategy>:
void sys_set_uheap_strategy(uint32 heapStrategy)
{
f010eb79:	55                   	push   %ebp
f010eb7a:	89 e5                	mov    %esp,%ebp
	_UHeapPlacementStrategy = heapStrategy;
f010eb7c:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb7f:	a3 e8 6a 85 f0       	mov    %eax,0xf0856ae8
}
f010eb84:	90                   	nop
f010eb85:	5d                   	pop    %ebp
f010eb86:	c3                   	ret    

f010eb87 <sys_create_shared_object>:

/*******************************/
/* SHARED MEMORY SYSTEM CALLS */
/*******************************/
int sys_create_shared_object(char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f010eb87:	55                   	push   %ebp
f010eb88:	89 e5                	mov    %esp,%ebp
f010eb8a:	83 ec 28             	sub    $0x28,%esp
f010eb8d:	8b 45 10             	mov    0x10(%ebp),%eax
f010eb90:	88 45 e4             	mov    %al,-0x1c(%ebp)
	struct Env* cur_env = get_cpu_proc();
f010eb93:	e8 80 ce ff ff       	call   f010ba18 <get_cpu_proc>
f010eb98:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010eb9b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010eb9f:	75 19                	jne    f010ebba <sys_create_shared_object+0x33>
f010eba1:	68 b0 0c 13 f0       	push   $0xf0130cb0
f010eba6:	68 c0 0c 13 f0       	push   $0xf0130cc0
f010ebab:	68 64 01 00 00       	push   $0x164
f010ebb0:	68 d5 0c 13 f0       	push   $0xf0130cd5
f010ebb5:	e8 f5 22 ff ff       	call   f0100eaf <_panic>

	return create_shared_object(cur_env->env_id, shareName, size, isWritable, virtual_address);
f010ebba:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
f010ebbe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ebc1:	8b 40 10             	mov    0x10(%eax),%eax
f010ebc4:	83 ec 0c             	sub    $0xc,%esp
f010ebc7:	ff 75 14             	pushl  0x14(%ebp)
f010ebca:	52                   	push   %edx
f010ebcb:	ff 75 0c             	pushl  0xc(%ebp)
f010ebce:	ff 75 08             	pushl  0x8(%ebp)
f010ebd1:	50                   	push   %eax
f010ebd2:	e8 1e ae ff ff       	call   f01099f5 <create_shared_object>
f010ebd7:	83 c4 20             	add    $0x20,%esp
}
f010ebda:	c9                   	leave  
f010ebdb:	c3                   	ret    

f010ebdc <sys_size_of_shared_object>:

int sys_size_of_shared_object(int32 ownerID, char* shareName)
{
f010ebdc:	55                   	push   %ebp
f010ebdd:	89 e5                	mov    %esp,%ebp
f010ebdf:	83 ec 08             	sub    $0x8,%esp
	return size_of_shared_object(ownerID, shareName);
f010ebe2:	83 ec 08             	sub    $0x8,%esp
f010ebe5:	ff 75 0c             	pushl  0xc(%ebp)
f010ebe8:	ff 75 08             	pushl  0x8(%ebp)
f010ebeb:	e8 b6 ad ff ff       	call   f01099a6 <size_of_shared_object>
f010ebf0:	83 c4 10             	add    $0x10,%esp
}
f010ebf3:	c9                   	leave  
f010ebf4:	c3                   	ret    

f010ebf5 <sys_get_shared_object>:

int sys_get_shared_object(int32 ownerID, char* shareName, void* virtual_address)
{
f010ebf5:	55                   	push   %ebp
f010ebf6:	89 e5                	mov    %esp,%ebp
f010ebf8:	83 ec 08             	sub    $0x8,%esp
	return get_shared_object(ownerID, shareName, virtual_address);
f010ebfb:	83 ec 04             	sub    $0x4,%esp
f010ebfe:	ff 75 10             	pushl  0x10(%ebp)
f010ec01:	ff 75 0c             	pushl  0xc(%ebp)
f010ec04:	ff 75 08             	pushl  0x8(%ebp)
f010ec07:	e8 09 ae ff ff       	call   f0109a15 <get_shared_object>
f010ec0c:	83 c4 10             	add    $0x10,%esp
}
f010ec0f:	c9                   	leave  
f010ec10:	c3                   	ret    

f010ec11 <sys_delete_shared_object>:

int sys_delete_shared_object(int32 sharedObjectID, void *startVA)
{
f010ec11:	55                   	push   %ebp
f010ec12:	89 e5                	mov    %esp,%ebp
f010ec14:	83 ec 08             	sub    $0x8,%esp
	return delete_shared_object(sharedObjectID, startVA);
f010ec17:	83 ec 08             	sub    $0x8,%esp
f010ec1a:	ff 75 0c             	pushl  0xc(%ebp)
f010ec1d:	ff 75 08             	pushl  0x8(%ebp)
f010ec20:	e8 2a ae ff ff       	call   f0109a4f <delete_shared_object>
f010ec25:	83 c4 10             	add    $0x10,%esp
}
f010ec28:	c9                   	leave  
f010ec29:	c3                   	ret    

f010ec2a <sys_getenvid>:
/* USER ENVIRONMENT SYSTEM CALLS */
/*********************************/
// Returns the current environment's envid.
//2017
static int32 sys_getenvid(void)
{
f010ec2a:	55                   	push   %ebp
f010ec2b:	89 e5                	mov    %esp,%ebp
f010ec2d:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010ec30:	e8 e3 cd ff ff       	call   f010ba18 <get_cpu_proc>
f010ec35:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010ec38:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ec3c:	75 19                	jne    f010ec57 <sys_getenvid+0x2d>
f010ec3e:	68 b0 0c 13 f0       	push   $0xf0130cb0
f010ec43:	68 c0 0c 13 f0       	push   $0xf0130cc0
f010ec48:	68 80 01 00 00       	push   $0x180
f010ec4d:	68 d5 0c 13 f0       	push   $0xf0130cd5
f010ec52:	e8 58 22 ff ff       	call   f0100eaf <_panic>

	return cur_env->env_id;
f010ec57:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ec5a:	8b 40 10             	mov    0x10(%eax),%eax
}
f010ec5d:	c9                   	leave  
f010ec5e:	c3                   	ret    

f010ec5f <sys_getenvindex>:

//2017
static int32 sys_getenvindex(void)
{
f010ec5f:	55                   	push   %ebp
f010ec60:	89 e5                	mov    %esp,%ebp
f010ec62:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010ec65:	e8 ae cd ff ff       	call   f010ba18 <get_cpu_proc>
f010ec6a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010ec6d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ec71:	75 19                	jne    f010ec8c <sys_getenvindex+0x2d>
f010ec73:	68 b0 0c 13 f0       	push   $0xf0130cb0
f010ec78:	68 c0 0c 13 f0       	push   $0xf0130cc0
f010ec7d:	68 89 01 00 00       	push   $0x189
f010ec82:	68 d5 0c 13 f0       	push   $0xf0130cd5
f010ec87:	e8 23 22 ff ff       	call   f0100eaf <_panic>

	//return cur_env->env_id;
	return (cur_env - envs) ;
f010ec8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ec8f:	8b 15 90 5b 81 f0    	mov    0xf0815b90,%edx
f010ec95:	29 d0                	sub    %edx,%eax
f010ec97:	c1 f8 02             	sar    $0x2,%eax
f010ec9a:	89 c1                	mov    %eax,%ecx
f010ec9c:	89 ca                	mov    %ecx,%edx
f010ec9e:	c1 e2 02             	shl    $0x2,%edx
f010eca1:	01 ca                	add    %ecx,%edx
f010eca3:	c1 e2 02             	shl    $0x2,%edx
f010eca6:	01 ca                	add    %ecx,%edx
f010eca8:	c1 e2 03             	shl    $0x3,%edx
f010ecab:	01 ca                	add    %ecx,%edx
f010ecad:	89 d0                	mov    %edx,%eax
f010ecaf:	c1 e0 05             	shl    $0x5,%eax
f010ecb2:	29 d0                	sub    %edx,%eax
f010ecb4:	c1 e0 02             	shl    $0x2,%eax
f010ecb7:	01 c8                	add    %ecx,%eax
f010ecb9:	c1 e0 02             	shl    $0x2,%eax
f010ecbc:	01 c8                	add    %ecx,%eax
f010ecbe:	c1 e0 02             	shl    $0x2,%eax
f010ecc1:	01 c8                	add    %ecx,%eax
f010ecc3:	c1 e0 06             	shl    $0x6,%eax
f010ecc6:	29 c8                	sub    %ecx,%eax
f010ecc8:	c1 e0 03             	shl    $0x3,%eax
f010eccb:	01 c8                	add    %ecx,%eax
f010eccd:	c1 e0 04             	shl    $0x4,%eax
f010ecd0:	01 c8                	add    %ecx,%eax
}
f010ecd2:	c9                   	leave  
f010ecd3:	c3                   	ret    

f010ecd4 <sys_getparentenvid>:

//2017
static int32 sys_getparentenvid(void)
{
f010ecd4:	55                   	push   %ebp
f010ecd5:	89 e5                	mov    %esp,%ebp
f010ecd7:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010ecda:	e8 39 cd ff ff       	call   f010ba18 <get_cpu_proc>
f010ecdf:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010ece2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ece6:	75 19                	jne    f010ed01 <sys_getparentenvid+0x2d>
f010ece8:	68 b0 0c 13 f0       	push   $0xf0130cb0
f010eced:	68 c0 0c 13 f0       	push   $0xf0130cc0
f010ecf2:	68 93 01 00 00       	push   $0x193
f010ecf7:	68 d5 0c 13 f0       	push   $0xf0130cd5
f010ecfc:	e8 ae 21 ff ff       	call   f0100eaf <_panic>

	return cur_env->env_parent_id;
f010ed01:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed04:	8b 40 14             	mov    0x14(%eax),%eax
}
f010ed07:	c9                   	leave  
f010ed08:	c3                   	ret    

f010ed09 <sys_destroy_env>:
//
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int sys_destroy_env(int32 envid)
{
f010ed09:	55                   	push   %ebp
f010ed0a:	89 e5                	mov    %esp,%ebp
f010ed0c:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010ed0f:	e8 04 cd ff ff       	call   f010ba18 <get_cpu_proc>
f010ed14:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010ed17:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ed1b:	75 19                	jne    f010ed36 <sys_destroy_env+0x2d>
f010ed1d:	68 b0 0c 13 f0       	push   $0xf0130cb0
f010ed22:	68 c0 0c 13 f0       	push   $0xf0130cc0
f010ed27:	68 a1 01 00 00       	push   $0x1a1
f010ed2c:	68 d5 0c 13 f0       	push   $0xf0130cd5
f010ed31:	e8 79 21 ff ff       	call   f0100eaf <_panic>

	int r;
	struct Env *e;
	if (envid == 0)
f010ed36:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ed3a:	75 08                	jne    f010ed44 <sys_destroy_env+0x3b>
	{
		e = cur_env ;
f010ed3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed3f:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010ed42:	eb 22                	jmp    f010ed66 <sys_destroy_env+0x5d>
	}
	else if ((r = envid2env(envid, &e, 0)) < 0)
f010ed44:	83 ec 04             	sub    $0x4,%esp
f010ed47:	6a 00                	push   $0x0
f010ed49:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010ed4c:	50                   	push   %eax
f010ed4d:	ff 75 08             	pushl  0x8(%ebp)
f010ed50:	e8 13 cd ff ff       	call   f010ba68 <envid2env>
f010ed55:	83 c4 10             	add    $0x10,%esp
f010ed58:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010ed5b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010ed5f:	79 05                	jns    f010ed66 <sys_destroy_env+0x5d>
	{
		return r;
f010ed61:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ed64:	eb 56                	jmp    f010edbc <sys_destroy_env+0xb3>
	}

	if (e == cur_env)
f010ed66:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ed69:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010ed6c:	75 19                	jne    f010ed87 <sys_destroy_env+0x7e>
	{
		cprintf("[%08x] exiting gracefully\n", cur_env->env_id);
f010ed6e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed71:	8b 40 10             	mov    0x10(%eax),%eax
f010ed74:	83 ec 08             	sub    $0x8,%esp
f010ed77:	50                   	push   %eax
f010ed78:	68 5e 0d 13 f0       	push   $0xf0130d5e
f010ed7d:	e8 da 2d ff ff       	call   f0101b5c <cprintf>
f010ed82:	83 c4 10             	add    $0x10,%esp
f010ed85:	eb 1e                	jmp    f010eda5 <sys_destroy_env+0x9c>
	}
	else
	{
		cprintf("[%08x] destroying %08x\n", cur_env->env_id, e->env_id);
f010ed87:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ed8a:	8b 50 10             	mov    0x10(%eax),%edx
f010ed8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed90:	8b 40 10             	mov    0x10(%eax),%eax
f010ed93:	83 ec 04             	sub    $0x4,%esp
f010ed96:	52                   	push   %edx
f010ed97:	50                   	push   %eax
f010ed98:	68 79 0d 13 f0       	push   $0xf0130d79
f010ed9d:	e8 ba 2d ff ff       	call   f0101b5c <cprintf>
f010eda2:	83 c4 10             	add    $0x10,%esp
	}
	//2015
	sched_kill_env(e->env_id);
f010eda5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010eda8:	8b 40 10             	mov    0x10(%eax),%eax
f010edab:	83 ec 0c             	sub    $0xc,%esp
f010edae:	50                   	push   %eax
f010edaf:	e8 71 7c ff ff       	call   f0106a25 <sched_kill_env>
f010edb4:	83 c4 10             	add    $0x10,%esp

	return 0;
f010edb7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010edbc:	c9                   	leave  
f010edbd:	c3                   	ret    

f010edbe <sys_exit_env>:

//Just place the current env into the EXIT queue & schedule the next one
static void sys_exit_env()
{
f010edbe:	55                   	push   %ebp
f010edbf:	89 e5                	mov    %esp,%ebp
f010edc1:	83 ec 08             	sub    $0x8,%esp
	//2015
	env_exit();
f010edc4:	e8 0d cc ff ff       	call   f010b9d6 <env_exit>

	//2024: if returned here, then it's not the current environment. So, just return
	//env_run_cmd_prmpt();
	//context_switch(&(cur_env->context), mycpu()->scheduler);

}
f010edc9:	90                   	nop
f010edca:	c9                   	leave  
f010edcb:	c3                   	ret    

f010edcc <sys_create_env>:

//New update in 2020
//Create a new env & add it to the NEW queue
int sys_create_env(char* programName, unsigned int page_WS_size,unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010edcc:	55                   	push   %ebp
f010edcd:	89 e5                	mov    %esp,%ebp
f010edcf:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\nAttempt to create a new env\n");

	struct Env* env =  env_create(programName, page_WS_size, LRU_second_list_size, percent_WS_pages_to_remove);
f010edd2:	ff 75 14             	pushl  0x14(%ebp)
f010edd5:	ff 75 10             	pushl  0x10(%ebp)
f010edd8:	ff 75 0c             	pushl  0xc(%ebp)
f010eddb:	ff 75 08             	pushl  0x8(%ebp)
f010edde:	e8 7e c0 ff ff       	call   f010ae61 <env_create>
f010ede3:	83 c4 10             	add    $0x10,%esp
f010ede6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(env == NULL)
f010ede9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010eded:	75 07                	jne    f010edf6 <sys_create_env+0x2a>
	{
		return E_ENV_CREATION_ERROR;
f010edef:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
f010edf4:	eb 14                	jmp    f010ee0a <sys_create_env+0x3e>
	}
	//cprintf("\nENV %d is created\n", env->env_id);

	//2015
	sched_new_env(env);
f010edf6:	83 ec 0c             	sub    $0xc,%esp
f010edf9:	ff 75 f4             	pushl  -0xc(%ebp)
f010edfc:	e8 88 78 ff ff       	call   f0106689 <sched_new_env>
f010ee01:	83 c4 10             	add    $0x10,%esp

	//cprintf("\nENV %d is scheduled as NEW\n", env->env_id);

	return env->env_id;
f010ee04:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ee07:	8b 40 10             	mov    0x10(%eax),%eax
}
f010ee0a:	c9                   	leave  
f010ee0b:	c3                   	ret    

f010ee0c <sys_run_env>:

//Place a new env into the READY queue
void sys_run_env(int32 envId)
{
f010ee0c:	55                   	push   %ebp
f010ee0d:	89 e5                	mov    %esp,%ebp
f010ee0f:	83 ec 08             	sub    $0x8,%esp
	sched_run_env(envId);
f010ee12:	8b 45 08             	mov    0x8(%ebp),%eax
f010ee15:	83 ec 0c             	sub    $0xc,%esp
f010ee18:	50                   	push   %eax
f010ee19:	e8 c1 78 ff ff       	call   f01066df <sched_run_env>
f010ee1e:	83 c4 10             	add    $0x10,%esp
}
f010ee21:	90                   	nop
f010ee22:	c9                   	leave  
f010ee23:	c3                   	ret    

f010ee24 <sys_get_optimal_num_faults>:

//Calculate the number of page faults for the OPTIMAL replacement
int sys_get_optimal_num_faults()
{
f010ee24:	55                   	push   %ebp
f010ee25:	89 e5                	mov    %esp,%ebp
f010ee27:	53                   	push   %ebx
f010ee28:	83 ec 24             	sub    $0x24,%esp
#if USE_KHEAP
	struct Env* cur_env = get_cpu_proc();
f010ee2b:	e8 e8 cb ff ff       	call   f010ba18 <get_cpu_proc>
f010ee30:	89 45 ec             	mov    %eax,-0x14(%ebp)
	assert(cur_env != NULL);
f010ee33:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010ee37:	75 19                	jne    f010ee52 <sys_get_optimal_num_faults+0x2e>
f010ee39:	68 b0 0c 13 f0       	push   $0xf0130cb0
f010ee3e:	68 c0 0c 13 f0       	push   $0xf0130cc0
f010ee43:	68 e8 01 00 00       	push   $0x1e8
f010ee48:	68 d5 0c 13 f0       	push   $0xf0130cd5
f010ee4d:	e8 5d 20 ff ff       	call   f0100eaf <_panic>

	struct WorkingSetElement *ptrWSE ;
	int w = 0;
f010ee52:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	LIST_FOREACH(ptrWSE, &(cur_env->page_WS_list))
f010ee59:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ee5c:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010ee62:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010ee65:	eb 5d                	jmp    f010eec4 <sys_get_optimal_num_faults+0xa0>
	{
		if (ROUNDDOWN(ptrWSE->virtual_address, PAGE_SIZE) != ROUNDDOWN(cur_env->prepagedVAs[w++], PAGE_SIZE))
f010ee67:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ee6a:	8b 00                	mov    (%eax),%eax
f010ee6c:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010ee6f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ee72:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010ee77:	89 c3                	mov    %eax,%ebx
f010ee79:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ee7c:	8b 88 ac 00 00 00    	mov    0xac(%eax),%ecx
f010ee82:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ee85:	8d 50 01             	lea    0x1(%eax),%edx
f010ee88:	89 55 f0             	mov    %edx,-0x10(%ebp)
f010ee8b:	c1 e0 02             	shl    $0x2,%eax
f010ee8e:	01 c8                	add    %ecx,%eax
f010ee90:	8b 00                	mov    (%eax),%eax
f010ee92:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010ee95:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010ee98:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010ee9d:	39 c3                	cmp    %eax,%ebx
f010ee9f:	74 17                	je     f010eeb8 <sys_get_optimal_num_faults+0x94>
		{
			panic("sys_get_optimal_num_faults(): page working set is changed during the OPTIMAL replacement while it's not expected to");
f010eea1:	83 ec 04             	sub    $0x4,%esp
f010eea4:	68 94 0d 13 f0       	push   $0xf0130d94
f010eea9:	68 f0 01 00 00       	push   $0x1f0
f010eeae:	68 d5 0c 13 f0       	push   $0xf0130cd5
f010eeb3:	e8 f7 1f ff ff       	call   f0100eaf <_panic>
	struct Env* cur_env = get_cpu_proc();
	assert(cur_env != NULL);

	struct WorkingSetElement *ptrWSE ;
	int w = 0;
	LIST_FOREACH(ptrWSE, &(cur_env->page_WS_list))
f010eeb8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010eebb:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010eec1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010eec4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010eec8:	74 08                	je     f010eed2 <sys_get_optimal_num_faults+0xae>
f010eeca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010eecd:	8b 40 10             	mov    0x10(%eax),%eax
f010eed0:	eb 05                	jmp    f010eed7 <sys_get_optimal_num_faults+0xb3>
f010eed2:	b8 00 00 00 00       	mov    $0x0,%eax
f010eed7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010eeda:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f010eee0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010eee3:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010eee9:	85 c0                	test   %eax,%eax
f010eeeb:	0f 85 76 ff ff ff    	jne    f010ee67 <sys_get_optimal_num_faults+0x43>
f010eef1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010eef5:	0f 85 6c ff ff ff    	jne    f010ee67 <sys_get_optimal_num_faults+0x43>
		if (ROUNDDOWN(ptrWSE->virtual_address, PAGE_SIZE) != ROUNDDOWN(cur_env->prepagedVAs[w++], PAGE_SIZE))
		{
			panic("sys_get_optimal_num_faults(): page working set is changed during the OPTIMAL replacement while it's not expected to");
		}
	}
	return get_optimal_num_faults(&(cur_env->page_WS_list), cur_env->page_WS_max_size, &(cur_env->referenceStreamList));
f010eefb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010eefe:	8d 88 9c 00 00 00    	lea    0x9c(%eax),%ecx
f010ef04:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ef07:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010ef0d:	89 c2                	mov    %eax,%edx
f010ef0f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ef12:	05 88 00 00 00       	add    $0x88,%eax
f010ef17:	83 ec 04             	sub    $0x4,%esp
f010ef1a:	51                   	push   %ecx
f010ef1b:	52                   	push   %edx
f010ef1c:	50                   	push   %eax
f010ef1d:	e8 25 0d 00 00       	call   f010fc47 <get_optimal_num_faults>
f010ef22:	83 c4 10             	add    $0x10,%esp
#else
	panic("MUST ENABLE KHEAP");
#endif
	return 0;
}
f010ef25:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010ef28:	c9                   	leave  
f010ef29:	c3                   	ret    

f010ef2a <sys_get_virtual_time>:
/*******************************/
/* ETC... SYSTEM CALLS */
/*******************************/

struct uint64 sys_get_virtual_time()
{
f010ef2a:	55                   	push   %ebp
f010ef2b:	89 e5                	mov    %esp,%ebp
f010ef2d:	83 ec 10             	sub    $0x10,%esp
	//	lcr4(0);


	struct uint64 result;

	__asm __volatile("rdtsc\n"
f010ef30:	0f 31                	rdtsc  
f010ef32:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010ef35:	89 55 f4             	mov    %edx,-0xc(%ebp)
	//ptr[3]=0;
	//cprintf("as str = %s\n", ptr);
	cprintf("ax = %x, bx = %x, cx = %x, dx = %x\n", eaxp,ebxp,ecxp,edxp);
	*/

	return result;
f010ef38:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ef3b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ef3e:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010ef41:	89 55 fc             	mov    %edx,-0x4(%ebp)
	struct uint64 t = get_virtual_time();
	return t;
f010ef44:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ef47:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010ef4a:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010ef4d:	89 01                	mov    %eax,(%ecx)
f010ef4f:	89 51 04             	mov    %edx,0x4(%ecx)
}
f010ef52:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef55:	c9                   	leave  
f010ef56:	c2 04 00             	ret    $0x4

f010ef59 <sys_rcr2>:

uint32 sys_rcr2()
{
f010ef59:	55                   	push   %ebp
f010ef5a:	89 e5                	mov    %esp,%ebp
f010ef5c:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010ef5f:	0f 20 d0             	mov    %cr2,%eax
f010ef62:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return val;
f010ef65:	8b 45 fc             	mov    -0x4(%ebp),%eax
	return rcr2();
f010ef68:	90                   	nop
}
f010ef69:	c9                   	leave  
f010ef6a:	c3                   	ret    

f010ef6b <sys_bypassPageFault>:
void sys_bypassPageFault(uint8 instrLength)
{
f010ef6b:	55                   	push   %ebp
f010ef6c:	89 e5                	mov    %esp,%ebp
f010ef6e:	83 ec 04             	sub    $0x4,%esp
f010ef71:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef74:	88 45 fc             	mov    %al,-0x4(%ebp)
	bypassInstrLength = instrLength;
f010ef77:	8a 45 fc             	mov    -0x4(%ebp),%al
f010ef7a:	a2 00 64 81 f0       	mov    %al,0xf0816400
}
f010ef7f:	90                   	nop
f010ef80:	c9                   	leave  
f010ef81:	c3                   	ret    

f010ef82 <syscall>:
/**************************************************************************/
/************************* SYSTEM CALLS HANDLER ***************************/
/**************************************************************************/
// Dispatches to the correct kernel function, passing the arguments.
uint32 syscall(uint32 syscallno, uint32 a1, uint32 a2, uint32 a3, uint32 a4, uint32 a5)
{
f010ef82:	55                   	push   %ebp
f010ef83:	89 e5                	mov    %esp,%ebp
f010ef85:	56                   	push   %esi
f010ef86:	53                   	push   %ebx
f010ef87:	83 ec 20             	sub    $0x20,%esp
	struct Env* cur_env = get_cpu_proc();
f010ef8a:	e8 89 ca ff ff       	call   f010ba18 <get_cpu_proc>
f010ef8f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010ef92:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ef96:	75 19                	jne    f010efb1 <syscall+0x2f>
f010ef98:	68 b0 0c 13 f0       	push   $0xf0130cb0
f010ef9d:	68 c0 0c 13 f0       	push   $0xf0130cc0
f010efa2:	68 16 02 00 00       	push   $0x216
f010efa7:	68 d5 0c 13 f0       	push   $0xf0130cd5
f010efac:	e8 fe 1e ff ff       	call   f0100eaf <_panic>

	//cprintf("syscallno = %d\n", syscallno);
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	switch(syscallno)
f010efb1:	83 7d 08 2e          	cmpl   $0x2e,0x8(%ebp)
f010efb5:	0f 87 b5 03 00 00    	ja     f010f370 <syscall+0x3ee>
f010efbb:	8b 45 08             	mov    0x8(%ebp),%eax
f010efbe:	c1 e0 02             	shl    $0x2,%eax
f010efc1:	05 08 0e 13 f0       	add    $0xf0130e08,%eax
f010efc6:	8b 00                	mov    (%eax),%eax
f010efc8:	ff e0                	jmp    *%eax
	//TODO: [PROJECT'25.IM#4] CPU SCHEDULING - #1 System Calls - Add suitable code here
	//Your code is here

	//=============================================
	case SYS_cputs:
		sys_cputs((const char*)a1,a2,(uint8)a3, a4);
f010efca:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010efcd:	8b 45 14             	mov    0x14(%ebp),%eax
f010efd0:	0f b6 d0             	movzbl %al,%edx
f010efd3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010efd6:	51                   	push   %ecx
f010efd7:	52                   	push   %edx
f010efd8:	ff 75 10             	pushl  0x10(%ebp)
f010efdb:	50                   	push   %eax
f010efdc:	e8 8e f6 ff ff       	call   f010e66f <sys_cputs>
f010efe1:	83 c4 10             	add    $0x10,%esp
		return 0;
f010efe4:	b8 00 00 00 00       	mov    $0x0,%eax
f010efe9:	e9 87 03 00 00       	jmp    f010f375 <syscall+0x3f3>
		break;
	case SYS_cgetc:
		return sys_cgetc();
f010efee:	e8 29 f7 ff ff       	call   f010e71c <sys_cgetc>
f010eff3:	e9 7d 03 00 00       	jmp    f010f375 <syscall+0x3f3>
		break;
	case SYS_cputc:
		sys_cputc((const char)a1);
f010eff8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010effb:	0f be c0             	movsbl %al,%eax
f010effe:	83 ec 0c             	sub    $0xc,%esp
f010f001:	50                   	push   %eax
f010f002:	e8 f1 f6 ff ff       	call   f010e6f8 <sys_cputc>
f010f007:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f00a:	b8 00 00 00 00       	mov    $0x0,%eax
f010f00f:	e9 61 03 00 00       	jmp    f010f375 <syscall+0x3f3>
		break;
	case SYS_lock_cons:
		sys_lock_cons();
f010f014:	e8 42 f7 ff ff       	call   f010e75b <sys_lock_cons>
		return 0;
f010f019:	b8 00 00 00 00       	mov    $0x0,%eax
f010f01e:	e9 52 03 00 00       	jmp    f010f375 <syscall+0x3f3>
		break;
	case SYS_unlock_cons:
		sys_unlock_cons();
f010f023:	e8 41 f7 ff ff       	call   f010e769 <sys_unlock_cons>
		return 0;
f010f028:	b8 00 00 00 00       	mov    $0x0,%eax
f010f02d:	e9 43 03 00 00       	jmp    f010f375 <syscall+0x3f3>
		break;
	case SYS_calc_req_frames:
		return sys_calculate_required_frames(a1, a2);
f010f032:	83 ec 08             	sub    $0x8,%esp
f010f035:	ff 75 10             	pushl  0x10(%ebp)
f010f038:	ff 75 0c             	pushl  0xc(%ebp)
f010f03b:	e8 21 f8 ff ff       	call   f010e861 <sys_calculate_required_frames>
f010f040:	83 c4 10             	add    $0x10,%esp
f010f043:	e9 2d 03 00 00       	jmp    f010f375 <syscall+0x3f3>
		break;
	case SYS_calc_free_frames:
		return sys_calculate_free_frames();
f010f048:	e8 5b f8 ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f010f04d:	e9 23 03 00 00       	jmp    f010f375 <syscall+0x3f3>
		break;
	case SYS_calc_modified_frames:
		return sys_calculate_modified_frames();
f010f052:	e8 70 f8 ff ff       	call   f010e8c7 <sys_calculate_modified_frames>
f010f057:	e9 19 03 00 00       	jmp    f010f375 <syscall+0x3f3>
		break;
	case SYS_calc_notmod_frames:
		return sys_calculate_notmod_frames();
f010f05c:	e8 80 f8 ff ff       	call   f010e8e1 <sys_calculate_notmod_frames>
f010f061:	e9 0f 03 00 00       	jmp    f010f375 <syscall+0x3f3>
		break;

	case SYS_pf_calc_allocated_pages:
		return sys_pf_calculate_allocated_pages();
f010f066:	e8 08 f9 ff ff       	call   f010e973 <sys_pf_calculate_allocated_pages>
f010f06b:	e9 05 03 00 00       	jmp    f010f375 <syscall+0x3f3>
		break;
	case SYS_calculate_pages_tobe_removed_ready_exit:
		return sys_calculate_pages_tobe_removed_ready_exit(a1);
f010f070:	83 ec 0c             	sub    $0xc,%esp
f010f073:	ff 75 0c             	pushl  0xc(%ebp)
f010f076:	e8 80 f8 ff ff       	call   f010e8fb <sys_calculate_pages_tobe_removed_ready_exit>
f010f07b:	83 c4 10             	add    $0x10,%esp
f010f07e:	e9 f2 02 00 00       	jmp    f010f375 <syscall+0x3f3>
		break;
	case SYS_scarce_memory:
		sys_scarce_memory();
f010f083:	e8 89 f8 ff ff       	call   f010e911 <sys_scarce_memory>
		return 0;
f010f088:	b8 00 00 00 00       	mov    $0x0,%eax
f010f08d:	e9 e3 02 00 00       	jmp    f010f375 <syscall+0x3f3>
		break;
	case SYS_allocate_chunk_in_mem:
		sys_allocate_chunk(a1, (uint32)a2, a3);
f010f092:	83 ec 04             	sub    $0x4,%esp
f010f095:	ff 75 14             	pushl  0x14(%ebp)
f010f098:	ff 75 10             	pushl  0x10(%ebp)
f010f09b:	ff 75 0c             	pushl  0xc(%ebp)
f010f09e:	e8 40 fa ff ff       	call   f010eae3 <sys_allocate_chunk>
f010f0a3:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f0a6:	b8 00 00 00 00       	mov    $0x0,%eax
f010f0ab:	e9 c5 02 00 00       	jmp    f010f375 <syscall+0x3f3>
		break;

		//======================
	case SYS_allocate_page:
		return __sys_allocate_page((void*)a1, a2);
f010f0b0:	8b 55 10             	mov    0x10(%ebp),%edx
f010f0b3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f0b6:	83 ec 08             	sub    $0x8,%esp
f010f0b9:	52                   	push   %edx
f010f0ba:	50                   	push   %eax
f010f0bb:	e8 b7 f6 ff ff       	call   f010e777 <__sys_allocate_page>
f010f0c0:	83 c4 10             	add    $0x10,%esp
f010f0c3:	e9 ad 02 00 00       	jmp    f010f375 <syscall+0x3f3>
		break;
	case SYS_map_frame:
		__sys_map_frame(a1, (void*)a2, a3, (void*)a4, a5);
f010f0c8:	8b 75 1c             	mov    0x1c(%ebp),%esi
f010f0cb:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010f0ce:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010f0d1:	8b 55 10             	mov    0x10(%ebp),%edx
f010f0d4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f0d7:	83 ec 0c             	sub    $0xc,%esp
f010f0da:	56                   	push   %esi
f010f0db:	53                   	push   %ebx
f010f0dc:	51                   	push   %ecx
f010f0dd:	52                   	push   %edx
f010f0de:	50                   	push   %eax
f010f0df:	e8 0d f7 ff ff       	call   f010e7f1 <__sys_map_frame>
f010f0e4:	83 c4 20             	add    $0x20,%esp
		return 0;
f010f0e7:	b8 00 00 00 00       	mov    $0x0,%eax
f010f0ec:	e9 84 02 00 00       	jmp    f010f375 <syscall+0x3f3>
		break;
	case SYS_unmap_frame:
		return __sys_unmap_frame(a1);
f010f0f1:	83 ec 0c             	sub    $0xc,%esp
f010f0f4:	ff 75 0c             	pushl  0xc(%ebp)
f010f0f7:	e8 12 f7 ff ff       	call   f010e80e <__sys_unmap_frame>
f010f0fc:	83 c4 10             	add    $0x10,%esp
f010f0ff:	e9 71 02 00 00       	jmp    f010f375 <syscall+0x3f3>
		break;

	case SYS_clearFFL:
		sys_clearFFL((const char)a1);
f010f104:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f107:	0f be c0             	movsbl %al,%eax
f010f10a:	83 ec 0c             	sub    $0xc,%esp
f010f10d:	50                   	push   %eax
f010f10e:	e8 0c f8 ff ff       	call   f010e91f <sys_clearFFL>
f010f113:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f116:	b8 00 00 00 00       	mov    $0x0,%eax
f010f11b:	e9 55 02 00 00       	jmp    f010f375 <syscall+0x3f3>
		break;

	case SYS_create_shared_object:
		return sys_create_shared_object((char*)a1, a2, a3, (void*)a4);
f010f120:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010f123:	8b 45 14             	mov    0x14(%ebp),%eax
f010f126:	0f b6 d0             	movzbl %al,%edx
f010f129:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f12c:	51                   	push   %ecx
f010f12d:	52                   	push   %edx
f010f12e:	ff 75 10             	pushl  0x10(%ebp)
f010f131:	50                   	push   %eax
f010f132:	e8 50 fa ff ff       	call   f010eb87 <sys_create_shared_object>
f010f137:	83 c4 10             	add    $0x10,%esp
f010f13a:	e9 36 02 00 00       	jmp    f010f375 <syscall+0x3f3>
		break;

	case SYS_get_shared_object:
		return sys_get_shared_object((int32)a1, (char*)a2, (void*)a3);
f010f13f:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010f142:	8b 55 10             	mov    0x10(%ebp),%edx
f010f145:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f148:	83 ec 04             	sub    $0x4,%esp
f010f14b:	51                   	push   %ecx
f010f14c:	52                   	push   %edx
f010f14d:	50                   	push   %eax
f010f14e:	e8 a2 fa ff ff       	call   f010ebf5 <sys_get_shared_object>
f010f153:	83 c4 10             	add    $0x10,%esp
f010f156:	e9 1a 02 00 00       	jmp    f010f375 <syscall+0x3f3>
		break;

	case SYS_free_shared_object:
		return sys_delete_shared_object((int32)a1, (void *)a2);
f010f15b:	8b 55 10             	mov    0x10(%ebp),%edx
f010f15e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f161:	83 ec 08             	sub    $0x8,%esp
f010f164:	52                   	push   %edx
f010f165:	50                   	push   %eax
f010f166:	e8 a6 fa ff ff       	call   f010ec11 <sys_delete_shared_object>
f010f16b:	83 c4 10             	add    $0x10,%esp
f010f16e:	e9 02 02 00 00       	jmp    f010f375 <syscall+0x3f3>
		break;

	case SYS_get_size_of_shared_object:
		return sys_size_of_shared_object((int32)a1, (char*)a2);
f010f173:	8b 55 10             	mov    0x10(%ebp),%edx
f010f176:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f179:	83 ec 08             	sub    $0x8,%esp
f010f17c:	52                   	push   %edx
f010f17d:	50                   	push   %eax
f010f17e:	e8 59 fa ff ff       	call   f010ebdc <sys_size_of_shared_object>
f010f183:	83 c4 10             	add    $0x10,%esp
f010f186:	e9 ea 01 00 00       	jmp    f010f375 <syscall+0x3f3>
		break;

	case SYS_create_env:
		return sys_create_env((char*)a1, (uint32)a2, (uint32)a3, (uint32)a4);
f010f18b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f18e:	ff 75 18             	pushl  0x18(%ebp)
f010f191:	ff 75 14             	pushl  0x14(%ebp)
f010f194:	ff 75 10             	pushl  0x10(%ebp)
f010f197:	50                   	push   %eax
f010f198:	e8 2f fc ff ff       	call   f010edcc <sys_create_env>
f010f19d:	83 c4 10             	add    $0x10,%esp
f010f1a0:	e9 d0 01 00 00       	jmp    f010f375 <syscall+0x3f3>
		break;

	case SYS_run_env:
		sys_run_env((int32)a1);
f010f1a5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f1a8:	83 ec 0c             	sub    $0xc,%esp
f010f1ab:	50                   	push   %eax
f010f1ac:	e8 5b fc ff ff       	call   f010ee0c <sys_run_env>
f010f1b1:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f1b4:	b8 00 00 00 00       	mov    $0x0,%eax
f010f1b9:	e9 b7 01 00 00       	jmp    f010f375 <syscall+0x3f3>
		break;
	case SYS_getenvindex:
		return sys_getenvindex();
f010f1be:	e8 9c fa ff ff       	call   f010ec5f <sys_getenvindex>
f010f1c3:	e9 ad 01 00 00       	jmp    f010f375 <syscall+0x3f3>
		break;
	case SYS_getenvid:
		return sys_getenvid();
f010f1c8:	e8 5d fa ff ff       	call   f010ec2a <sys_getenvid>
f010f1cd:	e9 a3 01 00 00       	jmp    f010f375 <syscall+0x3f3>
		break;
	case SYS_getparentenvid:
		return sys_getparentenvid();
f010f1d2:	e8 fd fa ff ff       	call   f010ecd4 <sys_getparentenvid>
f010f1d7:	e9 99 01 00 00       	jmp    f010f375 <syscall+0x3f3>
		break;
	case SYS_destroy_env:
		return sys_destroy_env(a1);
f010f1dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f1df:	83 ec 0c             	sub    $0xc,%esp
f010f1e2:	50                   	push   %eax
f010f1e3:	e8 21 fb ff ff       	call   f010ed09 <sys_destroy_env>
f010f1e8:	83 c4 10             	add    $0x10,%esp
f010f1eb:	e9 85 01 00 00       	jmp    f010f375 <syscall+0x3f3>
		break;
	case SYS_exit_env:
		sys_exit_env();
f010f1f0:	e8 c9 fb ff ff       	call   f010edbe <sys_exit_env>
		return 0;
f010f1f5:	b8 00 00 00 00       	mov    $0x0,%eax
f010f1fa:	e9 76 01 00 00       	jmp    f010f375 <syscall+0x3f3>
		break;
	case SYS_get_virtual_time:
	{
		struct uint64 res = sys_get_virtual_time();
f010f1ff:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f010f202:	83 ec 0c             	sub    $0xc,%esp
f010f205:	50                   	push   %eax
f010f206:	e8 1f fd ff ff       	call   f010ef2a <sys_get_virtual_time>
f010f20b:	83 c4 0c             	add    $0xc,%esp
		uint32* ptrlow = ((uint32*)a1);
f010f20e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f211:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32* ptrhi = ((uint32*)a2);
f010f214:	8b 45 10             	mov    0x10(%ebp),%eax
f010f217:	89 45 ec             	mov    %eax,-0x14(%ebp)
		*ptrlow = res.low;
f010f21a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f21d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f220:	89 10                	mov    %edx,(%eax)
		*ptrhi = res.hi;
f010f222:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010f225:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f228:	89 10                	mov    %edx,(%eax)
		return 0;
f010f22a:	b8 00 00 00 00       	mov    $0x0,%eax
f010f22f:	e9 41 01 00 00       	jmp    f010f375 <syscall+0x3f3>
		break;
	}
	case SYS_move_user_mem:
		sys_move_user_mem(a1, a2, a3);
f010f234:	83 ec 04             	sub    $0x4,%esp
f010f237:	ff 75 14             	pushl  0x14(%ebp)
f010f23a:	ff 75 10             	pushl  0x10(%ebp)
f010f23d:	ff 75 0c             	pushl  0xc(%ebp)
f010f240:	e8 e6 f8 ff ff       	call   f010eb2b <sys_move_user_mem>
f010f245:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f248:	b8 00 00 00 00       	mov    $0x0,%eax
f010f24d:	e9 23 01 00 00       	jmp    f010f375 <syscall+0x3f3>
		break;
	case SYS_rcr2:
		return sys_rcr2();
f010f252:	e8 02 fd ff ff       	call   f010ef59 <sys_rcr2>
f010f257:	e9 19 01 00 00       	jmp    f010f375 <syscall+0x3f3>
		break;
	case SYS_bypassPageFault:
		sys_bypassPageFault(a1);
f010f25c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f25f:	0f b6 c0             	movzbl %al,%eax
f010f262:	83 ec 0c             	sub    $0xc,%esp
f010f265:	50                   	push   %eax
f010f266:	e8 00 fd ff ff       	call   f010ef6b <sys_bypassPageFault>
f010f26b:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f26e:	b8 00 00 00 00       	mov    $0x0,%eax
f010f273:	e9 fd 00 00 00       	jmp    f010f375 <syscall+0x3f3>

	case SYS_rsttst:
		rsttst();
f010f278:	e8 b6 96 00 00       	call   f0118933 <rsttst>
		return 0;
f010f27d:	b8 00 00 00 00       	mov    $0x0,%eax
f010f282:	e9 ee 00 00 00       	jmp    f010f375 <syscall+0x3f3>
	case SYS_inctst:
		inctst();
f010f287:	e8 ef 96 00 00       	call   f011897b <inctst>
		return 0;
f010f28c:	b8 00 00 00 00       	mov    $0x0,%eax
f010f291:	e9 df 00 00 00       	jmp    f010f375 <syscall+0x3f3>
	case SYS_chktst:
		chktst(a1);
f010f296:	83 ec 0c             	sub    $0xc,%esp
f010f299:	ff 75 0c             	pushl  0xc(%ebp)
f010f29c:	e8 1c 98 00 00       	call   f0118abd <chktst>
f010f2a1:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f2a4:	b8 00 00 00 00       	mov    $0x0,%eax
f010f2a9:	e9 c7 00 00 00       	jmp    f010f375 <syscall+0x3f3>
	case SYS_gettst:
		return gettst();
f010f2ae:	e8 fc 96 00 00       	call   f01189af <gettst>
f010f2b3:	e9 bd 00 00 00       	jmp    f010f375 <syscall+0x3f3>
	case SYS_testNum:
		tst(a1, a2, a3, (char)a4, a5);
f010f2b8:	8b 55 1c             	mov    0x1c(%ebp),%edx
f010f2bb:	8b 45 18             	mov    0x18(%ebp),%eax
f010f2be:	0f be c0             	movsbl %al,%eax
f010f2c1:	83 ec 0c             	sub    $0xc,%esp
f010f2c4:	52                   	push   %edx
f010f2c5:	50                   	push   %eax
f010f2c6:	ff 75 14             	pushl  0x14(%ebp)
f010f2c9:	ff 75 10             	pushl  0x10(%ebp)
f010f2cc:	ff 75 0c             	pushl  0xc(%ebp)
f010f2cf:	e8 e5 96 00 00       	call   f01189b9 <tst>
f010f2d4:	83 c4 20             	add    $0x20,%esp
		return 0;
f010f2d7:	b8 00 00 00 00       	mov    $0x0,%eax
f010f2dc:	e9 94 00 00 00       	jmp    f010f375 <syscall+0x3f3>

	case SYS_get_heap_strategy:
		return sys_get_heap_strategy();
f010f2e1:	e8 89 f8 ff ff       	call   f010eb6f <sys_get_heap_strategy>
f010f2e6:	e9 8a 00 00 00       	jmp    f010f375 <syscall+0x3f3>

	case SYS_set_heap_strategy:
		sys_set_uheap_strategy(a1);
f010f2eb:	83 ec 0c             	sub    $0xc,%esp
f010f2ee:	ff 75 0c             	pushl  0xc(%ebp)
f010f2f1:	e8 83 f8 ff ff       	call   f010eb79 <sys_set_uheap_strategy>
f010f2f6:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f2f9:	b8 00 00 00 00       	mov    $0x0,%eax
f010f2fe:	eb 75                	jmp    f010f375 <syscall+0x3f3>

	case SYS_check_LRU_lists:
		return sys_check_LRU_lists((uint32*)a1, (uint32*)a2, (int)a3, (int)a4);
f010f300:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010f303:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010f306:	8b 55 10             	mov    0x10(%ebp),%edx
f010f309:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f30c:	53                   	push   %ebx
f010f30d:	51                   	push   %ecx
f010f30e:	52                   	push   %edx
f010f30f:	50                   	push   %eax
f010f310:	e8 62 1d 00 00       	call   f0111077 <sys_check_LRU_lists>
f010f315:	83 c4 10             	add    $0x10,%esp
f010f318:	eb 5b                	jmp    f010f375 <syscall+0x3f3>

	case SYS_check_LRU_lists_free:
		return sys_check_LRU_lists_free((uint32*)a1, (int)a2);
f010f31a:	8b 55 10             	mov    0x10(%ebp),%edx
f010f31d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f320:	83 ec 08             	sub    $0x8,%esp
f010f323:	52                   	push   %edx
f010f324:	50                   	push   %eax
f010f325:	e8 0f 1f 00 00       	call   f0111239 <sys_check_LRU_lists_free>
f010f32a:	83 c4 10             	add    $0x10,%esp
f010f32d:	eb 46                	jmp    f010f375 <syscall+0x3f3>

	case SYS_check_WS_list:
		return sys_check_WS_list((uint32*)a1, (int)a2, (uint32)a3, (bool)a4);
f010f32f:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010f332:	8b 55 10             	mov    0x10(%ebp),%edx
f010f335:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f338:	51                   	push   %ecx
f010f339:	ff 75 14             	pushl  0x14(%ebp)
f010f33c:	52                   	push   %edx
f010f33d:	50                   	push   %eax
f010f33e:	e8 83 20 00 00       	call   f01113c6 <sys_check_WS_list>
f010f343:	83 c4 10             	add    $0x10,%esp
f010f346:	eb 2d                	jmp    f010f375 <syscall+0x3f3>

	case SYS_utilities:
		sys_utilities((char*)a1, (int)a2);
f010f348:	8b 55 10             	mov    0x10(%ebp),%edx
f010f34b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f34e:	83 ec 08             	sub    $0x8,%esp
f010f351:	52                   	push   %edx
f010f352:	50                   	push   %eax
f010f353:	e8 66 99 00 00       	call   f0118cbe <sys_utilities>
f010f358:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f35b:	b8 00 00 00 00       	mov    $0x0,%eax
f010f360:	eb 13                	jmp    f010f375 <syscall+0x3f3>

	case SYS_get_optimal_num_faults:
		return sys_get_optimal_num_faults();
f010f362:	e8 bd fa ff ff       	call   f010ee24 <sys_get_optimal_num_faults>
f010f367:	eb 0c                	jmp    f010f375 <syscall+0x3f3>

	case NSYSCALLS:
		return 	-E_INVAL;
f010f369:	b8 03 00 00 00       	mov    $0x3,%eax
f010f36e:	eb 05                	jmp    f010f375 <syscall+0x3f3>
		break;
	}
	//panic("syscall not implemented");
	return -E_INVAL;
f010f370:	b8 03 00 00 00       	mov    $0x3,%eax
}
f010f375:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010f378:	5b                   	pop    %ebx
f010f379:	5e                   	pop    %esi
f010f37a:	5d                   	pop    %ebp
f010f37b:	c3                   	ret    

f010f37c <stab_binsearch>:
//	will exit setting left = 118, right = 554.
//
static void
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
f010f37c:	55                   	push   %ebp
f010f37d:	89 e5                	mov    %esp,%ebp
f010f37f:	83 ec 20             	sub    $0x20,%esp
	int l = *region_left, r = *region_right, any_matches = 0;
f010f382:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f385:	8b 00                	mov    (%eax),%eax
f010f387:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f38a:	8b 45 10             	mov    0x10(%ebp),%eax
f010f38d:	8b 00                	mov    (%eax),%eax
f010f38f:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010f392:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	while (l <= r) {
f010f399:	e9 ca 00 00 00       	jmp    f010f468 <stab_binsearch+0xec>
		int true_m = (l + r) / 2, m = true_m;
f010f39e:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f3a1:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010f3a4:	01 d0                	add    %edx,%eax
f010f3a6:	89 c2                	mov    %eax,%edx
f010f3a8:	c1 ea 1f             	shr    $0x1f,%edx
f010f3ab:	01 d0                	add    %edx,%eax
f010f3ad:	d1 f8                	sar    %eax
f010f3af:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010f3b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f3b5:	89 45 f0             	mov    %eax,-0x10(%ebp)

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010f3b8:	eb 03                	jmp    f010f3bd <stab_binsearch+0x41>
			m--;
f010f3ba:	ff 4d f0             	decl   -0x10(%ebp)

	while (l <= r) {
		int true_m = (l + r) / 2, m = true_m;

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010f3bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f3c0:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f3c3:	7c 1e                	jl     f010f3e3 <stab_binsearch+0x67>
f010f3c5:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f3c8:	89 d0                	mov    %edx,%eax
f010f3ca:	01 c0                	add    %eax,%eax
f010f3cc:	01 d0                	add    %edx,%eax
f010f3ce:	c1 e0 02             	shl    $0x2,%eax
f010f3d1:	89 c2                	mov    %eax,%edx
f010f3d3:	8b 45 08             	mov    0x8(%ebp),%eax
f010f3d6:	01 d0                	add    %edx,%eax
f010f3d8:	8a 40 04             	mov    0x4(%eax),%al
f010f3db:	0f b6 c0             	movzbl %al,%eax
f010f3de:	3b 45 14             	cmp    0x14(%ebp),%eax
f010f3e1:	75 d7                	jne    f010f3ba <stab_binsearch+0x3e>
			m--;
		if (m < l) {	// no match in [l, m]
f010f3e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f3e6:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f3e9:	7d 09                	jge    f010f3f4 <stab_binsearch+0x78>
			l = true_m + 1;
f010f3eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f3ee:	40                   	inc    %eax
f010f3ef:	89 45 fc             	mov    %eax,-0x4(%ebp)
			continue;
f010f3f2:	eb 74                	jmp    f010f468 <stab_binsearch+0xec>
		}

		// actual binary search
		any_matches = 1;
f010f3f4:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		if (stabs[m].n_value < addr) {
f010f3fb:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f3fe:	89 d0                	mov    %edx,%eax
f010f400:	01 c0                	add    %eax,%eax
f010f402:	01 d0                	add    %edx,%eax
f010f404:	c1 e0 02             	shl    $0x2,%eax
f010f407:	89 c2                	mov    %eax,%edx
f010f409:	8b 45 08             	mov    0x8(%ebp),%eax
f010f40c:	01 d0                	add    %edx,%eax
f010f40e:	8b 40 08             	mov    0x8(%eax),%eax
f010f411:	3b 45 18             	cmp    0x18(%ebp),%eax
f010f414:	73 11                	jae    f010f427 <stab_binsearch+0xab>
			*region_left = m;
f010f416:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f419:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f41c:	89 10                	mov    %edx,(%eax)
			l = true_m + 1;
f010f41e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f421:	40                   	inc    %eax
f010f422:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f425:	eb 41                	jmp    f010f468 <stab_binsearch+0xec>
		} else if (stabs[m].n_value > addr) {
f010f427:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f42a:	89 d0                	mov    %edx,%eax
f010f42c:	01 c0                	add    %eax,%eax
f010f42e:	01 d0                	add    %edx,%eax
f010f430:	c1 e0 02             	shl    $0x2,%eax
f010f433:	89 c2                	mov    %eax,%edx
f010f435:	8b 45 08             	mov    0x8(%ebp),%eax
f010f438:	01 d0                	add    %edx,%eax
f010f43a:	8b 40 08             	mov    0x8(%eax),%eax
f010f43d:	3b 45 18             	cmp    0x18(%ebp),%eax
f010f440:	76 14                	jbe    f010f456 <stab_binsearch+0xda>
			*region_right = m - 1;
f010f442:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f445:	8d 50 ff             	lea    -0x1(%eax),%edx
f010f448:	8b 45 10             	mov    0x10(%ebp),%eax
f010f44b:	89 10                	mov    %edx,(%eax)
			r = m - 1;
f010f44d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f450:	48                   	dec    %eax
f010f451:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010f454:	eb 12                	jmp    f010f468 <stab_binsearch+0xec>
		} else {
			// exact match for 'addr', but continue loop to find
			// *region_right
			*region_left = m;
f010f456:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f459:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f45c:	89 10                	mov    %edx,(%eax)
			l = m;
f010f45e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f461:	89 45 fc             	mov    %eax,-0x4(%ebp)
			addr++;
f010f464:	83 45 18 04          	addl   $0x4,0x18(%ebp)
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
	int l = *region_left, r = *region_right, any_matches = 0;

	while (l <= r) {
f010f468:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010f46b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f010f46e:	0f 8e 2a ff ff ff    	jle    f010f39e <stab_binsearch+0x22>
			l = m;
			addr++;
		}
	}

	if (!any_matches)
f010f474:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f478:	75 0f                	jne    f010f489 <stab_binsearch+0x10d>
		*region_right = *region_left - 1;
f010f47a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f47d:	8b 00                	mov    (%eax),%eax
f010f47f:	8d 50 ff             	lea    -0x1(%eax),%edx
f010f482:	8b 45 10             	mov    0x10(%ebp),%eax
f010f485:	89 10                	mov    %edx,(%eax)
		     l > *region_left && stabs[l].n_type != type;
		     l--)
			/* do nothing */;
		*region_left = l;
	}
}
f010f487:	eb 3d                	jmp    f010f4c6 <stab_binsearch+0x14a>

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010f489:	8b 45 10             	mov    0x10(%ebp),%eax
f010f48c:	8b 00                	mov    (%eax),%eax
f010f48e:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f491:	eb 03                	jmp    f010f496 <stab_binsearch+0x11a>
		     l > *region_left && stabs[l].n_type != type;
		     l--)
f010f493:	ff 4d fc             	decl   -0x4(%ebp)
	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
		     l > *region_left && stabs[l].n_type != type;
f010f496:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f499:	8b 00                	mov    (%eax),%eax

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010f49b:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f49e:	7d 1e                	jge    f010f4be <stab_binsearch+0x142>
		     l > *region_left && stabs[l].n_type != type;
f010f4a0:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f4a3:	89 d0                	mov    %edx,%eax
f010f4a5:	01 c0                	add    %eax,%eax
f010f4a7:	01 d0                	add    %edx,%eax
f010f4a9:	c1 e0 02             	shl    $0x2,%eax
f010f4ac:	89 c2                	mov    %eax,%edx
f010f4ae:	8b 45 08             	mov    0x8(%ebp),%eax
f010f4b1:	01 d0                	add    %edx,%eax
f010f4b3:	8a 40 04             	mov    0x4(%eax),%al
f010f4b6:	0f b6 c0             	movzbl %al,%eax
f010f4b9:	3b 45 14             	cmp    0x14(%ebp),%eax
f010f4bc:	75 d5                	jne    f010f493 <stab_binsearch+0x117>
		     l--)
			/* do nothing */;
		*region_left = l;
f010f4be:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4c1:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f4c4:	89 10                	mov    %edx,(%eax)
	}
}
f010f4c6:	90                   	nop
f010f4c7:	c9                   	leave  
f010f4c8:	c3                   	ret    

f010f4c9 <debuginfo_eip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_eip(uint32*  addr, struct Eipdebuginfo *info)
{
f010f4c9:	55                   	push   %ebp
f010f4ca:	89 e5                	mov    %esp,%ebp
f010f4cc:	83 ec 38             	sub    $0x38,%esp
	const struct Stab *stabs, *stab_end;
	const char *stabstr, *stabstr_end;
	int lfile, rfile, lfun, rfun, lline, rline;

	// Initialize *info
	info->eip_file = "<unknown>";
f010f4cf:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4d2:	c7 00 c4 0e 13 f0    	movl   $0xf0130ec4,(%eax)
	info->eip_line = 0;
f010f4d8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4db:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	info->eip_fn_name = "<unknown>";
f010f4e2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4e5:	c7 40 08 c4 0e 13 f0 	movl   $0xf0130ec4,0x8(%eax)
	info->eip_fn_namelen = 9;
f010f4ec:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4ef:	c7 40 0c 09 00 00 00 	movl   $0x9,0xc(%eax)
	info->eip_fn_addr = addr;
f010f4f6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f4f9:	8b 55 08             	mov    0x8(%ebp),%edx
f010f4fc:	89 50 10             	mov    %edx,0x10(%eax)
	info->eip_fn_narg = 0;
f010f4ff:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f502:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)

	// Find the relevant set of stabs
	if ((uint32)addr >= USER_LIMIT) {
f010f509:	8b 45 08             	mov    0x8(%ebp),%eax
f010f50c:	3d ff ff 7f ef       	cmp    $0xef7fffff,%eax
f010f511:	76 1e                	jbe    f010f531 <debuginfo_eip+0x68>
		stabs = __STAB_BEGIN__;
f010f513:	c7 45 f4 d4 60 13 f0 	movl   $0xf01360d4,-0xc(%ebp)
		stab_end = __STAB_END__;
f010f51a:	c7 45 f0 18 35 16 f0 	movl   $0xf0163518,-0x10(%ebp)
		stabstr = __STABSTR_BEGIN__;
f010f521:	c7 45 ec 19 35 16 f0 	movl   $0xf0163519,-0x14(%ebp)
		stabstr_end = __STABSTR_END__;
f010f528:	c7 45 e8 01 66 17 f0 	movl   $0xf0176601,-0x18(%ebp)
f010f52f:	eb 2a                	jmp    f010f55b <debuginfo_eip+0x92>
		// The user-application linker script, user/user.ld,
		// puts information about the application's stabs (equivalent
		// to __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__, and
		// __STABSTR_END__) in a structure located at virtual address
		// USTABDATA.
		const struct UserStabData *usd = (const struct UserStabData *) USTABDATA;
f010f531:	c7 45 e0 00 00 20 00 	movl   $0x200000,-0x20(%ebp)

		// Make sure this memory is valid.
		// Return -1 if it is not.  Hint: Call user_mem_check.
		// LAB 3: Your code here.

		stabs = usd->stabs;
f010f538:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f53b:	8b 00                	mov    (%eax),%eax
f010f53d:	89 45 f4             	mov    %eax,-0xc(%ebp)
		stab_end = usd->stab_end;
f010f540:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f543:	8b 40 04             	mov    0x4(%eax),%eax
f010f546:	89 45 f0             	mov    %eax,-0x10(%ebp)
		stabstr = usd->stabstr;
f010f549:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f54c:	8b 40 08             	mov    0x8(%eax),%eax
f010f54f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		stabstr_end = usd->stabstr_end;
f010f552:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f555:	8b 40 0c             	mov    0xc(%eax),%eax
f010f558:	89 45 e8             	mov    %eax,-0x18(%ebp)
		// Make sure the STABS and string table memory is valid.
		// LAB 3: Your code here.
	}

	// String table validity checks
	if (stabstr_end <= stabstr || stabstr_end[-1] != 0)
f010f55b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f55e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f561:	76 0a                	jbe    f010f56d <debuginfo_eip+0xa4>
f010f563:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f566:	48                   	dec    %eax
f010f567:	8a 00                	mov    (%eax),%al
f010f569:	84 c0                	test   %al,%al
f010f56b:	74 0a                	je     f010f577 <debuginfo_eip+0xae>
		return -1;
f010f56d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010f572:	e9 01 02 00 00       	jmp    f010f778 <debuginfo_eip+0x2af>
	// 'eip'.  First, we find the basic source file containing 'eip'.
	// Then, we look in that source file for the function.  Then we look
	// for the line number.

	// Search the entire set of stabs for the source file (type N_SO).
	lfile = 0;
f010f577:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	rfile = (stab_end - stabs) - 1;
f010f57e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f581:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f584:	29 c2                	sub    %eax,%edx
f010f586:	89 d0                	mov    %edx,%eax
f010f588:	c1 f8 02             	sar    $0x2,%eax
f010f58b:	89 c2                	mov    %eax,%edx
f010f58d:	89 d0                	mov    %edx,%eax
f010f58f:	c1 e0 02             	shl    $0x2,%eax
f010f592:	01 d0                	add    %edx,%eax
f010f594:	c1 e0 02             	shl    $0x2,%eax
f010f597:	01 d0                	add    %edx,%eax
f010f599:	c1 e0 02             	shl    $0x2,%eax
f010f59c:	01 d0                	add    %edx,%eax
f010f59e:	89 c1                	mov    %eax,%ecx
f010f5a0:	c1 e1 08             	shl    $0x8,%ecx
f010f5a3:	01 c8                	add    %ecx,%eax
f010f5a5:	89 c1                	mov    %eax,%ecx
f010f5a7:	c1 e1 10             	shl    $0x10,%ecx
f010f5aa:	01 c8                	add    %ecx,%eax
f010f5ac:	01 c0                	add    %eax,%eax
f010f5ae:	01 d0                	add    %edx,%eax
f010f5b0:	48                   	dec    %eax
f010f5b1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
f010f5b4:	ff 75 08             	pushl  0x8(%ebp)
f010f5b7:	6a 64                	push   $0x64
f010f5b9:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f010f5bc:	50                   	push   %eax
f010f5bd:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010f5c0:	50                   	push   %eax
f010f5c1:	ff 75 f4             	pushl  -0xc(%ebp)
f010f5c4:	e8 b3 fd ff ff       	call   f010f37c <stab_binsearch>
f010f5c9:	83 c4 14             	add    $0x14,%esp
	if (lfile == 0)
f010f5cc:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f5cf:	85 c0                	test   %eax,%eax
f010f5d1:	75 0a                	jne    f010f5dd <debuginfo_eip+0x114>
		return -1;
f010f5d3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010f5d8:	e9 9b 01 00 00       	jmp    f010f778 <debuginfo_eip+0x2af>

	// Search within that file's stabs for the function definition
	// (N_FUN).
	lfun = lfile;
f010f5dd:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f5e0:	89 45 d0             	mov    %eax,-0x30(%ebp)
	rfun = rfile;
f010f5e3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010f5e6:	89 45 cc             	mov    %eax,-0x34(%ebp)
	stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
f010f5e9:	ff 75 08             	pushl  0x8(%ebp)
f010f5ec:	6a 24                	push   $0x24
f010f5ee:	8d 45 cc             	lea    -0x34(%ebp),%eax
f010f5f1:	50                   	push   %eax
f010f5f2:	8d 45 d0             	lea    -0x30(%ebp),%eax
f010f5f5:	50                   	push   %eax
f010f5f6:	ff 75 f4             	pushl  -0xc(%ebp)
f010f5f9:	e8 7e fd ff ff       	call   f010f37c <stab_binsearch>
f010f5fe:	83 c4 14             	add    $0x14,%esp

	if (lfun <= rfun) {
f010f601:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010f604:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010f607:	39 c2                	cmp    %eax,%edx
f010f609:	0f 8f 86 00 00 00    	jg     f010f695 <debuginfo_eip+0x1cc>
		// stabs[lfun] points to the function name
		// in the string table, but check bounds just in case.
		if (stabs[lfun].n_strx < stabstr_end - stabstr)
f010f60f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f612:	89 c2                	mov    %eax,%edx
f010f614:	89 d0                	mov    %edx,%eax
f010f616:	01 c0                	add    %eax,%eax
f010f618:	01 d0                	add    %edx,%eax
f010f61a:	c1 e0 02             	shl    $0x2,%eax
f010f61d:	89 c2                	mov    %eax,%edx
f010f61f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f622:	01 d0                	add    %edx,%eax
f010f624:	8b 00                	mov    (%eax),%eax
f010f626:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010f629:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f62c:	29 d1                	sub    %edx,%ecx
f010f62e:	89 ca                	mov    %ecx,%edx
f010f630:	39 d0                	cmp    %edx,%eax
f010f632:	73 22                	jae    f010f656 <debuginfo_eip+0x18d>
			info->eip_fn_name = stabstr + stabs[lfun].n_strx;
f010f634:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f637:	89 c2                	mov    %eax,%edx
f010f639:	89 d0                	mov    %edx,%eax
f010f63b:	01 c0                	add    %eax,%eax
f010f63d:	01 d0                	add    %edx,%eax
f010f63f:	c1 e0 02             	shl    $0x2,%eax
f010f642:	89 c2                	mov    %eax,%edx
f010f644:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f647:	01 d0                	add    %edx,%eax
f010f649:	8b 10                	mov    (%eax),%edx
f010f64b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f64e:	01 c2                	add    %eax,%edx
f010f650:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f653:	89 50 08             	mov    %edx,0x8(%eax)
		info->eip_fn_addr = (uint32*) stabs[lfun].n_value;
f010f656:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f659:	89 c2                	mov    %eax,%edx
f010f65b:	89 d0                	mov    %edx,%eax
f010f65d:	01 c0                	add    %eax,%eax
f010f65f:	01 d0                	add    %edx,%eax
f010f661:	c1 e0 02             	shl    $0x2,%eax
f010f664:	89 c2                	mov    %eax,%edx
f010f666:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f669:	01 d0                	add    %edx,%eax
f010f66b:	8b 50 08             	mov    0x8(%eax),%edx
f010f66e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f671:	89 50 10             	mov    %edx,0x10(%eax)
		addr = (uint32*)(addr - (info->eip_fn_addr));
f010f674:	8b 55 08             	mov    0x8(%ebp),%edx
f010f677:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f67a:	8b 40 10             	mov    0x10(%eax),%eax
f010f67d:	29 c2                	sub    %eax,%edx
f010f67f:	89 d0                	mov    %edx,%eax
f010f681:	c1 f8 02             	sar    $0x2,%eax
f010f684:	89 45 08             	mov    %eax,0x8(%ebp)
		// Search within the function definition for the line number.
		lline = lfun;
f010f687:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f68a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfun;
f010f68d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010f690:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010f693:	eb 15                	jmp    f010f6aa <debuginfo_eip+0x1e1>
	} else {
		// Couldn't find function stab!  Maybe we're in an assembly
		// file.  Search the whole file for the line number.
		info->eip_fn_addr = addr;
f010f695:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f698:	8b 55 08             	mov    0x8(%ebp),%edx
f010f69b:	89 50 10             	mov    %edx,0x10(%eax)
		lline = lfile;
f010f69e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f6a1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfile;
f010f6a4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010f6a7:	89 45 dc             	mov    %eax,-0x24(%ebp)
	}
	// Ignore stuff after the colon.
	info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
f010f6aa:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f6ad:	8b 40 08             	mov    0x8(%eax),%eax
f010f6b0:	83 ec 08             	sub    $0x8,%esp
f010f6b3:	6a 3a                	push   $0x3a
f010f6b5:	50                   	push   %eax
f010f6b6:	e8 82 b5 00 00       	call   f011ac3d <strfind>
f010f6bb:	83 c4 10             	add    $0x10,%esp
f010f6be:	89 c2                	mov    %eax,%edx
f010f6c0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f6c3:	8b 40 08             	mov    0x8(%eax),%eax
f010f6c6:	29 c2                	sub    %eax,%edx
f010f6c8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f6cb:	89 50 0c             	mov    %edx,0xc(%eax)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010f6ce:	eb 03                	jmp    f010f6d3 <debuginfo_eip+0x20a>
	       && stabs[lline].n_type != N_SOL
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
		lline--;
f010f6d0:	ff 4d e4             	decl   -0x1c(%ebp)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010f6d3:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f6d6:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010f6d9:	7c 4e                	jl     f010f729 <debuginfo_eip+0x260>
	       && stabs[lline].n_type != N_SOL
f010f6db:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f6de:	89 d0                	mov    %edx,%eax
f010f6e0:	01 c0                	add    %eax,%eax
f010f6e2:	01 d0                	add    %edx,%eax
f010f6e4:	c1 e0 02             	shl    $0x2,%eax
f010f6e7:	89 c2                	mov    %eax,%edx
f010f6e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f6ec:	01 d0                	add    %edx,%eax
f010f6ee:	8a 40 04             	mov    0x4(%eax),%al
f010f6f1:	3c 84                	cmp    $0x84,%al
f010f6f3:	74 34                	je     f010f729 <debuginfo_eip+0x260>
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
f010f6f5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f6f8:	89 d0                	mov    %edx,%eax
f010f6fa:	01 c0                	add    %eax,%eax
f010f6fc:	01 d0                	add    %edx,%eax
f010f6fe:	c1 e0 02             	shl    $0x2,%eax
f010f701:	89 c2                	mov    %eax,%edx
f010f703:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f706:	01 d0                	add    %edx,%eax
f010f708:	8a 40 04             	mov    0x4(%eax),%al
f010f70b:	3c 64                	cmp    $0x64,%al
f010f70d:	75 c1                	jne    f010f6d0 <debuginfo_eip+0x207>
f010f70f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f712:	89 d0                	mov    %edx,%eax
f010f714:	01 c0                	add    %eax,%eax
f010f716:	01 d0                	add    %edx,%eax
f010f718:	c1 e0 02             	shl    $0x2,%eax
f010f71b:	89 c2                	mov    %eax,%edx
f010f71d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f720:	01 d0                	add    %edx,%eax
f010f722:	8b 40 08             	mov    0x8(%eax),%eax
f010f725:	85 c0                	test   %eax,%eax
f010f727:	74 a7                	je     f010f6d0 <debuginfo_eip+0x207>
		lline--;
	if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr)
f010f729:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f72c:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010f72f:	7c 42                	jl     f010f773 <debuginfo_eip+0x2aa>
f010f731:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f734:	89 d0                	mov    %edx,%eax
f010f736:	01 c0                	add    %eax,%eax
f010f738:	01 d0                	add    %edx,%eax
f010f73a:	c1 e0 02             	shl    $0x2,%eax
f010f73d:	89 c2                	mov    %eax,%edx
f010f73f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f742:	01 d0                	add    %edx,%eax
f010f744:	8b 00                	mov    (%eax),%eax
f010f746:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010f749:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f74c:	29 d1                	sub    %edx,%ecx
f010f74e:	89 ca                	mov    %ecx,%edx
f010f750:	39 d0                	cmp    %edx,%eax
f010f752:	73 1f                	jae    f010f773 <debuginfo_eip+0x2aa>
		info->eip_file = stabstr + stabs[lline].n_strx;
f010f754:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f757:	89 d0                	mov    %edx,%eax
f010f759:	01 c0                	add    %eax,%eax
f010f75b:	01 d0                	add    %edx,%eax
f010f75d:	c1 e0 02             	shl    $0x2,%eax
f010f760:	89 c2                	mov    %eax,%edx
f010f762:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f765:	01 d0                	add    %edx,%eax
f010f767:	8b 10                	mov    (%eax),%edx
f010f769:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f76c:	01 c2                	add    %eax,%edx
f010f76e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f771:	89 10                	mov    %edx,(%eax)
	// Set eip_fn_narg to the number of arguments taken by the function,
	// or 0 if there was no containing function.
	// Your code here.


	return 0;
f010f773:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f778:	c9                   	leave  
f010f779:	c3                   	ret    

f010f77a <setPageReplacmentAlgorithmLRU>:
//===============================
// REPLACEMENT STRATEGIES
//===============================
//2020
void setPageReplacmentAlgorithmLRU(int LRU_TYPE)
{
f010f77a:	55                   	push   %ebp
f010f77b:	89 e5                	mov    %esp,%ebp
f010f77d:	83 ec 08             	sub    $0x8,%esp
	assert(LRU_TYPE == PG_REP_LRU_TIME_APPROX || LRU_TYPE == PG_REP_LRU_LISTS_APPROX);
f010f780:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010f784:	74 1c                	je     f010f7a2 <setPageReplacmentAlgorithmLRU+0x28>
f010f786:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f78a:	74 16                	je     f010f7a2 <setPageReplacmentAlgorithmLRU+0x28>
f010f78c:	68 d0 0e 13 f0       	push   $0xf0130ed0
f010f791:	68 1a 0f 13 f0       	push   $0xf0130f1a
f010f796:	6a 1a                	push   $0x1a
f010f798:	68 2f 0f 13 f0       	push   $0xf0130f2f
f010f79d:	e8 0d 17 ff ff       	call   f0100eaf <_panic>
	_PageRepAlgoType = LRU_TYPE ;
f010f7a2:	8b 45 08             	mov    0x8(%ebp),%eax
f010f7a5:	a3 68 6d 85 f0       	mov    %eax,0xf0856d68
}
f010f7aa:	90                   	nop
f010f7ab:	c9                   	leave  
f010f7ac:	c3                   	ret    

f010f7ad <setPageReplacmentAlgorithmCLOCK>:
void setPageReplacmentAlgorithmCLOCK(){_PageRepAlgoType = PG_REP_CLOCK;}
f010f7ad:	55                   	push   %ebp
f010f7ae:	89 e5                	mov    %esp,%ebp
f010f7b0:	c7 05 68 6d 85 f0 03 	movl   $0x3,0xf0856d68
f010f7b7:	00 00 00 
f010f7ba:	90                   	nop
f010f7bb:	5d                   	pop    %ebp
f010f7bc:	c3                   	ret    

f010f7bd <setPageReplacmentAlgorithmFIFO>:
void setPageReplacmentAlgorithmFIFO(){_PageRepAlgoType = PG_REP_FIFO;}
f010f7bd:	55                   	push   %ebp
f010f7be:	89 e5                	mov    %esp,%ebp
f010f7c0:	c7 05 68 6d 85 f0 04 	movl   $0x4,0xf0856d68
f010f7c7:	00 00 00 
f010f7ca:	90                   	nop
f010f7cb:	5d                   	pop    %ebp
f010f7cc:	c3                   	ret    

f010f7cd <setPageReplacmentAlgorithmModifiedCLOCK>:
void setPageReplacmentAlgorithmModifiedCLOCK(){_PageRepAlgoType = PG_REP_MODIFIEDCLOCK;}
f010f7cd:	55                   	push   %ebp
f010f7ce:	89 e5                	mov    %esp,%ebp
f010f7d0:	c7 05 68 6d 85 f0 05 	movl   $0x5,0xf0856d68
f010f7d7:	00 00 00 
f010f7da:	90                   	nop
f010f7db:	5d                   	pop    %ebp
f010f7dc:	c3                   	ret    

f010f7dd <setPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ void setPageReplacmentAlgorithmDynamicLocal(){_PageRepAlgoType = PG_REP_DYNAMIC_LOCAL;}
f010f7dd:	55                   	push   %ebp
f010f7de:	89 e5                	mov    %esp,%ebp
f010f7e0:	c7 05 68 6d 85 f0 07 	movl   $0x7,0xf0856d68
f010f7e7:	00 00 00 
f010f7ea:	90                   	nop
f010f7eb:	5d                   	pop    %ebp
f010f7ec:	c3                   	ret    

f010f7ed <setPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ void setPageReplacmentAlgorithmNchanceCLOCK(int PageWSMaxSweeps){_PageRepAlgoType = PG_REP_NchanceCLOCK;  page_WS_max_sweeps = PageWSMaxSweeps;}
f010f7ed:	55                   	push   %ebp
f010f7ee:	89 e5                	mov    %esp,%ebp
f010f7f0:	c7 05 68 6d 85 f0 06 	movl   $0x6,0xf0856d68
f010f7f7:	00 00 00 
f010f7fa:	8b 45 08             	mov    0x8(%ebp),%eax
f010f7fd:	a3 b4 e7 83 f0       	mov    %eax,0xf083e7b4
f010f802:	90                   	nop
f010f803:	5d                   	pop    %ebp
f010f804:	c3                   	ret    

f010f805 <setFASTNchanceCLOCK>:
/*2024*/ void setFASTNchanceCLOCK(bool fast){ FASTNchanceCLOCK = fast; };
f010f805:	55                   	push   %ebp
f010f806:	89 e5                	mov    %esp,%ebp
f010f808:	8b 45 08             	mov    0x8(%ebp),%eax
f010f80b:	a3 14 6b 85 f0       	mov    %eax,0xf0856b14
f010f810:	90                   	nop
f010f811:	5d                   	pop    %ebp
f010f812:	c3                   	ret    

f010f813 <setPageReplacmentAlgorithmOPTIMAL>:
/*2025*/ void setPageReplacmentAlgorithmOPTIMAL(){ _PageRepAlgoType = PG_REP_OPTIMAL; };
f010f813:	55                   	push   %ebp
f010f814:	89 e5                	mov    %esp,%ebp
f010f816:	c7 05 68 6d 85 f0 08 	movl   $0x8,0xf0856d68
f010f81d:	00 00 00 
f010f820:	90                   	nop
f010f821:	5d                   	pop    %ebp
f010f822:	c3                   	ret    

f010f823 <isPageReplacmentAlgorithmLRU>:

//2020
uint32 isPageReplacmentAlgorithmLRU(int LRU_TYPE){return _PageRepAlgoType == LRU_TYPE ? 1 : 0;}
f010f823:	55                   	push   %ebp
f010f824:	89 e5                	mov    %esp,%ebp
f010f826:	8b 15 68 6d 85 f0    	mov    0xf0856d68,%edx
f010f82c:	8b 45 08             	mov    0x8(%ebp),%eax
f010f82f:	39 c2                	cmp    %eax,%edx
f010f831:	0f 94 c0             	sete   %al
f010f834:	0f b6 c0             	movzbl %al,%eax
f010f837:	5d                   	pop    %ebp
f010f838:	c3                   	ret    

f010f839 <isPageReplacmentAlgorithmCLOCK>:
uint32 isPageReplacmentAlgorithmCLOCK(){if(_PageRepAlgoType == PG_REP_CLOCK) return 1; return 0;}
f010f839:	55                   	push   %ebp
f010f83a:	89 e5                	mov    %esp,%ebp
f010f83c:	a1 68 6d 85 f0       	mov    0xf0856d68,%eax
f010f841:	83 f8 03             	cmp    $0x3,%eax
f010f844:	75 07                	jne    f010f84d <isPageReplacmentAlgorithmCLOCK+0x14>
f010f846:	b8 01 00 00 00       	mov    $0x1,%eax
f010f84b:	eb 05                	jmp    f010f852 <isPageReplacmentAlgorithmCLOCK+0x19>
f010f84d:	b8 00 00 00 00       	mov    $0x0,%eax
f010f852:	5d                   	pop    %ebp
f010f853:	c3                   	ret    

f010f854 <isPageReplacmentAlgorithmFIFO>:
uint32 isPageReplacmentAlgorithmFIFO(){if(_PageRepAlgoType == PG_REP_FIFO) return 1; return 0;}
f010f854:	55                   	push   %ebp
f010f855:	89 e5                	mov    %esp,%ebp
f010f857:	a1 68 6d 85 f0       	mov    0xf0856d68,%eax
f010f85c:	83 f8 04             	cmp    $0x4,%eax
f010f85f:	75 07                	jne    f010f868 <isPageReplacmentAlgorithmFIFO+0x14>
f010f861:	b8 01 00 00 00       	mov    $0x1,%eax
f010f866:	eb 05                	jmp    f010f86d <isPageReplacmentAlgorithmFIFO+0x19>
f010f868:	b8 00 00 00 00       	mov    $0x0,%eax
f010f86d:	5d                   	pop    %ebp
f010f86e:	c3                   	ret    

f010f86f <isPageReplacmentAlgorithmModifiedCLOCK>:
uint32 isPageReplacmentAlgorithmModifiedCLOCK(){if(_PageRepAlgoType == PG_REP_MODIFIEDCLOCK) return 1; return 0;}
f010f86f:	55                   	push   %ebp
f010f870:	89 e5                	mov    %esp,%ebp
f010f872:	a1 68 6d 85 f0       	mov    0xf0856d68,%eax
f010f877:	83 f8 05             	cmp    $0x5,%eax
f010f87a:	75 07                	jne    f010f883 <isPageReplacmentAlgorithmModifiedCLOCK+0x14>
f010f87c:	b8 01 00 00 00       	mov    $0x1,%eax
f010f881:	eb 05                	jmp    f010f888 <isPageReplacmentAlgorithmModifiedCLOCK+0x19>
f010f883:	b8 00 00 00 00       	mov    $0x0,%eax
f010f888:	5d                   	pop    %ebp
f010f889:	c3                   	ret    

f010f88a <isPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ uint32 isPageReplacmentAlgorithmDynamicLocal(){if(_PageRepAlgoType == PG_REP_DYNAMIC_LOCAL) return 1; return 0;}
f010f88a:	55                   	push   %ebp
f010f88b:	89 e5                	mov    %esp,%ebp
f010f88d:	a1 68 6d 85 f0       	mov    0xf0856d68,%eax
f010f892:	83 f8 07             	cmp    $0x7,%eax
f010f895:	75 07                	jne    f010f89e <isPageReplacmentAlgorithmDynamicLocal+0x14>
f010f897:	b8 01 00 00 00       	mov    $0x1,%eax
f010f89c:	eb 05                	jmp    f010f8a3 <isPageReplacmentAlgorithmDynamicLocal+0x19>
f010f89e:	b8 00 00 00 00       	mov    $0x0,%eax
f010f8a3:	5d                   	pop    %ebp
f010f8a4:	c3                   	ret    

f010f8a5 <isPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ uint32 isPageReplacmentAlgorithmNchanceCLOCK(){if(_PageRepAlgoType == PG_REP_NchanceCLOCK) return 1; return 0;}
f010f8a5:	55                   	push   %ebp
f010f8a6:	89 e5                	mov    %esp,%ebp
f010f8a8:	a1 68 6d 85 f0       	mov    0xf0856d68,%eax
f010f8ad:	83 f8 06             	cmp    $0x6,%eax
f010f8b0:	75 07                	jne    f010f8b9 <isPageReplacmentAlgorithmNchanceCLOCK+0x14>
f010f8b2:	b8 01 00 00 00       	mov    $0x1,%eax
f010f8b7:	eb 05                	jmp    f010f8be <isPageReplacmentAlgorithmNchanceCLOCK+0x19>
f010f8b9:	b8 00 00 00 00       	mov    $0x0,%eax
f010f8be:	5d                   	pop    %ebp
f010f8bf:	c3                   	ret    

f010f8c0 <isPageReplacmentAlgorithmOPTIMAL>:
/*2021*/ uint32 isPageReplacmentAlgorithmOPTIMAL(){if(_PageRepAlgoType == PG_REP_OPTIMAL) return 1; return 0;}
f010f8c0:	55                   	push   %ebp
f010f8c1:	89 e5                	mov    %esp,%ebp
f010f8c3:	a1 68 6d 85 f0       	mov    0xf0856d68,%eax
f010f8c8:	83 f8 08             	cmp    $0x8,%eax
f010f8cb:	75 07                	jne    f010f8d4 <isPageReplacmentAlgorithmOPTIMAL+0x14>
f010f8cd:	b8 01 00 00 00       	mov    $0x1,%eax
f010f8d2:	eb 05                	jmp    f010f8d9 <isPageReplacmentAlgorithmOPTIMAL+0x19>
f010f8d4:	b8 00 00 00 00       	mov    $0x0,%eax
f010f8d9:	5d                   	pop    %ebp
f010f8da:	c3                   	ret    

f010f8db <enableModifiedBuffer>:

//===============================
// PAGE BUFFERING
//===============================
void enableModifiedBuffer(uint32 enableIt){_EnableModifiedBuffer = enableIt;}
f010f8db:	55                   	push   %ebp
f010f8dc:	89 e5                	mov    %esp,%ebp
f010f8de:	8b 45 08             	mov    0x8(%ebp),%eax
f010f8e1:	a3 00 6b 85 f0       	mov    %eax,0xf0856b00
f010f8e6:	90                   	nop
f010f8e7:	5d                   	pop    %ebp
f010f8e8:	c3                   	ret    

f010f8e9 <isModifiedBufferEnabled>:
uint8 isModifiedBufferEnabled(){  return _EnableModifiedBuffer ; }
f010f8e9:	55                   	push   %ebp
f010f8ea:	89 e5                	mov    %esp,%ebp
f010f8ec:	a1 00 6b 85 f0       	mov    0xf0856b00,%eax
f010f8f1:	5d                   	pop    %ebp
f010f8f2:	c3                   	ret    

f010f8f3 <enableBuffering>:

void enableBuffering(uint32 enableIt){_EnableBuffering = enableIt;}
f010f8f3:	55                   	push   %ebp
f010f8f4:	89 e5                	mov    %esp,%ebp
f010f8f6:	8b 45 08             	mov    0x8(%ebp),%eax
f010f8f9:	a3 d4 6d 85 f0       	mov    %eax,0xf0856dd4
f010f8fe:	90                   	nop
f010f8ff:	5d                   	pop    %ebp
f010f900:	c3                   	ret    

f010f901 <isBufferingEnabled>:
uint8 isBufferingEnabled(){  return _EnableBuffering ; }
f010f901:	55                   	push   %ebp
f010f902:	89 e5                	mov    %esp,%ebp
f010f904:	a1 d4 6d 85 f0       	mov    0xf0856dd4,%eax
f010f909:	5d                   	pop    %ebp
f010f90a:	c3                   	ret    

f010f90b <setModifiedBufferLength>:

void setModifiedBufferLength(uint32 length) { _ModifiedBufferLength = length;}
f010f90b:	55                   	push   %ebp
f010f90c:	89 e5                	mov    %esp,%ebp
f010f90e:	8b 45 08             	mov    0x8(%ebp),%eax
f010f911:	a3 70 6e 85 f0       	mov    %eax,0xf0856e70
f010f916:	90                   	nop
f010f917:	5d                   	pop    %ebp
f010f918:	c3                   	ret    

f010f919 <getModifiedBufferLength>:
uint32 getModifiedBufferLength() { return _ModifiedBufferLength;}
f010f919:	55                   	push   %ebp
f010f91a:	89 e5                	mov    %esp,%ebp
f010f91c:	a1 70 6e 85 f0       	mov    0xf0856e70,%eax
f010f921:	5d                   	pop    %ebp
f010f922:	c3                   	ret    

f010f923 <fault_handler_init>:

//==================
// [0] INIT HANDLER:
//==================
void fault_handler_init()
{
f010f923:	55                   	push   %ebp
f010f924:	89 e5                	mov    %esp,%ebp
	//setPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX);
	//setPageReplacmentAlgorithmOPTIMAL();
	setPageReplacmentAlgorithmCLOCK();
f010f926:	e8 82 fe ff ff       	call   f010f7ad <setPageReplacmentAlgorithmCLOCK>
	//setPageReplacmentAlgorithmModifiedCLOCK();
	enableBuffering(0);
f010f92b:	6a 00                	push   $0x0
f010f92d:	e8 c1 ff ff ff       	call   f010f8f3 <enableBuffering>
f010f932:	83 c4 04             	add    $0x4,%esp
	enableModifiedBuffer(0) ;
f010f935:	6a 00                	push   $0x0
f010f937:	e8 9f ff ff ff       	call   f010f8db <enableModifiedBuffer>
f010f93c:	83 c4 04             	add    $0x4,%esp
	setModifiedBufferLength(1000);
f010f93f:	68 e8 03 00 00       	push   $0x3e8
f010f944:	e8 c2 ff ff ff       	call   f010f90b <setModifiedBufferLength>
f010f949:	83 c4 04             	add    $0x4,%esp
}
f010f94c:	90                   	nop
f010f94d:	c9                   	leave  
f010f94e:	c3                   	ret    

f010f94f <fault_handler>:
int8 num_repeated_fault  = 0;
extern uint32 sys_calculate_free_frames() ;

struct Env* last_faulted_env = NULL;
void fault_handler(struct Trapframe *tf)
{
f010f94f:	55                   	push   %ebp
f010f950:	89 e5                	mov    %esp,%ebp
f010f952:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010f955:	0f 20 d0             	mov    %cr2,%eax
f010f958:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f010f95b:	8b 45 d8             	mov    -0x28(%ebp),%eax
	/******************************************************/
	// Read processor's CR2 register to find the faulting address
	uint32 fault_va = rcr2();
f010f95e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	//	print_trapframe(tf);
	/******************************************************/

	//If same fault va for 3 times, then panic
	//UPDATE: 3 FAULTS MUST come from the same environment (or the kernel)
	struct Env* cur_env = get_cpu_proc();
f010f961:	e8 b2 c0 ff ff       	call   f010ba18 <get_cpu_proc>
f010f966:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (last_fault_va == fault_va && last_faulted_env == cur_env)
f010f969:	a1 0c 64 81 f0       	mov    0xf081640c,%eax
f010f96e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f971:	75 50                	jne    f010f9c3 <fault_handler+0x74>
f010f973:	a1 18 64 81 f0       	mov    0xf0816418,%eax
f010f978:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010f97b:	75 46                	jne    f010f9c3 <fault_handler+0x74>
	{
		num_repeated_fault++ ;
f010f97d:	a0 14 64 81 f0       	mov    0xf0816414,%al
f010f982:	40                   	inc    %eax
f010f983:	a2 14 64 81 f0       	mov    %al,0xf0816414
		if (num_repeated_fault == 3)
f010f988:	a0 14 64 81 f0       	mov    0xf0816414,%al
f010f98d:	3c 03                	cmp    $0x3,%al
f010f98f:	75 4d                	jne    f010f9de <fault_handler+0x8f>
		{
			print_trapframe(tf);
f010f991:	83 ec 0c             	sub    $0xc,%esp
f010f994:	ff 75 08             	pushl  0x8(%ebp)
f010f997:	e8 41 e6 ff ff       	call   f010dfdd <print_trapframe>
f010f99c:	83 c4 10             	add    $0x10,%esp
			panic("Failed to handle fault! fault @ at va = %x from eip = %x causes va (%x) to be faulted for 3 successive times\n", before_last_fault_va, before_last_eip, fault_va);
f010f99f:	8b 15 08 64 81 f0    	mov    0xf0816408,%edx
f010f9a5:	a1 10 64 81 f0       	mov    0xf0816410,%eax
f010f9aa:	83 ec 08             	sub    $0x8,%esp
f010f9ad:	ff 75 ec             	pushl  -0x14(%ebp)
f010f9b0:	52                   	push   %edx
f010f9b1:	50                   	push   %eax
f010f9b2:	68 4c 0f 13 f0       	push   $0xf0130f4c
f010f9b7:	6a 69                	push   $0x69
f010f9b9:	68 2f 0f 13 f0       	push   $0xf0130f2f
f010f9be:	e8 ec 14 ff ff       	call   f0100eaf <_panic>
		}
	}
	else
	{
		before_last_fault_va = last_fault_va;
f010f9c3:	a1 0c 64 81 f0       	mov    0xf081640c,%eax
f010f9c8:	a3 10 64 81 f0       	mov    %eax,0xf0816410
		before_last_eip = last_eip;
f010f9cd:	a1 04 64 81 f0       	mov    0xf0816404,%eax
f010f9d2:	a3 08 64 81 f0       	mov    %eax,0xf0816408
		num_repeated_fault = 0;
f010f9d7:	c6 05 14 64 81 f0 00 	movb   $0x0,0xf0816414
	}
	last_eip = (uint32)tf->tf_eip;
f010f9de:	8b 45 08             	mov    0x8(%ebp),%eax
f010f9e1:	8b 40 30             	mov    0x30(%eax),%eax
f010f9e4:	a3 04 64 81 f0       	mov    %eax,0xf0816404
	last_fault_va = fault_va ;
f010f9e9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f9ec:	a3 0c 64 81 f0       	mov    %eax,0xf081640c
	last_faulted_env = cur_env;
f010f9f1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f9f4:	a3 18 64 81 f0       	mov    %eax,0xf0816418
	/******************************************************/
	//2017: Check stack overflow for Kernel
	int userTrap = 0;
f010f9f9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if ((tf->tf_cs & 3) == 3) {
f010fa00:	8b 45 08             	mov    0x8(%ebp),%eax
f010fa03:	8b 40 34             	mov    0x34(%eax),%eax
f010fa06:	0f b7 c0             	movzwl %ax,%eax
f010fa09:	83 e0 03             	and    $0x3,%eax
f010fa0c:	83 f8 03             	cmp    $0x3,%eax
f010fa0f:	75 07                	jne    f010fa18 <fault_handler+0xc9>
		userTrap = 1;
f010fa11:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (!userTrap)
f010fa18:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010fa1c:	0f 85 cb 00 00 00    	jne    f010faed <fault_handler+0x19e>
	{
		struct cpu* c = mycpu();
f010fa22:	e8 49 85 ff ff       	call   f0107f70 <mycpu>
f010fa27:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//cprintf("trap from KERNEL\n");
		if (cur_env && fault_va >= (uint32)cur_env->kstack && fault_va < (uint32)cur_env->kstack + PAGE_SIZE)
f010fa2a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010fa2e:	74 32                	je     f010fa62 <fault_handler+0x113>
f010fa30:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fa33:	8b 40 70             	mov    0x70(%eax),%eax
f010fa36:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fa39:	77 27                	ja     f010fa62 <fault_handler+0x113>
f010fa3b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fa3e:	8b 40 70             	mov    0x70(%eax),%eax
f010fa41:	05 00 10 00 00       	add    $0x1000,%eax
f010fa46:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fa49:	76 17                	jbe    f010fa62 <fault_handler+0x113>
			panic("User Kernel Stack: overflow exception!");
f010fa4b:	83 ec 04             	sub    $0x4,%esp
f010fa4e:	68 bc 0f 13 f0       	push   $0xf0130fbc
f010fa53:	68 80 00 00 00       	push   $0x80
f010fa58:	68 2f 0f 13 f0       	push   $0xf0130f2f
f010fa5d:	e8 4d 14 ff ff       	call   f0100eaf <_panic>
		else if (fault_va >= (uint32)c->stack && fault_va < (uint32)c->stack + PAGE_SIZE)
f010fa62:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fa65:	8b 40 08             	mov    0x8(%eax),%eax
f010fa68:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fa6b:	77 60                	ja     f010facd <fault_handler+0x17e>
f010fa6d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fa70:	8b 40 08             	mov    0x8(%eax),%eax
f010fa73:	05 00 10 00 00       	add    $0x1000,%eax
f010fa78:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fa7b:	76 50                	jbe    f010facd <fault_handler+0x17e>
			panic("Sched Kernel Stack of CPU #%d: overflow exception!", c - CPUS);
f010fa7d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fa80:	ba 00 e9 83 f0       	mov    $0xf083e900,%edx
f010fa85:	29 d0                	sub    %edx,%eax
f010fa87:	c1 f8 03             	sar    $0x3,%eax
f010fa8a:	89 c2                	mov    %eax,%edx
f010fa8c:	89 d0                	mov    %edx,%eax
f010fa8e:	c1 e0 02             	shl    $0x2,%eax
f010fa91:	01 d0                	add    %edx,%eax
f010fa93:	01 c0                	add    %eax,%eax
f010fa95:	01 d0                	add    %edx,%eax
f010fa97:	c1 e0 03             	shl    $0x3,%eax
f010fa9a:	01 d0                	add    %edx,%eax
f010fa9c:	89 c1                	mov    %eax,%ecx
f010fa9e:	c1 e1 0b             	shl    $0xb,%ecx
f010faa1:	01 c8                	add    %ecx,%eax
f010faa3:	c1 e0 05             	shl    $0x5,%eax
f010faa6:	01 d0                	add    %edx,%eax
f010faa8:	c1 e0 02             	shl    $0x2,%eax
f010faab:	01 d0                	add    %edx,%eax
f010faad:	01 c0                	add    %eax,%eax
f010faaf:	01 d0                	add    %edx,%eax
f010fab1:	c1 e0 03             	shl    $0x3,%eax
f010fab4:	01 d0                	add    %edx,%eax
f010fab6:	f7 d8                	neg    %eax
f010fab8:	50                   	push   %eax
f010fab9:	68 e4 0f 13 f0       	push   $0xf0130fe4
f010fabe:	68 82 00 00 00       	push   $0x82
f010fac3:	68 2f 0f 13 f0       	push   $0xf0130f2f
f010fac8:	e8 e2 13 ff ff       	call   f0100eaf <_panic>
#if USE_KHEAP
		if (fault_va >= KERNEL_HEAP_MAX)
f010facd:	81 7d ec ff ef ff ff 	cmpl   $0xffffefff,-0x14(%ebp)
f010fad4:	76 40                	jbe    f010fb16 <fault_handler+0x1c7>
			panic("Kernel: heap overflow exception!");
f010fad6:	83 ec 04             	sub    $0x4,%esp
f010fad9:	68 18 10 13 f0       	push   $0xf0131018
f010fade:	68 85 00 00 00       	push   $0x85
f010fae3:	68 2f 0f 13 f0       	push   $0xf0130f2f
f010fae8:	e8 c2 13 ff ff       	call   f0100eaf <_panic>
	}
	//2017: Check stack underflow for User
	else
	{
		//cprintf("trap from USER\n");
		if (fault_va >= USTACKTOP && fault_va < USER_TOP)
f010faed:	81 7d ec ff df bf ee 	cmpl   $0xeebfdfff,-0x14(%ebp)
f010faf4:	76 20                	jbe    f010fb16 <fault_handler+0x1c7>
f010faf6:	81 7d ec ff ff bf ee 	cmpl   $0xeebfffff,-0x14(%ebp)
f010fafd:	77 17                	ja     f010fb16 <fault_handler+0x1c7>
			panic("User: stack underflow exception!");
f010faff:	83 ec 04             	sub    $0x4,%esp
f010fb02:	68 3c 10 13 f0       	push   $0xf013103c
f010fb07:	68 8d 00 00 00       	push   $0x8d
f010fb0c:	68 2f 0f 13 f0       	push   $0xf0130f2f
f010fb11:	e8 99 13 ff ff       	call   f0100eaf <_panic>
	}

	//get a pointer to the environment that caused the fault at runtime
	//cprintf("curenv = %x\n", curenv);
	struct Env* faulted_env = cur_env;
f010fb16:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fb19:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (faulted_env == NULL)
f010fb1c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010fb20:	75 38                	jne    f010fb5a <fault_handler+0x20b>
	{
		cprintf("\nFaulted VA = %x\n", fault_va);
f010fb22:	83 ec 08             	sub    $0x8,%esp
f010fb25:	ff 75 ec             	pushl  -0x14(%ebp)
f010fb28:	68 5d 10 13 f0       	push   $0xf013105d
f010fb2d:	e8 2a 20 ff ff       	call   f0101b5c <cprintf>
f010fb32:	83 c4 10             	add    $0x10,%esp
		print_trapframe(tf);
f010fb35:	83 ec 0c             	sub    $0xc,%esp
f010fb38:	ff 75 08             	pushl  0x8(%ebp)
f010fb3b:	e8 9d e4 ff ff       	call   f010dfdd <print_trapframe>
f010fb40:	83 c4 10             	add    $0x10,%esp
		panic("faulted env == NULL!");
f010fb43:	83 ec 04             	sub    $0x4,%esp
f010fb46:	68 6f 10 13 f0       	push   $0xf013106f
f010fb4b:	68 97 00 00 00       	push   $0x97
f010fb50:	68 2f 0f 13 f0       	push   $0xf0130f2f
f010fb55:	e8 55 13 ff ff       	call   f0100eaf <_panic>
	}
	//check the faulted address, is it a table or not ?
	//If the directory entry of the faulted address is NOT PRESENT then
	if ( (faulted_env->env_page_directory[PDX(fault_va)] & PERM_PRESENT) != PERM_PRESENT)
f010fb5a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fb5d:	8b 40 64             	mov    0x64(%eax),%eax
f010fb60:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010fb63:	c1 ea 16             	shr    $0x16,%edx
f010fb66:	c1 e2 02             	shl    $0x2,%edx
f010fb69:	01 d0                	add    %edx,%eax
f010fb6b:	8b 00                	mov    (%eax),%eax
f010fb6d:	83 e0 01             	and    $0x1,%eax
f010fb70:	85 c0                	test   %eax,%eax
f010fb72:	75 28                	jne    f010fb9c <fault_handler+0x24d>
	{
		faulted_env->tableFaultsCounter ++ ;
f010fb74:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fb77:	8b 80 9c 05 00 00    	mov    0x59c(%eax),%eax
f010fb7d:	8d 50 01             	lea    0x1(%eax),%edx
f010fb80:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fb83:	89 90 9c 05 00 00    	mov    %edx,0x59c(%eax)
		table_fault_handler(faulted_env, fault_va);
f010fb89:	83 ec 08             	sub    $0x8,%esp
f010fb8c:	ff 75 ec             	pushl  -0x14(%ebp)
f010fb8f:	ff 75 e0             	pushl  -0x20(%ebp)
f010fb92:	e8 8f 00 00 00       	call   f010fc26 <table_fault_handler>
f010fb97:	83 c4 10             	add    $0x10,%esp
f010fb9a:	eb 7b                	jmp    f010fc17 <fault_handler+0x2c8>

			/*============================================================================================*/
		}

		/*2022: Check if fault due to Access Rights */
		int perms = pt_get_page_permissions(faulted_env->env_page_directory, fault_va);
f010fb9c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fb9f:	8b 40 64             	mov    0x64(%eax),%eax
f010fba2:	83 ec 08             	sub    $0x8,%esp
f010fba5:	ff 75 ec             	pushl  -0x14(%ebp)
f010fba8:	50                   	push   %eax
f010fba9:	e8 16 a1 ff ff       	call   f0109cc4 <pt_get_page_permissions>
f010fbae:	83 c4 10             	add    $0x10,%esp
f010fbb1:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (perms & PERM_PRESENT)
f010fbb4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fbb7:	83 e0 01             	and    $0x1,%eax
f010fbba:	85 c0                	test   %eax,%eax
f010fbbc:	74 17                	je     f010fbd5 <fault_handler+0x286>
			panic("Page @va=%x is exist! page fault due to violation of ACCESS RIGHTS\n", fault_va) ;
f010fbbe:	ff 75 ec             	pushl  -0x14(%ebp)
f010fbc1:	68 84 10 13 f0       	push   $0xf0131084
f010fbc6:	68 af 00 00 00       	push   $0xaf
f010fbcb:	68 2f 0f 13 f0       	push   $0xf0130f2f
f010fbd0:	e8 da 12 ff ff       	call   f0100eaf <_panic>
		/*============================================================================================*/


		// we have normal page fault =============================================================
		faulted_env->pageFaultsCounter ++ ;
f010fbd5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fbd8:	8b 80 98 05 00 00    	mov    0x598(%eax),%eax
f010fbde:	8d 50 01             	lea    0x1(%eax),%edx
f010fbe1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fbe4:	89 90 98 05 00 00    	mov    %edx,0x598(%eax)
//				cprintf("[%08s] user PAGE fault va %08x\n", faulted_env->prog_name, fault_va);
//				cprintf("\nPage working set BEFORE fault handler...\n");
//				env_page_ws_print(faulted_env);
		//int ffb = sys_calculate_free_frames();

		if(isBufferingEnabled())
f010fbea:	e8 12 fd ff ff       	call   f010f901 <isBufferingEnabled>
f010fbef:	84 c0                	test   %al,%al
f010fbf1:	74 13                	je     f010fc06 <fault_handler+0x2b7>
		{
			__page_fault_handler_with_buffering(faulted_env, fault_va);
f010fbf3:	83 ec 08             	sub    $0x8,%esp
f010fbf6:	ff 75 ec             	pushl  -0x14(%ebp)
f010fbf9:	ff 75 e0             	pushl  -0x20(%ebp)
f010fbfc:	e8 2c 01 00 00       	call   f010fd2d <__page_fault_handler_with_buffering>
f010fc01:	83 c4 10             	add    $0x10,%esp
f010fc04:	eb 11                	jmp    f010fc17 <fault_handler+0x2c8>
		}
		else
		{
			page_fault_handler(faulted_env, fault_va);
f010fc06:	83 ec 08             	sub    $0x8,%esp
f010fc09:	ff 75 ec             	pushl  -0x14(%ebp)
f010fc0c:	ff 75 e0             	pushl  -0x20(%ebp)
f010fc0f:	e8 50 00 00 00       	call   f010fc64 <page_fault_handler>
f010fc14:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010fc17:	0f 20 d8             	mov    %cr3,%eax
f010fc1a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010fc1d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fc20:	0f 22 d8             	mov    %eax,%cr3

	/*************************************************************/
	//Refresh the TLB cache
	tlbflush();
	/*************************************************************/
}
f010fc23:	90                   	nop
f010fc24:	c9                   	leave  
f010fc25:	c3                   	ret    

f010fc26 <table_fault_handler>:

//=========================
// [2] TABLE FAULT HANDLER:
//=========================
void table_fault_handler(struct Env * curenv, uint32 fault_va)
{
f010fc26:	55                   	push   %ebp
f010fc27:	89 e5                	mov    %esp,%ebp
f010fc29:	83 ec 18             	sub    $0x18,%esp
	//panic("table_fault_handler() is not implemented yet...!!");
	//Check if it's a stack page
	uint32* ptr_table;
#if USE_KHEAP
	{
		ptr_table = create_page_table(curenv->env_page_directory, (uint32)fault_va);
f010fc2c:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc2f:	8b 40 64             	mov    0x64(%eax),%eax
f010fc32:	83 ec 08             	sub    $0x8,%esp
f010fc35:	ff 75 0c             	pushl  0xc(%ebp)
f010fc38:	50                   	push   %eax
f010fc39:	e8 6b 97 ff ff       	call   f01093a9 <create_page_table>
f010fc3e:	83 c4 10             	add    $0x10,%esp
f010fc41:	89 45 f4             	mov    %eax,-0xc(%ebp)
#else
	{
		__static_cpt(curenv->env_page_directory, (uint32)fault_va, &ptr_table);
	}
#endif
}
f010fc44:	90                   	nop
f010fc45:	c9                   	leave  
f010fc46:	c3                   	ret    

f010fc47 <get_optimal_num_faults>:
 * 	3. Page References List (contains the stream of referenced VAs till the process finished)
 *
 * 	IMPORTANT: This function SHOULD NOT change any of the given lists
 */
int get_optimal_num_faults(struct WS_List *initWorkingSet, int maxWSSize, struct PageRef_List *pageReferences)
{
f010fc47:	55                   	push   %ebp
f010fc48:	89 e5                	mov    %esp,%ebp
f010fc4a:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#1] FAULT HANDLER II - #2 get_optimal_num_faults
	//Your code is here
	//Comment the following line
	panic("get_optimal_num_faults() is not implemented yet...!!");
f010fc4d:	83 ec 04             	sub    $0x4,%esp
f010fc50:	68 c8 10 13 f0       	push   $0xf01310c8
f010fc55:	68 f4 00 00 00       	push   $0xf4
f010fc5a:	68 2f 0f 13 f0       	push   $0xf0130f2f
f010fc5f:	e8 4b 12 ff ff       	call   f0100eaf <_panic>

f010fc64 <page_fault_handler>:
}

void page_fault_handler(struct Env * faulted_env, uint32 fault_va)
{
f010fc64:	55                   	push   %ebp
f010fc65:	89 e5                	mov    %esp,%ebp
f010fc67:	83 ec 18             	sub    $0x18,%esp
#if USE_KHEAP
	struct WorkingSetElement *victimWSElement = NULL;
f010fc6a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 wsSize = LIST_SIZE(&(faulted_env->page_WS_list));
f010fc71:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc74:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010fc7a:	89 45 f0             	mov    %eax,-0x10(%ebp)
#else
	int iWS =faulted_env->page_last_WS_index;
	uint32 wsSize = env_page_ws_get_size(faulted_env);
#endif
	if(wsSize < (faulted_env->page_WS_max_size))
f010fc7d:	8b 45 08             	mov    0x8(%ebp),%eax
f010fc80:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010fc86:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010fc89:	76 17                	jbe    f010fca2 <page_fault_handler+0x3e>
	{
		//TODO: [PROJECT'25.GM#3] FAULT HANDLER I - #3 placement
		//Your code is here
		//Comment the following line
		panic("page_fault_handler().PLACEMENT is not implemented yet...!!");
f010fc8b:	83 ec 04             	sub    $0x4,%esp
f010fc8e:	68 00 11 13 f0       	push   $0xf0131100
f010fc93:	68 05 01 00 00       	push   $0x105
f010fc98:	68 2f 0f 13 f0       	push   $0xf0130f2f
f010fc9d:	e8 0d 12 ff ff       	call   f0100eaf <_panic>
	}
	else
	{
		if (isPageReplacmentAlgorithmOPTIMAL())
f010fca2:	e8 19 fc ff ff       	call   f010f8c0 <isPageReplacmentAlgorithmOPTIMAL>
f010fca7:	85 c0                	test   %eax,%eax
f010fca9:	74 17                	je     f010fcc2 <page_fault_handler+0x5e>
		{
			//TODO: [PROJECT'25.IM#1] FAULT HANDLER II - #1 Optimal Reference Stream
			//Your code is here
			//Comment the following line
			panic("page_fault_handler().REPLACEMENT is not implemented yet...!!");
f010fcab:	83 ec 04             	sub    $0x4,%esp
f010fcae:	68 3c 11 13 f0       	push   $0xf013113c
f010fcb3:	68 0e 01 00 00       	push   $0x10e
f010fcb8:	68 2f 0f 13 f0       	push   $0xf0130f2f
f010fcbd:	e8 ed 11 ff ff       	call   f0100eaf <_panic>
		}
		else if (isPageReplacmentAlgorithmOPTIMAL())
f010fcc2:	e8 f9 fb ff ff       	call   f010f8c0 <isPageReplacmentAlgorithmOPTIMAL>
f010fcc7:	85 c0                	test   %eax,%eax
f010fcc9:	74 17                	je     f010fce2 <page_fault_handler+0x7e>
		{
			//TODO: [PROJECT'25.IM#1] FAULT HANDLER II - #3 Clock Replacement
			//Your code is here
			//Comment the following line
			panic("page_fault_handler().REPLACEMENT is not implemented yet...!!");
f010fccb:	83 ec 04             	sub    $0x4,%esp
f010fcce:	68 3c 11 13 f0       	push   $0xf013113c
f010fcd3:	68 15 01 00 00       	push   $0x115
f010fcd8:	68 2f 0f 13 f0       	push   $0xf0130f2f
f010fcdd:	e8 cd 11 ff ff       	call   f0100eaf <_panic>
		}
		else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f010fce2:	83 ec 0c             	sub    $0xc,%esp
f010fce5:	6a 01                	push   $0x1
f010fce7:	e8 37 fb ff ff       	call   f010f823 <isPageReplacmentAlgorithmLRU>
f010fcec:	83 c4 10             	add    $0x10,%esp
f010fcef:	85 c0                	test   %eax,%eax
f010fcf1:	74 17                	je     f010fd0a <page_fault_handler+0xa6>
		{
			//TODO: [PROJECT'25.IM#6] FAULT HANDLER II - #2 LRU Aging Replacement
			//Your code is here
			//Comment the following line
			panic("page_fault_handler().REPLACEMENT is not implemented yet...!!");
f010fcf3:	83 ec 04             	sub    $0x4,%esp
f010fcf6:	68 3c 11 13 f0       	push   $0xf013113c
f010fcfb:	68 1c 01 00 00       	push   $0x11c
f010fd00:	68 2f 0f 13 f0       	push   $0xf0130f2f
f010fd05:	e8 a5 11 ff ff       	call   f0100eaf <_panic>
		}
		else if (isPageReplacmentAlgorithmModifiedCLOCK())
f010fd0a:	e8 60 fb ff ff       	call   f010f86f <isPageReplacmentAlgorithmModifiedCLOCK>
f010fd0f:	85 c0                	test   %eax,%eax
f010fd11:	74 17                	je     f010fd2a <page_fault_handler+0xc6>
		{
			//TODO: [PROJECT'25.IM#6] FAULT HANDLER II - #3 Modified Clock Replacement
			//Your code is here
			//Comment the following line
			panic("page_fault_handler().REPLACEMENT is not implemented yet...!!");
f010fd13:	83 ec 04             	sub    $0x4,%esp
f010fd16:	68 3c 11 13 f0       	push   $0xf013113c
f010fd1b:	68 23 01 00 00       	push   $0x123
f010fd20:	68 2f 0f 13 f0       	push   $0xf0130f2f
f010fd25:	e8 85 11 ff ff       	call   f0100eaf <_panic>
		}
	}
}
f010fd2a:	90                   	nop
f010fd2b:	c9                   	leave  
f010fd2c:	c3                   	ret    

f010fd2d <__page_fault_handler_with_buffering>:

void __page_fault_handler_with_buffering(struct Env * curenv, uint32 fault_va)
{
f010fd2d:	55                   	push   %ebp
f010fd2e:	89 e5                	mov    %esp,%ebp
f010fd30:	83 ec 08             	sub    $0x8,%esp
	panic("this function is not required...!!");
f010fd33:	83 ec 04             	sub    $0x4,%esp
f010fd36:	68 7c 11 13 f0       	push   $0xf013117c
f010fd3b:	68 2a 01 00 00       	push   $0x12a
f010fd40:	68 2f 0f 13 f0       	push   $0xf0130f2f
f010fd45:	e8 65 11 ff ff       	call   f0100eaf <_panic>

f010fd4a <init_kspinlock>:
#include "inc/assert.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_kspinlock(struct kspinlock *lk, char *name)
{
f010fd4a:	55                   	push   %ebp
f010fd4b:	89 e5                	mov    %esp,%ebp
f010fd4d:	83 ec 08             	sub    $0x8,%esp
	strcpy(lk->name, name);
f010fd50:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd53:	83 c0 04             	add    $0x4,%eax
f010fd56:	83 ec 08             	sub    $0x8,%esp
f010fd59:	ff 75 0c             	pushl  0xc(%ebp)
f010fd5c:	50                   	push   %eax
f010fd5d:	e8 68 ad 00 00       	call   f011aaca <strcpy>
f010fd62:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010fd65:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd68:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->cpu = 0;
f010fd6e:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd71:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
f010fd78:	90                   	nop
f010fd79:	c9                   	leave  
f010fd7a:	c3                   	ret    

f010fd7b <acquire_kspinlock>:
// Acquire the lock.
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void acquire_kspinlock(struct kspinlock *lk)
{
f010fd7b:	55                   	push   %ebp
f010fd7c:	89 e5                	mov    %esp,%ebp
f010fd7e:	53                   	push   %ebx
f010fd7f:	83 ec 24             	sub    $0x24,%esp
	if(holding_kspinlock(lk))
f010fd82:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd85:	83 ec 0c             	sub    $0xc,%esp
f010fd88:	50                   	push   %eax
f010fd89:	e8 42 02 00 00       	call   f010ffd0 <holding_kspinlock>
f010fd8e:	83 c4 10             	add    $0x10,%esp
f010fd91:	85 c0                	test   %eax,%eax
f010fd93:	74 18                	je     f010fdad <acquire_kspinlock+0x32>
		panic("acquire_spinlock: lock \"%s\" is already held by the same CPU.", lk->name);
f010fd95:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd98:	83 c0 04             	add    $0x4,%eax
f010fd9b:	50                   	push   %eax
f010fd9c:	68 a0 11 13 f0       	push   $0xf01311a0
f010fda1:	6a 1f                	push   $0x1f
f010fda3:	68 dd 11 13 f0       	push   $0xf01311dd
f010fda8:	e8 02 11 ff ff       	call   f0100eaf <_panic>

	/*disable interrupts to avoid deadlock (in case if interrupted from a higher priority (or event handler)
	 * just after holding the lock => the handler will stuck in busy-waiting and prevent the other from resuming)
	 */
	pushcli();
f010fdad:	e8 7e 82 ff ff       	call   f0108030 <pushcli>

	int envID = 0;
f010fdb2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct Env *e = get_cpu_proc() ;
f010fdb9:	e8 5a bc ff ff       	call   f010ba18 <get_cpu_proc>
f010fdbe:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (e) envID = e->env_id;
f010fdc1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010fdc5:	74 09                	je     f010fdd0 <acquire_kspinlock+0x55>
f010fdc7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fdca:	8b 40 10             	mov    0x10(%eax),%eax
f010fdcd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("[%d] try to acquire spinlock [%s]\n", envID, lk->name);

	// The xchg is atomic.
	while(xchg(&lk->locked, 1) != 0) ;
f010fdd0:	90                   	nop
f010fdd1:	8b 45 08             	mov    0x8(%ebp),%eax
f010fdd4:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010fdd7:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f010fdde:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010fde1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fde4:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f010fde7:	f0 87 02             	lock xchg %eax,(%edx)
f010fdea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
               "+m" (*addr), "=a" (result) :
               "1" (newval) :
               "cc");
  return result;
f010fded:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fdf0:	85 c0                	test   %eax,%eax
f010fdf2:	75 dd                	jne    f010fdd1 <acquire_kspinlock+0x56>
	//cprintf("SPIN lock [%s] is ACQUIRED  by [%d]\n", lk->name, envID);

	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that the critical section's memory
	// references happen after the lock is acquired.
	__sync_synchronize();
f010fdf4:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Record info about lock acquisition for debugging.
	lk->cpu = mycpu();
f010fdf9:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010fdfc:	e8 6f 81 ff ff       	call   f0107f70 <mycpu>
f010fe01:	89 43 44             	mov    %eax,0x44(%ebx)
	getcallerpcs(&lk, lk->pcs);
f010fe04:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe07:	83 c0 48             	add    $0x48,%eax
f010fe0a:	83 ec 08             	sub    $0x8,%esp
f010fe0d:	50                   	push   %eax
f010fe0e:	8d 45 08             	lea    0x8(%ebp),%eax
f010fe11:	50                   	push   %eax
f010fe12:	e8 92 00 00 00       	call   f010fea9 <getcallerpcs>
f010fe17:	83 c4 10             	add    $0x10,%esp

}
f010fe1a:	90                   	nop
f010fe1b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010fe1e:	c9                   	leave  
f010fe1f:	c3                   	ret    

f010fe20 <release_kspinlock>:

// Release the lock.
void release_kspinlock(struct kspinlock *lk)
{
f010fe20:	55                   	push   %ebp
f010fe21:	89 e5                	mov    %esp,%ebp
f010fe23:	83 ec 18             	sub    $0x18,%esp
	if(!holding_kspinlock(lk))
f010fe26:	83 ec 0c             	sub    $0xc,%esp
f010fe29:	ff 75 08             	pushl  0x8(%ebp)
f010fe2c:	e8 9f 01 00 00       	call   f010ffd0 <holding_kspinlock>
f010fe31:	83 c4 10             	add    $0x10,%esp
f010fe34:	85 c0                	test   %eax,%eax
f010fe36:	75 26                	jne    f010fe5e <release_kspinlock+0x3e>
	{
		printcallstack(lk);
f010fe38:	83 ec 0c             	sub    $0xc,%esp
f010fe3b:	ff 75 08             	pushl  0x8(%ebp)
f010fe3e:	e8 26 01 00 00       	call   f010ff69 <printcallstack>
f010fe43:	83 c4 10             	add    $0x10,%esp
		panic("release: lock \"%s\" is either not held or held by another CPU!", lk->name);
f010fe46:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe49:	83 c0 04             	add    $0x4,%eax
f010fe4c:	50                   	push   %eax
f010fe4d:	68 f4 11 13 f0       	push   $0xf01311f4
f010fe52:	6a 41                	push   $0x41
f010fe54:	68 dd 11 13 f0       	push   $0xf01311dd
f010fe59:	e8 51 10 ff ff       	call   f0100eaf <_panic>
	}
	lk->pcs[0] = 0;
f010fe5e:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe61:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
	lk->cpu = 0;
f010fe68:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe6b:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that all the stores in the critical
	// section are visible to other cores before the lock is released.
	// Both the C compiler and the hardware may re-order loads and
	// stores; __sync_synchronize() tells them both not to.
	__sync_synchronize();
f010fe72:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Release the lock, equivalent to lk->locked = 0.
	// This code can't use a C assignment, since it might
	// not be atomic. A real OS would use C atomics here.
	asm volatile("movl $0, %0" : "+m" (lk->locked) : );
f010fe77:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe7a:	8b 55 08             	mov    0x8(%ebp),%edx
f010fe7d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	int envID = 0;
f010fe83:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct Env *e = get_cpu_proc() ;
f010fe8a:	e8 89 bb ff ff       	call   f010ba18 <get_cpu_proc>
f010fe8f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (e) envID = e->env_id;
f010fe92:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010fe96:	74 09                	je     f010fea1 <release_kspinlock+0x81>
f010fe98:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fe9b:	8b 40 10             	mov    0x10(%eax),%eax
f010fe9e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("[%d] release spinlock [%s]\n", envID, lk->name);

	popcli();
f010fea1:	e8 dc 81 ff ff       	call   f0108082 <popcli>

}
f010fea6:	90                   	nop
f010fea7:	c9                   	leave  
f010fea8:	c3                   	ret    

f010fea9 <getcallerpcs>:

// Record the current call stack in pcs[] by following the %ebp chain.
int getcallerpcs(void *v, uint32 pcs[])
{
f010fea9:	55                   	push   %ebp
f010feaa:	89 e5                	mov    %esp,%ebp
f010feac:	83 ec 28             	sub    $0x28,%esp
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
f010feaf:	e8 64 bb ff ff       	call   f010ba18 <get_cpu_proc>
f010feb4:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct cpu* c = mycpu();
f010feb7:	e8 b4 80 ff ff       	call   f0107f70 <mycpu>
f010febc:	89 45 e8             	mov    %eax,-0x18(%ebp)
	ebp = (uint32*)v - 2;
f010febf:	8b 45 08             	mov    0x8(%ebp),%eax
f010fec2:	83 e8 08             	sub    $0x8,%eax
f010fec5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(i = 0; i < 10; i++)
f010fec8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010fecf:	eb 67                	jmp    f010ff38 <getcallerpcs+0x8f>
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010fed1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010fed5:	74 67                	je     f010ff3e <getcallerpcs+0x95>
f010fed7:	81 7d f4 ff ff 7f ef 	cmpl   $0xef7fffff,-0xc(%ebp)
f010fede:	76 5e                	jbe    f010ff3e <getcallerpcs+0x95>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010fee0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fee3:	8b 40 08             	mov    0x8(%eax),%eax
f010fee6:	05 00 80 00 00       	add    $0x8000,%eax
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010feeb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010feee:	77 10                	ja     f010ff00 <getcallerpcs+0x57>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010fef0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fef3:	8b 40 08             	mov    0x8(%eax),%eax
f010fef6:	05 00 90 00 00       	add    $0x9000,%eax
f010fefb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010fefe:	77 3e                	ja     f010ff3e <getcallerpcs+0x95>
f010ff00:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010ff04:	74 10                	je     f010ff16 <getcallerpcs+0x6d>
				(p && ebp >= (uint32*) (p->kstack + KERNEL_STACK_SIZE)))
f010ff06:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ff09:	8b 40 70             	mov    0x70(%eax),%eax
f010ff0c:	05 00 80 00 00       	add    $0x8000,%eax
f010ff11:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010ff14:	76 28                	jbe    f010ff3e <getcallerpcs+0x95>
			break;
		pcs[i] = ebp[1];     // saved %eip
f010ff16:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ff19:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010ff20:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ff23:	01 c2                	add    %eax,%edx
f010ff25:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ff28:	8b 40 04             	mov    0x4(%eax),%eax
f010ff2b:	89 02                	mov    %eax,(%edx)
		ebp = (uint32*)ebp[0]; // saved %ebp
f010ff2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ff30:	8b 00                	mov    (%eax),%eax
f010ff32:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
f010ff35:	ff 45 f0             	incl   -0x10(%ebp)
f010ff38:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f010ff3c:	7e 93                	jle    f010fed1 <getcallerpcs+0x28>
		pcs[i] = ebp[1];     // saved %eip
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
f010ff3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ff41:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for(; i < 10; i++)
f010ff44:	eb 18                	jmp    f010ff5e <getcallerpcs+0xb5>
		pcs[i] = 0;
f010ff46:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ff49:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010ff50:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ff53:	01 d0                	add    %edx,%eax
f010ff55:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
	for(; i < 10; i++)
f010ff5b:	ff 45 f0             	incl   -0x10(%ebp)
f010ff5e:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f010ff62:	7e e2                	jle    f010ff46 <getcallerpcs+0x9d>
		pcs[i] = 0;
	return length ;
f010ff64:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f010ff67:	c9                   	leave  
f010ff68:	c3                   	ret    

f010ff69 <printcallstack>:

void printcallstack(struct kspinlock *lk)
{
f010ff69:	55                   	push   %ebp
f010ff6a:	89 e5                	mov    %esp,%ebp
f010ff6c:	83 ec 18             	sub    $0x18,%esp
	cprintf("\nCaller Stack:\n");
f010ff6f:	83 ec 0c             	sub    $0xc,%esp
f010ff72:	68 32 12 13 f0       	push   $0xf0131232
f010ff77:	e8 e0 1b ff ff       	call   f0101b5c <cprintf>
f010ff7c:	83 c4 10             	add    $0x10,%esp
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
f010ff7f:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff82:	83 c0 48             	add    $0x48,%eax
f010ff85:	83 ec 08             	sub    $0x8,%esp
f010ff88:	50                   	push   %eax
f010ff89:	8d 45 08             	lea    0x8(%ebp),%eax
f010ff8c:	50                   	push   %eax
f010ff8d:	e8 17 ff ff ff       	call   f010fea9 <getcallerpcs>
f010ff92:	83 c4 10             	add    $0x10,%esp
f010ff95:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for (int i = 0; i < stacklen; ++i) {
f010ff98:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010ff9f:	eb 24                	jmp    f010ffc5 <printcallstack+0x5c>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
f010ffa1:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffa4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ffa7:	83 c2 10             	add    $0x10,%edx
f010ffaa:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
f010ffae:	83 ec 04             	sub    $0x4,%esp
f010ffb1:	50                   	push   %eax
f010ffb2:	ff 75 f4             	pushl  -0xc(%ebp)
f010ffb5:	68 42 12 13 f0       	push   $0xf0131242
f010ffba:	e8 9d 1b ff ff       	call   f0101b5c <cprintf>
f010ffbf:	83 c4 10             	add    $0x10,%esp

void printcallstack(struct kspinlock *lk)
{
	cprintf("\nCaller Stack:\n");
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
	for (int i = 0; i < stacklen; ++i) {
f010ffc2:	ff 45 f4             	incl   -0xc(%ebp)
f010ffc5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ffc8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010ffcb:	7c d4                	jl     f010ffa1 <printcallstack+0x38>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
	}
}
f010ffcd:	90                   	nop
f010ffce:	c9                   	leave  
f010ffcf:	c3                   	ret    

f010ffd0 <holding_kspinlock>:
// Check whether this cpu is holding the lock.
int holding_kspinlock(struct kspinlock *lock)
{
f010ffd0:	55                   	push   %ebp
f010ffd1:	89 e5                	mov    %esp,%ebp
f010ffd3:	53                   	push   %ebx
f010ffd4:	83 ec 14             	sub    $0x14,%esp
	int r;
	pushcli();
f010ffd7:	e8 54 80 ff ff       	call   f0108030 <pushcli>
	r = lock->locked && lock->cpu == mycpu();
f010ffdc:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffdf:	8b 00                	mov    (%eax),%eax
f010ffe1:	85 c0                	test   %eax,%eax
f010ffe3:	74 16                	je     f010fffb <holding_kspinlock+0x2b>
f010ffe5:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffe8:	8b 58 44             	mov    0x44(%eax),%ebx
f010ffeb:	e8 80 7f ff ff       	call   f0107f70 <mycpu>
f010fff0:	39 c3                	cmp    %eax,%ebx
f010fff2:	75 07                	jne    f010fffb <holding_kspinlock+0x2b>
f010fff4:	b8 01 00 00 00       	mov    $0x1,%eax
f010fff9:	eb 05                	jmp    f0110000 <holding_kspinlock+0x30>
f010fffb:	b8 00 00 00 00       	mov    $0x0,%eax
f0110000:	89 45 f4             	mov    %eax,-0xc(%ebp)
	popcli();
f0110003:	e8 7a 80 ff ff       	call   f0108082 <popcli>
	return r;
f0110008:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011000b:	83 c4 14             	add    $0x14,%esp
f011000e:	5b                   	pop    %ebx
f011000f:	5d                   	pop    %ebp
f0110010:	c3                   	ret    

f0110011 <init_sleeplock>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_sleeplock(struct sleeplock *lk, char *name)
{
f0110011:	55                   	push   %ebp
f0110012:	89 e5                	mov    %esp,%ebp
f0110014:	57                   	push   %edi
f0110015:	56                   	push   %esi
f0110016:	53                   	push   %ebx
f0110017:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	init_channel(&(lk->chan), "sleep lock channel");
f011001d:	8b 45 08             	mov    0x8(%ebp),%eax
f0110020:	83 c0 74             	add    $0x74,%eax
f0110023:	83 ec 08             	sub    $0x8,%esp
f0110026:	68 54 12 13 f0       	push   $0xf0131254
f011002b:	50                   	push   %eax
f011002c:	e8 22 01 00 00       	call   f0110153 <init_channel>
f0110031:	83 c4 10             	add    $0x10,%esp
	char prefix[30] = "lock of sleeplock - ";
f0110034:	8d 45 ca             	lea    -0x36(%ebp),%eax
f0110037:	bb 67 12 13 f0       	mov    $0xf0131267,%ebx
f011003c:	ba 15 00 00 00       	mov    $0x15,%edx
f0110041:	89 c7                	mov    %eax,%edi
f0110043:	89 de                	mov    %ebx,%esi
f0110045:	89 d1                	mov    %edx,%ecx
f0110047:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0110049:	8d 55 df             	lea    -0x21(%ebp),%edx
f011004c:	b9 09 00 00 00       	mov    $0x9,%ecx
f0110051:	b0 00                	mov    $0x0,%al
f0110053:	89 d7                	mov    %edx,%edi
f0110055:	f3 aa                	rep stos %al,%es:(%edi)
	char guardName[30+NAMELEN];
	strcconcat(prefix, name, guardName);
f0110057:	83 ec 04             	sub    $0x4,%esp
f011005a:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f0110060:	50                   	push   %eax
f0110061:	ff 75 0c             	pushl  0xc(%ebp)
f0110064:	8d 45 ca             	lea    -0x36(%ebp),%eax
f0110067:	50                   	push   %eax
f0110068:	e8 3c b0 00 00       	call   f011b0a9 <strcconcat>
f011006d:	83 c4 10             	add    $0x10,%esp
	init_kspinlock(&(lk->lk), guardName);
f0110070:	8b 45 08             	mov    0x8(%ebp),%eax
f0110073:	8d 50 04             	lea    0x4(%eax),%edx
f0110076:	83 ec 08             	sub    $0x8,%esp
f0110079:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011007f:	50                   	push   %eax
f0110080:	52                   	push   %edx
f0110081:	e8 c4 fc ff ff       	call   f010fd4a <init_kspinlock>
f0110086:	83 c4 10             	add    $0x10,%esp
	strcpy(lk->name, name);
f0110089:	8b 45 08             	mov    0x8(%ebp),%eax
f011008c:	05 c4 00 00 00       	add    $0xc4,%eax
f0110091:	83 ec 08             	sub    $0x8,%esp
f0110094:	ff 75 0c             	pushl  0xc(%ebp)
f0110097:	50                   	push   %eax
f0110098:	e8 2d aa 00 00       	call   f011aaca <strcpy>
f011009d:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f01100a0:	8b 45 08             	mov    0x8(%ebp),%eax
f01100a3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->pid = 0;
f01100a9:	8b 45 08             	mov    0x8(%ebp),%eax
f01100ac:	c7 80 04 01 00 00 00 	movl   $0x0,0x104(%eax)
f01100b3:	00 00 00 
}
f01100b6:	90                   	nop
f01100b7:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01100ba:	5b                   	pop    %ebx
f01100bb:	5e                   	pop    %esi
f01100bc:	5f                   	pop    %edi
f01100bd:	5d                   	pop    %ebp
f01100be:	c3                   	ret    

f01100bf <acquire_sleeplock>:

void acquire_sleeplock(struct sleeplock *lk)
{
f01100bf:	55                   	push   %ebp
f01100c0:	89 e5                	mov    %esp,%ebp
f01100c2:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#5] KERNEL PROTECTION: #4 SLEEP LOCK - acquire_sleeplock
	//Your code is here
	//Comment the following line
	panic("acquire_sleeplock() is not implemented yet...!!");
f01100c5:	83 ec 04             	sub    $0x4,%esp
f01100c8:	68 88 12 13 f0       	push   $0xf0131288
f01100cd:	6a 20                	push   $0x20
f01100cf:	68 b8 12 13 f0       	push   $0xf01312b8
f01100d4:	e8 d6 0d ff ff       	call   f0100eaf <_panic>

f01100d9 <release_sleeplock>:
}

void release_sleeplock(struct sleeplock *lk)
{
f01100d9:	55                   	push   %ebp
f01100da:	89 e5                	mov    %esp,%ebp
f01100dc:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#5] KERNEL PROTECTION: #5 SLEEP LOCK - release_sleeplock
	//Your code is here
	//Comment the following line
	panic("release_sleeplock() is not implemented yet...!!");
f01100df:	83 ec 04             	sub    $0x4,%esp
f01100e2:	68 d0 12 13 f0       	push   $0xf01312d0
f01100e7:	6a 28                	push   $0x28
f01100e9:	68 b8 12 13 f0       	push   $0xf01312b8
f01100ee:	e8 bc 0d ff ff       	call   f0100eaf <_panic>

f01100f3 <holding_sleeplock>:
}

int holding_sleeplock(struct sleeplock *lk)
{
f01100f3:	55                   	push   %ebp
f01100f4:	89 e5                	mov    %esp,%ebp
f01100f6:	53                   	push   %ebx
f01100f7:	83 ec 14             	sub    $0x14,%esp
	int r;
	acquire_kspinlock(&(lk->lk));
f01100fa:	8b 45 08             	mov    0x8(%ebp),%eax
f01100fd:	83 c0 04             	add    $0x4,%eax
f0110100:	83 ec 0c             	sub    $0xc,%esp
f0110103:	50                   	push   %eax
f0110104:	e8 72 fc ff ff       	call   f010fd7b <acquire_kspinlock>
f0110109:	83 c4 10             	add    $0x10,%esp
	r = lk->locked && (lk->pid == get_cpu_proc()->env_id);
f011010c:	8b 45 08             	mov    0x8(%ebp),%eax
f011010f:	8b 00                	mov    (%eax),%eax
f0110111:	85 c0                	test   %eax,%eax
f0110113:	74 1c                	je     f0110131 <holding_sleeplock+0x3e>
f0110115:	8b 45 08             	mov    0x8(%ebp),%eax
f0110118:	8b 98 04 01 00 00    	mov    0x104(%eax),%ebx
f011011e:	e8 f5 b8 ff ff       	call   f010ba18 <get_cpu_proc>
f0110123:	8b 40 10             	mov    0x10(%eax),%eax
f0110126:	39 c3                	cmp    %eax,%ebx
f0110128:	75 07                	jne    f0110131 <holding_sleeplock+0x3e>
f011012a:	b8 01 00 00 00       	mov    $0x1,%eax
f011012f:	eb 05                	jmp    f0110136 <holding_sleeplock+0x43>
f0110131:	b8 00 00 00 00       	mov    $0x0,%eax
f0110136:	89 45 f4             	mov    %eax,-0xc(%ebp)
	release_kspinlock(&(lk->lk));
f0110139:	8b 45 08             	mov    0x8(%ebp),%eax
f011013c:	83 c0 04             	add    $0x4,%eax
f011013f:	83 ec 0c             	sub    $0xc,%esp
f0110142:	50                   	push   %eax
f0110143:	e8 d8 fc ff ff       	call   f010fe20 <release_kspinlock>
f0110148:	83 c4 10             	add    $0x10,%esp
	return r;
f011014b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011014e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0110151:	c9                   	leave  
f0110152:	c3                   	ret    

f0110153 <init_channel>:
//===============================
// 1) INITIALIZE THE CHANNEL:
//===============================
// initialize its lock & queue
void init_channel(struct Channel *chan, char *name)
{
f0110153:	55                   	push   %ebp
f0110154:	89 e5                	mov    %esp,%ebp
f0110156:	83 ec 08             	sub    $0x8,%esp
	strcpy(chan->name, name);
f0110159:	8b 45 08             	mov    0x8(%ebp),%eax
f011015c:	83 c0 10             	add    $0x10,%eax
f011015f:	83 ec 08             	sub    $0x8,%esp
f0110162:	ff 75 0c             	pushl  0xc(%ebp)
f0110165:	50                   	push   %eax
f0110166:	e8 5f a9 00 00       	call   f011aaca <strcpy>
f011016b:	83 c4 10             	add    $0x10,%esp
	init_queue(&(chan->queue));
f011016e:	8b 45 08             	mov    0x8(%ebp),%eax
f0110171:	83 ec 0c             	sub    $0xc,%esp
f0110174:	50                   	push   %eax
f0110175:	e8 50 5d ff ff       	call   f0105eca <init_queue>
f011017a:	83 c4 10             	add    $0x10,%esp
}
f011017d:	90                   	nop
f011017e:	c9                   	leave  
f011017f:	c3                   	ret    

f0110180 <sleep>:
//===============================
// Atomically release lock and sleep on chan.
// Reacquires lock when awakened.
// Ref: xv6-x86 OS code
void sleep(struct Channel *chan, struct kspinlock* lk)
{
f0110180:	55                   	push   %ebp
f0110181:	89 e5                	mov    %esp,%ebp
f0110183:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#5] KERNEL PROTECTION: #1 CHANNEL - sleep
	//Your code is here
	//Comment the following line
	panic("sleep() is not implemented yet...!!");
f0110186:	83 ec 04             	sub    $0x4,%esp
f0110189:	68 00 13 13 f0       	push   $0xf0131300
f011018e:	6a 22                	push   $0x22
f0110190:	68 24 13 13 f0       	push   $0xf0131324
f0110195:	e8 15 0d ff ff       	call   f0100eaf <_panic>

f011019a <wakeup_one>:
// Wake up ONE process sleeping on chan.
// The qlock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes
void wakeup_one(struct Channel *chan)
{
f011019a:	55                   	push   %ebp
f011019b:	89 e5                	mov    %esp,%ebp
f011019d:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#5] KERNEL PROTECTION: #2 CHANNEL - wakeup_one
	//Your code is here
	//Comment the following line
	panic("wakeup_one() is not implemented yet...!!");
f01101a0:	83 ec 04             	sub    $0x4,%esp
f01101a3:	68 38 13 13 f0       	push   $0xf0131338
f01101a8:	6a 31                	push   $0x31
f01101aa:	68 24 13 13 f0       	push   $0xf0131324
f01101af:	e8 fb 0c ff ff       	call   f0100eaf <_panic>

f01101b4 <wakeup_all>:
// The queues lock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes

void wakeup_all(struct Channel *chan)
{
f01101b4:	55                   	push   %ebp
f01101b5:	89 e5                	mov    %esp,%ebp
f01101b7:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#5] KERNEL PROTECTION: #3 CHANNEL - wakeup_all
	//Your code is here
	//Comment the following line
	panic("wakeup_all() is not implemented yet...!!");
f01101ba:	83 ec 04             	sub    $0x4,%esp
f01101bd:	68 64 13 13 f0       	push   $0xf0131364
f01101c2:	6a 41                	push   $0x41
f01101c4:	68 24 13 13 f0       	push   $0xf0131324
f01101c9:	e8 e1 0c ff ff       	call   f0100eaf <_panic>

f01101ce <init_ksemaphore>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_ksemaphore(struct ksemaphore *ksem, int value, char *name)
{
f01101ce:	55                   	push   %ebp
f01101cf:	89 e5                	mov    %esp,%ebp
f01101d1:	83 ec 08             	sub    $0x8,%esp
	init_channel(&(ksem->chan), "ksemaphore channel");
f01101d4:	8b 45 08             	mov    0x8(%ebp),%eax
f01101d7:	83 c0 74             	add    $0x74,%eax
f01101da:	83 ec 08             	sub    $0x8,%esp
f01101dd:	68 90 13 13 f0       	push   $0xf0131390
f01101e2:	50                   	push   %eax
f01101e3:	e8 6b ff ff ff       	call   f0110153 <init_channel>
f01101e8:	83 c4 10             	add    $0x10,%esp
	init_kspinlock(&(ksem->lk), "lock of ksemaphore");
f01101eb:	8b 45 08             	mov    0x8(%ebp),%eax
f01101ee:	83 c0 04             	add    $0x4,%eax
f01101f1:	83 ec 08             	sub    $0x8,%esp
f01101f4:	68 a3 13 13 f0       	push   $0xf01313a3
f01101f9:	50                   	push   %eax
f01101fa:	e8 4b fb ff ff       	call   f010fd4a <init_kspinlock>
f01101ff:	83 c4 10             	add    $0x10,%esp
	strcpy(ksem->name, name);
f0110202:	8b 45 08             	mov    0x8(%ebp),%eax
f0110205:	05 c4 00 00 00       	add    $0xc4,%eax
f011020a:	83 ec 08             	sub    $0x8,%esp
f011020d:	ff 75 10             	pushl  0x10(%ebp)
f0110210:	50                   	push   %eax
f0110211:	e8 b4 a8 00 00       	call   f011aaca <strcpy>
f0110216:	83 c4 10             	add    $0x10,%esp
	ksem->count = value;
f0110219:	8b 45 08             	mov    0x8(%ebp),%eax
f011021c:	8b 55 0c             	mov    0xc(%ebp),%edx
f011021f:	89 10                	mov    %edx,(%eax)
}
f0110221:	90                   	nop
f0110222:	c9                   	leave  
f0110223:	c3                   	ret    

f0110224 <wait_ksemaphore>:

void wait_ksemaphore(struct ksemaphore *ksem)
{
f0110224:	55                   	push   %ebp
f0110225:	89 e5                	mov    %esp,%ebp
f0110227:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#5] KERNEL PROTECTION: #6 SEMAPHORE - wait_ksemaphore
	//Your code is here
	//Comment the following line
	panic("wait_ksemaphore() is not implemented yet...!!");
f011022a:	83 ec 04             	sub    $0x4,%esp
f011022d:	68 b8 13 13 f0       	push   $0xf01313b8
f0110232:	6a 1c                	push   $0x1c
f0110234:	68 e6 13 13 f0       	push   $0xf01313e6
f0110239:	e8 71 0c ff ff       	call   f0100eaf <_panic>

f011023e <signal_ksemaphore>:

}

void signal_ksemaphore(struct ksemaphore *ksem)
{
f011023e:	55                   	push   %ebp
f011023f:	89 e5                	mov    %esp,%ebp
f0110241:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#5] KERNEL PROTECTION: #7 SEMAPHORE - signal_ksemaphore
	//Your code is here
	//Comment the following line
	panic("signal_ksemaphore() is not implemented yet...!!");
f0110244:	83 ec 04             	sub    $0x4,%esp
f0110247:	68 00 14 13 f0       	push   $0xf0131400
f011024c:	6a 25                	push   $0x25
f011024e:	68 e6 13 13 f0       	push   $0xf01313e6
f0110253:	e8 57 0c ff ff       	call   f0100eaf <_panic>

f0110258 <set_kheap_strategy>:
uint32 kheapPageAllocStart ;
uint32 kheapPageAllocBreak ;
uint32 kheapPlacementStrategy;

/*2025*/ //Replaced by setter & getter function
static inline void set_kheap_strategy(uint32 strategy){kheapPlacementStrategy = strategy;}
f0110258:	55                   	push   %ebp
f0110259:	89 e5                	mov    %esp,%ebp
f011025b:	8b 45 08             	mov    0x8(%ebp),%eax
f011025e:	a3 c4 69 85 f0       	mov    %eax,0xf08569c4
f0110263:	90                   	nop
f0110264:	5d                   	pop    %ebp
f0110265:	c3                   	ret    

f0110266 <tst_handler>:

//=================//
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
f0110266:	55                   	push   %ebp
f0110267:	89 e5                	mov    %esp,%ebp
f0110269:	83 ec 18             	sub    $0x18,%esp
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f011026c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0110273:	eb 26                	jmp    f011029b <tst_handler+0x35>
	{
		arguments[a] = arguments[a+1] ;
f0110275:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110278:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011027f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110282:	01 c2                	add    %eax,%edx
f0110284:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110287:	40                   	inc    %eax
f0110288:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f011028f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110292:	01 c8                	add    %ecx,%eax
f0110294:	8b 00                	mov    (%eax),%eax
f0110296:	89 02                	mov    %eax,(%edx)
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f0110298:	ff 45 f4             	incl   -0xc(%ebp)
f011029b:	8b 45 08             	mov    0x8(%ebp),%eax
f011029e:	48                   	dec    %eax
f011029f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01102a2:	7f d1                	jg     f0110275 <tst_handler+0xf>
	{
		arguments[a] = arguments[a+1] ;
	}
	number_of_arguments--;
f01102a4:	ff 4d 08             	decl   0x8(%ebp)

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
f01102a7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f01102ae:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01102b5:	eb 35                	jmp    f01102ec <tst_handler+0x86>
	{
		if (strcmp(arguments[0], tests[i].name) == 0)
f01102b7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01102ba:	89 d0                	mov    %edx,%eax
f01102bc:	01 c0                	add    %eax,%eax
f01102be:	01 d0                	add    %edx,%eax
f01102c0:	c1 e0 02             	shl    $0x2,%eax
f01102c3:	05 c0 00 18 f0       	add    $0xf01800c0,%eax
f01102c8:	8b 10                	mov    (%eax),%edx
f01102ca:	8b 45 0c             	mov    0xc(%ebp),%eax
f01102cd:	8b 00                	mov    (%eax),%eax
f01102cf:	83 ec 08             	sub    $0x8,%esp
f01102d2:	52                   	push   %edx
f01102d3:	50                   	push   %eax
f01102d4:	e8 ae a8 00 00       	call   f011ab87 <strcmp>
f01102d9:	83 c4 10             	add    $0x10,%esp
f01102dc:	85 c0                	test   %eax,%eax
f01102de:	75 09                	jne    f01102e9 <tst_handler+0x83>
		{
			test_found = 1;
f01102e0:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			break;
f01102e7:	eb 0f                	jmp    f01102f8 <tst_handler+0x92>
	number_of_arguments--;

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f01102e9:	ff 45 ec             	incl   -0x14(%ebp)
f01102ec:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01102ef:	a1 80 01 18 f0       	mov    0xf0180180,%eax
f01102f4:	39 c2                	cmp    %eax,%edx
f01102f6:	72 bf                	jb     f01102b7 <tst_handler+0x51>
			test_found = 1;
			break;
		}
	}

	if(test_found)
f01102f8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01102fc:	74 29                	je     f0110327 <tst_handler+0xc1>
	{
		int return_value;
		return_value = tests[i].function_to_execute(number_of_arguments, arguments);
f01102fe:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0110301:	89 d0                	mov    %edx,%eax
f0110303:	01 c0                	add    %eax,%eax
f0110305:	01 d0                	add    %edx,%eax
f0110307:	c1 e0 02             	shl    $0x2,%eax
f011030a:	05 c8 00 18 f0       	add    $0xf01800c8,%eax
f011030f:	8b 00                	mov    (%eax),%eax
f0110311:	83 ec 08             	sub    $0x8,%esp
f0110314:	ff 75 0c             	pushl  0xc(%ebp)
f0110317:	ff 75 08             	pushl  0x8(%ebp)
f011031a:	ff d0                	call   *%eax
f011031c:	83 c4 10             	add    $0x10,%esp
f011031f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		return return_value;
f0110322:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110325:	eb 1b                	jmp    f0110342 <tst_handler+0xdc>
	}
	else
	{
		cprintf("Unknown test '%s'\n", arguments[0]);
f0110327:	8b 45 0c             	mov    0xc(%ebp),%eax
f011032a:	8b 00                	mov    (%eax),%eax
f011032c:	83 ec 08             	sub    $0x8,%esp
f011032f:	50                   	push   %eax
f0110330:	68 c0 17 13 f0       	push   $0xf01317c0
f0110335:	e8 22 18 ff ff       	call   f0101b5c <cprintf>
f011033a:	83 c4 10             	add    $0x10,%esp
		return 0;
f011033d:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0110342:	c9                   	leave  
f0110343:	c3                   	ret    

f0110344 <tst_three_creation_functions>:

//=================//
/*TESTING Functions*/
//=================//
int tst_three_creation_functions(int number_of_arguments, char **arguments)
{
f0110344:	55                   	push   %ebp
f0110345:	89 e5                	mov    %esp,%ebp
f0110347:	83 ec 08             	sub    $0x8,%esp
	test_three_creation_functions();
f011034a:	e8 25 78 00 00       	call   f0117b74 <test_three_creation_functions>
	return 0;
f011034f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110354:	c9                   	leave  
f0110355:	c3                   	ret    

f0110356 <tst_priority1>:

int tst_priority1(int number_of_arguments, char **arguments)
{
f0110356:	55                   	push   %ebp
f0110357:	89 e5                	mov    %esp,%ebp
f0110359:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_higher();
f011035c:	e8 3a 6e 00 00       	call   f011719b <test_priority_normal_and_higher>
	return 0;
f0110361:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110366:	c9                   	leave  
f0110367:	c3                   	ret    

f0110368 <tst_priority2>:

int tst_priority2(int number_of_arguments, char **arguments)
{
f0110368:	55                   	push   %ebp
f0110369:	89 e5                	mov    %esp,%ebp
f011036b:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_lower();
f011036e:	e8 42 6e 00 00       	call   f01171b5 <test_priority_normal_and_lower>
	return 0;
f0110373:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110378:	c9                   	leave  
f0110379:	c3                   	ret    

f011037a <tst_kfreeall>:

int tst_kfreeall(int number_of_arguments, char **arguments)
{
f011037a:	55                   	push   %ebp
f011037b:	89 e5                	mov    %esp,%ebp
f011037d:	83 ec 08             	sub    $0x8,%esp
	test_kfreeall();
f0110380:	e8 a2 79 00 00       	call   f0117d27 <test_kfreeall>
	return 0;
f0110385:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011038a:	c9                   	leave  
f011038b:	c3                   	ret    

f011038c <tst_kexpand>:

int tst_kexpand(int number_of_arguments, char **arguments)
{
f011038c:	55                   	push   %ebp
f011038d:	89 e5                	mov    %esp,%ebp
f011038f:	83 ec 08             	sub    $0x8,%esp
	test_kexpand();
f0110392:	e8 ad 79 00 00       	call   f0117d44 <test_kexpand>
	return 0;
f0110397:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011039c:	c9                   	leave  
f011039d:	c3                   	ret    

f011039e <tst_kshrink>:

int tst_kshrink(int number_of_arguments, char **arguments)
{
f011039e:	55                   	push   %ebp
f011039f:	89 e5                	mov    %esp,%ebp
f01103a1:	83 ec 08             	sub    $0x8,%esp
	test_kshrink();
f01103a4:	e8 b8 79 00 00       	call   f0117d61 <test_kshrink>
	return 0;
f01103a9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01103ae:	c9                   	leave  
f01103af:	c3                   	ret    

f01103b0 <tst_kfreelast>:

int tst_kfreelast(int number_of_arguments, char **arguments)
{
f01103b0:	55                   	push   %ebp
f01103b1:	89 e5                	mov    %esp,%ebp
f01103b3:	83 ec 08             	sub    $0x8,%esp
	test_kfreelast();
f01103b6:	e8 c3 79 00 00       	call   f0117d7e <test_kfreelast>
	return 0;
f01103bb:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01103c0:	c9                   	leave  
f01103c1:	c3                   	ret    

f01103c2 <tst_sc_MLFQ>:

int tst_sc_MLFQ(int number_of_arguments, char **arguments)
{
f01103c2:	55                   	push   %ebp
f01103c3:	89 e5                	mov    %esp,%ebp
f01103c5:	83 ec 18             	sub    $0x18,%esp
	int numOfSlave2 = strtol(arguments[1], NULL, 10);
f01103c8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01103cb:	83 c0 04             	add    $0x4,%eax
f01103ce:	8b 00                	mov    (%eax),%eax
f01103d0:	83 ec 04             	sub    $0x4,%esp
f01103d3:	6a 0a                	push   $0xa
f01103d5:	6a 00                	push   $0x0
f01103d7:	50                   	push   %eax
f01103d8:	e8 ad aa 00 00       	call   f011ae8a <strtol>
f01103dd:	83 c4 10             	add    $0x10,%esp
f01103e0:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int cnt = 0 ;
f01103e3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int firstTime = 1;
f01103ea:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct Env *e ;
	acquire_kspinlock(&ProcessQueues.qlock);
f01103f1:	83 ec 0c             	sub    $0xc,%esp
f01103f4:	68 20 e7 83 f0       	push   $0xf083e720
f01103f9:	e8 7d f9 ff ff       	call   f010fd7b <acquire_kspinlock>
f01103fe:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f0110401:	a1 a0 e7 83 f0       	mov    0xf083e7a0,%eax
f0110406:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0110409:	eb 3b                	jmp    f0110446 <tst_sc_MLFQ+0x84>
									{
			if (strcmp(e->prog_name, "tmlfq_2") == 0)
f011040b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011040e:	83 c0 20             	add    $0x20,%eax
f0110411:	83 ec 08             	sub    $0x8,%esp
f0110414:	68 d3 17 13 f0       	push   $0xf01317d3
f0110419:	50                   	push   %eax
f011041a:	e8 68 a7 00 00       	call   f011ab87 <strcmp>
f011041f:	83 c4 10             	add    $0x10,%esp
f0110422:	85 c0                	test   %eax,%eax
f0110424:	75 12                	jne    f0110438 <tst_sc_MLFQ+0x76>
			{
				if (firstTime)
f0110426:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011042a:	74 07                	je     f0110433 <tst_sc_MLFQ+0x71>
					firstTime = 0;
f011042c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cnt++ ;
f0110433:	ff 45 f4             	incl   -0xc(%ebp)
f0110436:	eb 06                	jmp    f011043e <tst_sc_MLFQ+0x7c>
			}
			else if (!firstTime)
f0110438:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011043c:	74 31                	je     f011046f <tst_sc_MLFQ+0xad>
	int cnt = 0 ;
	int firstTime = 1;
	struct Env *e ;
	acquire_kspinlock(&ProcessQueues.qlock);
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f011043e:	a1 a8 e7 83 f0       	mov    0xf083e7a8,%eax
f0110443:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0110446:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011044a:	74 08                	je     f0110454 <tst_sc_MLFQ+0x92>
f011044c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011044f:	8b 40 08             	mov    0x8(%eax),%eax
f0110452:	eb 05                	jmp    f0110459 <tst_sc_MLFQ+0x97>
f0110454:	b8 00 00 00 00       	mov    $0x0,%eax
f0110459:	a3 a8 e7 83 f0       	mov    %eax,0xf083e7a8
f011045e:	a1 a8 e7 83 f0       	mov    0xf083e7a8,%eax
f0110463:	85 c0                	test   %eax,%eax
f0110465:	75 a4                	jne    f011040b <tst_sc_MLFQ+0x49>
f0110467:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011046b:	75 9e                	jne    f011040b <tst_sc_MLFQ+0x49>
f011046d:	eb 01                	jmp    f0110470 <tst_sc_MLFQ+0xae>
				if (firstTime)
					firstTime = 0;
				cnt++ ;
			}
			else if (!firstTime)
				break;
f011046f:	90                   	nop
									}
		if(cnt == numOfSlave2)
f0110470:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110473:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0110476:	75 12                	jne    f011048a <tst_sc_MLFQ+0xc8>
		{
			cprintf("Congratulations... MLFQScenario# completed successfully\n");
f0110478:	83 ec 0c             	sub    $0xc,%esp
f011047b:	68 dc 17 13 f0       	push   $0xf01317dc
f0110480:	e8 d7 16 ff ff       	call   f0101b5c <cprintf>
f0110485:	83 c4 10             	add    $0x10,%esp
f0110488:	eb 17                	jmp    f01104a1 <tst_sc_MLFQ+0xdf>
		}
		else
		{
			panic("MLFQScenario# failed\n");
f011048a:	83 ec 04             	sub    $0x4,%esp
f011048d:	68 15 18 13 f0       	push   $0xf0131815
f0110492:	68 9c 00 00 00       	push   $0x9c
f0110497:	68 2b 18 13 f0       	push   $0xf013182b
f011049c:	e8 0e 0a ff ff       	call   f0100eaf <_panic>
		}
	}
	release_kspinlock(&ProcessQueues.qlock);
f01104a1:	83 ec 0c             	sub    $0xc,%esp
f01104a4:	68 20 e7 83 f0       	push   $0xf083e720
f01104a9:	e8 72 f9 ff ff       	call   f010fe20 <release_kspinlock>
f01104ae:	83 c4 10             	add    $0x10,%esp
	return 0;
f01104b1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01104b6:	c9                   	leave  
f01104b7:	c3                   	ret    

f01104b8 <tst_bsd_nice>:


/*2023*/
int tst_bsd_nice(int number_of_arguments, char **arguments)
{
f01104b8:	55                   	push   %ebp
f01104b9:	89 e5                	mov    %esp,%ebp
f01104bb:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments != 2)
f01104be:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01104c2:	74 17                	je     f01104db <tst_bsd_nice+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst bsd_nice <testnumber>\n");
f01104c4:	83 ec 0c             	sub    $0xc,%esp
f01104c7:	68 44 18 13 f0       	push   $0xf0131844
f01104cc:	e8 8b 16 ff ff       	call   f0101b5c <cprintf>
f01104d1:	83 c4 10             	add    $0x10,%esp
		return 0;
f01104d4:	b8 00 00 00 00       	mov    $0x0,%eax
f01104d9:	eb 45                	jmp    f0110520 <tst_bsd_nice+0x68>
	}
	int testNumber = strtol(arguments[1], NULL, 10);
f01104db:	8b 45 0c             	mov    0xc(%ebp),%eax
f01104de:	83 c0 04             	add    $0x4,%eax
f01104e1:	8b 00                	mov    (%eax),%eax
f01104e3:	83 ec 04             	sub    $0x4,%esp
f01104e6:	6a 0a                	push   $0xa
f01104e8:	6a 00                	push   $0x0
f01104ea:	50                   	push   %eax
f01104eb:	e8 9a a9 00 00       	call   f011ae8a <strtol>
f01104f0:	83 c4 10             	add    $0x10,%esp
f01104f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (testNumber)
f01104f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01104f9:	83 f8 01             	cmp    $0x1,%eax
f01104fc:	74 10                	je     f011050e <tst_bsd_nice+0x56>
f01104fe:	83 f8 02             	cmp    $0x2,%eax
f0110501:	74 12                	je     f0110515 <tst_bsd_nice+0x5d>
f0110503:	85 c0                	test   %eax,%eax
f0110505:	75 14                	jne    f011051b <tst_bsd_nice+0x63>
	{
	case 0:
		test_bsd_nice_0();
f0110507:	e8 e4 79 00 00       	call   f0117ef0 <test_bsd_nice_0>
		break;
f011050c:	eb 0d                	jmp    f011051b <tst_bsd_nice+0x63>
	case 1:
		test_bsd_nice_1();
f011050e:	e8 f7 79 00 00       	call   f0117f0a <test_bsd_nice_1>
		break;
f0110513:	eb 06                	jmp    f011051b <tst_bsd_nice+0x63>
	case 2:
		test_bsd_nice_2();
f0110515:	e8 0a 7a 00 00       	call   f0117f24 <test_bsd_nice_2>
		break;
f011051a:	90                   	nop
	}
	return 0;
f011051b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110520:	c9                   	leave  
f0110521:	c3                   	ret    

f0110522 <tst_priorityRR>:

/*2024*/
int tst_priorityRR(int number_of_arguments, char **arguments)
{
f0110522:	55                   	push   %ebp
f0110523:	89 e5                	mov    %esp,%ebp
f0110525:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments != 2)
f0110528:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011052c:	74 17                	je     f0110545 <tst_priorityRR+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst priorityRR <testnumber>\n");
f011052e:	83 ec 0c             	sub    $0xc,%esp
f0110531:	68 84 18 13 f0       	push   $0xf0131884
f0110536:	e8 21 16 ff ff       	call   f0101b5c <cprintf>
f011053b:	83 c4 10             	add    $0x10,%esp
		return 0;
f011053e:	b8 00 00 00 00       	mov    $0x0,%eax
f0110543:	eb 45                	jmp    f011058a <tst_priorityRR+0x68>
	}
	int testNumber = strtol(arguments[1], NULL, 10);
f0110545:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110548:	83 c0 04             	add    $0x4,%eax
f011054b:	8b 00                	mov    (%eax),%eax
f011054d:	83 ec 04             	sub    $0x4,%esp
f0110550:	6a 0a                	push   $0xa
f0110552:	6a 00                	push   $0x0
f0110554:	50                   	push   %eax
f0110555:	e8 30 a9 00 00       	call   f011ae8a <strtol>
f011055a:	83 c4 10             	add    $0x10,%esp
f011055d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (testNumber)
f0110560:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110563:	83 f8 01             	cmp    $0x1,%eax
f0110566:	74 10                	je     f0110578 <tst_priorityRR+0x56>
f0110568:	83 f8 02             	cmp    $0x2,%eax
f011056b:	74 12                	je     f011057f <tst_priorityRR+0x5d>
f011056d:	85 c0                	test   %eax,%eax
f011056f:	75 14                	jne    f0110585 <tst_priorityRR+0x63>
	{
	case 0:
		test_priorityRR_0();
f0110571:	e8 c8 79 00 00       	call   f0117f3e <test_priorityRR_0>
		break;
f0110576:	eb 0d                	jmp    f0110585 <tst_priorityRR+0x63>
	case 1:
		test_priorityRR_1();
f0110578:	e8 70 7c 00 00       	call   f01181ed <test_priorityRR_1>
		break;
f011057d:	eb 06                	jmp    f0110585 <tst_priorityRR+0x63>
	case 2:
		test_priorityRR_2();
f011057f:	e8 fc 7e 00 00       	call   f0118480 <test_priorityRR_2>
		break;
f0110584:	90                   	nop
	}
	return 0;
f0110585:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011058a:	c9                   	leave  
f011058b:	c3                   	ret    

f011058c <tst_str2lower>:
int tst_str2lower(int number_of_arguments, char **arguments)
{
f011058c:	55                   	push   %ebp
f011058d:	89 e5                	mov    %esp,%ebp
f011058f:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 1)
f0110592:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0110596:	74 17                	je     f01105af <tst_str2lower+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst str2lower\n");
f0110598:	83 ec 0c             	sub    $0xc,%esp
f011059b:	68 c8 18 13 f0       	push   $0xf01318c8
f01105a0:	e8 b7 15 ff ff       	call   f0101b5c <cprintf>
f01105a5:	83 c4 10             	add    $0x10,%esp
		return 0;
f01105a8:	b8 00 00 00 00       	mov    $0x0,%eax
f01105ad:	eb 0a                	jmp    f01105b9 <tst_str2lower+0x2d>
	}

	test_str2lower_function();
f01105af:	e8 7e 16 00 00       	call   f0111c32 <test_str2lower_function>
	return 0;
f01105b4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01105b9:	c9                   	leave  
f01105ba:	c3                   	ret    

f01105bb <tst_autocomplete>:

int tst_autocomplete(int number_of_arguments, char **arguments)
{
f01105bb:	55                   	push   %ebp
f01105bc:	89 e5                	mov    %esp,%ebp
f01105be:	83 ec 18             	sub    $0x18,%esp
	int x = TestAutoCompleteCommand();
f01105c1:	e8 51 12 00 00       	call   f0111817 <TestAutoCompleteCommand>
f01105c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return 0;
f01105c9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01105ce:	c9                   	leave  
f01105cf:	c3                   	ret    

f01105d0 <tst_dyn_alloc>:
int tst_dyn_alloc(int number_of_arguments, char **arguments)
{
f01105d0:	55                   	push   %ebp
f01105d1:	89 e5                	mov    %esp,%ebp
f01105d3:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f01105d6:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01105da:	74 1a                	je     f01105f6 <tst_dyn_alloc+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tst dynalloc <testname>\n") ;
f01105dc:	83 ec 0c             	sub    $0xc,%esp
f01105df:	68 fc 18 13 f0       	push   $0xf01318fc
f01105e4:	e8 73 15 ff ff       	call   f0101b5c <cprintf>
f01105e9:	83 c4 10             	add    $0x10,%esp
		return 0;
f01105ec:	b8 00 00 00 00       	mov    $0x0,%eax
f01105f1:	e9 93 00 00 00       	jmp    f0110689 <tst_dyn_alloc+0xb9>
	}
	//str2lower(arguments[1]);
	// Test 1 Example for initialize_MemBlocksList: tstdynalloc init
	if(strcmp(arguments[1], "init") == 0)
f01105f6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01105f9:	83 c0 04             	add    $0x4,%eax
f01105fc:	8b 00                	mov    (%eax),%eax
f01105fe:	83 ec 08             	sub    $0x8,%esp
f0110601:	68 39 19 13 f0       	push   $0xf0131939
f0110606:	50                   	push   %eax
f0110607:	e8 7b a5 00 00       	call   f011ab87 <strcmp>
f011060c:	83 c4 10             	add    $0x10,%esp
f011060f:	85 c0                	test   %eax,%eax
f0110611:	75 07                	jne    f011061a <tst_dyn_alloc+0x4a>
	{
		test_initialize_dynamic_allocator();
f0110613:	e8 d1 09 00 00       	call   f0110fe9 <test_initialize_dynamic_allocator>
f0110618:	eb 6a                	jmp    f0110684 <tst_dyn_alloc+0xb4>
	}
	// Test 2 Example for alloc_block: tst dynalloc alloc
	else if(strcmp(arguments[1], "alloc") == 0)
f011061a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011061d:	83 c0 04             	add    $0x4,%eax
f0110620:	8b 00                	mov    (%eax),%eax
f0110622:	83 ec 08             	sub    $0x8,%esp
f0110625:	68 3e 19 13 f0       	push   $0xf013193e
f011062a:	50                   	push   %eax
f011062b:	e8 57 a5 00 00       	call   f011ab87 <strcmp>
f0110630:	83 c4 10             	add    $0x10,%esp
f0110633:	85 c0                	test   %eax,%eax
f0110635:	75 07                	jne    f011063e <tst_dyn_alloc+0x6e>
	{
		test_alloc_block();
f0110637:	e8 e4 09 00 00       	call   f0111020 <test_alloc_block>
f011063c:	eb 46                	jmp    f0110684 <tst_dyn_alloc+0xb4>
	{
		test_alloc_block_NF();
	}
	 */
	// Test 5 Example for free_block: tst dynalloc free
	else if(strcmp(arguments[1], "free") == 0)
f011063e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110641:	83 c0 04             	add    $0x4,%eax
f0110644:	8b 00                	mov    (%eax),%eax
f0110646:	83 ec 08             	sub    $0x8,%esp
f0110649:	68 44 19 13 f0       	push   $0xf0131944
f011064e:	50                   	push   %eax
f011064f:	e8 33 a5 00 00       	call   f011ab87 <strcmp>
f0110654:	83 c4 10             	add    $0x10,%esp
f0110657:	85 c0                	test   %eax,%eax
f0110659:	75 07                	jne    f0110662 <tst_dyn_alloc+0x92>
	{
		test_free_block();
f011065b:	e8 dd 09 00 00       	call   f011103d <test_free_block>
f0110660:	eb 22                	jmp    f0110684 <tst_dyn_alloc+0xb4>
	else if(strcmp(arguments[1], "freenf") == 0)
	{
		test_free_block_NF();
	}*/
	// Test 8 Example for realloc_block: tst dynalloc realloc
	else if(strcmp(arguments[1], "realloc") == 0)
f0110662:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110665:	83 c0 04             	add    $0x4,%eax
f0110668:	8b 00                	mov    (%eax),%eax
f011066a:	83 ec 08             	sub    $0x8,%esp
f011066d:	68 49 19 13 f0       	push   $0xf0131949
f0110672:	50                   	push   %eax
f0110673:	e8 0f a5 00 00       	call   f011ab87 <strcmp>
f0110678:	83 c4 10             	add    $0x10,%esp
f011067b:	85 c0                	test   %eax,%eax
f011067d:	75 05                	jne    f0110684 <tst_dyn_alloc+0xb4>
	{
		test_realloc_block();
f011067f:	e8 d6 09 00 00       	call   f011105a <test_realloc_block>
	}
	return 0;
f0110684:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110689:	c9                   	leave  
f011068a:	c3                   	ret    

f011068b <tst_chunks>:

int tst_chunks(int number_of_arguments, char **arguments)
{
f011068b:	55                   	push   %ebp
f011068c:	89 e5                	mov    %esp,%ebp
f011068e:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f0110691:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0110695:	74 1a                	je     f01106b1 <tst_chunks+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tst chunks <testname>\n") ;
f0110697:	83 ec 0c             	sub    $0xc,%esp
f011069a:	68 54 19 13 f0       	push   $0xf0131954
f011069f:	e8 b8 14 ff ff       	call   f0101b5c <cprintf>
f01106a4:	83 c4 10             	add    $0x10,%esp
		return 0;
f01106a7:	b8 00 00 00 00       	mov    $0x0,%eax
f01106ac:	e9 e1 00 00 00       	jmp    f0110792 <tst_chunks+0x107>
	}
	// CUT-PASTE Test
	if(strcmp(arguments[1], "cutpaste") == 0)
f01106b1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01106b4:	83 c0 04             	add    $0x4,%eax
f01106b7:	8b 00                	mov    (%eax),%eax
f01106b9:	83 ec 08             	sub    $0x8,%esp
f01106bc:	68 8f 19 13 f0       	push   $0xf013198f
f01106c1:	50                   	push   %eax
f01106c2:	e8 c0 a4 00 00       	call   f011ab87 <strcmp>
f01106c7:	83 c4 10             	add    $0x10,%esp
f01106ca:	85 c0                	test   %eax,%eax
f01106cc:	75 0a                	jne    f01106d8 <tst_chunks+0x4d>
	{
		test_cut_paste_pages();
f01106ce:	e8 00 22 00 00       	call   f01128d3 <test_cut_paste_pages>
f01106d3:	e9 b5 00 00 00       	jmp    f011078d <tst_chunks+0x102>
	}
	// COPY-PASTE Test
	else if(strcmp(arguments[1], "copypaste") == 0)
f01106d8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01106db:	83 c0 04             	add    $0x4,%eax
f01106de:	8b 00                	mov    (%eax),%eax
f01106e0:	83 ec 08             	sub    $0x8,%esp
f01106e3:	68 98 19 13 f0       	push   $0xf0131998
f01106e8:	50                   	push   %eax
f01106e9:	e8 99 a4 00 00       	call   f011ab87 <strcmp>
f01106ee:	83 c4 10             	add    $0x10,%esp
f01106f1:	85 c0                	test   %eax,%eax
f01106f3:	75 0a                	jne    f01106ff <tst_chunks+0x74>
	{
		test_copy_paste_chunk();
f01106f5:	e8 24 2c 00 00       	call   f011331e <test_copy_paste_chunk>
f01106fa:	e9 8e 00 00 00       	jmp    f011078d <tst_chunks+0x102>
	}
	// SHARE Test
	else if(strcmp(arguments[1], "share") == 0)
f01106ff:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110702:	83 c0 04             	add    $0x4,%eax
f0110705:	8b 00                	mov    (%eax),%eax
f0110707:	83 ec 08             	sub    $0x8,%esp
f011070a:	68 a2 19 13 f0       	push   $0xf01319a2
f011070f:	50                   	push   %eax
f0110710:	e8 72 a4 00 00       	call   f011ab87 <strcmp>
f0110715:	83 c4 10             	add    $0x10,%esp
f0110718:	85 c0                	test   %eax,%eax
f011071a:	75 07                	jne    f0110723 <tst_chunks+0x98>
	{
		test_share_chunk();
f011071c:	e8 fb 3c 00 00       	call   f011441c <test_share_chunk>
f0110721:	eb 6a                	jmp    f011078d <tst_chunks+0x102>
	}
	// ALLOCATE Test
	else if(strcmp(arguments[1], "allocate") == 0)
f0110723:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110726:	83 c0 04             	add    $0x4,%eax
f0110729:	8b 00                	mov    (%eax),%eax
f011072b:	83 ec 08             	sub    $0x8,%esp
f011072e:	68 a8 19 13 f0       	push   $0xf01319a8
f0110733:	50                   	push   %eax
f0110734:	e8 4e a4 00 00       	call   f011ab87 <strcmp>
f0110739:	83 c4 10             	add    $0x10,%esp
f011073c:	85 c0                	test   %eax,%eax
f011073e:	75 07                	jne    f0110747 <tst_chunks+0xbc>
	{
		test_allocate_chunk();
f0110740:	e8 ff 46 00 00       	call   f0114e44 <test_allocate_chunk>
f0110745:	eb 46                	jmp    f011078d <tst_chunks+0x102>
	}
	// REQUIRED SPACE Test
	else if(strcmp(arguments[1], "required_space") == 0)
f0110747:	8b 45 0c             	mov    0xc(%ebp),%eax
f011074a:	83 c0 04             	add    $0x4,%eax
f011074d:	8b 00                	mov    (%eax),%eax
f011074f:	83 ec 08             	sub    $0x8,%esp
f0110752:	68 b1 19 13 f0       	push   $0xf01319b1
f0110757:	50                   	push   %eax
f0110758:	e8 2a a4 00 00       	call   f011ab87 <strcmp>
f011075d:	83 c4 10             	add    $0x10,%esp
f0110760:	85 c0                	test   %eax,%eax
f0110762:	75 07                	jne    f011076b <tst_chunks+0xe0>
	{
		test_calculate_required_frames();
f0110764:	e8 e2 4f 00 00       	call   f011574b <test_calculate_required_frames>
f0110769:	eb 22                	jmp    f011078d <tst_chunks+0x102>
	}
	// ALLOCATED SPACE Test
	else if(strcmp(arguments[1], "allocated_space") == 0)
f011076b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011076e:	83 c0 04             	add    $0x4,%eax
f0110771:	8b 00                	mov    (%eax),%eax
f0110773:	83 ec 08             	sub    $0x8,%esp
f0110776:	68 c0 19 13 f0       	push   $0xf01319c0
f011077b:	50                   	push   %eax
f011077c:	e8 06 a4 00 00       	call   f011ab87 <strcmp>
f0110781:	83 c4 10             	add    $0x10,%esp
f0110784:	85 c0                	test   %eax,%eax
f0110786:	75 05                	jne    f011078d <tst_chunks+0x102>
	{
		test_calculate_allocated_space();
f0110788:	e8 32 58 00 00       	call   f0115fbf <test_calculate_allocated_space>
	}
	return 0;
f011078d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110792:	c9                   	leave  
f0110793:	c3                   	ret    

f0110794 <tst_paging_manipulation>:

int tst_paging_manipulation(int number_of_arguments, char **arguments)
{
f0110794:	55                   	push   %ebp
f0110795:	89 e5                	mov    %esp,%ebp
f0110797:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f011079a:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011079e:	74 1a                	je     f01107ba <tst_paging_manipulation+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tst pg <testname>\n") ;
f01107a0:	83 ec 0c             	sub    $0xc,%esp
f01107a3:	68 d0 19 13 f0       	push   $0xf01319d0
f01107a8:	e8 af 13 ff ff       	call   f0101b5c <cprintf>
f01107ad:	83 c4 10             	add    $0x10,%esp
		return 0;
f01107b0:	b8 00 00 00 00       	mov    $0x0,%eax
f01107b5:	e9 e1 00 00 00       	jmp    f011089b <tst_paging_manipulation+0x107>
	}
	// Test 1.1-Set/Clear permissions: tst pg scperm1
	if(strcmp(arguments[1], "scperm1") == 0)
f01107ba:	8b 45 0c             	mov    0xc(%ebp),%eax
f01107bd:	83 c0 04             	add    $0x4,%eax
f01107c0:	8b 00                	mov    (%eax),%eax
f01107c2:	83 ec 08             	sub    $0x8,%esp
f01107c5:	68 07 1a 13 f0       	push   $0xf0131a07
f01107ca:	50                   	push   %eax
f01107cb:	e8 b7 a3 00 00       	call   f011ab87 <strcmp>
f01107d0:	83 c4 10             	add    $0x10,%esp
f01107d3:	85 c0                	test   %eax,%eax
f01107d5:	75 0a                	jne    f01107e1 <tst_paging_manipulation+0x4d>
	{
		test_pt_set_page_permissions();
f01107d7:	e8 dc 17 00 00       	call   f0111fb8 <test_pt_set_page_permissions>
f01107dc:	e9 b5 00 00 00       	jmp    f0110896 <tst_paging_manipulation+0x102>
	}
	// Test 1.2-Set/Clear permissions: tst pg scperm2
	else if(strcmp(arguments[1], "scperm2") == 0)
f01107e1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01107e4:	83 c0 04             	add    $0x4,%eax
f01107e7:	8b 00                	mov    (%eax),%eax
f01107e9:	83 ec 08             	sub    $0x8,%esp
f01107ec:	68 0f 1a 13 f0       	push   $0xf0131a0f
f01107f1:	50                   	push   %eax
f01107f2:	e8 90 a3 00 00       	call   f011ab87 <strcmp>
f01107f7:	83 c4 10             	add    $0x10,%esp
f01107fa:	85 c0                	test   %eax,%eax
f01107fc:	75 0a                	jne    f0110808 <tst_paging_manipulation+0x74>
	{
		test_pt_set_page_permissions_invalid_va();
f01107fe:	e8 24 1a 00 00       	call   f0112227 <test_pt_set_page_permissions_invalid_va>
f0110803:	e9 8e 00 00 00       	jmp    f0110896 <tst_paging_manipulation+0x102>
	}
	// Test 2-Get permissions: tst pg getperm
	else if(strcmp(arguments[1], "getperm") == 0)
f0110808:	8b 45 0c             	mov    0xc(%ebp),%eax
f011080b:	83 c0 04             	add    $0x4,%eax
f011080e:	8b 00                	mov    (%eax),%eax
f0110810:	83 ec 08             	sub    $0x8,%esp
f0110813:	68 17 1a 13 f0       	push   $0xf0131a17
f0110818:	50                   	push   %eax
f0110819:	e8 69 a3 00 00       	call   f011ab87 <strcmp>
f011081e:	83 c4 10             	add    $0x10,%esp
f0110821:	85 c0                	test   %eax,%eax
f0110823:	75 07                	jne    f011082c <tst_paging_manipulation+0x98>
	{
		test_pt_get_page_permissions();
f0110825:	e8 46 1a 00 00       	call   f0112270 <test_pt_get_page_permissions>
f011082a:	eb 6a                	jmp    f0110896 <tst_paging_manipulation+0x102>
	}
	// Test 3.1-Clear entry: tst pg clear1
	else if(strcmp(arguments[1], "clear1") == 0)
f011082c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011082f:	83 c0 04             	add    $0x4,%eax
f0110832:	8b 00                	mov    (%eax),%eax
f0110834:	83 ec 08             	sub    $0x8,%esp
f0110837:	68 1f 1a 13 f0       	push   $0xf0131a1f
f011083c:	50                   	push   %eax
f011083d:	e8 45 a3 00 00       	call   f011ab87 <strcmp>
f0110842:	83 c4 10             	add    $0x10,%esp
f0110845:	85 c0                	test   %eax,%eax
f0110847:	75 07                	jne    f0110850 <tst_paging_manipulation+0xbc>
	{
		test_pt_clear_page_table_entry();
f0110849:	e8 66 1b 00 00       	call   f01123b4 <test_pt_clear_page_table_entry>
f011084e:	eb 46                	jmp    f0110896 <tst_paging_manipulation+0x102>
	}
	// Test 3.2-Clear entry: tst pg clear2
	else if(strcmp(arguments[1], "clear2") == 0)
f0110850:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110853:	83 c0 04             	add    $0x4,%eax
f0110856:	8b 00                	mov    (%eax),%eax
f0110858:	83 ec 08             	sub    $0x8,%esp
f011085b:	68 26 1a 13 f0       	push   $0xf0131a26
f0110860:	50                   	push   %eax
f0110861:	e8 21 a3 00 00       	call   f011ab87 <strcmp>
f0110866:	83 c4 10             	add    $0x10,%esp
f0110869:	85 c0                	test   %eax,%eax
f011086b:	75 07                	jne    f0110874 <tst_paging_manipulation+0xe0>
	{
		test_pt_clear_page_table_entry_invalid_va();
f011086d:	e8 9b 1c 00 00       	call   f011250d <test_pt_clear_page_table_entry_invalid_va>
f0110872:	eb 22                	jmp    f0110896 <tst_paging_manipulation+0x102>
	}
	// Test 4-Convert virtual to physical: tst pg v2p
	else if(strcmp(arguments[1], "v2p") == 0)
f0110874:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110877:	83 c0 04             	add    $0x4,%eax
f011087a:	8b 00                	mov    (%eax),%eax
f011087c:	83 ec 08             	sub    $0x8,%esp
f011087f:	68 2d 1a 13 f0       	push   $0xf0131a2d
f0110884:	50                   	push   %eax
f0110885:	e8 fd a2 00 00       	call   f011ab87 <strcmp>
f011088a:	83 c4 10             	add    $0x10,%esp
f011088d:	85 c0                	test   %eax,%eax
f011088f:	75 05                	jne    f0110896 <tst_paging_manipulation+0x102>
	{
		test_virtual_to_physical();
f0110891:	e8 af 1c 00 00       	call   f0112545 <test_virtual_to_physical>
	}
	return 0;
f0110896:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011089b:	c9                   	leave  
f011089c:	c3                   	ret    

f011089d <tst_kheap>:

int tst_kheap(int number_of_arguments, char **arguments)
{
f011089d:	55                   	push   %ebp
f011089e:	89 e5                	mov    %esp,%ebp
f01108a0:	83 ec 18             	sub    $0x18,%esp
#if !USE_KHEAP
	panic("MUST ENABLE KHEAP");
	return 0;
#endif
	// Parameters Validation Checking
	if (strcmp(arguments[2], "kmalloc") == 0 && number_of_arguments != 4)
f01108a3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01108a6:	83 c0 08             	add    $0x8,%eax
f01108a9:	8b 00                	mov    (%eax),%eax
f01108ab:	83 ec 08             	sub    $0x8,%esp
f01108ae:	68 31 1a 13 f0       	push   $0xf0131a31
f01108b3:	50                   	push   %eax
f01108b4:	e8 ce a2 00 00       	call   f011ab87 <strcmp>
f01108b9:	83 c4 10             	add    $0x10,%esp
f01108bc:	85 c0                	test   %eax,%eax
f01108be:	75 20                	jne    f01108e0 <tst_kheap+0x43>
f01108c0:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f01108c4:	74 1a                	je     f01108e0 <tst_kheap+0x43>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> kmalloc <both or blk or page>\n") ;
f01108c6:	83 ec 0c             	sub    $0xc,%esp
f01108c9:	68 3c 1a 13 f0       	push   $0xf0131a3c
f01108ce:	e8 89 12 ff ff       	call   f0101b5c <cprintf>
f01108d3:	83 c4 10             	add    $0x10,%esp
		return 0;
f01108d6:	b8 00 00 00 00       	mov    $0x0,%eax
f01108db:	e9 b1 04 00 00       	jmp    f0110d91 <tst_kheap+0x4f4>
	}
	else if (strcmp(arguments[2], "fast") == 0 && number_of_arguments != 3)
f01108e0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01108e3:	83 c0 08             	add    $0x8,%eax
f01108e6:	8b 00                	mov    (%eax),%eax
f01108e8:	83 ec 08             	sub    $0x8,%esp
f01108eb:	68 94 1a 13 f0       	push   $0xf0131a94
f01108f0:	50                   	push   %eax
f01108f1:	e8 91 a2 00 00       	call   f011ab87 <strcmp>
f01108f6:	83 c4 10             	add    $0x10,%esp
f01108f9:	85 c0                	test   %eax,%eax
f01108fb:	75 20                	jne    f011091d <tst_kheap+0x80>
f01108fd:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0110901:	74 1a                	je     f011091d <tst_kheap+0x80>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> fast\n") ;
f0110903:	83 ec 0c             	sub    $0xc,%esp
f0110906:	68 9c 1a 13 f0       	push   $0xf0131a9c
f011090b:	e8 4c 12 ff ff       	call   f0101b5c <cprintf>
f0110910:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110913:	b8 00 00 00 00       	mov    $0x0,%eax
f0110918:	e9 74 04 00 00       	jmp    f0110d91 <tst_kheap+0x4f4>
	}
	else if (strcmp(arguments[2], "kfree") == 0 && number_of_arguments != 4)
f011091d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110920:	83 c0 08             	add    $0x8,%eax
f0110923:	8b 00                	mov    (%eax),%eax
f0110925:	83 ec 08             	sub    $0x8,%esp
f0110928:	68 db 1a 13 f0       	push   $0xf0131adb
f011092d:	50                   	push   %eax
f011092e:	e8 54 a2 00 00       	call   f011ab87 <strcmp>
f0110933:	83 c4 10             	add    $0x10,%esp
f0110936:	85 c0                	test   %eax,%eax
f0110938:	75 20                	jne    f011095a <tst_kheap+0xbd>
f011093a:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f011093e:	74 1a                	je     f011095a <tst_kheap+0xbd>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> kfree <both or blk or page>\n") ;
f0110940:	83 ec 0c             	sub    $0xc,%esp
f0110943:	68 e4 1a 13 f0       	push   $0xf0131ae4
f0110948:	e8 0f 12 ff ff       	call   f0101b5c <cprintf>
f011094d:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110950:	b8 00 00 00 00       	mov    $0x0,%eax
f0110955:	e9 37 04 00 00       	jmp    f0110d91 <tst_kheap+0x4f4>
	}
	else if (strcmp(arguments[2], "kvirtaddr") == 0 && number_of_arguments != 2)
f011095a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011095d:	83 c0 08             	add    $0x8,%eax
f0110960:	8b 00                	mov    (%eax),%eax
f0110962:	83 ec 08             	sub    $0x8,%esp
f0110965:	68 3a 1b 13 f0       	push   $0xf0131b3a
f011096a:	50                   	push   %eax
f011096b:	e8 17 a2 00 00       	call   f011ab87 <strcmp>
f0110970:	83 c4 10             	add    $0x10,%esp
f0110973:	85 c0                	test   %eax,%eax
f0110975:	75 20                	jne    f0110997 <tst_kheap+0xfa>
f0110977:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011097b:	74 1a                	je     f0110997 <tst_kheap+0xfa>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap kvirtaddr\n") ;
f011097d:	83 ec 0c             	sub    $0xc,%esp
f0110980:	68 44 1b 13 f0       	push   $0xf0131b44
f0110985:	e8 d2 11 ff ff       	call   f0101b5c <cprintf>
f011098a:	83 c4 10             	add    $0x10,%esp
		return 0;
f011098d:	b8 00 00 00 00       	mov    $0x0,%eax
f0110992:	e9 fa 03 00 00       	jmp    f0110d91 <tst_kheap+0x4f4>
	}
	else if (strcmp(arguments[2], "kphysaddr") == 0 && number_of_arguments != 2)
f0110997:	8b 45 0c             	mov    0xc(%ebp),%eax
f011099a:	83 c0 08             	add    $0x8,%eax
f011099d:	8b 00                	mov    (%eax),%eax
f011099f:	83 ec 08             	sub    $0x8,%esp
f01109a2:	68 7d 1b 13 f0       	push   $0xf0131b7d
f01109a7:	50                   	push   %eax
f01109a8:	e8 da a1 00 00       	call   f011ab87 <strcmp>
f01109ad:	83 c4 10             	add    $0x10,%esp
f01109b0:	85 c0                	test   %eax,%eax
f01109b2:	75 20                	jne    f01109d4 <tst_kheap+0x137>
f01109b4:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01109b8:	74 1a                	je     f01109d4 <tst_kheap+0x137>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap kphysaddr\n") ;
f01109ba:	83 ec 0c             	sub    $0xc,%esp
f01109bd:	68 88 1b 13 f0       	push   $0xf0131b88
f01109c2:	e8 95 11 ff ff       	call   f0101b5c <cprintf>
f01109c7:	83 c4 10             	add    $0x10,%esp
		return 0;
f01109ca:	b8 00 00 00 00       	mov    $0x0,%eax
f01109cf:	e9 bd 03 00 00       	jmp    f0110d91 <tst_kheap+0x4f4>
	}
	else if (strcmp(arguments[2], "krealloc") == 0 && number_of_arguments != 4)
f01109d4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01109d7:	83 c0 08             	add    $0x8,%eax
f01109da:	8b 00                	mov    (%eax),%eax
f01109dc:	83 ec 08             	sub    $0x8,%esp
f01109df:	68 c1 1b 13 f0       	push   $0xf0131bc1
f01109e4:	50                   	push   %eax
f01109e5:	e8 9d a1 00 00       	call   f011ab87 <strcmp>
f01109ea:	83 c4 10             	add    $0x10,%esp
f01109ed:	85 c0                	test   %eax,%eax
f01109ef:	75 20                	jne    f0110a11 <tst_kheap+0x174>
f01109f1:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f01109f5:	74 1a                	je     f0110a11 <tst_kheap+0x174>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> krealloc <both or blk or page>\n") ;
f01109f7:	83 ec 0c             	sub    $0xc,%esp
f01109fa:	68 cc 1b 13 f0       	push   $0xf0131bcc
f01109ff:	e8 58 11 ff ff       	call   f0101b5c <cprintf>
f0110a04:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110a07:	b8 00 00 00 00       	mov    $0x0,%eax
f0110a0c:	e9 80 03 00 00       	jmp    f0110d91 <tst_kheap+0x4f4>
	}

	// Specify Test Type [ig any]
	uint32 testType = 0;
f0110a11:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (number_of_arguments == 4)
f0110a18:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0110a1c:	0f 85 8c 00 00 00    	jne    f0110aae <tst_kheap+0x211>
	{
		if (strcmp(arguments[3], "page") == 0)
f0110a22:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110a25:	83 c0 0c             	add    $0xc,%eax
f0110a28:	8b 00                	mov    (%eax),%eax
f0110a2a:	83 ec 08             	sub    $0x8,%esp
f0110a2d:	68 25 1c 13 f0       	push   $0xf0131c25
f0110a32:	50                   	push   %eax
f0110a33:	e8 4f a1 00 00       	call   f011ab87 <strcmp>
f0110a38:	83 c4 10             	add    $0x10,%esp
f0110a3b:	85 c0                	test   %eax,%eax
f0110a3d:	75 09                	jne    f0110a48 <tst_kheap+0x1ab>
		{
			testType = TST_PAGE_ALLOC;
f0110a3f:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f0110a46:	eb 66                	jmp    f0110aae <tst_kheap+0x211>
		}
		else if (strcmp(arguments[3], "blk") == 0)
f0110a48:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110a4b:	83 c0 0c             	add    $0xc,%eax
f0110a4e:	8b 00                	mov    (%eax),%eax
f0110a50:	83 ec 08             	sub    $0x8,%esp
f0110a53:	68 2a 1c 13 f0       	push   $0xf0131c2a
f0110a58:	50                   	push   %eax
f0110a59:	e8 29 a1 00 00       	call   f011ab87 <strcmp>
f0110a5e:	83 c4 10             	add    $0x10,%esp
f0110a61:	85 c0                	test   %eax,%eax
f0110a63:	75 09                	jne    f0110a6e <tst_kheap+0x1d1>
		{
			testType = TST_BLOCK_ALLOC;
f0110a65:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0110a6c:	eb 40                	jmp    f0110aae <tst_kheap+0x211>
		}
		else if (strcmp(arguments[3], "both") == 0)
f0110a6e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110a71:	83 c0 0c             	add    $0xc,%eax
f0110a74:	8b 00                	mov    (%eax),%eax
f0110a76:	83 ec 08             	sub    $0x8,%esp
f0110a79:	68 2e 1c 13 f0       	push   $0xf0131c2e
f0110a7e:	50                   	push   %eax
f0110a7f:	e8 03 a1 00 00       	call   f011ab87 <strcmp>
f0110a84:	83 c4 10             	add    $0x10,%esp
f0110a87:	85 c0                	test   %eax,%eax
f0110a89:	75 09                	jne    f0110a94 <tst_kheap+0x1f7>
		{
			testType = TST_BOTH_ALLOC;
f0110a8b:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
f0110a92:	eb 1a                	jmp    f0110aae <tst_kheap+0x211>
		}
		else
		{
			cprintf("Invalid Allocator Type! <both or blk or page>\n") ;
f0110a94:	83 ec 0c             	sub    $0xc,%esp
f0110a97:	68 34 1c 13 f0       	push   $0xf0131c34
f0110a9c:	e8 bb 10 ff ff       	call   f0101b5c <cprintf>
f0110aa1:	83 c4 10             	add    $0x10,%esp
			return 0;
f0110aa4:	b8 00 00 00 00       	mov    $0x0,%eax
f0110aa9:	e9 e3 02 00 00       	jmp    f0110d91 <tst_kheap+0x4f4>
		}
	}

	// Setting Strategy
	if(strcmp(arguments[1], "FF") == 0 || strcmp(arguments[1], "ff") == 0)
f0110aae:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110ab1:	83 c0 04             	add    $0x4,%eax
f0110ab4:	8b 00                	mov    (%eax),%eax
f0110ab6:	83 ec 08             	sub    $0x8,%esp
f0110ab9:	68 63 1c 13 f0       	push   $0xf0131c63
f0110abe:	50                   	push   %eax
f0110abf:	e8 c3 a0 00 00       	call   f011ab87 <strcmp>
f0110ac4:	83 c4 10             	add    $0x10,%esp
f0110ac7:	85 c0                	test   %eax,%eax
f0110ac9:	74 1d                	je     f0110ae8 <tst_kheap+0x24b>
f0110acb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110ace:	83 c0 04             	add    $0x4,%eax
f0110ad1:	8b 00                	mov    (%eax),%eax
f0110ad3:	83 ec 08             	sub    $0x8,%esp
f0110ad6:	68 66 1c 13 f0       	push   $0xf0131c66
f0110adb:	50                   	push   %eax
f0110adc:	e8 a6 a0 00 00       	call   f011ab87 <strcmp>
f0110ae1:	83 c4 10             	add    $0x10,%esp
f0110ae4:	85 c0                	test   %eax,%eax
f0110ae6:	75 22                	jne    f0110b0a <tst_kheap+0x26d>
	{
		set_kheap_strategy(KHP_PLACE_FIRSTFIT);
f0110ae8:	83 ec 0c             	sub    $0xc,%esp
f0110aeb:	6a 01                	push   $0x1
f0110aed:	e8 66 f7 ff ff       	call   f0110258 <set_kheap_strategy>
f0110af2:	83 c4 10             	add    $0x10,%esp
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f0110af5:	83 ec 0c             	sub    $0xc,%esp
f0110af8:	68 6c 1c 13 f0       	push   $0xf0131c6c
f0110afd:	e8 5a 10 ff ff       	call   f0101b5c <cprintf>
f0110b02:	83 c4 10             	add    $0x10,%esp
f0110b05:	e9 68 01 00 00       	jmp    f0110c72 <tst_kheap+0x3d5>
	}
	else if(strcmp(arguments[1], "BF") == 0 || strcmp(arguments[1], "bf") == 0)
f0110b0a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110b0d:	83 c0 04             	add    $0x4,%eax
f0110b10:	8b 00                	mov    (%eax),%eax
f0110b12:	83 ec 08             	sub    $0x8,%esp
f0110b15:	68 99 1c 13 f0       	push   $0xf0131c99
f0110b1a:	50                   	push   %eax
f0110b1b:	e8 67 a0 00 00       	call   f011ab87 <strcmp>
f0110b20:	83 c4 10             	add    $0x10,%esp
f0110b23:	85 c0                	test   %eax,%eax
f0110b25:	74 1d                	je     f0110b44 <tst_kheap+0x2a7>
f0110b27:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110b2a:	83 c0 04             	add    $0x4,%eax
f0110b2d:	8b 00                	mov    (%eax),%eax
f0110b2f:	83 ec 08             	sub    $0x8,%esp
f0110b32:	68 9c 1c 13 f0       	push   $0xf0131c9c
f0110b37:	50                   	push   %eax
f0110b38:	e8 4a a0 00 00       	call   f011ab87 <strcmp>
f0110b3d:	83 c4 10             	add    $0x10,%esp
f0110b40:	85 c0                	test   %eax,%eax
f0110b42:	75 22                	jne    f0110b66 <tst_kheap+0x2c9>
	{
		set_kheap_strategy(KHP_PLACE_BESTFIT);
f0110b44:	83 ec 0c             	sub    $0xc,%esp
f0110b47:	6a 02                	push   $0x2
f0110b49:	e8 0a f7 ff ff       	call   f0110258 <set_kheap_strategy>
f0110b4e:	83 c4 10             	add    $0x10,%esp
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f0110b51:	83 ec 0c             	sub    $0xc,%esp
f0110b54:	68 a0 1c 13 f0       	push   $0xf0131ca0
f0110b59:	e8 fe 0f ff ff       	call   f0101b5c <cprintf>
f0110b5e:	83 c4 10             	add    $0x10,%esp
f0110b61:	e9 0c 01 00 00       	jmp    f0110c72 <tst_kheap+0x3d5>
	}
	else if(strcmp(arguments[1], "NF") == 0 || strcmp(arguments[1], "nf") == 0)
f0110b66:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110b69:	83 c0 04             	add    $0x4,%eax
f0110b6c:	8b 00                	mov    (%eax),%eax
f0110b6e:	83 ec 08             	sub    $0x8,%esp
f0110b71:	68 cc 1c 13 f0       	push   $0xf0131ccc
f0110b76:	50                   	push   %eax
f0110b77:	e8 0b a0 00 00       	call   f011ab87 <strcmp>
f0110b7c:	83 c4 10             	add    $0x10,%esp
f0110b7f:	85 c0                	test   %eax,%eax
f0110b81:	74 1d                	je     f0110ba0 <tst_kheap+0x303>
f0110b83:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110b86:	83 c0 04             	add    $0x4,%eax
f0110b89:	8b 00                	mov    (%eax),%eax
f0110b8b:	83 ec 08             	sub    $0x8,%esp
f0110b8e:	68 cf 1c 13 f0       	push   $0xf0131ccf
f0110b93:	50                   	push   %eax
f0110b94:	e8 ee 9f 00 00       	call   f011ab87 <strcmp>
f0110b99:	83 c4 10             	add    $0x10,%esp
f0110b9c:	85 c0                	test   %eax,%eax
f0110b9e:	75 22                	jne    f0110bc2 <tst_kheap+0x325>
	{
		set_kheap_strategy(KHP_PLACE_NEXTFIT);
f0110ba0:	83 ec 0c             	sub    $0xc,%esp
f0110ba3:	6a 03                	push   $0x3
f0110ba5:	e8 ae f6 ff ff       	call   f0110258 <set_kheap_strategy>
f0110baa:	83 c4 10             	add    $0x10,%esp
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f0110bad:	83 ec 0c             	sub    $0xc,%esp
f0110bb0:	68 d4 1c 13 f0       	push   $0xf0131cd4
f0110bb5:	e8 a2 0f ff ff       	call   f0101b5c <cprintf>
f0110bba:	83 c4 10             	add    $0x10,%esp
f0110bbd:	e9 b0 00 00 00       	jmp    f0110c72 <tst_kheap+0x3d5>
	}
	else if(strcmp(arguments[1], "WF") == 0 || strcmp(arguments[1], "wf") == 0)
f0110bc2:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110bc5:	83 c0 04             	add    $0x4,%eax
f0110bc8:	8b 00                	mov    (%eax),%eax
f0110bca:	83 ec 08             	sub    $0x8,%esp
f0110bcd:	68 00 1d 13 f0       	push   $0xf0131d00
f0110bd2:	50                   	push   %eax
f0110bd3:	e8 af 9f 00 00       	call   f011ab87 <strcmp>
f0110bd8:	83 c4 10             	add    $0x10,%esp
f0110bdb:	85 c0                	test   %eax,%eax
f0110bdd:	74 1d                	je     f0110bfc <tst_kheap+0x35f>
f0110bdf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110be2:	83 c0 04             	add    $0x4,%eax
f0110be5:	8b 00                	mov    (%eax),%eax
f0110be7:	83 ec 08             	sub    $0x8,%esp
f0110bea:	68 03 1d 13 f0       	push   $0xf0131d03
f0110bef:	50                   	push   %eax
f0110bf0:	e8 92 9f 00 00       	call   f011ab87 <strcmp>
f0110bf5:	83 c4 10             	add    $0x10,%esp
f0110bf8:	85 c0                	test   %eax,%eax
f0110bfa:	75 1f                	jne    f0110c1b <tst_kheap+0x37e>
	{
		set_kheap_strategy(KHP_PLACE_WORSTFIT);
f0110bfc:	83 ec 0c             	sub    $0xc,%esp
f0110bff:	6a 04                	push   $0x4
f0110c01:	e8 52 f6 ff ff       	call   f0110258 <set_kheap_strategy>
f0110c06:	83 c4 10             	add    $0x10,%esp
		cprintf("Kernel Heap placement strategy is WORST FIT\n");
f0110c09:	83 ec 0c             	sub    $0xc,%esp
f0110c0c:	68 08 1d 13 f0       	push   $0xf0131d08
f0110c11:	e8 46 0f ff ff       	call   f0101b5c <cprintf>
f0110c16:	83 c4 10             	add    $0x10,%esp
f0110c19:	eb 57                	jmp    f0110c72 <tst_kheap+0x3d5>
	}
	else if(strcmp(arguments[1], "CF") == 0 || strcmp(arguments[1], "cf") == 0)
f0110c1b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110c1e:	83 c0 04             	add    $0x4,%eax
f0110c21:	8b 00                	mov    (%eax),%eax
f0110c23:	83 ec 08             	sub    $0x8,%esp
f0110c26:	68 35 1d 13 f0       	push   $0xf0131d35
f0110c2b:	50                   	push   %eax
f0110c2c:	e8 56 9f 00 00       	call   f011ab87 <strcmp>
f0110c31:	83 c4 10             	add    $0x10,%esp
f0110c34:	85 c0                	test   %eax,%eax
f0110c36:	74 1d                	je     f0110c55 <tst_kheap+0x3b8>
f0110c38:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110c3b:	83 c0 04             	add    $0x4,%eax
f0110c3e:	8b 00                	mov    (%eax),%eax
f0110c40:	83 ec 08             	sub    $0x8,%esp
f0110c43:	68 38 1d 13 f0       	push   $0xf0131d38
f0110c48:	50                   	push   %eax
f0110c49:	e8 39 9f 00 00       	call   f011ab87 <strcmp>
f0110c4e:	83 c4 10             	add    $0x10,%esp
f0110c51:	85 c0                	test   %eax,%eax
f0110c53:	75 1d                	jne    f0110c72 <tst_kheap+0x3d5>
	{
		set_kheap_strategy(KHP_PLACE_CUSTOMFIT);
f0110c55:	83 ec 0c             	sub    $0xc,%esp
f0110c58:	6a 05                	push   $0x5
f0110c5a:	e8 f9 f5 ff ff       	call   f0110258 <set_kheap_strategy>
f0110c5f:	83 c4 10             	add    $0x10,%esp
		cprintf("Kernel Heap placement strategy is CUSTOM FIT\n");
f0110c62:	83 ec 0c             	sub    $0xc,%esp
f0110c65:	68 3c 1d 13 f0       	push   $0xf0131d3c
f0110c6a:	e8 ed 0e ff ff       	call   f0101b5c <cprintf>
f0110c6f:	83 c4 10             	add    $0x10,%esp
	}
	// Test 1-kmalloc: tst kheap <Strategy> kmalloc <allocator>
	if(strcmp(arguments[2], "kmalloc") == 0)
f0110c72:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110c75:	83 c0 08             	add    $0x8,%eax
f0110c78:	8b 00                	mov    (%eax),%eax
f0110c7a:	83 ec 08             	sub    $0x8,%esp
f0110c7d:	68 31 1a 13 f0       	push   $0xf0131a31
f0110c82:	50                   	push   %eax
f0110c83:	e8 ff 9e 00 00       	call   f011ab87 <strcmp>
f0110c88:	83 c4 10             	add    $0x10,%esp
f0110c8b:	85 c0                	test   %eax,%eax
f0110c8d:	75 18                	jne    f0110ca7 <tst_kheap+0x40a>
	{
		test_kmalloc(testType);
f0110c8f:	83 ec 0c             	sub    $0xc,%esp
f0110c92:	ff 75 f4             	pushl  -0xc(%ebp)
f0110c95:	e8 42 65 00 00       	call   f01171dc <test_kmalloc>
f0110c9a:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110c9d:	b8 00 00 00 00       	mov    $0x0,%eax
f0110ca2:	e9 ea 00 00 00       	jmp    f0110d91 <tst_kheap+0x4f4>
	}
	// Test Fast Implementation of kmalloc/kfree: tst kheap <Startegy> fast
	else if(strcmp(arguments[2], "fast") == 0)
f0110ca7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110caa:	83 c0 08             	add    $0x8,%eax
f0110cad:	8b 00                	mov    (%eax),%eax
f0110caf:	83 ec 08             	sub    $0x8,%esp
f0110cb2:	68 94 1a 13 f0       	push   $0xf0131a94
f0110cb7:	50                   	push   %eax
f0110cb8:	e8 ca 9e 00 00       	call   f011ab87 <strcmp>
f0110cbd:	83 c4 10             	add    $0x10,%esp
f0110cc0:	85 c0                	test   %eax,%eax
f0110cc2:	75 0f                	jne    f0110cd3 <tst_kheap+0x436>
	{
		test_fast_page_alloc();
f0110cc4:	e8 61 68 00 00       	call   f011752a <test_fast_page_alloc>
		return 0;
f0110cc9:	b8 00 00 00 00       	mov    $0x0,%eax
f0110cce:	e9 be 00 00 00       	jmp    f0110d91 <tst_kheap+0x4f4>
	}
	// Test 2-kfree: tst kheap <Strategy> kfree <allocator>
	else if(strcmp(arguments[2], "kfree") == 0)
f0110cd3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110cd6:	83 c0 08             	add    $0x8,%eax
f0110cd9:	8b 00                	mov    (%eax),%eax
f0110cdb:	83 ec 08             	sub    $0x8,%esp
f0110cde:	68 db 1a 13 f0       	push   $0xf0131adb
f0110ce3:	50                   	push   %eax
f0110ce4:	e8 9e 9e 00 00       	call   f011ab87 <strcmp>
f0110ce9:	83 c4 10             	add    $0x10,%esp
f0110cec:	85 c0                	test   %eax,%eax
f0110cee:	75 18                	jne    f0110d08 <tst_kheap+0x46b>
	{
		test_kfree(testType);
f0110cf0:	83 ec 0c             	sub    $0xc,%esp
f0110cf3:	ff 75 f4             	pushl  -0xc(%ebp)
f0110cf6:	e8 fb 65 00 00       	call   f01172f6 <test_kfree>
f0110cfb:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110cfe:	b8 00 00 00 00       	mov    $0x0,%eax
f0110d03:	e9 89 00 00 00       	jmp    f0110d91 <tst_kheap+0x4f4>
	}
	// Test 3-kphysaddr: tst kheap kphysaddr
	else if(strcmp(arguments[2], "kphysaddr") == 0)
f0110d08:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110d0b:	83 c0 08             	add    $0x8,%eax
f0110d0e:	8b 00                	mov    (%eax),%eax
f0110d10:	83 ec 08             	sub    $0x8,%esp
f0110d13:	68 7d 1b 13 f0       	push   $0xf0131b7d
f0110d18:	50                   	push   %eax
f0110d19:	e8 69 9e 00 00       	call   f011ab87 <strcmp>
f0110d1e:	83 c4 10             	add    $0x10,%esp
f0110d21:	85 c0                	test   %eax,%eax
f0110d23:	75 0c                	jne    f0110d31 <tst_kheap+0x494>
	{
		test_kheap_phys_addr();
f0110d25:	e8 60 68 00 00       	call   f011758a <test_kheap_phys_addr>
		return 0;
f0110d2a:	b8 00 00 00 00       	mov    $0x0,%eax
f0110d2f:	eb 60                	jmp    f0110d91 <tst_kheap+0x4f4>
	}
	// Test 4-kvirtaddr: tst kheap kvirtaddr
	else if(strcmp(arguments[2], "kvirtaddr") == 0)
f0110d31:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110d34:	83 c0 08             	add    $0x8,%eax
f0110d37:	8b 00                	mov    (%eax),%eax
f0110d39:	83 ec 08             	sub    $0x8,%esp
f0110d3c:	68 3a 1b 13 f0       	push   $0xf0131b3a
f0110d41:	50                   	push   %eax
f0110d42:	e8 40 9e 00 00       	call   f011ab87 <strcmp>
f0110d47:	83 c4 10             	add    $0x10,%esp
f0110d4a:	85 c0                	test   %eax,%eax
f0110d4c:	75 0c                	jne    f0110d5a <tst_kheap+0x4bd>
	{
		test_kheap_virt_addr();
f0110d4e:	e8 57 68 00 00       	call   f01175aa <test_kheap_virt_addr>
		return 0;
f0110d53:	b8 00 00 00 00       	mov    $0x0,%eax
f0110d58:	eb 37                	jmp    f0110d91 <tst_kheap+0x4f4>
	}
	// Test 5-krealloc: tst kheap <Strategy> krealloc <allocator>
	else if(strcmp(arguments[2], "krealloc") == 0)
f0110d5a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110d5d:	83 c0 08             	add    $0x8,%eax
f0110d60:	8b 00                	mov    (%eax),%eax
f0110d62:	83 ec 08             	sub    $0x8,%esp
f0110d65:	68 c1 1b 13 f0       	push   $0xf0131bc1
f0110d6a:	50                   	push   %eax
f0110d6b:	e8 17 9e 00 00       	call   f011ab87 <strcmp>
f0110d70:	83 c4 10             	add    $0x10,%esp
f0110d73:	85 c0                	test   %eax,%eax
f0110d75:	75 15                	jne    f0110d8c <tst_kheap+0x4ef>
	{
		test_krealloc(testType);
f0110d77:	83 ec 0c             	sub    $0xc,%esp
f0110d7a:	ff 75 f4             	pushl  -0xc(%ebp)
f0110d7d:	e8 8e 66 00 00       	call   f0117410 <test_krealloc>
f0110d82:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110d85:	b8 00 00 00 00       	mov    $0x0,%eax
f0110d8a:	eb 05                	jmp    f0110d91 <tst_kheap+0x4f4>
	/*	// Test 6-sbr: tst kheap FF sbrk
	else if (strcmp(arguments[2], "sbrk") == 0)
	{
		test_ksbrk();
	}*/
	return 0;
f0110d8c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110d91:	c9                   	leave  
f0110d92:	c3                   	ret    

f0110d93 <IDX>:

short* startVAsInit[DYN_ALLOC_MAX_BLOCK_SIZE + 1] ;
short* endVAsInit[DYN_ALLOC_MAX_BLOCK_SIZE + 1] ;

__inline__ uint8 IDX(uint32 size)
{
f0110d93:	55                   	push   %ebp
f0110d94:	89 e5                	mov    %esp,%ebp
f0110d96:	83 ec 10             	sub    $0x10,%esp
	size>>= LOG2_MIN_SIZE;
f0110d99:	c1 6d 08 03          	shrl   $0x3,0x8(%ebp)
	int index = 0;
f0110d9d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	while ((size>>=1) != 0)
f0110da4:	eb 03                	jmp    f0110da9 <IDX+0x16>
	{
		index++;
f0110da6:	ff 45 fc             	incl   -0x4(%ebp)

__inline__ uint8 IDX(uint32 size)
{
	size>>= LOG2_MIN_SIZE;
	int index = 0;
	while ((size>>=1) != 0)
f0110da9:	d1 6d 08             	shrl   0x8(%ebp)
f0110dac:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0110db0:	75 f4                	jne    f0110da6 <IDX+0x13>
	{
		index++;
	}
	return index;
f0110db2:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0110db5:	c9                   	leave  
f0110db6:	c3                   	ret    

f0110db7 <check_dynalloc_datastruct>:

int check_dynalloc_datastruct(uint32 curSize, uint32 numOfBlksAtCurSize)
{
f0110db7:	55                   	push   %ebp
f0110db8:	89 e5                	mov    %esp,%ebp
f0110dba:	53                   	push   %ebx
f0110dbb:	83 ec 44             	sub    $0x44,%esp
	int maxNumOfBlksPerPage = PAGE_SIZE / curSize;
f0110dbe:	b8 00 10 00 00       	mov    $0x1000,%eax
f0110dc3:	ba 00 00 00 00       	mov    $0x0,%edx
f0110dc8:	f7 75 08             	divl   0x8(%ebp)
f0110dcb:	89 45 dc             	mov    %eax,-0x24(%ebp)
	int expectedNumOfCompletePages = numOfBlksAtCurSize / maxNumOfBlksPerPage;
f0110dce:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f0110dd1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110dd4:	ba 00 00 00 00       	mov    $0x0,%edx
f0110dd9:	f7 f3                	div    %ebx
f0110ddb:	89 45 d8             	mov    %eax,-0x28(%ebp)
	int expectedNumOfInCompletePages = numOfBlksAtCurSize % maxNumOfBlksPerPage != 0? 1 : 0;
f0110dde:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f0110de1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110de4:	ba 00 00 00 00       	mov    $0x0,%edx
f0110de9:	f7 f1                	div    %ecx
f0110deb:	89 d0                	mov    %edx,%eax
f0110ded:	85 c0                	test   %eax,%eax
f0110def:	0f 95 c0             	setne  %al
f0110df2:	0f b6 c0             	movzbl %al,%eax
f0110df5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	int expectedNumOfFreeBlks = expectedNumOfInCompletePages * (maxNumOfBlksPerPage - numOfBlksAtCurSize % maxNumOfBlksPerPage);
f0110df8:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f0110dfb:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f0110dfe:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110e01:	ba 00 00 00 00       	mov    $0x0,%edx
f0110e06:	f7 f3                	div    %ebx
f0110e08:	89 d0                	mov    %edx,%eax
f0110e0a:	29 c1                	sub    %eax,%ecx
f0110e0c:	89 ca                	mov    %ecx,%edx
f0110e0e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0110e11:	0f af c2             	imul   %edx,%eax
f0110e14:	89 45 d0             	mov    %eax,-0x30(%ebp)

	//[1] Check PageBlkInfoArr
	int numOfPages = DYN_ALLOC_MAX_SIZE / PAGE_SIZE;
f0110e17:	c7 45 cc 00 20 00 00 	movl   $0x2000,-0x34(%ebp)
	int actualNumOfCompletePages = 0;
f0110e1e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int actualNumOfInCompletePages = 0;
f0110e25:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int actualNumOfFreeBlks = 0;
f0110e2c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	for (int i = 0; i < numOfPages; ++i)
f0110e33:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0110e3a:	eb 59                	jmp    f0110e95 <check_dynalloc_datastruct+0xde>
	{
		if (pageBlockInfoArr[i].block_size == curSize)
f0110e3c:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0110e3f:	89 d0                	mov    %edx,%eax
f0110e41:	01 c0                	add    %eax,%eax
f0110e43:	01 d0                	add    %edx,%eax
f0110e45:	c1 e0 02             	shl    $0x2,%eax
f0110e48:	05 c8 e9 83 f0       	add    $0xf083e9c8,%eax
f0110e4d:	8b 00                	mov    (%eax),%eax
f0110e4f:	0f b7 c0             	movzwl %ax,%eax
f0110e52:	3b 45 08             	cmp    0x8(%ebp),%eax
f0110e55:	75 3b                	jne    f0110e92 <check_dynalloc_datastruct+0xdb>
		{
			if (pageBlockInfoArr[i].num_of_free_blocks == 0)
f0110e57:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0110e5a:	89 d0                	mov    %edx,%eax
f0110e5c:	01 c0                	add    %eax,%eax
f0110e5e:	01 d0                	add    %edx,%eax
f0110e60:	c1 e0 02             	shl    $0x2,%eax
f0110e63:	05 ca e9 83 f0       	add    $0xf083e9ca,%eax
f0110e68:	66 8b 00             	mov    (%eax),%ax
f0110e6b:	66 85 c0             	test   %ax,%ax
f0110e6e:	75 05                	jne    f0110e75 <check_dynalloc_datastruct+0xbe>
			{
				actualNumOfCompletePages++;
f0110e70:	ff 45 f4             	incl   -0xc(%ebp)
f0110e73:	eb 1d                	jmp    f0110e92 <check_dynalloc_datastruct+0xdb>
			}
			else
			{
				actualNumOfInCompletePages++;
f0110e75:	ff 45 f0             	incl   -0x10(%ebp)
				actualNumOfFreeBlks += pageBlockInfoArr[i].num_of_free_blocks;
f0110e78:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0110e7b:	89 d0                	mov    %edx,%eax
f0110e7d:	01 c0                	add    %eax,%eax
f0110e7f:	01 d0                	add    %edx,%eax
f0110e81:	c1 e0 02             	shl    $0x2,%eax
f0110e84:	05 ca e9 83 f0       	add    $0xf083e9ca,%eax
f0110e89:	66 8b 00             	mov    (%eax),%ax
f0110e8c:	0f b7 c0             	movzwl %ax,%eax
f0110e8f:	01 45 ec             	add    %eax,-0x14(%ebp)
	//[1] Check PageBlkInfoArr
	int numOfPages = DYN_ALLOC_MAX_SIZE / PAGE_SIZE;
	int actualNumOfCompletePages = 0;
	int actualNumOfInCompletePages = 0;
	int actualNumOfFreeBlks = 0;
	for (int i = 0; i < numOfPages; ++i)
f0110e92:	ff 45 e8             	incl   -0x18(%ebp)
f0110e95:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110e98:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f0110e9b:	7c 9f                	jl     f0110e3c <check_dynalloc_datastruct+0x85>
				actualNumOfInCompletePages++;
				actualNumOfFreeBlks += pageBlockInfoArr[i].num_of_free_blocks;
			}
		}
	}
	if (actualNumOfCompletePages != expectedNumOfCompletePages ||
f0110e9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110ea0:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f0110ea3:	75 10                	jne    f0110eb5 <check_dynalloc_datastruct+0xfe>
f0110ea5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110ea8:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0110eab:	75 08                	jne    f0110eb5 <check_dynalloc_datastruct+0xfe>
			actualNumOfInCompletePages != expectedNumOfInCompletePages ||
f0110ead:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110eb0:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0110eb3:	74 1c                	je     f0110ed1 <check_dynalloc_datastruct+0x11a>
			actualNumOfFreeBlks != expectedNumOfFreeBlks)
	{
		cprintf_colored(TEXT_TESTERR_CLR, "PageBlkInfoArr is not set/updated correctly!\n");
f0110eb5:	83 ec 08             	sub    $0x8,%esp
f0110eb8:	68 6c 1d 13 f0       	push   $0xf0131d6c
f0110ebd:	6a 0c                	push   $0xc
f0110ebf:	e8 c8 0c ff ff       	call   f0101b8c <cprintf_colored>
f0110ec4:	83 c4 10             	add    $0x10,%esp
		//		cprintf("actualNumOfCompletePages = %d, expectedNumOfCompletePages = %d\n", actualNumOfCompletePages, expectedNumOfCompletePages);
		//		cprintf("actualNumOfInCompletePages = %d, expectedNumOfInCompletePages = %d\n", actualNumOfInCompletePages, expectedNumOfInCompletePages);
		//		cprintf("actualNumOfFreeBlks = %d, expectedNumOfFreeBlks = %d\n", actualNumOfFreeBlks, expectedNumOfFreeBlks);
		return 0;
f0110ec7:	b8 00 00 00 00       	mov    $0x0,%eax
f0110ecc:	e9 9d 00 00 00       	jmp    f0110f6e <check_dynalloc_datastruct+0x1b7>
	}

	//[2] Check freeBlkLists
	int index = IDX(curSize);
f0110ed1:	83 ec 0c             	sub    $0xc,%esp
f0110ed4:	ff 75 08             	pushl  0x8(%ebp)
f0110ed7:	e8 b7 fe ff ff       	call   f0110d93 <IDX>
f0110edc:	83 c4 10             	add    $0x10,%esp
f0110edf:	0f b6 c0             	movzbl %al,%eax
f0110ee2:	89 45 c8             	mov    %eax,-0x38(%ebp)
	struct BlockElement_List *ptrList = &freeBlockLists[index];
f0110ee5:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0110ee8:	c1 e0 04             	shl    $0x4,%eax
f0110eeb:	05 40 6c 85 f0       	add    $0xf0856c40,%eax
f0110ef0:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	int n = 0;
f0110ef3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	struct BlockElement *ptrBlk;
	LIST_FOREACH(ptrBlk, ptrList)
f0110efa:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110efd:	8b 00                	mov    (%eax),%eax
f0110eff:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0110f02:	eb 0c                	jmp    f0110f10 <check_dynalloc_datastruct+0x159>
	{
		n++;
f0110f04:	ff 45 e4             	incl   -0x1c(%ebp)
	//[2] Check freeBlkLists
	int index = IDX(curSize);
	struct BlockElement_List *ptrList = &freeBlockLists[index];
	int n = 0;
	struct BlockElement *ptrBlk;
	LIST_FOREACH(ptrBlk, ptrList)
f0110f07:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110f0a:	8b 40 08             	mov    0x8(%eax),%eax
f0110f0d:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0110f10:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0110f14:	74 07                	je     f0110f1d <check_dynalloc_datastruct+0x166>
f0110f16:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110f19:	8b 00                	mov    (%eax),%eax
f0110f1b:	eb 05                	jmp    f0110f22 <check_dynalloc_datastruct+0x16b>
f0110f1d:	b8 00 00 00 00       	mov    $0x0,%eax
f0110f22:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0110f25:	89 42 08             	mov    %eax,0x8(%edx)
f0110f28:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110f2b:	8b 40 08             	mov    0x8(%eax),%eax
f0110f2e:	85 c0                	test   %eax,%eax
f0110f30:	75 d2                	jne    f0110f04 <check_dynalloc_datastruct+0x14d>
f0110f32:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0110f36:	75 cc                	jne    f0110f04 <check_dynalloc_datastruct+0x14d>
	{
		n++;
	}
	if (LIST_SIZE(ptrList) != expectedNumOfFreeBlks || n != expectedNumOfFreeBlks)
f0110f38:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110f3b:	8b 50 0c             	mov    0xc(%eax),%edx
f0110f3e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0110f41:	39 c2                	cmp    %eax,%edx
f0110f43:	75 08                	jne    f0110f4d <check_dynalloc_datastruct+0x196>
f0110f45:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110f48:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0110f4b:	74 1c                	je     f0110f69 <check_dynalloc_datastruct+0x1b2>
	{
		cprintf_colored(TEXT_TESTERR_CLR,"freeBlockLists[%d] is not updated correctly!", index);
f0110f4d:	83 ec 04             	sub    $0x4,%esp
f0110f50:	ff 75 c8             	pushl  -0x38(%ebp)
f0110f53:	68 9c 1d 13 f0       	push   $0xf0131d9c
f0110f58:	6a 0c                	push   $0xc
f0110f5a:	e8 2d 0c ff ff       	call   f0101b8c <cprintf_colored>
f0110f5f:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110f62:	b8 00 00 00 00       	mov    $0x0,%eax
f0110f67:	eb 05                	jmp    f0110f6e <check_dynalloc_datastruct+0x1b7>
	}
	return 1;
f0110f69:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0110f6e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0110f71:	c9                   	leave  
f0110f72:	c3                   	ret    

f0110f73 <check_list_size>:
int check_list_size(uint32 expectedListSize)
{
f0110f73:	55                   	push   %ebp
f0110f74:	89 e5                	mov    %esp,%ebp
f0110f76:	83 ec 08             	sub    $0x8,%esp
	panic("update is required!!");
f0110f79:	83 ec 04             	sub    $0x4,%esp
f0110f7c:	68 c9 1d 13 f0       	push   $0xf0131dc9
f0110f81:	6a 64                	push   $0x64
f0110f83:	68 e0 1d 13 f0       	push   $0xf0131de0
f0110f88:	e8 22 ff fe ff       	call   f0100eaf <_panic>

f0110f8d <remove_current_mappings>:
extern uint32* ptr_page_directory;
extern void unmap_frame(uint32 *ptr_page_directory, uint32 virtual_address);
extern uint32 sys_calculate_free_frames() ;

void remove_current_mappings(uint32 startVA, uint32 endVA)
{
f0110f8d:	55                   	push   %ebp
f0110f8e:	89 e5                	mov    %esp,%ebp
f0110f90:	83 ec 18             	sub    $0x18,%esp
	assert(startVA >= KERNEL_HEAP_START && endVA >= KERNEL_HEAP_START);
f0110f93:	81 7d 08 ff ff ff f5 	cmpl   $0xf5ffffff,0x8(%ebp)
f0110f9a:	76 09                	jbe    f0110fa5 <remove_current_mappings+0x18>
f0110f9c:	81 7d 0c ff ff ff f5 	cmpl   $0xf5ffffff,0xc(%ebp)
f0110fa3:	77 16                	ja     f0110fbb <remove_current_mappings+0x2e>
f0110fa5:	68 04 1e 13 f0       	push   $0xf0131e04
f0110faa:	68 3f 1e 13 f0       	push   $0xf0131e3f
f0110faf:	6a 73                	push   $0x73
f0110fb1:	68 e0 1d 13 f0       	push   $0xf0131de0
f0110fb6:	e8 f4 fe fe ff       	call   f0100eaf <_panic>
	for (uint32 va = startVA; va < endVA; va+=PAGE_SIZE)
f0110fbb:	8b 45 08             	mov    0x8(%ebp),%eax
f0110fbe:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0110fc1:	eb 1b                	jmp    f0110fde <remove_current_mappings+0x51>
	{
		unmap_frame(ptr_page_directory, va);
f0110fc3:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0110fc8:	83 ec 08             	sub    $0x8,%esp
f0110fcb:	ff 75 f4             	pushl  -0xc(%ebp)
f0110fce:	50                   	push   %eax
f0110fcf:	e8 7b 86 ff ff       	call   f010964f <unmap_frame>
f0110fd4:	83 c4 10             	add    $0x10,%esp
extern uint32 sys_calculate_free_frames() ;

void remove_current_mappings(uint32 startVA, uint32 endVA)
{
	assert(startVA >= KERNEL_HEAP_START && endVA >= KERNEL_HEAP_START);
	for (uint32 va = startVA; va < endVA; va+=PAGE_SIZE)
f0110fd7:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0110fde:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110fe1:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0110fe4:	72 dd                	jb     f0110fc3 <remove_current_mappings+0x36>
	{
		unmap_frame(ptr_page_directory, va);
	}
}
f0110fe6:	90                   	nop
f0110fe7:	c9                   	leave  
f0110fe8:	c3                   	ret    

f0110fe9 <test_initialize_dynamic_allocator>:
/***********************************************************************************************************************/

void test_initialize_dynamic_allocator()
{
f0110fe9:	55                   	push   %ebp
f0110fea:	89 e5                	mov    %esp,%ebp
f0110fec:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_initialize_dynamic_allocator: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0110fef:	83 ec 04             	sub    $0x4,%esp
f0110ff2:	68 54 1e 13 f0       	push   $0xf0131e54
f0110ff7:	6a 7e                	push   $0x7e
f0110ff9:	68 e0 1d 13 f0       	push   $0xf0131de0
f0110ffe:	e8 ac fe fe ff       	call   f0100eaf <_panic>

f0111003 <test_initial_alloc>:
			"\nCongratulations!! test initialize_dynamic_allocator completed successfully.\n"
			"=============================================================================\n");
}

int test_initial_alloc()
{
f0111003:	55                   	push   %ebp
f0111004:	89 e5                	mov    %esp,%ebp
f0111006:	83 ec 58             	sub    $0x58,%esp
#if USE_KHEAP
	panic("test_initial_alloc: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0111009:	83 ec 04             	sub    $0x4,%esp
f011100c:	68 b4 1e 13 f0       	push   $0xf0131eb4
f0111011:	68 b8 00 00 00       	push   $0xb8
f0111016:	68 e0 1d 13 f0       	push   $0xf0131de0
f011101b:	e8 8f fe fe ff       	call   f0100eaf <_panic>

f0111020 <test_alloc_block>:

	return eval;
}

void test_alloc_block()
{
f0111020:	55                   	push   %ebp
f0111021:	89 e5                	mov    %esp,%ebp
f0111023:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_alloc_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0111026:	83 ec 04             	sub    $0x4,%esp
f0111029:	68 04 1f 13 f0       	push   $0xf0131f04
f011102e:	68 6f 01 00 00       	push   $0x16f
f0111033:	68 e0 1d 13 f0       	push   $0xf0131de0
f0111038:	e8 72 fe fe ff       	call   f0100eaf <_panic>

f011103d <test_free_block>:
	cprintf("test alloc_block Evaluation = %d%\n", eval);
	return ;
}

void test_free_block()
{
f011103d:	55                   	push   %ebp
f011103e:	89 e5                	mov    %esp,%ebp
f0111040:	83 ec 08             	sub    $0x8,%esp
	panic("update is required!!");
f0111043:	83 ec 04             	sub    $0x4,%esp
f0111046:	68 c9 1d 13 f0       	push   $0xf0131dc9
f011104b:	68 84 01 00 00       	push   $0x184
f0111050:	68 e0 1d 13 f0       	push   $0xf0131de0
f0111055:	e8 55 fe fe ff       	call   f0100eaf <_panic>

f011105a <test_realloc_block>:
	cprintf("===========================================================\n") ;
	void*expected_va ;
}

void test_realloc_block()
{
f011105a:	55                   	push   %ebp
f011105b:	89 e5                	mov    %esp,%ebp
f011105d:	83 ec 08             	sub    $0x8,%esp
	panic("update is required!!");
f0111060:	83 ec 04             	sub    $0x4,%esp
f0111063:	68 c9 1d 13 f0       	push   $0xf0131dc9
f0111068:	68 93 01 00 00       	push   $0x193
f011106d:	68 e0 1d 13 f0       	push   $0xf0131de0
f0111072:	e8 38 fe fe ff       	call   f0100eaf <_panic>

f0111077 <sys_check_LRU_lists>:
#include <kern/proc/user_environment.h>
#include <kern/mem/working_set_manager.h>

//2020
int sys_check_LRU_lists(uint32* active_list_content, uint32* second_list_content, int actual_active_list_size, int actual_second_list_size)
{
f0111077:	55                   	push   %ebp
f0111078:	89 e5                	mov    %esp,%ebp
f011107a:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f011107d:	e8 96 a9 ff ff       	call   f010ba18 <get_cpu_proc>
f0111082:	89 45 e0             	mov    %eax,-0x20(%ebp)
	assert(cur_env != NULL);
f0111085:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111089:	75 16                	jne    f01110a1 <sys_check_LRU_lists+0x2a>
f011108b:	68 54 1f 13 f0       	push   $0xf0131f54
f0111090:	68 64 1f 13 f0       	push   $0xf0131f64
f0111095:	6a 10                	push   $0x10
f0111097:	68 79 1f 13 f0       	push   $0xf0131f79
f011109c:	e8 0e fe fe ff       	call   f0100eaf <_panic>
	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
f01110a1:	83 ec 0c             	sub    $0xc,%esp
f01110a4:	68 98 1f 13 f0       	push   $0xf0131f98
f01110a9:	e8 ae 0a ff ff       	call   f0101b5c <cprintf>
f01110ae:	83 c4 10             	add    $0x10,%esp
	env_page_ws_print(cur_env);
f01110b1:	83 ec 0c             	sub    $0xc,%esp
f01110b4:	ff 75 e0             	pushl  -0x20(%ebp)
f01110b7:	e8 23 94 ff ff       	call   f010a4df <env_page_ws_print>
f01110bc:	83 c4 10             	add    $0x10,%esp

	struct Env* env = cur_env;
f01110bf:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01110c2:	89 45 dc             	mov    %eax,-0x24(%ebp)
	int active_list_validation = 1;
f01110c5:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	int second_list_validation = 1;
f01110cc:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	//1- Check active list content if not null
	if(active_list_content != NULL)
f01110d3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01110d7:	0f 84 a5 00 00 00    	je     f0111182 <sys_check_LRU_lists+0x10b>
	{
		int idx_active_list = 0;
f01110dd:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f01110e4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01110e7:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f01110ed:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01110f0:	eb 4a                	jmp    f011113c <sys_check_LRU_lists+0xc5>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(active_list_content[idx_active_list], PAGE_SIZE))
f01110f2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01110f5:	8b 00                	mov    (%eax),%eax
f01110f7:	89 45 d8             	mov    %eax,-0x28(%ebp)
f01110fa:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01110fd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111102:	89 c2                	mov    %eax,%edx
f0111104:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111107:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f011110e:	8b 45 08             	mov    0x8(%ebp),%eax
f0111111:	01 c8                	add    %ecx,%eax
f0111113:	8b 00                	mov    (%eax),%eax
f0111115:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0111118:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011111b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111120:	39 c2                	cmp    %eax,%edx
f0111122:	74 09                	je     f011112d <sys_check_LRU_lists+0xb6>
			{
				active_list_validation = 0;
f0111124:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f011112b:	eb 3e                	jmp    f011116b <sys_check_LRU_lists+0xf4>
			}
			idx_active_list++;
f011112d:	ff 45 e8             	incl   -0x18(%ebp)

	//1- Check active list content if not null
	if(active_list_content != NULL)
	{
		int idx_active_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0111130:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111133:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f0111139:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011113c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0111140:	74 08                	je     f011114a <sys_check_LRU_lists+0xd3>
f0111142:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111145:	8b 40 10             	mov    0x10(%eax),%eax
f0111148:	eb 05                	jmp    f011114f <sys_check_LRU_lists+0xd8>
f011114a:	b8 00 00 00 00       	mov    $0x0,%eax
f011114f:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0111152:	89 82 70 05 00 00    	mov    %eax,0x570(%edx)
f0111158:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011115b:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f0111161:	85 c0                	test   %eax,%eax
f0111163:	75 8d                	jne    f01110f2 <sys_check_LRU_lists+0x7b>
f0111165:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0111169:	75 87                	jne    f01110f2 <sys_check_LRU_lists+0x7b>
				active_list_validation = 0;
				break;
			}
			idx_active_list++;
		}
		if(LIST_SIZE(&env->ActiveList) != actual_active_list_size)
f011116b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011116e:	8b 90 74 05 00 00    	mov    0x574(%eax),%edx
f0111174:	8b 45 10             	mov    0x10(%ebp),%eax
f0111177:	39 c2                	cmp    %eax,%edx
f0111179:	74 07                	je     f0111182 <sys_check_LRU_lists+0x10b>
		{
			active_list_validation = 0;
f011117b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

		}
	}

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
f0111182:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0111186:	0f 84 a5 00 00 00    	je     f0111231 <sys_check_LRU_lists+0x1ba>
	{
		int idx_second_list = 0;
f011118c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0111193:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111196:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f011119c:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011119f:	eb 4a                	jmp    f01111eb <sys_check_LRU_lists+0x174>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(second_list_content[idx_second_list], PAGE_SIZE))
f01111a1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01111a4:	8b 00                	mov    (%eax),%eax
f01111a6:	89 45 d0             	mov    %eax,-0x30(%ebp)
f01111a9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01111ac:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01111b1:	89 c2                	mov    %eax,%edx
f01111b3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01111b6:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01111bd:	8b 45 0c             	mov    0xc(%ebp),%eax
f01111c0:	01 c8                	add    %ecx,%eax
f01111c2:	8b 00                	mov    (%eax),%eax
f01111c4:	89 45 cc             	mov    %eax,-0x34(%ebp)
f01111c7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01111ca:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01111cf:	39 c2                	cmp    %eax,%edx
f01111d1:	74 09                	je     f01111dc <sys_check_LRU_lists+0x165>
			{
				second_list_validation = 0;
f01111d3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				break;
f01111da:	eb 3e                	jmp    f011121a <sys_check_LRU_lists+0x1a3>
			}
			idx_second_list++;
f01111dc:	ff 45 e4             	incl   -0x1c(%ebp)

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
	{
		int idx_second_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f01111df:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01111e2:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f01111e8:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01111eb:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01111ef:	74 08                	je     f01111f9 <sys_check_LRU_lists+0x182>
f01111f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01111f4:	8b 40 10             	mov    0x10(%eax),%eax
f01111f7:	eb 05                	jmp    f01111fe <sys_check_LRU_lists+0x187>
f01111f9:	b8 00 00 00 00       	mov    $0x0,%eax
f01111fe:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0111201:	89 82 80 05 00 00    	mov    %eax,0x580(%edx)
f0111207:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011120a:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f0111210:	85 c0                	test   %eax,%eax
f0111212:	75 8d                	jne    f01111a1 <sys_check_LRU_lists+0x12a>
f0111214:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0111218:	75 87                	jne    f01111a1 <sys_check_LRU_lists+0x12a>
				second_list_validation = 0;
				break;
			}
			idx_second_list++;
		}
		if(LIST_SIZE(&env->SecondList) != actual_second_list_size)
f011121a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011121d:	8b 90 84 05 00 00    	mov    0x584(%eax),%edx
f0111223:	8b 45 14             	mov    0x14(%ebp),%eax
f0111226:	39 c2                	cmp    %eax,%edx
f0111228:	74 07                	je     f0111231 <sys_check_LRU_lists+0x1ba>
			second_list_validation = 0;
f011122a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}
	return active_list_validation&second_list_validation;
f0111231:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111234:	23 45 f0             	and    -0x10(%ebp),%eax
}
f0111237:	c9                   	leave  
f0111238:	c3                   	ret    

f0111239 <sys_check_LRU_lists_free>:


//2020
int sys_check_LRU_lists_free(uint32* list_content, int list_size)
{
f0111239:	55                   	push   %ebp
f011123a:	89 e5                	mov    %esp,%ebp
f011123c:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f011123f:	e8 d4 a7 ff ff       	call   f010ba18 <get_cpu_proc>
f0111244:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f0111247:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011124b:	75 16                	jne    f0111263 <sys_check_LRU_lists_free+0x2a>
f011124d:	68 54 1f 13 f0       	push   $0xf0131f54
f0111252:	68 64 1f 13 f0       	push   $0xf0131f64
f0111257:	6a 45                	push   $0x45
f0111259:	68 79 1f 13 f0       	push   $0xf0131f79
f011125e:	e8 4c fc fe ff       	call   f0100eaf <_panic>
	struct Env* env = cur_env;
f0111263:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0111266:	89 45 e0             	mov    %eax,-0x20(%ebp)
	int list_validation_count = 0;
f0111269:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0111270:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111273:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0111279:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011127c:	eb 65                	jmp    f01112e3 <sys_check_LRU_lists_free+0xaa>
	{
		for(int var = 0; var < list_size; var++)
f011127e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0111285:	eb 3a                	jmp    f01112c1 <sys_check_LRU_lists_free+0x88>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f0111287:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011128a:	8b 00                	mov    (%eax),%eax
f011128c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011128f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0111292:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111297:	89 c2                	mov    %eax,%edx
f0111299:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011129c:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01112a3:	8b 45 08             	mov    0x8(%ebp),%eax
f01112a6:	01 c8                	add    %ecx,%eax
f01112a8:	8b 00                	mov    (%eax),%eax
f01112aa:	89 45 d0             	mov    %eax,-0x30(%ebp)
f01112ad:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01112b0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01112b5:	39 c2                	cmp    %eax,%edx
f01112b7:	75 05                	jne    f01112be <sys_check_LRU_lists_free+0x85>
			{
				list_validation_count++;
f01112b9:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f01112bc:	eb 0b                	jmp    f01112c9 <sys_check_LRU_lists_free+0x90>
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
	{
		for(int var = 0; var < list_size; var++)
f01112be:	ff 45 ec             	incl   -0x14(%ebp)
f01112c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01112c4:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01112c7:	7c be                	jl     f0111287 <sys_check_LRU_lists_free+0x4e>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f01112c9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01112cd:	7e 08                	jle    f01112d7 <sys_check_LRU_lists_free+0x9e>
			return list_validation_count;
f01112cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01112d2:	e9 ed 00 00 00       	jmp    f01113c4 <sys_check_LRU_lists_free+0x18b>
	assert(cur_env != NULL);
	struct Env* env = cur_env;
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f01112d7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01112da:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f01112e0:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01112e3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01112e7:	74 08                	je     f01112f1 <sys_check_LRU_lists_free+0xb8>
f01112e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01112ec:	8b 40 10             	mov    0x10(%eax),%eax
f01112ef:	eb 05                	jmp    f01112f6 <sys_check_LRU_lists_free+0xbd>
f01112f1:	b8 00 00 00 00       	mov    $0x0,%eax
f01112f6:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01112f9:	89 82 70 05 00 00    	mov    %eax,0x570(%edx)
f01112ff:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111302:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f0111308:	85 c0                	test   %eax,%eax
f011130a:	0f 85 6e ff ff ff    	jne    f011127e <sys_check_LRU_lists_free+0x45>
f0111310:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111314:	0f 85 64 ff ff ff    	jne    f011127e <sys_check_LRU_lists_free+0x45>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f011131a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011131d:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0111323:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111326:	eb 62                	jmp    f011138a <sys_check_LRU_lists_free+0x151>
	{
		for(int var = 0; var < list_size; var++)
f0111328:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f011132f:	eb 3a                	jmp    f011136b <sys_check_LRU_lists_free+0x132>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f0111331:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111334:	8b 00                	mov    (%eax),%eax
f0111336:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0111339:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011133c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111341:	89 c2                	mov    %eax,%edx
f0111343:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111346:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f011134d:	8b 45 08             	mov    0x8(%ebp),%eax
f0111350:	01 c8                	add    %ecx,%eax
f0111352:	8b 00                	mov    (%eax),%eax
f0111354:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0111357:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011135a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011135f:	39 c2                	cmp    %eax,%edx
f0111361:	75 05                	jne    f0111368 <sys_check_LRU_lists_free+0x12f>
			{
				list_validation_count++;
f0111363:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f0111366:	eb 0b                	jmp    f0111373 <sys_check_LRU_lists_free+0x13a>
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
	{
		for(int var = 0; var < list_size; var++)
f0111368:	ff 45 e8             	incl   -0x18(%ebp)
f011136b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011136e:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111371:	7c be                	jl     f0111331 <sys_check_LRU_lists_free+0xf8>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f0111373:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0111377:	7e 05                	jle    f011137e <sys_check_LRU_lists_free+0x145>
			return list_validation_count;
f0111379:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011137c:	eb 46                	jmp    f01113c4 <sys_check_LRU_lists_free+0x18b>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f011137e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111381:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f0111387:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011138a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011138e:	74 08                	je     f0111398 <sys_check_LRU_lists_free+0x15f>
f0111390:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111393:	8b 40 10             	mov    0x10(%eax),%eax
f0111396:	eb 05                	jmp    f011139d <sys_check_LRU_lists_free+0x164>
f0111398:	b8 00 00 00 00       	mov    $0x0,%eax
f011139d:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01113a0:	89 82 80 05 00 00    	mov    %eax,0x580(%edx)
f01113a6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01113a9:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f01113af:	85 c0                	test   %eax,%eax
f01113b1:	0f 85 71 ff ff ff    	jne    f0111328 <sys_check_LRU_lists_free+0xef>
f01113b7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01113bb:	0f 85 67 ff ff ff    	jne    f0111328 <sys_check_LRU_lists_free+0xef>
			return list_validation_count;

	}


	return list_validation_count;
f01113c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01113c4:	c9                   	leave  
f01113c5:	c3                   	ret    

f01113c6 <sys_check_WS_list>:
 * = 1: check entire list (order is important)
 * = 2: check only the existence of the given set of elements
 * = 3: check only the NOT existence of the given set of elements
 */
int sys_check_WS_list(uint32* WS_list_content, int actual_WS_list_size, uint32 last_WS_element_content, bool chk_status)
{
f01113c6:	55                   	push   %ebp
f01113c7:	89 e5                	mov    %esp,%ebp
f01113c9:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
//	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
//	env_page_ws_print(get_cpu_proc());
	struct Env* cur_env = get_cpu_proc();
f01113cc:	e8 47 a6 ff ff       	call   f010ba18 <get_cpu_proc>
f01113d1:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f01113d4:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f01113d8:	75 16                	jne    f01113f0 <sys_check_WS_list+0x2a>
f01113da:	68 54 1f 13 f0       	push   $0xf0131f54
f01113df:	68 64 1f 13 f0       	push   $0xf0131f64
f01113e4:	6a 79                	push   $0x79
f01113e6:	68 79 1f 13 f0       	push   $0xf0131f79
f01113eb:	e8 bf fa fe ff       	call   f0100eaf <_panic>
	struct Env* env = cur_env;
f01113f0:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01113f3:	89 45 cc             	mov    %eax,-0x34(%ebp)
	int WS_list_validation = 1;
f01113f6:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	if (chk_status == 0 || chk_status == 1)
f01113fd:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f0111401:	74 06                	je     f0111409 <sys_check_WS_list+0x43>
f0111403:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f0111407:	75 1f                	jne    f0111428 <sys_check_WS_list+0x62>
	{
		if(LIST_SIZE(&(env->page_WS_list)) != actual_WS_list_size)
f0111409:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011140c:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f0111412:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111415:	39 c2                	cmp    %eax,%edx
f0111417:	74 0f                	je     f0111428 <sys_check_WS_list+0x62>
		{
			return WS_list_validation = 0;
f0111419:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0111420:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111423:	e9 ec 02 00 00       	jmp    f0111714 <sys_check_WS_list+0x34e>
		}
	}
	//if it's required to check the last_WS_element
	if (last_WS_element_content != 0)
f0111428:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011142c:	74 39                	je     f0111467 <sys_check_WS_list+0xa1>
	{
		if (ROUNDDOWN(env->page_last_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f011142e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111431:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f0111437:	8b 00                	mov    (%eax),%eax
f0111439:	89 45 c8             	mov    %eax,-0x38(%ebp)
f011143c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011143f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111444:	89 c2                	mov    %eax,%edx
f0111446:	8b 45 10             	mov    0x10(%ebp),%eax
f0111449:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f011144c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011144f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111454:	39 c2                	cmp    %eax,%edx
f0111456:	74 0f                	je     f0111467 <sys_check_WS_list+0xa1>
		{
			return WS_list_validation = 0;
f0111458:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011145f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111462:	e9 ad 02 00 00       	jmp    f0111714 <sys_check_WS_list+0x34e>
		}
	}
	//if the order of the content is important to check
	if (chk_status == 1)
f0111467:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f011146b:	0f 85 13 01 00 00    	jne    f0111584 <sys_check_WS_list+0x1be>
		//				WS_list_validation = 0;
		//				break;
		//			}
		//			idx_WS_list++;
		//		}
		int idx_WS_list = 0;
f0111471:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
f0111478:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011147c:	74 4c                	je     f01114ca <sys_check_WS_list+0x104>
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f011147e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0111485:	eb 3b                	jmp    f01114c2 <sys_check_WS_list+0xfc>
			{
				if (ROUNDDOWN(WS_list_content[i], PAGE_SIZE) == ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f0111487:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011148a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0111491:	8b 45 08             	mov    0x8(%ebp),%eax
f0111494:	01 d0                	add    %edx,%eax
f0111496:	8b 00                	mov    (%eax),%eax
f0111498:	89 45 c0             	mov    %eax,-0x40(%ebp)
f011149b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011149e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01114a3:	89 c2                	mov    %eax,%edx
f01114a5:	8b 45 10             	mov    0x10(%ebp),%eax
f01114a8:	89 45 bc             	mov    %eax,-0x44(%ebp)
f01114ab:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01114ae:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01114b3:	39 c2                	cmp    %eax,%edx
f01114b5:	75 08                	jne    f01114bf <sys_check_WS_list+0xf9>
				{
					idx_WS_list = i ;
f01114b7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01114ba:	89 45 ec             	mov    %eax,-0x14(%ebp)
					break;
f01114bd:	eb 0b                	jmp    f01114ca <sys_check_WS_list+0x104>
		int idx_WS_list = 0;

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f01114bf:	ff 45 e8             	incl   -0x18(%ebp)
f01114c2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01114c5:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01114c8:	7c bd                	jl     f0111487 <sys_check_WS_list+0xc1>
				}
			}
		}
		//cprintf("index of last WS element = %d\n",idx_WS_list);
		//Check the expected content starting from last WS element (if any)
		if (env->page_last_WS_element)
f01114ca:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01114cd:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f01114d3:	85 c0                	test   %eax,%eax
f01114d5:	74 0e                	je     f01114e5 <sys_check_WS_list+0x11f>
			ptr_WS_element = env->page_last_WS_element;
f01114d7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01114da:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f01114e0:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01114e3:	eb 0c                	jmp    f01114f1 <sys_check_WS_list+0x12b>
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f01114e5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01114e8:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f01114ee:	89 45 f0             	mov    %eax,-0x10(%ebp)

		//cprintf("comparison start from va = %x\n",ptr_WS_element->virtual_address);

		for (int i = 0; i < actual_WS_list_size; ++i)
f01114f1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f01114f8:	eb 79                	jmp    f0111573 <sys_check_WS_list+0x1ad>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(WS_list_content[idx_WS_list], PAGE_SIZE))
f01114fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01114fd:	8b 00                	mov    (%eax),%eax
f01114ff:	89 45 b8             	mov    %eax,-0x48(%ebp)
f0111502:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0111505:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011150a:	89 c2                	mov    %eax,%edx
f011150c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011150f:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111516:	8b 45 08             	mov    0x8(%ebp),%eax
f0111519:	01 c8                	add    %ecx,%eax
f011151b:	8b 00                	mov    (%eax),%eax
f011151d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f0111520:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0111523:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111528:	39 c2                	cmp    %eax,%edx
f011152a:	74 0c                	je     f0111538 <sys_check_WS_list+0x172>
			{
				WS_list_validation = 0;
f011152c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0111533:	e9 d9 01 00 00       	jmp    f0111711 <sys_check_WS_list+0x34b>
			}
			idx_WS_list = (idx_WS_list + 1) % env->page_WS_max_size;
f0111538:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011153b:	40                   	inc    %eax
f011153c:	89 c2                	mov    %eax,%edx
f011153e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111541:	8b 88 84 00 00 00    	mov    0x84(%eax),%ecx
f0111547:	89 d0                	mov    %edx,%eax
f0111549:	ba 00 00 00 00       	mov    $0x0,%edx
f011154e:	f7 f1                	div    %ecx
f0111550:	89 d0                	mov    %edx,%eax
f0111552:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
f0111555:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111558:	8b 40 10             	mov    0x10(%eax),%eax
f011155b:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_WS_element == NULL)
f011155e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111562:	75 0c                	jne    f0111570 <sys_check_WS_list+0x1aa>
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f0111564:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111567:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f011156d:	89 45 f0             	mov    %eax,-0x10(%ebp)
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));

		//cprintf("comparison start from va = %x\n",ptr_WS_element->virtual_address);

		for (int i = 0; i < actual_WS_list_size; ++i)
f0111570:	ff 45 e4             	incl   -0x1c(%ebp)
f0111573:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0111576:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111579:	0f 8c 7b ff ff ff    	jl     f01114fa <sys_check_WS_list+0x134>
f011157f:	e9 8d 01 00 00       	jmp    f0111711 <sys_check_WS_list+0x34b>
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
			if (ptr_WS_element == NULL)
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
f0111584:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f0111588:	74 0a                	je     f0111594 <sys_check_WS_list+0x1ce>
f011158a:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
f011158e:	0f 85 be 00 00 00    	jne    f0111652 <sys_check_WS_list+0x28c>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0111594:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011159b:	e9 a1 00 00 00       	jmp    f0111641 <sys_check_WS_list+0x27b>
		{
			bool found = 0;
f01115a0:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f01115a7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01115aa:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f01115b0:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01115b3:	eb 47                	jmp    f01115fc <sys_check_WS_list+0x236>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f01115b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01115b8:	8b 00                	mov    (%eax),%eax
f01115ba:	89 45 a8             	mov    %eax,-0x58(%ebp)
f01115bd:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01115c0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01115c5:	89 c2                	mov    %eax,%edx
f01115c7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01115ca:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01115d1:	8b 45 08             	mov    0x8(%ebp),%eax
f01115d4:	01 c8                	add    %ecx,%eax
f01115d6:	8b 00                	mov    (%eax),%eax
f01115d8:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f01115db:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01115de:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01115e3:	39 c2                	cmp    %eax,%edx
f01115e5:	75 09                	jne    f01115f0 <sys_check_WS_list+0x22a>
				{
					found = 1;
f01115e7:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
					break;
f01115ee:	eb 3b                	jmp    f011162b <sys_check_WS_list+0x265>
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f01115f0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01115f3:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f01115f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01115fc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111600:	74 08                	je     f011160a <sys_check_WS_list+0x244>
f0111602:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111605:	8b 40 10             	mov    0x10(%eax),%eax
f0111608:	eb 05                	jmp    f011160f <sys_check_WS_list+0x249>
f011160a:	b8 00 00 00 00       	mov    $0x0,%eax
f011160f:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0111612:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f0111618:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011161b:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f0111621:	85 c0                	test   %eax,%eax
f0111623:	75 90                	jne    f01115b5 <sys_check_WS_list+0x1ef>
f0111625:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111629:	75 8a                	jne    f01115b5 <sys_check_WS_list+0x1ef>
				{
					found = 1;
					break;
				}
			}
			if (!found)
f011162b:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011162f:	75 0d                	jne    f011163e <sys_check_WS_list+0x278>
			{
				WS_list_validation = 0;
f0111631:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0111638:	90                   	nop
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0111639:	e9 d3 00 00 00       	jmp    f0111711 <sys_check_WS_list+0x34b>
f011163e:	ff 45 e0             	incl   -0x20(%ebp)
f0111641:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111644:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111647:	0f 8c 53 ff ff ff    	jl     f01115a0 <sys_check_WS_list+0x1da>
f011164d:	e9 bf 00 00 00       	jmp    f0111711 <sys_check_WS_list+0x34b>
				break;
			}
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
f0111652:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
f0111656:	0f 85 b5 00 00 00    	jne    f0111711 <sys_check_WS_list+0x34b>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f011165c:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f0111663:	e9 9d 00 00 00       	jmp    f0111705 <sys_check_WS_list+0x33f>
		{
			bool found = 0;
f0111668:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f011166f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111672:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0111678:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011167b:	eb 47                	jmp    f01116c4 <sys_check_WS_list+0x2fe>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f011167d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111680:	8b 00                	mov    (%eax),%eax
f0111682:	89 45 b0             	mov    %eax,-0x50(%ebp)
f0111685:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0111688:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011168d:	89 c2                	mov    %eax,%edx
f011168f:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111692:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111699:	8b 45 08             	mov    0x8(%ebp),%eax
f011169c:	01 c8                	add    %ecx,%eax
f011169e:	8b 00                	mov    (%eax),%eax
f01116a0:	89 45 ac             	mov    %eax,-0x54(%ebp)
f01116a3:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01116a6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01116ab:	39 c2                	cmp    %eax,%edx
f01116ad:	75 09                	jne    f01116b8 <sys_check_WS_list+0x2f2>
				{
					found = 1;
f01116af:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
					break;
f01116b6:	eb 3b                	jmp    f01116f3 <sys_check_WS_list+0x32d>
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f01116b8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01116bb:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f01116c1:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01116c4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01116c8:	74 08                	je     f01116d2 <sys_check_WS_list+0x30c>
f01116ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01116cd:	8b 40 10             	mov    0x10(%eax),%eax
f01116d0:	eb 05                	jmp    f01116d7 <sys_check_WS_list+0x311>
f01116d2:	b8 00 00 00 00       	mov    $0x0,%eax
f01116d7:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01116da:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f01116e0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01116e3:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f01116e9:	85 c0                	test   %eax,%eax
f01116eb:	75 90                	jne    f011167d <sys_check_WS_list+0x2b7>
f01116ed:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01116f1:	75 8a                	jne    f011167d <sys_check_WS_list+0x2b7>
				{
					found = 1;
					break;
				}
			}
			if (found)
f01116f3:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01116f7:	74 09                	je     f0111702 <sys_check_WS_list+0x33c>
			{
				WS_list_validation = 0;
f01116f9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0111700:	eb 0f                	jmp    f0111711 <sys_check_WS_list+0x34b>
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0111702:	ff 45 d8             	incl   -0x28(%ebp)
f0111705:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111708:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011170b:	0f 8c 57 ff ff ff    	jl     f0111668 <sys_check_WS_list+0x2a2>
				break;
			}
		}
	}

	return WS_list_validation;
f0111711:	8b 45 f4             	mov    -0xc(%ebp),%eax
#else
	panic("sys_check_WS_list: this function is intended to be used when USE_KHEAP = 1");
	return 0;
#endif
}
f0111714:	c9                   	leave  
f0111715:	c3                   	ret    

f0111716 <hasExpectedCommands>:
	cprintf("=================\n\n");
	return 0;
}*/

int hasExpectedCommands(char **expectedCommands, int commandsCount)
{
f0111716:	55                   	push   %ebp
f0111717:	89 e5                	mov    %esp,%ebp
f0111719:	83 ec 18             	sub    $0x18,%esp
	struct Command *cmd = NULL;
f011171c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (LIST_SIZE(&foundCommands) != commandsCount)
f0111723:	8b 15 78 6d 85 f0    	mov    0xf0856d78,%edx
f0111729:	8b 45 0c             	mov    0xc(%ebp),%eax
f011172c:	39 c2                	cmp    %eax,%edx
f011172e:	74 0a                	je     f011173a <hasExpectedCommands+0x24>
		return 0;
f0111730:	b8 00 00 00 00       	mov    $0x0,%eax
f0111735:	e9 8b 00 00 00       	jmp    f01117c5 <hasExpectedCommands+0xaf>

	LIST_FOREACH(cmd, &foundCommands)
f011173a:	a1 6c 6d 85 f0       	mov    0xf0856d6c,%eax
f011173f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0111742:	eb 55                	jmp    f0111799 <hasExpectedCommands+0x83>
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f0111744:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011174b:	eb 2a                	jmp    f0111777 <hasExpectedCommands+0x61>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
f011174d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111750:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0111757:	8b 45 08             	mov    0x8(%ebp),%eax
f011175a:	01 d0                	add    %edx,%eax
f011175c:	8b 10                	mov    (%eax),%edx
f011175e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111761:	8b 00                	mov    (%eax),%eax
f0111763:	83 ec 08             	sub    $0x8,%esp
f0111766:	52                   	push   %edx
f0111767:	50                   	push   %eax
f0111768:	e8 1a 94 00 00       	call   f011ab87 <strcmp>
f011176d:	83 c4 10             	add    $0x10,%esp
f0111770:	85 c0                	test   %eax,%eax
f0111772:	74 0d                	je     f0111781 <hasExpectedCommands+0x6b>
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f0111774:	ff 45 f0             	incl   -0x10(%ebp)
f0111777:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011177a:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011177d:	7c ce                	jl     f011174d <hasExpectedCommands+0x37>
f011177f:	eb 01                	jmp    f0111782 <hasExpectedCommands+0x6c>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
f0111781:	90                   	nop
		if (i == commandsCount)
f0111782:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111785:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111788:	75 07                	jne    f0111791 <hasExpectedCommands+0x7b>
			return 0;
f011178a:	b8 00 00 00 00       	mov    $0x0,%eax
f011178f:	eb 34                	jmp    f01117c5 <hasExpectedCommands+0xaf>
{
	struct Command *cmd = NULL;
	if (LIST_SIZE(&foundCommands) != commandsCount)
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
f0111791:	a1 74 6d 85 f0       	mov    0xf0856d74,%eax
f0111796:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0111799:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011179d:	74 08                	je     f01117a7 <hasExpectedCommands+0x91>
f011179f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01117a2:	8b 40 10             	mov    0x10(%eax),%eax
f01117a5:	eb 05                	jmp    f01117ac <hasExpectedCommands+0x96>
f01117a7:	b8 00 00 00 00       	mov    $0x0,%eax
f01117ac:	a3 74 6d 85 f0       	mov    %eax,0xf0856d74
f01117b1:	a1 74 6d 85 f0       	mov    0xf0856d74,%eax
f01117b6:	85 c0                	test   %eax,%eax
f01117b8:	75 8a                	jne    f0111744 <hasExpectedCommands+0x2e>
f01117ba:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01117be:	75 84                	jne    f0111744 <hasExpectedCommands+0x2e>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
		if (i == commandsCount)
			return 0;
	}
	return 1;
f01117c0:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01117c5:	c9                   	leave  
f01117c6:	c3                   	ret    

f01117c7 <getIndexOfCommand>:

int getIndexOfCommand(const char *commandName)
{
f01117c7:	55                   	push   %ebp
f01117c8:	89 e5                	mov    %esp,%ebp
f01117ca:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01117cd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01117d4:	eb 2e                	jmp    f0111804 <getIndexOfCommand+0x3d>
		if (strcmp(commands[i].name, commandName) == 0)
f01117d6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01117d9:	89 d0                	mov    %edx,%eax
f01117db:	01 c0                	add    %eax,%eax
f01117dd:	01 d0                	add    %edx,%eax
f01117df:	c1 e0 03             	shl    $0x3,%eax
f01117e2:	05 60 f5 17 f0       	add    $0xf017f560,%eax
f01117e7:	8b 00                	mov    (%eax),%eax
f01117e9:	83 ec 08             	sub    $0x8,%esp
f01117ec:	ff 75 08             	pushl  0x8(%ebp)
f01117ef:	50                   	push   %eax
f01117f0:	e8 92 93 00 00       	call   f011ab87 <strcmp>
f01117f5:	83 c4 10             	add    $0x10,%esp
f01117f8:	85 c0                	test   %eax,%eax
f01117fa:	75 05                	jne    f0111801 <getIndexOfCommand+0x3a>
			return i;
f01117fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01117ff:	eb 14                	jmp    f0111815 <getIndexOfCommand+0x4e>
}

int getIndexOfCommand(const char *commandName)
{
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0111801:	ff 45 f4             	incl   -0xc(%ebp)
f0111804:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0111807:	a1 a8 fb 17 f0       	mov    0xf017fba8,%eax
f011180c:	39 c2                	cmp    %eax,%edx
f011180e:	72 c6                	jb     f01117d6 <getIndexOfCommand+0xf>
		if (strcmp(commands[i].name, commandName) == 0)
			return i;
	return -404;
f0111810:	b8 6c fe ff ff       	mov    $0xfffffe6c,%eax
}
f0111815:	c9                   	leave  
f0111816:	c3                   	ret    

f0111817 <TestAutoCompleteCommand>:

int TestAutoCompleteCommand()
{
f0111817:	55                   	push   %ebp
f0111818:	89 e5                	mov    %esp,%ebp
f011181a:	57                   	push   %edi
f011181b:	56                   	push   %esi
f011181c:	53                   	push   %ebx
f011181d:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
	cprintf("Automatic Testing of Autocomplete:\n");
f0111823:	83 ec 0c             	sub    $0xc,%esp
f0111826:	68 c0 1f 13 f0       	push   $0xf0131fc0
f011182b:	e8 2c 03 ff ff       	call   f0101b5c <cprintf>
f0111830:	83 c4 10             	add    $0x10,%esp
	cprintf("\n========================\n");
f0111833:	83 ec 0c             	sub    $0xc,%esp
f0111836:	68 e4 1f 13 f0       	push   $0xf0131fe4
f011183b:	e8 1c 03 ff ff       	call   f0101b5c <cprintf>
f0111840:	83 c4 10             	add    $0x10,%esp

	// CASE1: command is found with correct number of arguments
	int eval = 0;
f0111843:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	char *args1[] = {"kernel_info"};
f011184a:	c7 45 8c ff 1f 13 f0 	movl   $0xf0131fff,-0x74(%ebp)
	int ret = process_command(ARRAY_LENGTH(args1), args1);
f0111851:	83 ec 08             	sub    $0x8,%esp
f0111854:	8d 45 8c             	lea    -0x74(%ebp),%eax
f0111857:	50                   	push   %eax
f0111858:	6a 01                	push   $0x1
f011185a:	e8 91 08 ff ff       	call   f01020f0 <process_command>
f011185f:	83 c4 10             	add    $0x10,%esp
f0111862:	89 45 e0             	mov    %eax,-0x20(%ebp)
	cprintf("==>Testing now AUTOCOMPLETE for: kernel_info\n");
f0111865:	83 ec 0c             	sub    $0xc,%esp
f0111868:	68 0c 20 13 f0       	push   $0xf013200c
f011186d:	e8 ea 02 ff ff       	call   f0101b5c <cprintf>
f0111872:	83 c4 10             	add    $0x10,%esp
	if (ret == getIndexOfCommand(args1[0]) && LIST_EMPTY(&foundCommands))
f0111875:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0111878:	83 ec 0c             	sub    $0xc,%esp
f011187b:	50                   	push   %eax
f011187c:	e8 46 ff ff ff       	call   f01117c7 <getIndexOfCommand>
f0111881:	83 c4 10             	add    $0x10,%esp
f0111884:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0111887:	75 0f                	jne    f0111898 <TestAutoCompleteCommand+0x81>
f0111889:	a1 6c 6d 85 f0       	mov    0xf0856d6c,%eax
f011188e:	85 c0                	test   %eax,%eax
f0111890:	75 06                	jne    f0111898 <TestAutoCompleteCommand+0x81>
		eval += 5;
f0111892:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
f0111896:	eb 10                	jmp    f01118a8 <TestAutoCompleteCommand+0x91>
	else
		cprintf("#1: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111898:	83 ec 0c             	sub    $0xc,%esp
f011189b:	68 3c 20 13 f0       	push   $0xf013203c
f01118a0:	e8 b7 02 ff ff       	call   f0101b5c <cprintf>
f01118a5:	83 c4 10             	add    $0x10,%esp

	// CASE2: command is not found BUT its chars are subsequence-matched with one or more commands
	// should print the commands that contains "clk" as subsequence
	cprintf("==>Testing now AUTOCOMPLETE for: clk\n");
f01118a8:	83 ec 0c             	sub    $0xc,%esp
f01118ab:	68 8c 20 13 f0       	push   $0xf013208c
f01118b0:	e8 a7 02 ff ff       	call   f0101b5c <cprintf>
f01118b5:	83 c4 10             	add    $0x10,%esp
	char *args2[] = {"clk"};
f01118b8:	c7 45 88 b2 20 13 f0 	movl   $0xf01320b2,-0x78(%ebp)
	ret = process_command(ARRAY_LENGTH(args2), args2);
f01118bf:	83 ec 08             	sub    $0x8,%esp
f01118c2:	8d 45 88             	lea    -0x78(%ebp),%eax
f01118c5:	50                   	push   %eax
f01118c6:	6a 01                	push   $0x1
f01118c8:	e8 23 08 ff ff       	call   f01020f0 <process_command>
f01118cd:	83 c4 10             	add    $0x10,%esp
f01118d0:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"clock", "modifiedclock", "nclock"}, 3))
f01118d3:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f01118d7:	75 30                	jne    f0111909 <TestAutoCompleteCommand+0xf2>
f01118d9:	8d 45 90             	lea    -0x70(%ebp),%eax
f01118dc:	bb cc 24 13 f0       	mov    $0xf01324cc,%ebx
f01118e1:	ba 03 00 00 00       	mov    $0x3,%edx
f01118e6:	89 c7                	mov    %eax,%edi
f01118e8:	89 de                	mov    %ebx,%esi
f01118ea:	89 d1                	mov    %edx,%ecx
f01118ec:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01118ee:	83 ec 08             	sub    $0x8,%esp
f01118f1:	6a 03                	push   $0x3
f01118f3:	8d 45 90             	lea    -0x70(%ebp),%eax
f01118f6:	50                   	push   %eax
f01118f7:	e8 1a fe ff ff       	call   f0111716 <hasExpectedCommands>
f01118fc:	83 c4 10             	add    $0x10,%esp
f01118ff:	85 c0                	test   %eax,%eax
f0111901:	74 06                	je     f0111909 <TestAutoCompleteCommand+0xf2>
		eval += 15;
f0111903:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111907:	eb 10                	jmp    f0111919 <TestAutoCompleteCommand+0x102>
	else
		cprintf("#2: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111909:	83 ec 0c             	sub    $0xc,%esp
f011190c:	68 b8 20 13 f0       	push   $0xf01320b8
f0111911:	e8 46 02 ff ff       	call   f0101b5c <cprintf>
f0111916:	83 c4 10             	add    $0x10,%esp

	// CASE3.1: should print invalid number of args
	cprintf("==>Testing now AUTOCOMPLETE for: wm\n");
f0111919:	83 ec 0c             	sub    $0xc,%esp
f011191c:	68 08 21 13 f0       	push   $0xf0132108
f0111921:	e8 36 02 ff ff       	call   f0101b5c <cprintf>
f0111926:	83 c4 10             	add    $0x10,%esp
	char *args3_1[] = {"wm"};
f0111929:	c7 45 84 2d 21 13 f0 	movl   $0xf013212d,-0x7c(%ebp)
	ret = process_command(ARRAY_LENGTH(args3_1), args3_1);
f0111930:	83 ec 08             	sub    $0x8,%esp
f0111933:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0111936:	50                   	push   %eax
f0111937:	6a 01                	push   $0x1
f0111939:	e8 b2 07 ff ff       	call   f01020f0 <process_command>
f011193e:	83 c4 10             	add    $0x10,%esp
f0111941:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INV_NUM_ARGS && hasExpectedCommands(args3_1, 1))
f0111944:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0111948:	75 1b                	jne    f0111965 <TestAutoCompleteCommand+0x14e>
f011194a:	83 ec 08             	sub    $0x8,%esp
f011194d:	6a 01                	push   $0x1
f011194f:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0111952:	50                   	push   %eax
f0111953:	e8 be fd ff ff       	call   f0111716 <hasExpectedCommands>
f0111958:	83 c4 10             	add    $0x10,%esp
f011195b:	85 c0                	test   %eax,%eax
f011195d:	74 06                	je     f0111965 <TestAutoCompleteCommand+0x14e>
		eval += 15;
f011195f:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111963:	eb 10                	jmp    f0111975 <TestAutoCompleteCommand+0x15e>
	else
		cprintf("#3.1: WRONG - process_command return wrong value or foundCommands contains wrong values.\n");
f0111965:	83 ec 0c             	sub    $0xc,%esp
f0111968:	68 30 21 13 f0       	push   $0xf0132130
f011196d:	e8 ea 01 ff ff       	call   f0101b5c <cprintf>
f0111972:	83 c4 10             	add    $0x10,%esp

	// CASE3.2: should print invalid number of args
	cprintf("==>Testing now AUTOCOMPLETE for: lru\n");
f0111975:	83 ec 0c             	sub    $0xc,%esp
f0111978:	68 8c 21 13 f0       	push   $0xf013218c
f011197d:	e8 da 01 ff ff       	call   f0101b5c <cprintf>
f0111982:	83 c4 10             	add    $0x10,%esp
	char *args3_2[] = {"lru", "2", "1"};
f0111985:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f011198b:	bb e0 24 13 f0       	mov    $0xf01324e0,%ebx
f0111990:	ba 03 00 00 00       	mov    $0x3,%edx
f0111995:	89 c7                	mov    %eax,%edi
f0111997:	89 de                	mov    %ebx,%esi
f0111999:	89 d1                	mov    %edx,%ecx
f011199b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	ret = process_command(ARRAY_LENGTH(args3_2), args3_2);
f011199d:	83 ec 08             	sub    $0x8,%esp
f01119a0:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f01119a6:	50                   	push   %eax
f01119a7:	6a 03                	push   $0x3
f01119a9:	e8 42 07 ff ff       	call   f01020f0 <process_command>
f01119ae:	83 c4 10             	add    $0x10,%esp
f01119b1:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INV_NUM_ARGS && hasExpectedCommands(args3_2, 1))
f01119b4:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f01119b8:	75 1e                	jne    f01119d8 <TestAutoCompleteCommand+0x1c1>
f01119ba:	83 ec 08             	sub    $0x8,%esp
f01119bd:	6a 01                	push   $0x1
f01119bf:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f01119c5:	50                   	push   %eax
f01119c6:	e8 4b fd ff ff       	call   f0111716 <hasExpectedCommands>
f01119cb:	83 c4 10             	add    $0x10,%esp
f01119ce:	85 c0                	test   %eax,%eax
f01119d0:	74 06                	je     f01119d8 <TestAutoCompleteCommand+0x1c1>
		eval += 15;
f01119d2:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f01119d6:	eb 10                	jmp    f01119e8 <TestAutoCompleteCommand+0x1d1>
	else
		cprintf("#3.2: WRONG - process_command return wrong value or foundCommands contains wrong values.\n");
f01119d8:	83 ec 0c             	sub    $0xc,%esp
f01119db:	68 b4 21 13 f0       	push   $0xf01321b4
f01119e0:	e8 77 01 ff ff       	call   f0101b5c <cprintf>
f01119e5:	83 c4 10             	add    $0x10,%esp

	// CASE4: should print invalid command
	cprintf("==>Testing now AUTOCOMPLETE for: smm\n");
f01119e8:	83 ec 0c             	sub    $0xc,%esp
f01119eb:	68 10 22 13 f0       	push   $0xf0132210
f01119f0:	e8 67 01 ff ff       	call   f0101b5c <cprintf>
f01119f5:	83 c4 10             	add    $0x10,%esp
	char *args4[] = {"smm"};
f01119f8:	c7 85 74 ff ff ff 36 	movl   $0xf0132236,-0x8c(%ebp)
f01119ff:	22 13 f0 
	ret = process_command(ARRAY_LENGTH(args4), args4);
f0111a02:	83 ec 08             	sub    $0x8,%esp
f0111a05:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0111a0b:	50                   	push   %eax
f0111a0c:	6a 01                	push   $0x1
f0111a0e:	e8 dd 06 ff ff       	call   f01020f0 <process_command>
f0111a13:	83 c4 10             	add    $0x10,%esp
f0111a16:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INVALID && LIST_SIZE(&foundCommands) == 0)
f0111a19:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f0111a1d:	75 0f                	jne    f0111a2e <TestAutoCompleteCommand+0x217>
f0111a1f:	a1 78 6d 85 f0       	mov    0xf0856d78,%eax
f0111a24:	85 c0                	test   %eax,%eax
f0111a26:	75 06                	jne    f0111a2e <TestAutoCompleteCommand+0x217>
		eval += 10;
f0111a28:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111a2c:	eb 10                	jmp    f0111a3e <TestAutoCompleteCommand+0x227>
	else
		cprintf("#4: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111a2e:	83 ec 0c             	sub    $0xc,%esp
f0111a31:	68 3c 22 13 f0       	push   $0xf013223c
f0111a36:	e8 21 01 ff ff       	call   f0101b5c <cprintf>
f0111a3b:	83 c4 10             	add    $0x10,%esp

	// CASE5: should print the commands that contains he
	cprintf("==>Testing now AUTOCOMPLETE for: he\n");
f0111a3e:	83 ec 0c             	sub    $0xc,%esp
f0111a41:	68 8c 22 13 f0       	push   $0xf013228c
f0111a46:	e8 11 01 ff ff       	call   f0101b5c <cprintf>
f0111a4b:	83 c4 10             	add    $0x10,%esp
	char *args5[] = {"he"};
f0111a4e:	c7 85 70 ff ff ff b1 	movl   $0xf01322b1,-0x90(%ebp)
f0111a55:	22 13 f0 
	ret = process_command(ARRAY_LENGTH(args5), args5);
f0111a58:	83 ec 08             	sub    $0x8,%esp
f0111a5b:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f0111a61:	50                   	push   %eax
f0111a62:	6a 01                	push   $0x1
f0111a64:	e8 87 06 ff ff       	call   f01020f0 <process_command>
f0111a69:	83 c4 10             	add    $0x10,%esp
f0111a6c:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"help", "sched?", "uhbestfit", "uhnextfit", "uheap?", "khbestfit", "khnextfit", "kheap?", "schedRR", "schedTest", "schedBSD", "schedMLFQ"}, 12))
f0111a6f:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0111a73:	75 30                	jne    f0111aa5 <TestAutoCompleteCommand+0x28e>
f0111a75:	8d 45 9c             	lea    -0x64(%ebp),%eax
f0111a78:	bb 60 25 13 f0       	mov    $0xf0132560,%ebx
f0111a7d:	ba 0c 00 00 00       	mov    $0xc,%edx
f0111a82:	89 c7                	mov    %eax,%edi
f0111a84:	89 de                	mov    %ebx,%esi
f0111a86:	89 d1                	mov    %edx,%ecx
f0111a88:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0111a8a:	83 ec 08             	sub    $0x8,%esp
f0111a8d:	6a 0c                	push   $0xc
f0111a8f:	8d 45 9c             	lea    -0x64(%ebp),%eax
f0111a92:	50                   	push   %eax
f0111a93:	e8 7e fc ff ff       	call   f0111716 <hasExpectedCommands>
f0111a98:	83 c4 10             	add    $0x10,%esp
f0111a9b:	85 c0                	test   %eax,%eax
f0111a9d:	74 06                	je     f0111aa5 <TestAutoCompleteCommand+0x28e>
		eval += 15;
f0111a9f:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111aa3:	eb 10                	jmp    f0111ab5 <TestAutoCompleteCommand+0x29e>
	else
		cprintf("#5: WRONG - process_command return wrong value or foundCommands is has wrong values.\n");
f0111aa5:	83 ec 0c             	sub    $0xc,%esp
f0111aa8:	68 b4 22 13 f0       	push   $0xf01322b4
f0111aad:	e8 aa 00 ff ff       	call   f0101b5c <cprintf>
f0111ab2:	83 c4 10             	add    $0x10,%esp

	// CASE6: should print the commands that contains ru ---> Shall print (rum, rub, rut, run, runall) .. Each in a separate line
	cprintf("==>Testing now AUTOCOMPLETE for: ru\n");
f0111ab5:	83 ec 0c             	sub    $0xc,%esp
f0111ab8:	68 0c 23 13 f0       	push   $0xf013230c
f0111abd:	e8 9a 00 ff ff       	call   f0101b5c <cprintf>
f0111ac2:	83 c4 10             	add    $0x10,%esp
	char *args6[] = {"ru"};
f0111ac5:	c7 85 6c ff ff ff 31 	movl   $0xf0132331,-0x94(%ebp)
f0111acc:	23 13 f0 
	ret = process_command(ARRAY_LENGTH(args6), args6);
f0111acf:	83 ec 08             	sub    $0x8,%esp
f0111ad2:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f0111ad8:	50                   	push   %eax
f0111ad9:	6a 01                	push   $0x1
f0111adb:	e8 10 06 ff ff       	call   f01020f0 <process_command>
f0111ae0:	83 c4 10             	add    $0x10,%esp
f0111ae3:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"runall", "lru", "rub", "run", "rum"}, 5))
f0111ae6:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0111aea:	75 30                	jne    f0111b1c <TestAutoCompleteCommand+0x305>
f0111aec:	8d 45 cc             	lea    -0x34(%ebp),%eax
f0111aef:	bb a4 25 13 f0       	mov    $0xf01325a4,%ebx
f0111af4:	ba 05 00 00 00       	mov    $0x5,%edx
f0111af9:	89 c7                	mov    %eax,%edi
f0111afb:	89 de                	mov    %ebx,%esi
f0111afd:	89 d1                	mov    %edx,%ecx
f0111aff:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0111b01:	83 ec 08             	sub    $0x8,%esp
f0111b04:	6a 05                	push   $0x5
f0111b06:	8d 45 cc             	lea    -0x34(%ebp),%eax
f0111b09:	50                   	push   %eax
f0111b0a:	e8 07 fc ff ff       	call   f0111716 <hasExpectedCommands>
f0111b0f:	83 c4 10             	add    $0x10,%esp
f0111b12:	85 c0                	test   %eax,%eax
f0111b14:	74 06                	je     f0111b1c <TestAutoCompleteCommand+0x305>
		eval += 10;
f0111b16:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111b1a:	eb 10                	jmp    f0111b2c <TestAutoCompleteCommand+0x315>
	else
		cprintf("#6: WRONG - process_command return wrong value. or foundCommands is has wrong values.\n");
f0111b1c:	83 ec 0c             	sub    $0xc,%esp
f0111b1f:	68 34 23 13 f0       	push   $0xf0132334
f0111b24:	e8 33 00 ff ff       	call   f0101b5c <cprintf>
f0111b29:	83 c4 10             	add    $0x10,%esp

	// CASE7: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: load game\n");
f0111b2c:	83 ec 0c             	sub    $0xc,%esp
f0111b2f:	68 8c 23 13 f0       	push   $0xf013238c
f0111b34:	e8 23 00 ff ff       	call   f0101b5c <cprintf>
f0111b39:	83 c4 10             	add    $0x10,%esp
	char *args7[] = {"load", "game"};
f0111b3c:	c7 85 64 ff ff ff b8 	movl   $0xf01323b8,-0x9c(%ebp)
f0111b43:	23 13 f0 
f0111b46:	c7 85 68 ff ff ff bd 	movl   $0xf01323bd,-0x98(%ebp)
f0111b4d:	23 13 f0 
	ret = process_command(ARRAY_LENGTH(args7), args7);
f0111b50:	83 ec 08             	sub    $0x8,%esp
f0111b53:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f0111b59:	50                   	push   %eax
f0111b5a:	6a 02                	push   $0x2
f0111b5c:	e8 8f 05 ff ff       	call   f01020f0 <process_command>
f0111b61:	83 c4 10             	add    $0x10,%esp
f0111b64:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args7[0]) && LIST_EMPTY(&foundCommands))
f0111b67:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f0111b6d:	83 ec 0c             	sub    $0xc,%esp
f0111b70:	50                   	push   %eax
f0111b71:	e8 51 fc ff ff       	call   f01117c7 <getIndexOfCommand>
f0111b76:	83 c4 10             	add    $0x10,%esp
f0111b79:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0111b7c:	75 0f                	jne    f0111b8d <TestAutoCompleteCommand+0x376>
f0111b7e:	a1 6c 6d 85 f0       	mov    0xf0856d6c,%eax
f0111b83:	85 c0                	test   %eax,%eax
f0111b85:	75 06                	jne    f0111b8d <TestAutoCompleteCommand+0x376>
		eval += 5;
f0111b87:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
f0111b8b:	eb 10                	jmp    f0111b9d <TestAutoCompleteCommand+0x386>
	else
		cprintf("#7: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111b8d:	83 ec 0c             	sub    $0xc,%esp
f0111b90:	68 c4 23 13 f0       	push   $0xf01323c4
f0111b95:	e8 c2 ff fe ff       	call   f0101b5c <cprintf>
f0111b9a:	83 c4 10             	add    $0x10,%esp

	// CASE8: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: wum 0xF0000000 M\n");
f0111b9d:	83 ec 0c             	sub    $0xc,%esp
f0111ba0:	68 14 24 13 f0       	push   $0xf0132414
f0111ba5:	e8 b2 ff fe ff       	call   f0101b5c <cprintf>
f0111baa:	83 c4 10             	add    $0x10,%esp
	char *args8[] = {"wum", "0xF0000000", "M"};
f0111bad:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
f0111bb3:	bb cc 25 13 f0       	mov    $0xf01325cc,%ebx
f0111bb8:	ba 03 00 00 00       	mov    $0x3,%edx
f0111bbd:	89 c7                	mov    %eax,%edi
f0111bbf:	89 de                	mov    %ebx,%esi
f0111bc1:	89 d1                	mov    %edx,%ecx
f0111bc3:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	ret = process_command(ARRAY_LENGTH(args8), args8);
f0111bc5:	83 ec 08             	sub    $0x8,%esp
f0111bc8:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
f0111bce:	50                   	push   %eax
f0111bcf:	6a 03                	push   $0x3
f0111bd1:	e8 1a 05 ff ff       	call   f01020f0 <process_command>
f0111bd6:	83 c4 10             	add    $0x10,%esp
f0111bd9:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args8[0]) && LIST_EMPTY(&foundCommands))
f0111bdc:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f0111be2:	83 ec 0c             	sub    $0xc,%esp
f0111be5:	50                   	push   %eax
f0111be6:	e8 dc fb ff ff       	call   f01117c7 <getIndexOfCommand>
f0111beb:	83 c4 10             	add    $0x10,%esp
f0111bee:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0111bf1:	75 0f                	jne    f0111c02 <TestAutoCompleteCommand+0x3eb>
f0111bf3:	a1 6c 6d 85 f0       	mov    0xf0856d6c,%eax
f0111bf8:	85 c0                	test   %eax,%eax
f0111bfa:	75 06                	jne    f0111c02 <TestAutoCompleteCommand+0x3eb>
		eval += 10;
f0111bfc:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111c00:	eb 10                	jmp    f0111c12 <TestAutoCompleteCommand+0x3fb>
	else
		cprintf("#8: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111c02:	83 ec 0c             	sub    $0xc,%esp
f0111c05:	68 48 24 13 f0       	push   $0xf0132448
f0111c0a:	e8 4d ff fe ff       	call   f0101b5c <cprintf>
f0111c0f:	83 c4 10             	add    $0x10,%esp

//	cprintf("test autocomplete completed. Evaluation = %d%%\n", eval);
//	cprintf("=================\n\n");
	cprintf("[AUTO_GR@DING_PARTIAL]%d\n", eval);
f0111c12:	83 ec 08             	sub    $0x8,%esp
f0111c15:	ff 75 e4             	pushl  -0x1c(%ebp)
f0111c18:	68 97 24 13 f0       	push   $0xf0132497
f0111c1d:	e8 3a ff fe ff       	call   f0101b5c <cprintf>
f0111c22:	83 c4 10             	add    $0x10,%esp

	return 0;
f0111c25:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111c2a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0111c2d:	5b                   	pop    %ebx
f0111c2e:	5e                   	pop    %esi
f0111c2f:	5f                   	pop    %edi
f0111c30:	5d                   	pop    %ebp
f0111c31:	c3                   	ret    

f0111c32 <test_str2lower_function>:

int test_str2lower_function()
{
f0111c32:	55                   	push   %ebp
f0111c33:	89 e5                	mov    %esp,%ebp
f0111c35:	81 ec f8 02 00 00    	sub    $0x2f8,%esp
	cprintf("Automatic Testing of str2lower:\n");
f0111c3b:	83 ec 0c             	sub    $0xc,%esp
f0111c3e:	68 d8 25 13 f0       	push   $0xf01325d8
f0111c43:	e8 14 ff fe ff       	call   f0101b5c <cprintf>
f0111c48:	83 c4 10             	add    $0x10,%esp
	cprintf("========================\n");
f0111c4b:	83 ec 0c             	sub    $0xc,%esp
f0111c4e:	68 f9 25 13 f0       	push   $0xf01325f9
f0111c53:	e8 04 ff fe ff       	call   f0101b5c <cprintf>
f0111c58:	83 c4 10             	add    $0x10,%esp
	int i = 0;
f0111c5b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int eval = 0;
f0111c62:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	// CASE1: input string in lower case
	const char *src1 = "HelloWorld";
f0111c69:	c7 45 ec 13 26 13 f0 	movl   $0xf0132613,-0x14(%ebp)
	char dst1[100];
	char *result = str2lower(dst1, src1);
f0111c70:	83 ec 08             	sub    $0x8,%esp
f0111c73:	ff 75 ec             	pushl  -0x14(%ebp)
f0111c76:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
f0111c7c:	50                   	push   %eax
f0111c7d:	e8 91 95 00 00       	call   f011b213 <str2lower>
f0111c82:	83 c4 10             	add    $0x10,%esp
f0111c85:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int resultLength = strlen(result);
f0111c88:	83 ec 0c             	sub    $0xc,%esp
f0111c8b:	ff 75 e8             	pushl  -0x18(%ebp)
f0111c8e:	e8 e8 8d 00 00       	call   f011aa7b <strlen>
f0111c93:	83 c4 10             	add    $0x10,%esp
f0111c96:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "helloworld") != 0 || resultLength != strlen(src1))
f0111c99:	83 ec 08             	sub    $0x8,%esp
f0111c9c:	68 1e 26 13 f0       	push   $0xf013261e
f0111ca1:	ff 75 e8             	pushl  -0x18(%ebp)
f0111ca4:	e8 de 8e 00 00       	call   f011ab87 <strcmp>
f0111ca9:	83 c4 10             	add    $0x10,%esp
f0111cac:	85 c0                	test   %eax,%eax
f0111cae:	75 13                	jne    f0111cc3 <test_str2lower_function+0x91>
f0111cb0:	83 ec 0c             	sub    $0xc,%esp
f0111cb3:	ff 75 ec             	pushl  -0x14(%ebp)
f0111cb6:	e8 c0 8d 00 00       	call   f011aa7b <strlen>
f0111cbb:	83 c4 10             	add    $0x10,%esp
f0111cbe:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111cc1:	74 15                	je     f0111cd8 <test_str2lower_function+0xa6>
		cprintf("str2lower #1: WRONG - str2lower return wrong value or length. Expected \"helloworld\", Actual \"%s\"\n", result);
f0111cc3:	83 ec 08             	sub    $0x8,%esp
f0111cc6:	ff 75 e8             	pushl  -0x18(%ebp)
f0111cc9:	68 2c 26 13 f0       	push   $0xf013262c
f0111cce:	e8 89 fe fe ff       	call   f0101b5c <cprintf>
f0111cd3:	83 c4 10             	add    $0x10,%esp
f0111cd6:	eb 04                	jmp    f0111cdc <test_str2lower_function+0xaa>
	else
		eval += 10;
f0111cd8:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE2: input string is empty
	const char *src2 = "";
f0111cdc:	c7 45 e0 8e 26 13 f0 	movl   $0xf013268e,-0x20(%ebp)
	char dst2[100];
	result = str2lower(dst2, src2);
f0111ce3:	83 ec 08             	sub    $0x8,%esp
f0111ce6:	ff 75 e0             	pushl  -0x20(%ebp)
f0111ce9:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111cef:	50                   	push   %eax
f0111cf0:	e8 1e 95 00 00       	call   f011b213 <str2lower>
f0111cf5:	83 c4 10             	add    $0x10,%esp
f0111cf8:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111cfb:	83 ec 0c             	sub    $0xc,%esp
f0111cfe:	ff 75 e8             	pushl  -0x18(%ebp)
f0111d01:	e8 75 8d 00 00       	call   f011aa7b <strlen>
f0111d06:	83 c4 10             	add    $0x10,%esp
f0111d09:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "") != 0 || resultLength != strlen(src2))
f0111d0c:	83 ec 08             	sub    $0x8,%esp
f0111d0f:	68 8e 26 13 f0       	push   $0xf013268e
f0111d14:	ff 75 e8             	pushl  -0x18(%ebp)
f0111d17:	e8 6b 8e 00 00       	call   f011ab87 <strcmp>
f0111d1c:	83 c4 10             	add    $0x10,%esp
f0111d1f:	85 c0                	test   %eax,%eax
f0111d21:	75 13                	jne    f0111d36 <test_str2lower_function+0x104>
f0111d23:	83 ec 0c             	sub    $0xc,%esp
f0111d26:	ff 75 e0             	pushl  -0x20(%ebp)
f0111d29:	e8 4d 8d 00 00       	call   f011aa7b <strlen>
f0111d2e:	83 c4 10             	add    $0x10,%esp
f0111d31:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111d34:	74 15                	je     f0111d4b <test_str2lower_function+0x119>
		cprintf("str2lower #2: WRONG - str2lower return wrong value or length. Expected \"\", Actual \"%s\"\n", result);
f0111d36:	83 ec 08             	sub    $0x8,%esp
f0111d39:	ff 75 e8             	pushl  -0x18(%ebp)
f0111d3c:	68 90 26 13 f0       	push   $0xf0132690
f0111d41:	e8 16 fe fe ff       	call   f0101b5c <cprintf>
f0111d46:	83 c4 10             	add    $0x10,%esp
f0111d49:	eb 04                	jmp    f0111d4f <test_str2lower_function+0x11d>
	else
		eval += 10;
f0111d4b:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE3: input string is Only special characters
	const char *src3 = "!@#$%%^&*()";
f0111d4f:	c7 45 dc e8 26 13 f0 	movl   $0xf01326e8,-0x24(%ebp)
	char dst3[100];
	result = str2lower(dst3, src3);
f0111d56:	83 ec 08             	sub    $0x8,%esp
f0111d59:	ff 75 dc             	pushl  -0x24(%ebp)
f0111d5c:	8d 85 a0 fe ff ff    	lea    -0x160(%ebp),%eax
f0111d62:	50                   	push   %eax
f0111d63:	e8 ab 94 00 00       	call   f011b213 <str2lower>
f0111d68:	83 c4 10             	add    $0x10,%esp
f0111d6b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111d6e:	83 ec 0c             	sub    $0xc,%esp
f0111d71:	ff 75 e8             	pushl  -0x18(%ebp)
f0111d74:	e8 02 8d 00 00       	call   f011aa7b <strlen>
f0111d79:	83 c4 10             	add    $0x10,%esp
f0111d7c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "!@#$%%^&*()") != 0 || resultLength != strlen(src3))
f0111d7f:	83 ec 08             	sub    $0x8,%esp
f0111d82:	68 e8 26 13 f0       	push   $0xf01326e8
f0111d87:	ff 75 e8             	pushl  -0x18(%ebp)
f0111d8a:	e8 f8 8d 00 00       	call   f011ab87 <strcmp>
f0111d8f:	83 c4 10             	add    $0x10,%esp
f0111d92:	85 c0                	test   %eax,%eax
f0111d94:	75 13                	jne    f0111da9 <test_str2lower_function+0x177>
f0111d96:	83 ec 0c             	sub    $0xc,%esp
f0111d99:	ff 75 dc             	pushl  -0x24(%ebp)
f0111d9c:	e8 da 8c 00 00       	call   f011aa7b <strlen>
f0111da1:	83 c4 10             	add    $0x10,%esp
f0111da4:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111da7:	74 15                	je     f0111dbe <test_str2lower_function+0x18c>
		cprintf("str2lower #3: WRONG - str2lower return wrong value or length. Expected \"!@#$%%^&*()\", Actual \"%s\"\n", result);
f0111da9:	83 ec 08             	sub    $0x8,%esp
f0111dac:	ff 75 e8             	pushl  -0x18(%ebp)
f0111daf:	68 f4 26 13 f0       	push   $0xf01326f4
f0111db4:	e8 a3 fd fe ff       	call   f0101b5c <cprintf>
f0111db9:	83 c4 10             	add    $0x10,%esp
f0111dbc:	eb 04                	jmp    f0111dc2 <test_str2lower_function+0x190>
	else
		eval += 15;
f0111dbe:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE4: input string is only numbers
	const char *src4 = "1234567890";
f0111dc2:	c7 45 d8 57 27 13 f0 	movl   $0xf0132757,-0x28(%ebp)
	char dst4[100];
	result = str2lower(dst4, src4);
f0111dc9:	83 ec 08             	sub    $0x8,%esp
f0111dcc:	ff 75 d8             	pushl  -0x28(%ebp)
f0111dcf:	8d 85 3c fe ff ff    	lea    -0x1c4(%ebp),%eax
f0111dd5:	50                   	push   %eax
f0111dd6:	e8 38 94 00 00       	call   f011b213 <str2lower>
f0111ddb:	83 c4 10             	add    $0x10,%esp
f0111dde:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111de1:	83 ec 0c             	sub    $0xc,%esp
f0111de4:	ff 75 e8             	pushl  -0x18(%ebp)
f0111de7:	e8 8f 8c 00 00       	call   f011aa7b <strlen>
f0111dec:	83 c4 10             	add    $0x10,%esp
f0111def:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "1234567890") != 0 || resultLength != strlen(src4))
f0111df2:	83 ec 08             	sub    $0x8,%esp
f0111df5:	68 57 27 13 f0       	push   $0xf0132757
f0111dfa:	ff 75 e8             	pushl  -0x18(%ebp)
f0111dfd:	e8 85 8d 00 00       	call   f011ab87 <strcmp>
f0111e02:	83 c4 10             	add    $0x10,%esp
f0111e05:	85 c0                	test   %eax,%eax
f0111e07:	75 13                	jne    f0111e1c <test_str2lower_function+0x1ea>
f0111e09:	83 ec 0c             	sub    $0xc,%esp
f0111e0c:	ff 75 d8             	pushl  -0x28(%ebp)
f0111e0f:	e8 67 8c 00 00       	call   f011aa7b <strlen>
f0111e14:	83 c4 10             	add    $0x10,%esp
f0111e17:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111e1a:	74 15                	je     f0111e31 <test_str2lower_function+0x1ff>
		cprintf("str2lower #4: WRONG - str2lower return wrong value or length. Expected \"1234567890\", Actual \"%s\"\n", result);
f0111e1c:	83 ec 08             	sub    $0x8,%esp
f0111e1f:	ff 75 e8             	pushl  -0x18(%ebp)
f0111e22:	68 64 27 13 f0       	push   $0xf0132764
f0111e27:	e8 30 fd fe ff       	call   f0101b5c <cprintf>
f0111e2c:	83 c4 10             	add    $0x10,%esp
f0111e2f:	eb 04                	jmp    f0111e35 <test_str2lower_function+0x203>
	else
		eval += 15;
f0111e31:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE5: input string contains invalid characters
	const char *src5 = "Hello!@#$%%^&*()World";
f0111e35:	c7 45 d4 c6 27 13 f0 	movl   $0xf01327c6,-0x2c(%ebp)
	char dst5[100];
	result = str2lower(dst5, src5);
f0111e3c:	83 ec 08             	sub    $0x8,%esp
f0111e3f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111e42:	8d 85 d8 fd ff ff    	lea    -0x228(%ebp),%eax
f0111e48:	50                   	push   %eax
f0111e49:	e8 c5 93 00 00       	call   f011b213 <str2lower>
f0111e4e:	83 c4 10             	add    $0x10,%esp
f0111e51:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111e54:	83 ec 0c             	sub    $0xc,%esp
f0111e57:	ff 75 e8             	pushl  -0x18(%ebp)
f0111e5a:	e8 1c 8c 00 00       	call   f011aa7b <strlen>
f0111e5f:	83 c4 10             	add    $0x10,%esp
f0111e62:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello!@#$%%^&*()world") != 0 || resultLength != strlen(src5))
f0111e65:	83 ec 08             	sub    $0x8,%esp
f0111e68:	68 dc 27 13 f0       	push   $0xf01327dc
f0111e6d:	ff 75 e8             	pushl  -0x18(%ebp)
f0111e70:	e8 12 8d 00 00       	call   f011ab87 <strcmp>
f0111e75:	83 c4 10             	add    $0x10,%esp
f0111e78:	85 c0                	test   %eax,%eax
f0111e7a:	75 13                	jne    f0111e8f <test_str2lower_function+0x25d>
f0111e7c:	83 ec 0c             	sub    $0xc,%esp
f0111e7f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111e82:	e8 f4 8b 00 00       	call   f011aa7b <strlen>
f0111e87:	83 c4 10             	add    $0x10,%esp
f0111e8a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111e8d:	74 15                	je     f0111ea4 <test_str2lower_function+0x272>
		cprintf("str2lower #5: WRONG - str2lower return wrong value or length. Expected \"hello!@#$%%^&*()world\", Actual \"%s\"\n", result);
f0111e8f:	83 ec 08             	sub    $0x8,%esp
f0111e92:	ff 75 e8             	pushl  -0x18(%ebp)
f0111e95:	68 f4 27 13 f0       	push   $0xf01327f4
f0111e9a:	e8 bd fc fe ff       	call   f0101b5c <cprintf>
f0111e9f:	83 c4 10             	add    $0x10,%esp
f0111ea2:	eb 04                	jmp    f0111ea8 <test_str2lower_function+0x276>
	else
		eval += 15;
f0111ea4:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE6: input string contains characters with white-space characters
	const char *src6 = "Hello World";
f0111ea8:	c7 45 d0 61 28 13 f0 	movl   $0xf0132861,-0x30(%ebp)
	char dst6[100];
	result = str2lower(dst6, src6);
f0111eaf:	83 ec 08             	sub    $0x8,%esp
f0111eb2:	ff 75 d0             	pushl  -0x30(%ebp)
f0111eb5:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
f0111ebb:	50                   	push   %eax
f0111ebc:	e8 52 93 00 00       	call   f011b213 <str2lower>
f0111ec1:	83 c4 10             	add    $0x10,%esp
f0111ec4:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111ec7:	83 ec 0c             	sub    $0xc,%esp
f0111eca:	ff 75 e8             	pushl  -0x18(%ebp)
f0111ecd:	e8 a9 8b 00 00       	call   f011aa7b <strlen>
f0111ed2:	83 c4 10             	add    $0x10,%esp
f0111ed5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world") != 0 || resultLength != strlen(src6))
f0111ed8:	83 ec 08             	sub    $0x8,%esp
f0111edb:	68 6d 28 13 f0       	push   $0xf013286d
f0111ee0:	ff 75 e8             	pushl  -0x18(%ebp)
f0111ee3:	e8 9f 8c 00 00       	call   f011ab87 <strcmp>
f0111ee8:	83 c4 10             	add    $0x10,%esp
f0111eeb:	85 c0                	test   %eax,%eax
f0111eed:	75 13                	jne    f0111f02 <test_str2lower_function+0x2d0>
f0111eef:	83 ec 0c             	sub    $0xc,%esp
f0111ef2:	ff 75 d0             	pushl  -0x30(%ebp)
f0111ef5:	e8 81 8b 00 00       	call   f011aa7b <strlen>
f0111efa:	83 c4 10             	add    $0x10,%esp
f0111efd:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111f00:	74 15                	je     f0111f17 <test_str2lower_function+0x2e5>
		cprintf("str2lower #6: WRONG - str2lower return wrong value or length. Expected \"hello world\", Actual \"%s\"\n", result);
f0111f02:	83 ec 08             	sub    $0x8,%esp
f0111f05:	ff 75 e8             	pushl  -0x18(%ebp)
f0111f08:	68 7c 28 13 f0       	push   $0xf013287c
f0111f0d:	e8 4a fc fe ff       	call   f0101b5c <cprintf>
f0111f12:	83 c4 10             	add    $0x10,%esp
f0111f15:	eb 04                	jmp    f0111f1b <test_str2lower_function+0x2e9>
	else
		eval += 15;
f0111f17:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE7: input string contains valid characters separated by _
	const char *src7 = "Hello WORLD String_2_LOWeR";
f0111f1b:	c7 45 cc df 28 13 f0 	movl   $0xf01328df,-0x34(%ebp)
	char dst7[100];
	result = str2lower(dst7, src7);
f0111f22:	83 ec 08             	sub    $0x8,%esp
f0111f25:	ff 75 cc             	pushl  -0x34(%ebp)
f0111f28:	8d 85 10 fd ff ff    	lea    -0x2f0(%ebp),%eax
f0111f2e:	50                   	push   %eax
f0111f2f:	e8 df 92 00 00       	call   f011b213 <str2lower>
f0111f34:	83 c4 10             	add    $0x10,%esp
f0111f37:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111f3a:	83 ec 0c             	sub    $0xc,%esp
f0111f3d:	ff 75 e8             	pushl  -0x18(%ebp)
f0111f40:	e8 36 8b 00 00       	call   f011aa7b <strlen>
f0111f45:	83 c4 10             	add    $0x10,%esp
f0111f48:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world string_2_lower") != 0 || resultLength != strlen(src7))
f0111f4b:	83 ec 08             	sub    $0x8,%esp
f0111f4e:	68 fa 28 13 f0       	push   $0xf01328fa
f0111f53:	ff 75 e8             	pushl  -0x18(%ebp)
f0111f56:	e8 2c 8c 00 00       	call   f011ab87 <strcmp>
f0111f5b:	83 c4 10             	add    $0x10,%esp
f0111f5e:	85 c0                	test   %eax,%eax
f0111f60:	75 13                	jne    f0111f75 <test_str2lower_function+0x343>
f0111f62:	83 ec 0c             	sub    $0xc,%esp
f0111f65:	ff 75 cc             	pushl  -0x34(%ebp)
f0111f68:	e8 0e 8b 00 00       	call   f011aa7b <strlen>
f0111f6d:	83 c4 10             	add    $0x10,%esp
f0111f70:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111f73:	74 15                	je     f0111f8a <test_str2lower_function+0x358>
		cprintf("str2lower #7: WRONG - str2lower return wrong value or length. Expected \"hello world string_2_lower\", Actual \"%s\"\n", result);
f0111f75:	83 ec 08             	sub    $0x8,%esp
f0111f78:	ff 75 e8             	pushl  -0x18(%ebp)
f0111f7b:	68 18 29 13 f0       	push   $0xf0132918
f0111f80:	e8 d7 fb fe ff       	call   f0101b5c <cprintf>
f0111f85:	83 c4 10             	add    $0x10,%esp
f0111f88:	eb 04                	jmp    f0111f8e <test_str2lower_function+0x35c>
	else
		eval += 20;
f0111f8a:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)

	cprintf("Test str2lower completed. Evaluation = %d%%\n", eval);
f0111f8e:	83 ec 08             	sub    $0x8,%esp
f0111f91:	ff 75 f4             	pushl  -0xc(%ebp)
f0111f94:	68 8c 29 13 f0       	push   $0xf013298c
f0111f99:	e8 be fb fe ff       	call   f0101b5c <cprintf>
f0111f9e:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f0111fa1:	83 ec 0c             	sub    $0xc,%esp
f0111fa4:	68 b9 29 13 f0       	push   $0xf01329b9
f0111fa9:	e8 ae fb fe ff       	call   f0101b5c <cprintf>
f0111fae:	83 c4 10             	add    $0x10,%esp
	return 0;
f0111fb1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111fb6:	c9                   	leave  
f0111fb7:	c3                   	ret    

f0111fb8 <test_pt_set_page_permissions>:

//=====================================
// 1) TEST SET/CLEAR PAGE PERMISSIONS:
//=====================================
int test_pt_set_page_permissions()
{
f0111fb8:	55                   	push   %ebp
f0111fb9:	89 e5                	mov    %esp,%ebp
f0111fbb:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check setting a permission
	uint32 va = 0xEF800000;
f0111fbe:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f0111fc5:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f0111fcc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111fd3:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0111fd8:	ff 75 ec             	pushl  -0x14(%ebp)
f0111fdb:	ff 75 f0             	pushl  -0x10(%ebp)
f0111fde:	ff 75 f4             	pushl  -0xc(%ebp)
f0111fe1:	50                   	push   %eax
f0111fe2:	e8 18 7c ff ff       	call   f0109bff <pt_set_page_permissions>
f0111fe7:	83 c4 10             	add    $0x10,%esp
	int ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111fea:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0111fef:	ff 75 ec             	pushl  -0x14(%ebp)
f0111ff2:	ff 75 f0             	pushl  -0x10(%ebp)
f0111ff5:	ff 75 f4             	pushl  -0xc(%ebp)
f0111ff8:	50                   	push   %eax
f0111ff9:	e8 02 4f 00 00       	call   f0116f00 <CP>
f0111ffe:	83 c4 10             	add    $0x10,%esp
f0112001:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0112004:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0112008:	74 17                	je     f0112021 <test_pt_set_page_permissions+0x69>
	{
		panic("[EVAL] #1 Set Permission Failed.\n");
f011200a:	83 ec 04             	sub    $0x4,%esp
f011200d:	68 d0 29 13 f0       	push   $0xf01329d0
f0112012:	68 2c 01 00 00       	push   $0x12c
f0112017:	68 f2 29 13 f0       	push   $0xf01329f2
f011201c:	e8 8e ee fe ff       	call   f0100eaf <_panic>
	}

	//Case 2: Check setting MORE THAN ONE permission
	va = 0xEF801000;
f0112021:	c7 45 f4 00 10 80 ef 	movl   $0xef801000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER;
f0112028:	c7 45 f0 44 00 00 00 	movl   $0x44,-0x10(%ebp)
	permissions_to_clear = 0;
f011202f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112036:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f011203b:	ff 75 ec             	pushl  -0x14(%ebp)
f011203e:	ff 75 f0             	pushl  -0x10(%ebp)
f0112041:	ff 75 f4             	pushl  -0xc(%ebp)
f0112044:	50                   	push   %eax
f0112045:	e8 b5 7b ff ff       	call   f0109bff <pt_set_page_permissions>
f011204a:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f011204d:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0112052:	ff 75 ec             	pushl  -0x14(%ebp)
f0112055:	ff 75 f0             	pushl  -0x10(%ebp)
f0112058:	ff 75 f4             	pushl  -0xc(%ebp)
f011205b:	50                   	push   %eax
f011205c:	e8 9f 4e 00 00       	call   f0116f00 <CP>
f0112061:	83 c4 10             	add    $0x10,%esp
f0112064:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0112067:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f011206b:	74 17                	je     f0112084 <test_pt_set_page_permissions+0xcc>
	{
		panic("[EVAL] #2 Set Permission Failed.\n");
f011206d:	83 ec 04             	sub    $0x4,%esp
f0112070:	68 10 2a 13 f0       	push   $0xf0132a10
f0112075:	68 38 01 00 00       	push   $0x138
f011207a:	68 f2 29 13 f0       	push   $0xf01329f2
f011207f:	e8 2b ee fe ff       	call   f0100eaf <_panic>
	}

	va = 0xEF800000;
f0112084:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER|PERM_USED|PERM_PRESENT;
f011208b:	c7 45 f0 65 00 00 00 	movl   $0x65,-0x10(%ebp)
	permissions_to_clear = 0;
f0112092:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112099:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f011209e:	ff 75 ec             	pushl  -0x14(%ebp)
f01120a1:	ff 75 f0             	pushl  -0x10(%ebp)
f01120a4:	ff 75 f4             	pushl  -0xc(%ebp)
f01120a7:	50                   	push   %eax
f01120a8:	e8 52 7b ff ff       	call   f0109bff <pt_set_page_permissions>
f01120ad:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01120b0:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01120b5:	ff 75 ec             	pushl  -0x14(%ebp)
f01120b8:	ff 75 f0             	pushl  -0x10(%ebp)
f01120bb:	ff 75 f4             	pushl  -0xc(%ebp)
f01120be:	50                   	push   %eax
f01120bf:	e8 3c 4e 00 00       	call   f0116f00 <CP>
f01120c4:	83 c4 10             	add    $0x10,%esp
f01120c7:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f01120ca:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f01120ce:	74 17                	je     f01120e7 <test_pt_set_page_permissions+0x12f>
	{
		panic("[EVAL] #3 Set Permission Failed.\n");
f01120d0:	83 ec 04             	sub    $0x4,%esp
f01120d3:	68 34 2a 13 f0       	push   $0xf0132a34
f01120d8:	68 43 01 00 00       	push   $0x143
f01120dd:	68 f2 29 13 f0       	push   $0xf01329f2
f01120e2:	e8 c8 ed fe ff       	call   f0100eaf <_panic>
	}

	//Case 3: Check clearing a permission
	va = 0xF0000000;
f01120e7:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	permissions_to_set = 0;
f01120ee:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_PRESENT;
f01120f5:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01120fc:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0112101:	ff 75 ec             	pushl  -0x14(%ebp)
f0112104:	ff 75 f0             	pushl  -0x10(%ebp)
f0112107:	ff 75 f4             	pushl  -0xc(%ebp)
f011210a:	50                   	push   %eax
f011210b:	e8 ef 7a ff ff       	call   f0109bff <pt_set_page_permissions>
f0112110:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112113:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0112118:	ff 75 ec             	pushl  -0x14(%ebp)
f011211b:	ff 75 f0             	pushl  -0x10(%ebp)
f011211e:	ff 75 f4             	pushl  -0xc(%ebp)
f0112121:	50                   	push   %eax
f0112122:	e8 d9 4d 00 00       	call   f0116f00 <CP>
f0112127:	83 c4 10             	add    $0x10,%esp
f011212a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f011212d:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0112131:	74 17                	je     f011214a <test_pt_set_page_permissions+0x192>
	{
		panic("[EVAL] #4 Clear Permission Failed.\n");
f0112133:	83 ec 04             	sub    $0x4,%esp
f0112136:	68 58 2a 13 f0       	push   $0xf0132a58
f011213b:	68 4f 01 00 00       	push   $0x14f
f0112140:	68 f2 29 13 f0       	push   $0xf01329f2
f0112145:	e8 65 ed fe ff       	call   f0100eaf <_panic>
	}

	//Case 4: Check clearing MORE THAN ONE permission
	va = 0xEF800000;
f011214a:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = 0;
f0112151:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_MODIFIED|PERM_USER;
f0112158:	c7 45 ec 44 00 00 00 	movl   $0x44,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f011215f:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0112164:	ff 75 ec             	pushl  -0x14(%ebp)
f0112167:	ff 75 f0             	pushl  -0x10(%ebp)
f011216a:	ff 75 f4             	pushl  -0xc(%ebp)
f011216d:	50                   	push   %eax
f011216e:	e8 8c 7a ff ff       	call   f0109bff <pt_set_page_permissions>
f0112173:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112176:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f011217b:	ff 75 ec             	pushl  -0x14(%ebp)
f011217e:	ff 75 f0             	pushl  -0x10(%ebp)
f0112181:	ff 75 f4             	pushl  -0xc(%ebp)
f0112184:	50                   	push   %eax
f0112185:	e8 76 4d 00 00       	call   f0116f00 <CP>
f011218a:	83 c4 10             	add    $0x10,%esp
f011218d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0112190:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0112194:	74 17                	je     f01121ad <test_pt_set_page_permissions+0x1f5>
	{
		panic("[EVAL] #5 Clear Permission Failed.\n");
f0112196:	83 ec 04             	sub    $0x4,%esp
f0112199:	68 7c 2a 13 f0       	push   $0xf0132a7c
f011219e:	68 5b 01 00 00       	push   $0x15b
f01121a3:	68 f2 29 13 f0       	push   $0xf01329f2
f01121a8:	e8 02 ed fe ff       	call   f0100eaf <_panic>
	}

	//Case 5: Check settiing & clearing MORE THAN ONE permission together
	va = 0xF0001000;
f01121ad:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	permissions_to_set = PERM_USER|PERM_BUFFERED;
f01121b4:	c7 45 f0 04 02 00 00 	movl   $0x204,-0x10(%ebp)
	permissions_to_clear = PERM_WRITEABLE|PERM_USED|PERM_MODIFIED;
f01121bb:	c7 45 ec 62 00 00 00 	movl   $0x62,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01121c2:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01121c7:	ff 75 ec             	pushl  -0x14(%ebp)
f01121ca:	ff 75 f0             	pushl  -0x10(%ebp)
f01121cd:	ff 75 f4             	pushl  -0xc(%ebp)
f01121d0:	50                   	push   %eax
f01121d1:	e8 29 7a ff ff       	call   f0109bff <pt_set_page_permissions>
f01121d6:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01121d9:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01121de:	ff 75 ec             	pushl  -0x14(%ebp)
f01121e1:	ff 75 f0             	pushl  -0x10(%ebp)
f01121e4:	ff 75 f4             	pushl  -0xc(%ebp)
f01121e7:	50                   	push   %eax
f01121e8:	e8 13 4d 00 00       	call   f0116f00 <CP>
f01121ed:	83 c4 10             	add    $0x10,%esp
f01121f0:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f01121f3:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f01121f7:	74 17                	je     f0112210 <test_pt_set_page_permissions+0x258>
	{
		panic("[EVAL] #6 Set & Clear Permission Failed.\n");
f01121f9:	83 ec 04             	sub    $0x4,%esp
f01121fc:	68 a0 2a 13 f0       	push   $0xf0132aa0
f0112201:	68 67 01 00 00       	push   $0x167
f0112206:	68 f2 29 13 f0       	push   $0xf01329f2
f011220b:	e8 9f ec fe ff       	call   f0100eaf <_panic>
	}

	cprintf("Congratulations!! test pt_set&clear_page_permissions completed successfully.\n");
f0112210:	83 ec 0c             	sub    $0xc,%esp
f0112213:	68 cc 2a 13 f0       	push   $0xf0132acc
f0112218:	e8 3f f9 fe ff       	call   f0101b5c <cprintf>
f011221d:	83 c4 10             	add    $0x10,%esp
	return 0;
f0112220:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0112225:	c9                   	leave  
f0112226:	c3                   	ret    

f0112227 <test_pt_set_page_permissions_invalid_va>:

int test_pt_set_page_permissions_invalid_va()
{
f0112227:	55                   	push   %ebp
f0112228:	89 e5                	mov    %esp,%ebp
f011222a:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x0;
f011222d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f0112234:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f011223b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112242:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0112247:	ff 75 ec             	pushl  -0x14(%ebp)
f011224a:	ff 75 f0             	pushl  -0x10(%ebp)
f011224d:	ff 75 f4             	pushl  -0xc(%ebp)
f0112250:	50                   	push   %eax
f0112251:	e8 a9 79 ff ff       	call   f0109bff <pt_set_page_permissions>
f0112256:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling setting permissions of an invalid virtual address with non existing page table.");
f0112259:	83 ec 04             	sub    $0x4,%esp
f011225c:	68 1c 2b 13 f0       	push   $0xf0132b1c
f0112261:	68 74 01 00 00       	push   $0x174
f0112266:	68 f2 29 13 f0       	push   $0xf01329f2
f011226b:	e8 3f ec fe ff       	call   f0100eaf <_panic>

f0112270 <test_pt_get_page_permissions>:

//=====================================
// 2) TEST GET PAGE PERMISSIONS:
//=====================================
int test_pt_get_page_permissions()
{
f0112270:	55                   	push   %ebp
f0112271:	89 e5                	mov    %esp,%ebp
f0112273:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check getting a permission of a non existing VA with NO table
	uint32 va = 0xeebfe000;
f0112276:	c7 45 f4 00 e0 bf ee 	movl   $0xeebfe000,-0xc(%ebp)
	int ret = pt_get_page_permissions(ptr_page_directory, va);
f011227d:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0112282:	83 ec 08             	sub    $0x8,%esp
f0112285:	ff 75 f4             	pushl  -0xc(%ebp)
f0112288:	50                   	push   %eax
f0112289:	e8 36 7a ff ff       	call   f0109cc4 <pt_get_page_permissions>
f011228e:	83 c4 10             	add    $0x10,%esp
f0112291:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != -1)
f0112294:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
f0112298:	74 17                	je     f01122b1 <test_pt_get_page_permissions+0x41>
	{
		panic("[EVAL] #1 Get Permission Failed.\n");
f011229a:	83 ec 04             	sub    $0x4,%esp
f011229d:	68 b8 2b 13 f0       	push   $0xf0132bb8
f01122a2:	68 82 01 00 00       	push   $0x182
f01122a7:	68 f2 29 13 f0       	push   $0xf01329f2
f01122ac:	e8 fe eb fe ff       	call   f0100eaf <_panic>
	}

	//Case 2: Check getting a permission of a non existing VA with an existing table
	va = 0xEF800000;
f01122b1:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f01122b8:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01122bd:	83 ec 08             	sub    $0x8,%esp
f01122c0:	ff 75 f4             	pushl  -0xc(%ebp)
f01122c3:	50                   	push   %eax
f01122c4:	e8 fb 79 ff ff       	call   f0109cc4 <pt_get_page_permissions>
f01122c9:	83 c4 10             	add    $0x10,%esp
f01122cc:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 0)
f01122cf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01122d3:	74 17                	je     f01122ec <test_pt_get_page_permissions+0x7c>
	{
		panic("[EVAL] #2 Get Permission Failed.\n");
f01122d5:	83 ec 04             	sub    $0x4,%esp
f01122d8:	68 dc 2b 13 f0       	push   $0xf0132bdc
f01122dd:	68 8a 01 00 00       	push   $0x18a
f01122e2:	68 f2 29 13 f0       	push   $0xf01329f2
f01122e7:	e8 c3 eb fe ff       	call   f0100eaf <_panic>
	}

	//Case 3: Check getting a permission of an existing VA with an existing table
	va = 0xf0000000;
f01122ec:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f01122f3:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01122f8:	83 ec 08             	sub    $0x8,%esp
f01122fb:	ff 75 f4             	pushl  -0xc(%ebp)
f01122fe:	50                   	push   %eax
f01122ff:	e8 c0 79 ff ff       	call   f0109cc4 <pt_get_page_permissions>
f0112304:	83 c4 10             	add    $0x10,%esp
f0112307:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f011230a:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f011230e:	74 17                	je     f0112327 <test_pt_get_page_permissions+0xb7>
	{
		panic("[EVAL] #3 Get Permission Failed.\n");
f0112310:	83 ec 04             	sub    $0x4,%esp
f0112313:	68 00 2c 13 f0       	push   $0xf0132c00
f0112318:	68 92 01 00 00       	push   $0x192
f011231d:	68 f2 29 13 f0       	push   $0xf01329f2
f0112322:	e8 88 eb fe ff       	call   f0100eaf <_panic>
	}

	va = 0xF1000000;
f0112327:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f011232e:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0112333:	83 ec 08             	sub    $0x8,%esp
f0112336:	ff 75 f4             	pushl  -0xc(%ebp)
f0112339:	50                   	push   %eax
f011233a:	e8 85 79 ff ff       	call   f0109cc4 <pt_get_page_permissions>
f011233f:	83 c4 10             	add    $0x10,%esp
f0112342:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f0112345:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0112349:	74 17                	je     f0112362 <test_pt_get_page_permissions+0xf2>
	{
		panic("[EVAL] #4 Get Permission Failed.\n");
f011234b:	83 ec 04             	sub    $0x4,%esp
f011234e:	68 24 2c 13 f0       	push   $0xf0132c24
f0112353:	68 99 01 00 00       	push   $0x199
f0112358:	68 f2 29 13 f0       	push   $0xf01329f2
f011235d:	e8 4d eb fe ff       	call   f0100eaf <_panic>
	}

	va = 0xF0001000;
f0112362:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0112369:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f011236e:	83 ec 08             	sub    $0x8,%esp
f0112371:	ff 75 f4             	pushl  -0xc(%ebp)
f0112374:	50                   	push   %eax
f0112375:	e8 4a 79 ff ff       	call   f0109cc4 <pt_get_page_permissions>
f011237a:	83 c4 10             	add    $0x10,%esp
f011237d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 99)
f0112380:	83 7d f0 63          	cmpl   $0x63,-0x10(%ebp)
f0112384:	74 17                	je     f011239d <test_pt_get_page_permissions+0x12d>
	{
		panic("[EVAL] #5 Get Permission Failed.\n");
f0112386:	83 ec 04             	sub    $0x4,%esp
f0112389:	68 48 2c 13 f0       	push   $0xf0132c48
f011238e:	68 a0 01 00 00       	push   $0x1a0
f0112393:	68 f2 29 13 f0       	push   $0xf01329f2
f0112398:	e8 12 eb fe ff       	call   f0100eaf <_panic>
	}
	cprintf("Congratulations!! test pt_get_page_permissions completed successfully.\n");
f011239d:	83 ec 0c             	sub    $0xc,%esp
f01123a0:	68 6c 2c 13 f0       	push   $0xf0132c6c
f01123a5:	e8 b2 f7 fe ff       	call   f0101b5c <cprintf>
f01123aa:	83 c4 10             	add    $0x10,%esp
	return 0;
f01123ad:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01123b2:	c9                   	leave  
f01123b3:	c3                   	ret    

f01123b4 <test_pt_clear_page_table_entry>:

//=====================================
// 3) TEST CLEAR PAGE TABLE ENTRY:
//=====================================
int test_pt_clear_page_table_entry()
{
f01123b4:	55                   	push   %ebp
f01123b5:	89 e5                	mov    %esp,%ebp
f01123b7:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0xF1000000;
f01123ba:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f01123c1:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01123c6:	83 ec 08             	sub    $0x8,%esp
f01123c9:	ff 75 f4             	pushl  -0xc(%ebp)
f01123cc:	50                   	push   %eax
f01123cd:	e8 0c 79 ff ff       	call   f0109cde <pt_clear_page_table_entry>
f01123d2:	83 c4 10             	add    $0x10,%esp
	int ret = CE(ptr_page_directory, va);
f01123d5:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01123da:	83 ec 08             	sub    $0x8,%esp
f01123dd:	ff 75 f4             	pushl  -0xc(%ebp)
f01123e0:	50                   	push   %eax
f01123e1:	e8 76 4a 00 00       	call   f0116e5c <CE>
f01123e6:	83 c4 10             	add    $0x10,%esp
f01123e9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f01123ec:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01123f0:	74 17                	je     f0112409 <test_pt_clear_page_table_entry+0x55>
	{
		panic("[EVAL] #1 Clear Page Table Entry Failed.\n");
f01123f2:	83 ec 04             	sub    $0x4,%esp
f01123f5:	68 b4 2c 13 f0       	push   $0xf0132cb4
f01123fa:	68 b0 01 00 00       	push   $0x1b0
f01123ff:	68 f2 29 13 f0       	push   $0xf01329f2
f0112404:	e8 a6 ea fe ff       	call   f0100eaf <_panic>
	}

	va = 0xF0001000;
f0112409:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0112410:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0112415:	83 ec 08             	sub    $0x8,%esp
f0112418:	ff 75 f4             	pushl  -0xc(%ebp)
f011241b:	50                   	push   %eax
f011241c:	e8 bd 78 ff ff       	call   f0109cde <pt_clear_page_table_entry>
f0112421:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0112424:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0112429:	83 ec 08             	sub    $0x8,%esp
f011242c:	ff 75 f4             	pushl  -0xc(%ebp)
f011242f:	50                   	push   %eax
f0112430:	e8 27 4a 00 00       	call   f0116e5c <CE>
f0112435:	83 c4 10             	add    $0x10,%esp
f0112438:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f011243b:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f011243f:	74 17                	je     f0112458 <test_pt_clear_page_table_entry+0xa4>
	{
		panic("[EVAL] #2 Clear Page Table Entry Failed.\n");
f0112441:	83 ec 04             	sub    $0x4,%esp
f0112444:	68 e0 2c 13 f0       	push   $0xf0132ce0
f0112449:	68 b8 01 00 00       	push   $0x1b8
f011244e:	68 f2 29 13 f0       	push   $0xf01329f2
f0112453:	e8 57 ea fe ff       	call   f0100eaf <_panic>
	}

	va = 0xEF800000;
f0112458:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f011245f:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0112464:	83 ec 08             	sub    $0x8,%esp
f0112467:	ff 75 f4             	pushl  -0xc(%ebp)
f011246a:	50                   	push   %eax
f011246b:	e8 6e 78 ff ff       	call   f0109cde <pt_clear_page_table_entry>
f0112470:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0112473:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0112478:	83 ec 08             	sub    $0x8,%esp
f011247b:	ff 75 f4             	pushl  -0xc(%ebp)
f011247e:	50                   	push   %eax
f011247f:	e8 d8 49 00 00       	call   f0116e5c <CE>
f0112484:	83 c4 10             	add    $0x10,%esp
f0112487:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f011248a:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f011248e:	74 17                	je     f01124a7 <test_pt_clear_page_table_entry+0xf3>
	{
		panic("[EVAL] #3 Clear Page Table Entry Failed.\n");
f0112490:	83 ec 04             	sub    $0x4,%esp
f0112493:	68 0c 2d 13 f0       	push   $0xf0132d0c
f0112498:	68 c0 01 00 00       	push   $0x1c0
f011249d:	68 f2 29 13 f0       	push   $0xf01329f2
f01124a2:	e8 08 ea fe ff       	call   f0100eaf <_panic>
	}

	va = 0xF0000000;
f01124a7:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f01124ae:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01124b3:	83 ec 08             	sub    $0x8,%esp
f01124b6:	ff 75 f4             	pushl  -0xc(%ebp)
f01124b9:	50                   	push   %eax
f01124ba:	e8 1f 78 ff ff       	call   f0109cde <pt_clear_page_table_entry>
f01124bf:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f01124c2:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01124c7:	83 ec 08             	sub    $0x8,%esp
f01124ca:	ff 75 f4             	pushl  -0xc(%ebp)
f01124cd:	50                   	push   %eax
f01124ce:	e8 89 49 00 00       	call   f0116e5c <CE>
f01124d3:	83 c4 10             	add    $0x10,%esp
f01124d6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f01124d9:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01124dd:	74 17                	je     f01124f6 <test_pt_clear_page_table_entry+0x142>
	{
		panic("[EVAL] #4 Clear Page Table Entry Failed.\n");
f01124df:	83 ec 04             	sub    $0x4,%esp
f01124e2:	68 38 2d 13 f0       	push   $0xf0132d38
f01124e7:	68 c8 01 00 00       	push   $0x1c8
f01124ec:	68 f2 29 13 f0       	push   $0xf01329f2
f01124f1:	e8 b9 e9 fe ff       	call   f0100eaf <_panic>
	}

	cprintf("Congratulations!! test pt_clear_page_table_entry completed successfully.\n");
f01124f6:	83 ec 0c             	sub    $0xc,%esp
f01124f9:	68 64 2d 13 f0       	push   $0xf0132d64
f01124fe:	e8 59 f6 fe ff       	call   f0101b5c <cprintf>
f0112503:	83 c4 10             	add    $0x10,%esp
	return 0;
f0112506:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011250b:	c9                   	leave  
f011250c:	c3                   	ret    

f011250d <test_pt_clear_page_table_entry_invalid_va>:

int test_pt_clear_page_table_entry_invalid_va()
{
f011250d:	55                   	push   %ebp
f011250e:	89 e5                	mov    %esp,%ebp
f0112510:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x1000;
f0112513:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f011251a:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f011251f:	83 ec 08             	sub    $0x8,%esp
f0112522:	ff 75 f4             	pushl  -0xc(%ebp)
f0112525:	50                   	push   %eax
f0112526:	e8 b3 77 ff ff       	call   f0109cde <pt_clear_page_table_entry>
f011252b:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling clearing the entry of an invalid virtual address non existing page table.");
f011252e:	83 ec 04             	sub    $0x4,%esp
f0112531:	68 b0 2d 13 f0       	push   $0xf0132db0
f0112536:	68 d3 01 00 00       	push   $0x1d3
f011253b:	68 f2 29 13 f0       	push   $0xf01329f2
f0112540:	e8 6a e9 fe ff       	call   f0100eaf <_panic>

f0112545 <test_virtual_to_physical>:

//=====================================
// 4) TEST CONVERTING VA 2 PA:
//=====================================
int test_virtual_to_physical()
{
f0112545:	55                   	push   %ebp
f0112546:	89 e5                	mov    %esp,%ebp
f0112548:	57                   	push   %edi
f0112549:	56                   	push   %esi
f011254a:	53                   	push   %ebx
f011254b:	81 ec ac 01 00 00    	sub    $0x1ac,%esp
	int kilo = 1024 ;
f0112551:	c7 45 e4 00 04 00 00 	movl   $0x400,-0x1c(%ebp)
	int mega = 1024*1024 ;
f0112558:	c7 45 e0 00 00 10 00 	movl   $0x100000,-0x20(%ebp)
	uint32 va;
	ClearUserSpace(ptr_page_directory);
f011255f:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0112564:	83 ec 0c             	sub    $0xc,%esp
f0112567:	50                   	push   %eax
f0112568:	e8 d1 49 00 00       	call   f0116f3e <ClearUserSpace>
f011256d:	83 c4 10             	add    $0x10,%esp

	//============================
	//Case 1: Check getting pa of a va with NO table
	va = 0xeebfe000;
f0112570:	c7 45 dc 00 e0 bf ee 	movl   $0xeebfe000,-0x24(%ebp)
	int pa = virtual_to_physical(ptr_page_directory, va);
f0112577:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f011257c:	83 ec 08             	sub    $0x8,%esp
f011257f:	ff 75 dc             	pushl  -0x24(%ebp)
f0112582:	50                   	push   %eax
f0112583:	e8 70 77 ff ff       	call   f0109cf8 <virtual_to_physical>
f0112588:	83 c4 10             	add    $0x10,%esp
f011258b:	89 45 d8             	mov    %eax,-0x28(%ebp)

	//cprintf("va = %x, pa = %x, ret pa = %d\n", va, CA(ptr_page_directory, va), pa);
	if(pa != -1)
f011258e:	83 7d d8 ff          	cmpl   $0xffffffff,-0x28(%ebp)
f0112592:	74 17                	je     f01125ab <test_virtual_to_physical+0x66>
		panic("[EVAL] #1 Test of virtual_to_physical Entry Failed.\n");
f0112594:	83 ec 04             	sub    $0x4,%esp
f0112597:	68 48 2e 13 f0       	push   $0xf0132e48
f011259c:	68 e8 01 00 00       	push   $0x1e8
f01125a1:	68 f2 29 13 f0       	push   $0xf01329f2
f01125a6:	e8 04 e9 fe ff       	call   f0100eaf <_panic>

	//============================
	//Case 2: Check getting pa of a va with a table
	va = 0xf0000000;
f01125ab:	c7 45 dc 00 00 00 f0 	movl   $0xf0000000,-0x24(%ebp)
	pa = virtual_to_physical(ptr_page_directory, va);
f01125b2:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01125b7:	83 ec 08             	sub    $0x8,%esp
f01125ba:	ff 75 dc             	pushl  -0x24(%ebp)
f01125bd:	50                   	push   %eax
f01125be:	e8 35 77 ff ff       	call   f0109cf8 <virtual_to_physical>
f01125c3:	83 c4 10             	add    $0x10,%esp
f01125c6:	89 45 d8             	mov    %eax,-0x28(%ebp)

	//cprintf("va = %x, pa = %x, ret pa = %x\n", va, CA(ptr_page_directory, va), pa);
	if(pa != CA(ptr_page_directory, va))
f01125c9:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01125ce:	83 ec 08             	sub    $0x8,%esp
f01125d1:	ff 75 dc             	pushl  -0x24(%ebp)
f01125d4:	50                   	push   %eax
f01125d5:	e8 63 48 00 00       	call   f0116e3d <CA>
f01125da:	83 c4 10             	add    $0x10,%esp
f01125dd:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f01125e0:	74 17                	je     f01125f9 <test_virtual_to_physical+0xb4>
		panic("[EVAL] #2 Test of virtual_to_physical Entry Failed.\n");
f01125e2:	83 ec 04             	sub    $0x4,%esp
f01125e5:	68 80 2e 13 f0       	push   $0xf0132e80
f01125ea:	68 f1 01 00 00       	push   $0x1f1
f01125ef:	68 f2 29 13 f0       	push   $0xf01329f2
f01125f4:	e8 b6 e8 fe ff       	call   f0100eaf <_panic>

	//============================
	char ap1[100] = "ap 0x2800000";execute_command(ap1);
f01125f9:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f01125ff:	bb 4c 30 13 f0       	mov    $0xf013304c,%ebx
f0112604:	ba 0d 00 00 00       	mov    $0xd,%edx
f0112609:	89 c7                	mov    %eax,%edi
f011260b:	89 de                	mov    %ebx,%esi
f011260d:	89 d1                	mov    %edx,%ecx
f011260f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112611:	8d 55 81             	lea    -0x7f(%ebp),%edx
f0112614:	b9 57 00 00 00       	mov    $0x57,%ecx
f0112619:	b0 00                	mov    $0x0,%al
f011261b:	89 d7                	mov    %edx,%edi
f011261d:	f3 aa                	rep stos %al,%es:(%edi)
f011261f:	83 ec 0c             	sub    $0xc,%esp
f0112622:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0112628:	50                   	push   %eax
f0112629:	e8 ed f7 fe ff       	call   f0101e1b <execute_command>
f011262e:	83 c4 10             	add    $0x10,%esp
	va = 0x2800000;
f0112631:	c7 45 dc 00 00 80 02 	movl   $0x2800000,-0x24(%ebp)
	pa = virtual_to_physical(ptr_page_directory, va);
f0112638:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f011263d:	83 ec 08             	sub    $0x8,%esp
f0112640:	ff 75 dc             	pushl  -0x24(%ebp)
f0112643:	50                   	push   %eax
f0112644:	e8 af 76 ff ff       	call   f0109cf8 <virtual_to_physical>
f0112649:	83 c4 10             	add    $0x10,%esp
f011264c:	89 45 d8             	mov    %eax,-0x28(%ebp)

	//cprintf("va = %x, pa = %x, ret pa = %x\n", va, CA(ptr_page_directory, va), pa);
	if(pa != CA(ptr_page_directory, va))
f011264f:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0112654:	83 ec 08             	sub    $0x8,%esp
f0112657:	ff 75 dc             	pushl  -0x24(%ebp)
f011265a:	50                   	push   %eax
f011265b:	e8 dd 47 00 00       	call   f0116e3d <CA>
f0112660:	83 c4 10             	add    $0x10,%esp
f0112663:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f0112666:	74 17                	je     f011267f <test_virtual_to_physical+0x13a>
		panic("[EVAL] #3 Test of virtual_to_physical Entry Failed.\n");
f0112668:	83 ec 04             	sub    $0x4,%esp
f011266b:	68 b8 2e 13 f0       	push   $0xf0132eb8
f0112670:	68 fa 01 00 00       	push   $0x1fa
f0112675:	68 f2 29 13 f0       	push   $0xf01329f2
f011267a:	e8 30 e8 fe ff       	call   f0100eaf <_panic>

	//============================
	char ap2[100] = "ap 0x2801000";execute_command(ap2);
f011267f:	8d 85 10 ff ff ff    	lea    -0xf0(%ebp),%eax
f0112685:	bb b0 30 13 f0       	mov    $0xf01330b0,%ebx
f011268a:	ba 0d 00 00 00       	mov    $0xd,%edx
f011268f:	89 c7                	mov    %eax,%edi
f0112691:	89 de                	mov    %ebx,%esi
f0112693:	89 d1                	mov    %edx,%ecx
f0112695:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112697:	8d 95 1d ff ff ff    	lea    -0xe3(%ebp),%edx
f011269d:	b9 57 00 00 00       	mov    $0x57,%ecx
f01126a2:	b0 00                	mov    $0x0,%al
f01126a4:	89 d7                	mov    %edx,%edi
f01126a6:	f3 aa                	rep stos %al,%es:(%edi)
f01126a8:	83 ec 0c             	sub    $0xc,%esp
f01126ab:	8d 85 10 ff ff ff    	lea    -0xf0(%ebp),%eax
f01126b1:	50                   	push   %eax
f01126b2:	e8 64 f7 fe ff       	call   f0101e1b <execute_command>
f01126b7:	83 c4 10             	add    $0x10,%esp
	va = 0x2801000;
f01126ba:	c7 45 dc 00 10 80 02 	movl   $0x2801000,-0x24(%ebp)
	pa = virtual_to_physical(ptr_page_directory, va);
f01126c1:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01126c6:	83 ec 08             	sub    $0x8,%esp
f01126c9:	ff 75 dc             	pushl  -0x24(%ebp)
f01126cc:	50                   	push   %eax
f01126cd:	e8 26 76 ff ff       	call   f0109cf8 <virtual_to_physical>
f01126d2:	83 c4 10             	add    $0x10,%esp
f01126d5:	89 45 d8             	mov    %eax,-0x28(%ebp)

	//cprintf("va = %x, pa = %x, ret pa = %x\n", va, CA(ptr_page_directory, va), pa);
	if(pa != CA(ptr_page_directory, va))
f01126d8:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01126dd:	83 ec 08             	sub    $0x8,%esp
f01126e0:	ff 75 dc             	pushl  -0x24(%ebp)
f01126e3:	50                   	push   %eax
f01126e4:	e8 54 47 00 00       	call   f0116e3d <CA>
f01126e9:	83 c4 10             	add    $0x10,%esp
f01126ec:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f01126ef:	74 17                	je     f0112708 <test_virtual_to_physical+0x1c3>
		panic("[EVAL] #4 Test of virtual_to_physical Entry Failed.\n");
f01126f1:	83 ec 04             	sub    $0x4,%esp
f01126f4:	68 f0 2e 13 f0       	push   $0xf0132ef0
f01126f9:	68 03 02 00 00       	push   $0x203
f01126fe:	68 f2 29 13 f0       	push   $0xf01329f2
f0112703:	e8 a7 e7 fe ff       	call   f0100eaf <_panic>

	//============================
	char ap3[100] = "ap 0x2802000";execute_command(ap3);
f0112708:	8d 85 ac fe ff ff    	lea    -0x154(%ebp),%eax
f011270e:	bb 14 31 13 f0       	mov    $0xf0133114,%ebx
f0112713:	ba 0d 00 00 00       	mov    $0xd,%edx
f0112718:	89 c7                	mov    %eax,%edi
f011271a:	89 de                	mov    %ebx,%esi
f011271c:	89 d1                	mov    %edx,%ecx
f011271e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112720:	8d 95 b9 fe ff ff    	lea    -0x147(%ebp),%edx
f0112726:	b9 57 00 00 00       	mov    $0x57,%ecx
f011272b:	b0 00                	mov    $0x0,%al
f011272d:	89 d7                	mov    %edx,%edi
f011272f:	f3 aa                	rep stos %al,%es:(%edi)
f0112731:	83 ec 0c             	sub    $0xc,%esp
f0112734:	8d 85 ac fe ff ff    	lea    -0x154(%ebp),%eax
f011273a:	50                   	push   %eax
f011273b:	e8 db f6 fe ff       	call   f0101e1b <execute_command>
f0112740:	83 c4 10             	add    $0x10,%esp
	va = 0x2802000;
f0112743:	c7 45 dc 00 20 80 02 	movl   $0x2802000,-0x24(%ebp)
	pa = virtual_to_physical(ptr_page_directory, va);
f011274a:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f011274f:	83 ec 08             	sub    $0x8,%esp
f0112752:	ff 75 dc             	pushl  -0x24(%ebp)
f0112755:	50                   	push   %eax
f0112756:	e8 9d 75 ff ff       	call   f0109cf8 <virtual_to_physical>
f011275b:	83 c4 10             	add    $0x10,%esp
f011275e:	89 45 d8             	mov    %eax,-0x28(%ebp)

	//cprintf("va = %x, pa = %x, ret pa = %x\n", va, CA(ptr_page_directory, va), pa);
	if(pa != CA(ptr_page_directory, va))
f0112761:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0112766:	83 ec 08             	sub    $0x8,%esp
f0112769:	ff 75 dc             	pushl  -0x24(%ebp)
f011276c:	50                   	push   %eax
f011276d:	e8 cb 46 00 00       	call   f0116e3d <CA>
f0112772:	83 c4 10             	add    $0x10,%esp
f0112775:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f0112778:	74 17                	je     f0112791 <test_virtual_to_physical+0x24c>
		panic("[EVAL] #5 Test of virtual_to_physical Entry Failed.\n");
f011277a:	83 ec 04             	sub    $0x4,%esp
f011277d:	68 28 2f 13 f0       	push   $0xf0132f28
f0112782:	68 0c 02 00 00       	push   $0x20c
f0112787:	68 f2 29 13 f0       	push   $0xf01329f2
f011278c:	e8 1e e7 fe ff       	call   f0100eaf <_panic>

	//============================
	va = 0xF0001000;
f0112791:	c7 45 dc 00 10 00 f0 	movl   $0xf0001000,-0x24(%ebp)
	pa = virtual_to_physical(ptr_page_directory, va);
f0112798:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f011279d:	83 ec 08             	sub    $0x8,%esp
f01127a0:	ff 75 dc             	pushl  -0x24(%ebp)
f01127a3:	50                   	push   %eax
f01127a4:	e8 4f 75 ff ff       	call   f0109cf8 <virtual_to_physical>
f01127a9:	83 c4 10             	add    $0x10,%esp
f01127ac:	89 45 d8             	mov    %eax,-0x28(%ebp)

	//cprintf("va = %x, pa = %x, ret pa = %x\n", va, CA(ptr_page_directory, va), pa);
	if(pa != CA(ptr_page_directory, va))
f01127af:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01127b4:	83 ec 08             	sub    $0x8,%esp
f01127b7:	ff 75 dc             	pushl  -0x24(%ebp)
f01127ba:	50                   	push   %eax
f01127bb:	e8 7d 46 00 00       	call   f0116e3d <CA>
f01127c0:	83 c4 10             	add    $0x10,%esp
f01127c3:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f01127c6:	74 17                	je     f01127df <test_virtual_to_physical+0x29a>
		panic("[EVAL] #6 Test of virtual_to_physical Entry Failed.\n");
f01127c8:	83 ec 04             	sub    $0x4,%esp
f01127cb:	68 60 2f 13 f0       	push   $0xf0132f60
f01127d0:	68 14 02 00 00       	push   $0x214
f01127d5:	68 f2 29 13 f0       	push   $0xf01329f2
f01127da:	e8 d0 e6 fe ff       	call   f0100eaf <_panic>

	//============================
	va = 0xF0001005;
f01127df:	c7 45 dc 05 10 00 f0 	movl   $0xf0001005,-0x24(%ebp)
	pa = virtual_to_physical(ptr_page_directory, va);
f01127e6:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01127eb:	83 ec 08             	sub    $0x8,%esp
f01127ee:	ff 75 dc             	pushl  -0x24(%ebp)
f01127f1:	50                   	push   %eax
f01127f2:	e8 01 75 ff ff       	call   f0109cf8 <virtual_to_physical>
f01127f7:	83 c4 10             	add    $0x10,%esp
f01127fa:	89 45 d8             	mov    %eax,-0x28(%ebp)

	//cprintf("va = %x, pa = %x, ret pa = %x\n", va, CA(ptr_page_directory, va), pa);
	if(pa != CA(ptr_page_directory, va))
f01127fd:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0112802:	83 ec 08             	sub    $0x8,%esp
f0112805:	ff 75 dc             	pushl  -0x24(%ebp)
f0112808:	50                   	push   %eax
f0112809:	e8 2f 46 00 00       	call   f0116e3d <CA>
f011280e:	83 c4 10             	add    $0x10,%esp
f0112811:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f0112814:	74 17                	je     f011282d <test_virtual_to_physical+0x2e8>
		panic("[EVAL] #7 Test of virtual_to_physical Entry Failed.\n");
f0112816:	83 ec 04             	sub    $0x4,%esp
f0112819:	68 98 2f 13 f0       	push   $0xf0132f98
f011281e:	68 1c 02 00 00       	push   $0x21c
f0112823:	68 f2 29 13 f0       	push   $0xf01329f2
f0112828:	e8 82 e6 fe ff       	call   f0100eaf <_panic>

	//============================
	char ap4[100] = "ap 0xeebfe000";execute_command(ap4);
f011282d:	8d 85 48 fe ff ff    	lea    -0x1b8(%ebp),%eax
f0112833:	bb 78 31 13 f0       	mov    $0xf0133178,%ebx
f0112838:	ba 0e 00 00 00       	mov    $0xe,%edx
f011283d:	89 c7                	mov    %eax,%edi
f011283f:	89 de                	mov    %ebx,%esi
f0112841:	89 d1                	mov    %edx,%ecx
f0112843:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112845:	8d 95 56 fe ff ff    	lea    -0x1aa(%ebp),%edx
f011284b:	b9 56 00 00 00       	mov    $0x56,%ecx
f0112850:	b0 00                	mov    $0x0,%al
f0112852:	89 d7                	mov    %edx,%edi
f0112854:	f3 aa                	rep stos %al,%es:(%edi)
f0112856:	83 ec 0c             	sub    $0xc,%esp
f0112859:	8d 85 48 fe ff ff    	lea    -0x1b8(%ebp),%eax
f011285f:	50                   	push   %eax
f0112860:	e8 b6 f5 fe ff       	call   f0101e1b <execute_command>
f0112865:	83 c4 10             	add    $0x10,%esp
	va = 0xeebfe000;
f0112868:	c7 45 dc 00 e0 bf ee 	movl   $0xeebfe000,-0x24(%ebp)
	pa = virtual_to_physical(ptr_page_directory, va);
f011286f:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0112874:	83 ec 08             	sub    $0x8,%esp
f0112877:	ff 75 dc             	pushl  -0x24(%ebp)
f011287a:	50                   	push   %eax
f011287b:	e8 78 74 ff ff       	call   f0109cf8 <virtual_to_physical>
f0112880:	83 c4 10             	add    $0x10,%esp
f0112883:	89 45 d8             	mov    %eax,-0x28(%ebp)

	//cprintf("va = %x, pa = %x, ret pa = %x\n", va, CA(ptr_page_directory, va), pa);
	if(pa != CA(ptr_page_directory, va))
f0112886:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f011288b:	83 ec 08             	sub    $0x8,%esp
f011288e:	ff 75 dc             	pushl  -0x24(%ebp)
f0112891:	50                   	push   %eax
f0112892:	e8 a6 45 00 00       	call   f0116e3d <CA>
f0112897:	83 c4 10             	add    $0x10,%esp
f011289a:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011289d:	74 17                	je     f01128b6 <test_virtual_to_physical+0x371>
		panic("[EVAL] #8 Test of virtual_to_physical Entry Failed.\n");
f011289f:	83 ec 04             	sub    $0x4,%esp
f01128a2:	68 d0 2f 13 f0       	push   $0xf0132fd0
f01128a7:	68 25 02 00 00       	push   $0x225
f01128ac:	68 f2 29 13 f0       	push   $0xf01329f2
f01128b1:	e8 f9 e5 fe ff       	call   f0100eaf <_panic>

	//============================
	cprintf("Congratulations!! test virtual_to_physical completed successfully.\n");
f01128b6:	83 ec 0c             	sub    $0xc,%esp
f01128b9:	68 08 30 13 f0       	push   $0xf0133008
f01128be:	e8 99 f2 fe ff       	call   f0101b5c <cprintf>
f01128c3:	83 c4 10             	add    $0x10,%esp

	return 0;
f01128c6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01128cb:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01128ce:	5b                   	pop    %ebx
f01128cf:	5e                   	pop    %esi
f01128d0:	5f                   	pop    %edi
f01128d1:	5d                   	pop    %ebp
f01128d2:	c3                   	ret    

f01128d3 <test_cut_paste_pages>:

//===============================
// 1) TEST CUT-PASTE PAGES:
//===============================
int test_cut_paste_pages()
{
f01128d3:	55                   	push   %ebp
f01128d4:	89 e5                	mov    %esp,%ebp
f01128d6:	57                   	push   %edi
f01128d7:	56                   	push   %esi
f01128d8:	53                   	push   %ebx
f01128d9:	81 ec ec 03 00 00    	sub    $0x3ec,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f01128df:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f01128e5:	bb 8c 34 13 f0       	mov    $0xf013348c,%ebx
f01128ea:	ba 0f 00 00 00       	mov    $0xf,%edx
f01128ef:	89 c7                	mov    %eax,%edi
f01128f1:	89 de                	mov    %ebx,%esi
f01128f3:	89 d1                	mov    %edx,%ecx
f01128f5:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01128f7:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f01128fd:	b9 23 00 00 00       	mov    $0x23,%ecx
f0112902:	b0 00                	mov    $0x0,%al
f0112904:	89 d7                	mov    %edx,%edi
f0112906:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0112908:	6a 00                	push   $0x0
f011290a:	6a 0a                	push   $0xa
f011290c:	6a 14                	push   $0x14
f011290e:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0112914:	50                   	push   %eax
f0112915:	e8 47 85 ff ff       	call   f010ae61 <env_create>
f011291a:	83 c4 10             	add    $0x10,%esp
f011291d:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0112920:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112923:	8b 40 64             	mov    0x64(%eax),%eax
f0112926:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f0112929:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011292c:	8b 40 68             	mov    0x68(%eax),%eax
f011292f:	89 45 90             	mov    %eax,-0x70(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0112932:	8b 45 90             	mov    -0x70(%ebp),%eax
f0112935:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0112938:	c7 85 4a ff ff ff 61 	movl   $0x20707561,-0xb6(%ebp)
f011293f:	75 70 20 
f0112942:	c7 85 4e ff ff ff 00 	movl   $0x0,-0xb2(%ebp)
f0112949:	00 00 00 
f011294c:	8d 95 52 ff ff ff    	lea    -0xae(%ebp),%edx
f0112952:	b9 03 00 00 00       	mov    $0x3,%ecx
f0112957:	b8 00 00 00 00       	mov    $0x0,%eax
f011295c:	89 d7                	mov    %edx,%edi
f011295e:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0112960:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112963:	8b 40 10             	mov    0x10(%eax),%eax
f0112966:	83 ec 08             	sub    $0x8,%esp
f0112969:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f011296f:	52                   	push   %edx
f0112970:	50                   	push   %eax
f0112971:	e8 5a 86 00 00       	call   f011afd0 <ltostr>
f0112976:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0112979:	83 ec 04             	sub    $0x4,%esp
f011297c:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112982:	50                   	push   %eax
f0112983:	8d 85 36 ff ff ff    	lea    -0xca(%ebp),%eax
f0112989:	50                   	push   %eax
f011298a:	8d 85 4a ff ff ff    	lea    -0xb6(%ebp),%eax
f0112990:	50                   	push   %eax
f0112991:	e8 13 87 00 00       	call   f011b0a9 <strcconcat>
f0112996:	83 c4 10             	add    $0x10,%esp
	//===================================================
	int numOfArgs = 0;
f0112999:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6;
	int kilo = 1024 ;
f01129a0:	c7 45 c8 00 04 00 00 	movl   $0x400,-0x38(%ebp)
	int mega = 1024*1024 ;
f01129a7:	c7 45 c4 00 00 10 00 	movl   $0x100000,-0x3c(%ebp)

	ClearUserSpace(proc_directory);
f01129ae:	83 ec 0c             	sub    $0xc,%esp
f01129b1:	ff 75 d4             	pushl  -0x2c(%ebp)
f01129b4:	e8 85 45 00 00       	call   f0116f3e <ClearUserSpace>
f01129b9:	83 c4 10             	add    $0x10,%esp

	char ap1[100] ;strcconcat(aup_cmd, " 0x2800000", ap1); execute_command(ap1);
f01129bc:	83 ec 04             	sub    $0x4,%esp
f01129bf:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f01129c5:	50                   	push   %eax
f01129c6:	68 dc 31 13 f0       	push   $0xf01331dc
f01129cb:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01129d1:	50                   	push   %eax
f01129d2:	e8 d2 86 00 00       	call   f011b0a9 <strcconcat>
f01129d7:	83 c4 10             	add    $0x10,%esp
f01129da:	83 ec 0c             	sub    $0xc,%esp
f01129dd:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f01129e3:	50                   	push   %eax
f01129e4:	e8 32 f4 fe ff       	call   f0101e1b <execute_command>
f01129e9:	83 c4 10             	add    $0x10,%esp
	char ap2[100] ;strcconcat(aup_cmd, " 0x2801000", ap2); execute_command(ap2);
f01129ec:	83 ec 04             	sub    $0x4,%esp
f01129ef:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f01129f5:	50                   	push   %eax
f01129f6:	68 e7 31 13 f0       	push   $0xf01331e7
f01129fb:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112a01:	50                   	push   %eax
f0112a02:	e8 a2 86 00 00       	call   f011b0a9 <strcconcat>
f0112a07:	83 c4 10             	add    $0x10,%esp
f0112a0a:	83 ec 0c             	sub    $0xc,%esp
f0112a0d:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f0112a13:	50                   	push   %eax
f0112a14:	e8 02 f4 fe ff       	call   f0101e1b <execute_command>
f0112a19:	83 c4 10             	add    $0x10,%esp
	char ap3[100] ;strcconcat(aup_cmd, " 0x2802000", ap3); execute_command(ap3);
f0112a1c:	83 ec 04             	sub    $0x4,%esp
f0112a1f:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f0112a25:	50                   	push   %eax
f0112a26:	68 f2 31 13 f0       	push   $0xf01331f2
f0112a2b:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112a31:	50                   	push   %eax
f0112a32:	e8 72 86 00 00       	call   f011b0a9 <strcconcat>
f0112a37:	83 c4 10             	add    $0x10,%esp
f0112a3a:	83 ec 0c             	sub    $0xc,%esp
f0112a3d:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f0112a43:	50                   	push   %eax
f0112a44:	e8 d2 f3 fe ff       	call   f0101e1b <execute_command>
f0112a49:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x2800000; *ptr1 = 'a';
f0112a4c:	c7 45 c0 00 00 80 02 	movl   $0x2800000,-0x40(%ebp)
f0112a53:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112a56:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x28017FF; *ptr1 = 'b';
f0112a59:	c7 45 c0 ff 17 80 02 	movl   $0x28017ff,-0x40(%ebp)
f0112a60:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112a63:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x2802FFF; *ptr1 = 'c';
f0112a66:	c7 45 c0 ff 2f 80 02 	movl   $0x2802fff,-0x40(%ebp)
f0112a6d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112a70:	c6 00 63             	movb   $0x63,(%eax)

	uint32 perms = GP(proc_directory, (uint32)ptr1);
f0112a73:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112a76:	83 ec 08             	sub    $0x8,%esp
f0112a79:	50                   	push   %eax
f0112a7a:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112a7d:	e8 9d 44 00 00       	call   f0116f1f <GP>
f0112a82:	83 c4 10             	add    $0x10,%esp
f0112a85:	89 45 bc             	mov    %eax,-0x44(%ebp)

	int eval = 0;
f0112a88:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int correct = 1;
f0112a8f:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	int ff1 = sys_calculate_free_frames();
f0112a96:	e8 0d be ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f0112a9b:	89 45 b8             	mov    %eax,-0x48(%ebp)

	/*=============================================*/
	/*PART I: Destination Pages Does NOT Exist 60% */
	/*=============================================*/
	cprintf("CASE I: Destination Pages Does NOT Exist [60%]\n") ;
f0112a9e:	83 ec 0c             	sub    $0xc,%esp
f0112aa1:	68 00 32 13 f0       	push   $0xf0133200
f0112aa6:	e8 b1 f0 fe ff       	call   f0101b5c <cprintf>
f0112aab:	83 c4 10             	add    $0x10,%esp
	int ret = cut_paste_pages(proc_directory, 0x2800000, 0x2900000, 3) ;
f0112aae:	6a 03                	push   $0x3
f0112ab0:	68 00 00 90 02       	push   $0x2900000
f0112ab5:	68 00 00 80 02       	push   $0x2800000
f0112aba:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112abd:	e8 bd 80 ff ff       	call   f010ab7f <cut_paste_pages>
f0112ac2:	83 c4 10             	add    $0x10,%esp
f0112ac5:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	int ff2 = sys_calculate_free_frames();
f0112ac8:	e8 db bd ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f0112acd:	89 45 b0             	mov    %eax,-0x50(%ebp)

	correct = 1 ;
f0112ad0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	if (ret != 0 || ff1 != ff2)
f0112ad7:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f0112adb:	75 08                	jne    f0112ae5 <test_cut_paste_pages+0x212>
f0112add:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112ae0:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0112ae3:	74 2b                	je     f0112b10 <test_cut_paste_pages+0x23d>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112ae5:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112ae8:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112aeb:	83 ec 0c             	sub    $0xc,%esp
f0112aee:	50                   	push   %eax
f0112aef:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112af2:	68 30 32 13 f0       	push   $0xf0133230
f0112af7:	68 63 02 00 00       	push   $0x263
f0112afc:	68 f2 29 13 f0       	push   $0xf01329f2
f0112b01:	e8 4e e5 fe ff       	call   f0101054 <_warn>
f0112b06:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112b09:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 5 ;
f0112b10:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112b14:	74 04                	je     f0112b1a <test_cut_paste_pages+0x247>
f0112b16:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0112b1a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2800000, 0x2900000, 3*PAGE_SIZE, 1, perms, 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f0112b21:	83 ec 08             	sub    $0x8,%esp
f0112b24:	6a 00                	push   $0x0
f0112b26:	6a 01                	push   $0x1
f0112b28:	6a 00                	push   $0x0
f0112b2a:	68 ff 0f 00 00       	push   $0xfff
f0112b2f:	ff 75 bc             	pushl  -0x44(%ebp)
f0112b32:	6a 01                	push   $0x1
f0112b34:	68 00 30 00 00       	push   $0x3000
f0112b39:	68 00 00 90 02       	push   $0x2900000
f0112b3e:	68 00 00 80 02       	push   $0x2800000
f0112b43:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112b46:	e8 27 44 00 00       	call   f0116f72 <CCP>
f0112b4b:	83 c4 30             	add    $0x30,%esp
f0112b4e:	83 f8 01             	cmp    $0x1,%eax
f0112b51:	74 21                	je     f0112b74 <test_cut_paste_pages+0x2a1>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0112b53:	83 ec 04             	sub    $0x4,%esp
f0112b56:	68 84 32 13 f0       	push   $0xf0133284
f0112b5b:	68 6b 02 00 00       	push   $0x26b
f0112b60:	68 f2 29 13 f0       	push   $0xf01329f2
f0112b65:	e8 ea e4 fe ff       	call   f0101054 <_warn>
f0112b6a:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0112b6d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 15 ;
f0112b74:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112b78:	74 04                	je     f0112b7e <test_cut_paste_pages+0x2ab>
f0112b7a:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	correct = 1 ;
f0112b7e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2900000, 0) && CB(proc_directory, 0x2901000, 0) && CB(proc_directory, 0x2902000, 0))
f0112b85:	83 ec 04             	sub    $0x4,%esp
f0112b88:	6a 00                	push   $0x0
f0112b8a:	68 00 00 90 02       	push   $0x2900000
f0112b8f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112b92:	e8 b7 41 00 00       	call   f0116d4e <CB>
f0112b97:	83 c4 10             	add    $0x10,%esp
f0112b9a:	85 c0                	test   %eax,%eax
f0112b9c:	0f 84 f6 00 00 00    	je     f0112c98 <test_cut_paste_pages+0x3c5>
f0112ba2:	83 ec 04             	sub    $0x4,%esp
f0112ba5:	6a 00                	push   $0x0
f0112ba7:	68 00 10 90 02       	push   $0x2901000
f0112bac:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112baf:	e8 9a 41 00 00       	call   f0116d4e <CB>
f0112bb4:	83 c4 10             	add    $0x10,%esp
f0112bb7:	85 c0                	test   %eax,%eax
f0112bb9:	0f 84 d9 00 00 00    	je     f0112c98 <test_cut_paste_pages+0x3c5>
f0112bbf:	83 ec 04             	sub    $0x4,%esp
f0112bc2:	6a 00                	push   $0x0
f0112bc4:	68 00 20 90 02       	push   $0x2902000
f0112bc9:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112bcc:	e8 7d 41 00 00       	call   f0116d4e <CB>
f0112bd1:	83 c4 10             	add    $0x10,%esp
f0112bd4:	85 c0                	test   %eax,%eax
f0112bd6:	0f 84 bc 00 00 00    	je     f0112c98 <test_cut_paste_pages+0x3c5>
	{
		ptr1 = (char*)0x2900000;
f0112bdc:	c7 45 c0 00 00 90 02 	movl   $0x2900000,-0x40(%ebp)
		ptr2 = (char*)0x29017FF;
f0112be3:	c7 45 ac ff 17 90 02 	movl   $0x29017ff,-0x54(%ebp)
		ptr3 = (char*)0x2902FFF;
f0112bea:	c7 45 a8 ff 2f 90 02 	movl   $0x2902fff,-0x58(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'b' || (*ptr3) != 'c')
f0112bf1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112bf4:	8a 00                	mov    (%eax),%al
f0112bf6:	3c 61                	cmp    $0x61,%al
f0112bf8:	75 12                	jne    f0112c0c <test_cut_paste_pages+0x339>
f0112bfa:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112bfd:	8a 00                	mov    (%eax),%al
f0112bff:	3c 62                	cmp    $0x62,%al
f0112c01:	75 09                	jne    f0112c0c <test_cut_paste_pages+0x339>
f0112c03:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112c06:	8a 00                	mov    (%eax),%al
f0112c08:	3c 63                	cmp    $0x63,%al
f0112c0a:	74 21                	je     f0112c2d <test_cut_paste_pages+0x35a>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112c0c:	83 ec 04             	sub    $0x4,%esp
f0112c0f:	68 d0 32 13 f0       	push   $0xf01332d0
f0112c14:	68 78 02 00 00       	push   $0x278
f0112c19:	68 f2 29 13 f0       	push   $0xf01329f2
f0112c1e:	e8 31 e4 fe ff       	call   f0101054 <_warn>
f0112c23:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112c26:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0112c2d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112c31:	74 04                	je     f0112c37 <test_cut_paste_pages+0x364>
f0112c33:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112c37:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CB(proc_directory, 0x2901000, 1))
f0112c3e:	83 ec 04             	sub    $0x4,%esp
f0112c41:	6a 01                	push   $0x1
f0112c43:	68 00 10 90 02       	push   $0x2901000
f0112c48:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112c4b:	e8 fe 40 00 00       	call   f0116d4e <CB>
f0112c50:	83 c4 10             	add    $0x10,%esp
f0112c53:	85 c0                	test   %eax,%eax
f0112c55:	74 41                	je     f0112c98 <test_cut_paste_pages+0x3c5>
		{
			*ptr2 = 'y';
f0112c57:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112c5a:	c6 00 79             	movb   $0x79,(%eax)
			if ((*ptr2) != 'y')
f0112c5d:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112c60:	8a 00                	mov    (%eax),%al
f0112c62:	3c 79                	cmp    $0x79,%al
f0112c64:	74 21                	je     f0112c87 <test_cut_paste_pages+0x3b4>
			{
				warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112c66:	83 ec 04             	sub    $0x4,%esp
f0112c69:	68 d0 32 13 f0       	push   $0xf01332d0
f0112c6e:	68 83 02 00 00       	push   $0x283
f0112c73:	68 f2 29 13 f0       	push   $0xf01329f2
f0112c78:	e8 d7 e3 fe ff       	call   f0101054 <_warn>
f0112c7d:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0112c80:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f0112c87:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112c8b:	74 04                	je     f0112c91 <test_cut_paste_pages+0x3be>
f0112c8d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0112c91:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}


	ff1 = ff2 ;
f0112c98:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0112c9b:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x2901000, 0x2BFF000, 2) ;
f0112c9e:	6a 02                	push   $0x2
f0112ca0:	68 00 f0 bf 02       	push   $0x2bff000
f0112ca5:	68 00 10 90 02       	push   $0x2901000
f0112caa:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112cad:	e8 cd 7e ff ff       	call   f010ab7f <cut_paste_pages>
f0112cb2:	83 c4 10             	add    $0x10,%esp
f0112cb5:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0112cb8:	e8 eb bb ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f0112cbd:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != 0 || ff1 - ff2 != 1)
f0112cc0:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f0112cc4:	75 0b                	jne    f0112cd1 <test_cut_paste_pages+0x3fe>
f0112cc6:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112cc9:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112ccc:	83 f8 01             	cmp    $0x1,%eax
f0112ccf:	74 2b                	je     f0112cfc <test_cut_paste_pages+0x429>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112cd1:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112cd4:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112cd7:	83 ec 0c             	sub    $0xc,%esp
f0112cda:	50                   	push   %eax
f0112cdb:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112cde:	68 30 32 13 f0       	push   $0xf0133230
f0112ce3:	68 94 02 00 00       	push   $0x294
f0112ce8:	68 f2 29 13 f0       	push   $0xf01329f2
f0112ced:	e8 62 e3 fe ff       	call   f0101054 <_warn>
f0112cf2:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112cf5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112cfc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112d00:	74 04                	je     f0112d06 <test_cut_paste_pages+0x433>
f0112d02:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112d06:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2901000, 0x2BFF000, 2*PAGE_SIZE, 1, perms , 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f0112d0d:	83 ec 08             	sub    $0x8,%esp
f0112d10:	6a 00                	push   $0x0
f0112d12:	6a 01                	push   $0x1
f0112d14:	6a 00                	push   $0x0
f0112d16:	68 ff 0f 00 00       	push   $0xfff
f0112d1b:	ff 75 bc             	pushl  -0x44(%ebp)
f0112d1e:	6a 01                	push   $0x1
f0112d20:	68 00 20 00 00       	push   $0x2000
f0112d25:	68 00 f0 bf 02       	push   $0x2bff000
f0112d2a:	68 00 10 90 02       	push   $0x2901000
f0112d2f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112d32:	e8 3b 42 00 00       	call   f0116f72 <CCP>
f0112d37:	83 c4 30             	add    $0x30,%esp
f0112d3a:	83 f8 01             	cmp    $0x1,%eax
f0112d3d:	74 21                	je     f0112d60 <test_cut_paste_pages+0x48d>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0112d3f:	83 ec 04             	sub    $0x4,%esp
f0112d42:	68 84 32 13 f0       	push   $0xf0133284
f0112d47:	68 9c 02 00 00       	push   $0x29c
f0112d4c:	68 f2 29 13 f0       	push   $0xf01329f2
f0112d51:	e8 fe e2 fe ff       	call   f0101054 <_warn>
f0112d56:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0112d59:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112d60:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112d64:	74 04                	je     f0112d6a <test_cut_paste_pages+0x497>
f0112d66:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112d6a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2BFF7FF, 0) && CB(proc_directory, 0x2C00FFF, 0))
f0112d71:	83 ec 04             	sub    $0x4,%esp
f0112d74:	6a 00                	push   $0x0
f0112d76:	68 ff f7 bf 02       	push   $0x2bff7ff
f0112d7b:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112d7e:	e8 cb 3f 00 00       	call   f0116d4e <CB>
f0112d83:	83 c4 10             	add    $0x10,%esp
f0112d86:	85 c0                	test   %eax,%eax
f0112d88:	74 6b                	je     f0112df5 <test_cut_paste_pages+0x522>
f0112d8a:	83 ec 04             	sub    $0x4,%esp
f0112d8d:	6a 00                	push   $0x0
f0112d8f:	68 ff 0f c0 02       	push   $0x2c00fff
f0112d94:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112d97:	e8 b2 3f 00 00       	call   f0116d4e <CB>
f0112d9c:	83 c4 10             	add    $0x10,%esp
f0112d9f:	85 c0                	test   %eax,%eax
f0112da1:	74 52                	je     f0112df5 <test_cut_paste_pages+0x522>
	{
		ptr1 = (char*)0x2BFF7FF;
f0112da3:	c7 45 c0 ff f7 bf 02 	movl   $0x2bff7ff,-0x40(%ebp)
		ptr2 = (char*)0x2C00FFF;
f0112daa:	c7 45 ac ff 0f c0 02 	movl   $0x2c00fff,-0x54(%ebp)
		if ((*ptr1) != 'y' || (*ptr2) != 'c')
f0112db1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112db4:	8a 00                	mov    (%eax),%al
f0112db6:	3c 79                	cmp    $0x79,%al
f0112db8:	75 09                	jne    f0112dc3 <test_cut_paste_pages+0x4f0>
f0112dba:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112dbd:	8a 00                	mov    (%eax),%al
f0112dbf:	3c 63                	cmp    $0x63,%al
f0112dc1:	74 21                	je     f0112de4 <test_cut_paste_pages+0x511>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112dc3:	83 ec 04             	sub    $0x4,%esp
f0112dc6:	68 d0 32 13 f0       	push   $0xf01332d0
f0112dcb:	68 a8 02 00 00       	push   $0x2a8
f0112dd0:	68 f2 29 13 f0       	push   $0xf01329f2
f0112dd5:	e8 7a e2 fe ff       	call   f0101054 <_warn>
f0112dda:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112ddd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0112de4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112de8:	74 04                	je     f0112dee <test_cut_paste_pages+0x51b>
f0112dea:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0112dee:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}
	cprintf("CASE I: END\n") ;
f0112df5:	83 ec 0c             	sub    $0xc,%esp
f0112df8:	68 09 33 13 f0       	push   $0xf0133309
f0112dfd:	e8 5a ed fe ff       	call   f0101b5c <cprintf>
f0112e02:	83 c4 10             	add    $0x10,%esp

	/*========================================*/
	/*PART II: Destination Pages Exist 40%	  */
	/*========================================*/
	cprintf("\nCASE II: Destination Pages Exist [40%]\n") ;
f0112e05:	83 ec 0c             	sub    $0xc,%esp
f0112e08:	68 18 33 13 f0       	push   $0xf0133318
f0112e0d:	e8 4a ed fe ff       	call   f0101b5c <cprintf>
f0112e12:	83 c4 10             	add    $0x10,%esp

	char ap4[100] ;strcconcat(aup_cmd, " 0x1400000", ap4); execute_command(ap4);
f0112e15:	83 ec 04             	sub    $0x4,%esp
f0112e18:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f0112e1e:	50                   	push   %eax
f0112e1f:	68 41 33 13 f0       	push   $0xf0133341
f0112e24:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112e2a:	50                   	push   %eax
f0112e2b:	e8 79 82 00 00       	call   f011b0a9 <strcconcat>
f0112e30:	83 c4 10             	add    $0x10,%esp
f0112e33:	83 ec 0c             	sub    $0xc,%esp
f0112e36:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f0112e3c:	50                   	push   %eax
f0112e3d:	e8 d9 ef fe ff       	call   f0101e1b <execute_command>
f0112e42:	83 c4 10             	add    $0x10,%esp
	char ap5[100] ;strcconcat(aup_cmd, " 0x1401000", ap5); execute_command(ap5);
f0112e45:	83 ec 04             	sub    $0x4,%esp
f0112e48:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f0112e4e:	50                   	push   %eax
f0112e4f:	68 4c 33 13 f0       	push   $0xf013334c
f0112e54:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112e5a:	50                   	push   %eax
f0112e5b:	e8 49 82 00 00       	call   f011b0a9 <strcconcat>
f0112e60:	83 c4 10             	add    $0x10,%esp
f0112e63:	83 ec 0c             	sub    $0xc,%esp
f0112e66:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f0112e6c:	50                   	push   %eax
f0112e6d:	e8 a9 ef fe ff       	call   f0101e1b <execute_command>
f0112e72:	83 c4 10             	add    $0x10,%esp
	char ap6[100] ;strcconcat(aup_cmd, " 0x1402000", ap6); execute_command(ap6);
f0112e75:	83 ec 04             	sub    $0x4,%esp
f0112e78:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f0112e7e:	50                   	push   %eax
f0112e7f:	68 57 33 13 f0       	push   $0xf0133357
f0112e84:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112e8a:	50                   	push   %eax
f0112e8b:	e8 19 82 00 00       	call   f011b0a9 <strcconcat>
f0112e90:	83 c4 10             	add    $0x10,%esp
f0112e93:	83 ec 0c             	sub    $0xc,%esp
f0112e96:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f0112e9c:	50                   	push   %eax
f0112e9d:	e8 79 ef fe ff       	call   f0101e1b <execute_command>
f0112ea2:	83 c4 10             	add    $0x10,%esp
	char ap7[100] ;strcconcat(aup_cmd, " 0x1C00000", ap7); execute_command(ap7);
f0112ea5:	83 ec 04             	sub    $0x4,%esp
f0112ea8:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f0112eae:	50                   	push   %eax
f0112eaf:	68 62 33 13 f0       	push   $0xf0133362
f0112eb4:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112eba:	50                   	push   %eax
f0112ebb:	e8 e9 81 00 00       	call   f011b0a9 <strcconcat>
f0112ec0:	83 c4 10             	add    $0x10,%esp
f0112ec3:	83 ec 0c             	sub    $0xc,%esp
f0112ec6:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f0112ecc:	50                   	push   %eax
f0112ecd:	e8 49 ef fe ff       	call   f0101e1b <execute_command>
f0112ed2:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x1400000; *ptr1 = 'a';
f0112ed5:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
f0112edc:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112edf:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x14007FF; *ptr1 = 'b';
f0112ee2:	c7 45 c0 ff 07 40 01 	movl   $0x14007ff,-0x40(%ebp)
f0112ee9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112eec:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x1400FFF; *ptr1 = 'c';
f0112eef:	c7 45 c0 ff 0f 40 01 	movl   $0x1400fff,-0x40(%ebp)
f0112ef6:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112ef9:	c6 00 63             	movb   $0x63,(%eax)
	ptr1 = (char*)0x1C00000; *ptr1 = 'x';
f0112efc:	c7 45 c0 00 00 c0 01 	movl   $0x1c00000,-0x40(%ebp)
f0112f03:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112f06:	c6 00 78             	movb   $0x78,(%eax)
	ptr1 = (char*)0x1C007FF; *ptr1 = 'y';
f0112f09:	c7 45 c0 ff 07 c0 01 	movl   $0x1c007ff,-0x40(%ebp)
f0112f10:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112f13:	c6 00 79             	movb   $0x79,(%eax)
	ptr1 = (char*)0x1C00FFF; *ptr1 = 'z';
f0112f16:	c7 45 c0 ff 0f c0 01 	movl   $0x1c00fff,-0x40(%ebp)
f0112f1d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112f20:	c6 00 7a             	movb   $0x7a,(%eax)
	uint32 srcp = GP(proc_directory, 0x1C00000) ;
f0112f23:	83 ec 08             	sub    $0x8,%esp
f0112f26:	68 00 00 c0 01       	push   $0x1c00000
f0112f2b:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112f2e:	e8 ec 3f 00 00       	call   f0116f1f <GP>
f0112f33:	83 c4 10             	add    $0x10,%esp
f0112f36:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	uint32 dstp = GP(proc_directory, 0x1400000) ;
f0112f39:	83 ec 08             	sub    $0x8,%esp
f0112f3c:	68 00 00 40 01       	push   $0x1400000
f0112f41:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112f44:	e8 d6 3f 00 00       	call   f0116f1f <GP>
f0112f49:	83 c4 10             	add    $0x10,%esp
f0112f4c:	89 45 a0             	mov    %eax,-0x60(%ebp)

	ff1 = sys_calculate_free_frames();
f0112f4f:	e8 54 b9 ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f0112f54:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1C00000, 0x1400000, 1) ;
f0112f57:	6a 01                	push   $0x1
f0112f59:	68 00 00 40 01       	push   $0x1400000
f0112f5e:	68 00 00 c0 01       	push   $0x1c00000
f0112f63:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112f66:	e8 14 7c ff ff       	call   f010ab7f <cut_paste_pages>
f0112f6b:	83 c4 10             	add    $0x10,%esp
f0112f6e:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0112f71:	e8 32 b9 ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f0112f76:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f0112f79:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0112f7d:	75 08                	jne    f0112f87 <test_cut_paste_pages+0x6b4>
f0112f7f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112f82:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0112f85:	74 2b                	je     f0112fb2 <test_cut_paste_pages+0x6df>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112f87:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112f8a:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112f8d:	83 ec 0c             	sub    $0xc,%esp
f0112f90:	50                   	push   %eax
f0112f91:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112f94:	68 70 33 13 f0       	push   $0xf0133370
f0112f99:	68 cb 02 00 00       	push   $0x2cb
f0112f9e:	68 f2 29 13 f0       	push   $0xf01329f2
f0112fa3:	e8 ac e0 fe ff       	call   f0101054 <_warn>
f0112fa8:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112fab:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112fb2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112fb6:	74 04                	je     f0112fbc <test_cut_paste_pages+0x6e9>
f0112fb8:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112fbc:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	int chk_cntnt = 1 ;
f0112fc3:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CCP(proc_directory, 0x1C00000, 0x1400000, 1*PAGE_SIZE, 1, dstp , 0xFFF, srcp, 0xFFF, CHK_CUT_PASTE) != 1)
f0112fca:	83 ec 08             	sub    $0x8,%esp
f0112fcd:	6a 00                	push   $0x0
f0112fcf:	68 ff 0f 00 00       	push   $0xfff
f0112fd4:	ff 75 a4             	pushl  -0x5c(%ebp)
f0112fd7:	68 ff 0f 00 00       	push   $0xfff
f0112fdc:	ff 75 a0             	pushl  -0x60(%ebp)
f0112fdf:	6a 01                	push   $0x1
f0112fe1:	68 00 10 00 00       	push   $0x1000
f0112fe6:	68 00 00 40 01       	push   $0x1400000
f0112feb:	68 00 00 c0 01       	push   $0x1c00000
f0112ff0:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112ff3:	e8 7a 3f 00 00       	call   f0116f72 <CCP>
f0112ff8:	83 c4 30             	add    $0x30,%esp
f0112ffb:	83 f8 01             	cmp    $0x1,%eax
f0112ffe:	74 28                	je     f0113028 <test_cut_paste_pages+0x755>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0113000:	83 ec 04             	sub    $0x4,%esp
f0113003:	68 84 32 13 f0       	push   $0xf0133284
f0113008:	68 d4 02 00 00       	push   $0x2d4
f011300d:	68 f2 29 13 f0       	push   $0xf01329f2
f0113012:	e8 3d e0 fe ff       	call   f0101054 <_warn>
f0113017:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f011301a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f0113021:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0113028:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011302c:	74 04                	je     f0113032 <test_cut_paste_pages+0x75f>
f011302e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0113032:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0113039:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011303d:	0f 84 92 00 00 00    	je     f01130d5 <test_cut_paste_pages+0x802>
	{
		ptr1 = (char*)0x1400000;
f0113043:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f011304a:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f0113051:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f0113058:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f011305f:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0113066:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f011306d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113070:	8a 00                	mov    (%eax),%al
f0113072:	3c 61                	cmp    $0x61,%al
f0113074:	75 2d                	jne    f01130a3 <test_cut_paste_pages+0x7d0>
f0113076:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113079:	8a 00                	mov    (%eax),%al
f011307b:	3c 78                	cmp    $0x78,%al
f011307d:	75 24                	jne    f01130a3 <test_cut_paste_pages+0x7d0>
f011307f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113082:	8a 00                	mov    (%eax),%al
f0113084:	3c 62                	cmp    $0x62,%al
f0113086:	75 1b                	jne    f01130a3 <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0113088:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011308b:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f011308d:	3c 79                	cmp    $0x79,%al
f011308f:	75 12                	jne    f01130a3 <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0113091:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113094:	8a 00                	mov    (%eax),%al
f0113096:	3c 63                	cmp    $0x63,%al
f0113098:	75 09                	jne    f01130a3 <test_cut_paste_pages+0x7d0>
f011309a:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011309d:	8a 00                	mov    (%eax),%al
f011309f:	3c 7a                	cmp    $0x7a,%al
f01130a1:	74 21                	je     f01130c4 <test_cut_paste_pages+0x7f1>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f01130a3:	83 ec 04             	sub    $0x4,%esp
f01130a6:	68 d0 32 13 f0       	push   $0xf01332d0
f01130ab:	68 e6 02 00 00       	push   $0x2e6
f01130b0:	68 f2 29 13 f0       	push   $0xf01329f2
f01130b5:	e8 9a df fe ff       	call   f0101054 <_warn>
f01130ba:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01130bd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01130c4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01130c8:	74 04                	je     f01130ce <test_cut_paste_pages+0x7fb>
f01130ca:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01130ce:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	ff1 = sys_calculate_free_frames();
f01130d5:	e8 ce b7 ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f01130da:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1400000, 0x1BFF000, 3) ;
f01130dd:	6a 03                	push   $0x3
f01130df:	68 00 f0 bf 01       	push   $0x1bff000
f01130e4:	68 00 00 40 01       	push   $0x1400000
f01130e9:	ff 75 d4             	pushl  -0x2c(%ebp)
f01130ec:	e8 8e 7a ff ff       	call   f010ab7f <cut_paste_pages>
f01130f1:	83 c4 10             	add    $0x10,%esp
f01130f4:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f01130f7:	e8 ac b7 ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f01130fc:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f01130ff:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0113103:	75 08                	jne    f011310d <test_cut_paste_pages+0x83a>
f0113105:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113108:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011310b:	74 2b                	je     f0113138 <test_cut_paste_pages+0x865>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f011310d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113110:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0113113:	83 ec 0c             	sub    $0xc,%esp
f0113116:	50                   	push   %eax
f0113117:	ff 75 b4             	pushl  -0x4c(%ebp)
f011311a:	68 70 33 13 f0       	push   $0xf0133370
f011311f:	68 f5 02 00 00       	push   $0x2f5
f0113124:	68 f2 29 13 f0       	push   $0xf01329f2
f0113129:	e8 26 df fe ff       	call   f0101054 <_warn>
f011312e:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0113131:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0113138:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011313c:	74 04                	je     f0113142 <test_cut_paste_pages+0x86f>
f011313e:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0113142:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	chk_cntnt = 1;
f0113149:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f0113150:	83 ec 04             	sub    $0x4,%esp
f0113153:	6a 00                	push   $0x0
f0113155:	68 00 00 40 01       	push   $0x1400000
f011315a:	ff 75 d4             	pushl  -0x2c(%ebp)
f011315d:	e8 ec 3b 00 00       	call   f0116d4e <CB>
f0113162:	83 c4 10             	add    $0x10,%esp
f0113165:	83 f8 01             	cmp    $0x1,%eax
f0113168:	0f 85 80 00 00 00    	jne    f01131ee <test_cut_paste_pages+0x91b>
f011316e:	83 ec 04             	sub    $0x4,%esp
f0113171:	6a 00                	push   $0x0
f0113173:	68 00 10 40 01       	push   $0x1401000
f0113178:	ff 75 d4             	pushl  -0x2c(%ebp)
f011317b:	e8 ce 3b 00 00       	call   f0116d4e <CB>
f0113180:	83 c4 10             	add    $0x10,%esp
f0113183:	83 f8 01             	cmp    $0x1,%eax
f0113186:	75 66                	jne    f01131ee <test_cut_paste_pages+0x91b>
f0113188:	83 ec 04             	sub    $0x4,%esp
f011318b:	6a 00                	push   $0x0
f011318d:	68 00 20 40 01       	push   $0x1402000
f0113192:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113195:	e8 b4 3b 00 00       	call   f0116d4e <CB>
f011319a:	83 c4 10             	add    $0x10,%esp
f011319d:	83 f8 01             	cmp    $0x1,%eax
f01131a0:	75 4c                	jne    f01131ee <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f01131a2:	83 ec 04             	sub    $0x4,%esp
f01131a5:	6a 00                	push   $0x0
f01131a7:	68 00 f0 bf 01       	push   $0x1bff000
f01131ac:	ff 75 d4             	pushl  -0x2c(%ebp)
f01131af:	e8 9a 3b 00 00       	call   f0116d4e <CB>
f01131b4:	83 c4 10             	add    $0x10,%esp
		correct = 0;
	}
	if (correct) eval += 10 ;
	correct = 1 ;
	chk_cntnt = 1;
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f01131b7:	85 c0                	test   %eax,%eax
f01131b9:	75 33                	jne    f01131ee <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f01131bb:	83 ec 04             	sub    $0x4,%esp
f01131be:	6a 00                	push   $0x0
f01131c0:	68 00 00 c0 01       	push   $0x1c00000
f01131c5:	ff 75 d4             	pushl  -0x2c(%ebp)
f01131c8:	e8 81 3b 00 00       	call   f0116d4e <CB>
f01131cd:	83 c4 10             	add    $0x10,%esp
f01131d0:	83 f8 01             	cmp    $0x1,%eax
f01131d3:	75 19                	jne    f01131ee <test_cut_paste_pages+0x91b>
f01131d5:	83 ec 04             	sub    $0x4,%esp
f01131d8:	6a 00                	push   $0x0
f01131da:	68 00 10 c0 01       	push   $0x1c01000
f01131df:	ff 75 d4             	pushl  -0x2c(%ebp)
f01131e2:	e8 67 3b 00 00       	call   f0116d4e <CB>
f01131e7:	83 c4 10             	add    $0x10,%esp
f01131ea:	85 c0                	test   %eax,%eax
f01131ec:	74 28                	je     f0113216 <test_cut_paste_pages+0x943>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions)\n");
f01131ee:	83 ec 04             	sub    $0x4,%esp
f01131f1:	68 d0 33 13 f0       	push   $0xf01333d0
f01131f6:	68 fe 02 00 00       	push   $0x2fe
f01131fb:	68 f2 29 13 f0       	push   $0xf01329f2
f0113200:	e8 4f de fe ff       	call   f0101054 <_warn>
f0113205:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0113208:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f011320f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0113216:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011321a:	74 04                	je     f0113220 <test_cut_paste_pages+0x94d>
f011321c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0113220:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0113227:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011322b:	0f 84 99 00 00 00    	je     f01132ca <test_cut_paste_pages+0x9f7>
	{
		ptr1 = (char*)0x1400000;
f0113231:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f0113238:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f011323f:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f0113246:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f011324d:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0113254:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f011325b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011325e:	8a 00                	mov    (%eax),%al
f0113260:	3c 61                	cmp    $0x61,%al
f0113262:	75 2d                	jne    f0113291 <test_cut_paste_pages+0x9be>
f0113264:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113267:	8a 00                	mov    (%eax),%al
f0113269:	3c 78                	cmp    $0x78,%al
f011326b:	75 24                	jne    f0113291 <test_cut_paste_pages+0x9be>
f011326d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113270:	8a 00                	mov    (%eax),%al
f0113272:	3c 62                	cmp    $0x62,%al
f0113274:	75 1b                	jne    f0113291 <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0113276:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0113279:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f011327b:	3c 79                	cmp    $0x79,%al
f011327d:	75 12                	jne    f0113291 <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f011327f:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113282:	8a 00                	mov    (%eax),%al
f0113284:	3c 63                	cmp    $0x63,%al
f0113286:	75 09                	jne    f0113291 <test_cut_paste_pages+0x9be>
f0113288:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011328b:	8a 00                	mov    (%eax),%al
f011328d:	3c 7a                	cmp    $0x7a,%al
f011328f:	74 28                	je     f01132b9 <test_cut_paste_pages+0x9e6>
		{
			correct = 0;
f0113291:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chk_cntnt = 0;
f0113298:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f011329f:	83 ec 04             	sub    $0x4,%esp
f01132a2:	68 d0 32 13 f0       	push   $0xf01332d0
f01132a7:	68 12 03 00 00       	push   $0x312
f01132ac:	68 f2 29 13 f0       	push   $0xf01329f2
f01132b1:	e8 9e dd fe ff       	call   f0101054 <_warn>
f01132b6:	83 c4 10             	add    $0x10,%esp
		}
		if (correct) eval += 5 ;
f01132b9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01132bd:	74 04                	je     f01132c3 <test_cut_paste_pages+0x9f0>
f01132bf:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01132c3:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	cprintf("CASE II: END\n") ;
f01132ca:	83 ec 0c             	sub    $0xc,%esp
f01132cd:	68 09 34 13 f0       	push   $0xf0133409
f01132d2:	e8 85 e8 fe ff       	call   f0101b5c <cprintf>
f01132d7:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] cut_paste_pages: FINISHED. Evaluation = %d\n", eval);
f01132da:	83 ec 08             	sub    $0x8,%esp
f01132dd:	ff 75 e4             	pushl  -0x1c(%ebp)
f01132e0:	68 18 34 13 f0       	push   $0xf0133418
f01132e5:	e8 72 e8 fe ff       	call   f0101b5c <cprintf>
f01132ea:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01132ed:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01132f1:	75 10                	jne    f0113303 <test_cut_paste_pages+0xa30>
		cprintf("Congratulations!! test cut_paste_pages completed successfully.\n");
f01132f3:	83 ec 0c             	sub    $0xc,%esp
f01132f6:	68 4c 34 13 f0       	push   $0xf013344c
f01132fb:	e8 5c e8 fe ff       	call   f0101b5c <cprintf>
f0113300:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0113303:	a1 e0 6d 85 f0       	mov    0xf0856de0,%eax
f0113308:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011330b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011330e:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0113311:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113316:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0113319:	5b                   	pop    %ebx
f011331a:	5e                   	pop    %esi
f011331b:	5f                   	pop    %edi
f011331c:	5d                   	pop    %ebp
f011331d:	c3                   	ret    

f011331e <test_copy_paste_chunk>:

//===============================
// 2) TEST COPY-PASTE CHUNK:
//===============================
int test_copy_paste_chunk()
{
f011331e:	55                   	push   %ebp
f011331f:	89 e5                	mov    %esp,%ebp
f0113321:	57                   	push   %edi
f0113322:	56                   	push   %esi
f0113323:	53                   	push   %ebx
f0113324:	81 ec ac 05 00 00    	sub    $0x5ac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f011332a:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f0113330:	bb 8c 34 13 f0       	mov    $0xf013348c,%ebx
f0113335:	ba 0f 00 00 00       	mov    $0xf,%edx
f011333a:	89 c7                	mov    %eax,%edi
f011333c:	89 de                	mov    %ebx,%esi
f011333e:	89 d1                	mov    %edx,%ecx
f0113340:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113342:	8d 95 51 ff ff ff    	lea    -0xaf(%ebp),%edx
f0113348:	b9 23 00 00 00       	mov    $0x23,%ecx
f011334d:	b0 00                	mov    $0x0,%al
f011334f:	89 d7                	mov    %edx,%edi
f0113351:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0113353:	6a 00                	push   $0x0
f0113355:	6a 0a                	push   $0xa
f0113357:	6a 14                	push   $0x14
f0113359:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f011335f:	50                   	push   %eax
f0113360:	e8 fc 7a ff ff       	call   f010ae61 <env_create>
f0113365:	83 c4 10             	add    $0x10,%esp
f0113368:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f011336b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011336e:	8b 40 64             	mov    0x64(%eax),%eax
f0113371:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f0113374:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0113377:	8b 40 68             	mov    0x68(%eax),%eax
f011337a:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0113380:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0113386:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0113389:	c7 85 2e ff ff ff 61 	movl   $0x20707561,-0xd2(%ebp)
f0113390:	75 70 20 
f0113393:	c7 85 32 ff ff ff 00 	movl   $0x0,-0xce(%ebp)
f011339a:	00 00 00 
f011339d:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f01133a3:	b9 03 00 00 00       	mov    $0x3,%ecx
f01133a8:	b8 00 00 00 00       	mov    $0x0,%eax
f01133ad:	89 d7                	mov    %edx,%edi
f01133af:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f01133b1:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01133b4:	8b 40 10             	mov    0x10(%eax),%eax
f01133b7:	83 ec 08             	sub    $0x8,%esp
f01133ba:	8d 95 1a ff ff ff    	lea    -0xe6(%ebp),%edx
f01133c0:	52                   	push   %edx
f01133c1:	50                   	push   %eax
f01133c2:	e8 09 7c 00 00       	call   f011afd0 <ltostr>
f01133c7:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f01133ca:	83 ec 04             	sub    $0x4,%esp
f01133cd:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01133d3:	50                   	push   %eax
f01133d4:	8d 85 1a ff ff ff    	lea    -0xe6(%ebp),%eax
f01133da:	50                   	push   %eax
f01133db:	8d 85 2e ff ff ff    	lea    -0xd2(%ebp),%eax
f01133e1:	50                   	push   %eax
f01133e2:	e8 c2 7c 00 00       	call   f011b0a9 <strcconcat>
f01133e7:	83 c4 10             	add    $0x10,%esp
	//===================================================

	ClearUserSpace(proc_directory);
f01133ea:	83 ec 0c             	sub    $0xc,%esp
f01133ed:	ff 75 d4             	pushl  -0x2c(%ebp)
f01133f0:	e8 49 3b 00 00       	call   f0116f3e <ClearUserSpace>
f01133f5:	83 c4 10             	add    $0x10,%esp
	int numOfArgs = 0;
f01133f8:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;
	uint32 res =0;
f01133ff:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint32 eval = 0; int correct = 1 ;
f0113406:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011340d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter ;
	char *ch1, *ch2, *ch3, *ch4, *ch5, *ch6, *ch7,*ch8, *ch9, *ch10, *ch11, *ch12 ;
	char tch[13];
	int kilo = 1024 ;
f0113414:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f011341b:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	/*==================================================*/
	/*PART I: Destination page(s) exist & read only 20% */
	/*==================================================*/
	cprintf("\nCASE I: Destination page(s) exist & read only [20%]\n") ;
f0113422:	83 ec 0c             	sub    $0xc,%esp
f0113425:	68 c0 34 13 f0       	push   $0xf01334c0
f011342a:	e8 2d e7 fe ff       	call   f0101b5c <cprintf>
f011342f:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0113432:	83 ec 04             	sub    $0x4,%esp
f0113435:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f011343b:	50                   	push   %eax
f011343c:	68 f6 34 13 f0       	push   $0xf01334f6
f0113441:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113447:	50                   	push   %eax
f0113448:	e8 5c 7c 00 00       	call   f011b0a9 <strcconcat>
f011344d:	83 c4 10             	add    $0x10,%esp
f0113450:	83 ec 0c             	sub    $0xc,%esp
f0113453:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113459:	50                   	push   %eax
f011345a:	e8 bc e9 fe ff       	call   f0101e1b <execute_command>
f011345f:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x1000", c1); execute_command(c1);
f0113462:	83 ec 04             	sub    $0x4,%esp
f0113465:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f011346b:	50                   	push   %eax
f011346c:	68 fb 34 13 f0       	push   $0xf01334fb
f0113471:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113477:	50                   	push   %eax
f0113478:	e8 2c 7c 00 00       	call   f011b0a9 <strcconcat>
f011347d:	83 c4 10             	add    $0x10,%esp
f0113480:	83 ec 0c             	sub    $0xc,%esp
f0113483:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113489:	50                   	push   %eax
f011348a:	e8 8c e9 fe ff       	call   f0101e1b <execute_command>
f011348f:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x000000 a";execute_command(c2);
f0113492:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0113498:	bb 01 38 13 f0       	mov    $0xf0133801,%ebx
f011349d:	ba 0f 00 00 00       	mov    $0xf,%edx
f01134a2:	89 c7                	mov    %eax,%edi
f01134a4:	89 de                	mov    %ebx,%esi
f01134a6:	89 d1                	mov    %edx,%ecx
f01134a8:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01134aa:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f01134b0:	b9 55 00 00 00       	mov    $0x55,%ecx
f01134b5:	b0 00                	mov    $0x0,%al
f01134b7:	89 d7                	mov    %edx,%edi
f01134b9:	f3 aa                	rep stos %al,%es:(%edi)
f01134bb:	83 ec 0c             	sub    $0xc,%esp
f01134be:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f01134c4:	50                   	push   %eax
f01134c5:	e8 51 e9 fe ff       	call   f0101e1b <execute_command>
f01134ca:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x0007FF b";execute_command(c3);
f01134cd:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f01134d3:	bb 65 38 13 f0       	mov    $0xf0133865,%ebx
f01134d8:	ba 0f 00 00 00       	mov    $0xf,%edx
f01134dd:	89 c7                	mov    %eax,%edi
f01134df:	89 de                	mov    %ebx,%esi
f01134e1:	89 d1                	mov    %edx,%ecx
f01134e3:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01134e5:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f01134eb:	b9 55 00 00 00       	mov    $0x55,%ecx
f01134f0:	b0 00                	mov    $0x0,%al
f01134f2:	89 d7                	mov    %edx,%edi
f01134f4:	f3 aa                	rep stos %al,%es:(%edi)
f01134f6:	83 ec 0c             	sub    $0xc,%esp
f01134f9:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f01134ff:	50                   	push   %eax
f0113500:	e8 16 e9 fe ff       	call   f0101e1b <execute_command>
f0113505:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x000FFF c";execute_command(c4);
f0113508:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f011350e:	bb c9 38 13 f0       	mov    $0xf01338c9,%ebx
f0113513:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113518:	89 c7                	mov    %eax,%edi
f011351a:	89 de                	mov    %ebx,%esi
f011351c:	89 d1                	mov    %edx,%ecx
f011351e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113520:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0113526:	b9 55 00 00 00       	mov    $0x55,%ecx
f011352b:	b0 00                	mov    $0x0,%al
f011352d:	89 d7                	mov    %edx,%edi
f011352f:	f3 aa                	rep stos %al,%es:(%edi)
f0113531:	83 ec 0c             	sub    $0xc,%esp
f0113534:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f011353a:	50                   	push   %eax
f011353b:	e8 db e8 fe ff       	call   f0101e1b <execute_command>
f0113540:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x001000 d";execute_command(c22);
f0113543:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0113549:	bb 2d 39 13 f0       	mov    $0xf013392d,%ebx
f011354e:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113553:	89 c7                	mov    %eax,%edi
f0113555:	89 de                	mov    %ebx,%esi
f0113557:	89 d1                	mov    %edx,%ecx
f0113559:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011355b:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f0113561:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113566:	b0 00                	mov    $0x0,%al
f0113568:	89 d7                	mov    %edx,%edi
f011356a:	f3 aa                	rep stos %al,%es:(%edi)
f011356c:	83 ec 0c             	sub    $0xc,%esp
f011356f:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0113575:	50                   	push   %eax
f0113576:	e8 a0 e8 fe ff       	call   f0101e1b <execute_command>
f011357b:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x0017FF e";execute_command(c23);
f011357e:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0113584:	bb 91 39 13 f0       	mov    $0xf0133991,%ebx
f0113589:	ba 0f 00 00 00       	mov    $0xf,%edx
f011358e:	89 c7                	mov    %eax,%edi
f0113590:	89 de                	mov    %ebx,%esi
f0113592:	89 d1                	mov    %edx,%ecx
f0113594:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113596:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f011359c:	b9 55 00 00 00       	mov    $0x55,%ecx
f01135a1:	b0 00                	mov    $0x0,%al
f01135a3:	89 d7                	mov    %edx,%edi
f01135a5:	f3 aa                	rep stos %al,%es:(%edi)
f01135a7:	83 ec 0c             	sub    $0xc,%esp
f01135aa:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f01135b0:	50                   	push   %eax
f01135b1:	e8 65 e8 fe ff       	call   f0101e1b <execute_command>
f01135b6:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x001FFF f";execute_command(c24);
f01135b9:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f01135bf:	bb f5 39 13 f0       	mov    $0xf01339f5,%ebx
f01135c4:	ba 0f 00 00 00       	mov    $0xf,%edx
f01135c9:	89 c7                	mov    %eax,%edi
f01135cb:	89 de                	mov    %ebx,%esi
f01135cd:	89 d1                	mov    %edx,%ecx
f01135cf:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01135d1:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f01135d7:	b9 55 00 00 00       	mov    $0x55,%ecx
f01135dc:	b0 00                	mov    $0x0,%al
f01135de:	89 d7                	mov    %edx,%edi
f01135e0:	f3 aa                	rep stos %al,%es:(%edi)
f01135e2:	83 ec 0c             	sub    $0xc,%esp
f01135e5:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f01135eb:	50                   	push   %eax
f01135ec:	e8 2a e8 fe ff       	call   f0101e1b <execute_command>
f01135f1:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x100000", c5); execute_command(c5);
f01135f4:	83 ec 04             	sub    $0x4,%esp
f01135f7:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01135fd:	50                   	push   %eax
f01135fe:	68 03 35 13 f0       	push   $0xf0133503
f0113603:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113609:	50                   	push   %eax
f011360a:	e8 9a 7a 00 00       	call   f011b0a9 <strcconcat>
f011360f:	83 c4 10             	add    $0x10,%esp
f0113612:	83 ec 0c             	sub    $0xc,%esp
f0113615:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011361b:	50                   	push   %eax
f011361c:	e8 fa e7 fe ff       	call   f0101e1b <execute_command>
f0113621:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x101000 r", c5); execute_command(c5);
f0113624:	83 ec 04             	sub    $0x4,%esp
f0113627:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011362d:	50                   	push   %eax
f011362e:	68 0d 35 13 f0       	push   $0xf013350d
f0113633:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113639:	50                   	push   %eax
f011363a:	e8 6a 7a 00 00       	call   f011b0a9 <strcconcat>
f011363f:	83 c4 10             	add    $0x10,%esp
f0113642:	83 ec 0c             	sub    $0xc,%esp
f0113645:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011364b:	50                   	push   %eax
f011364c:	e8 ca e7 fe ff       	call   f0101e1b <execute_command>
f0113651:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x100000 x";execute_command(c6);
f0113654:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f011365a:	bb 59 3a 13 f0       	mov    $0xf0133a59,%ebx
f011365f:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113664:	89 c7                	mov    %eax,%edi
f0113666:	89 de                	mov    %ebx,%esi
f0113668:	89 d1                	mov    %edx,%ecx
f011366a:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011366c:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0113672:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113677:	b0 00                	mov    $0x0,%al
f0113679:	89 d7                	mov    %edx,%edi
f011367b:	f3 aa                	rep stos %al,%es:(%edi)
f011367d:	83 ec 0c             	sub    $0xc,%esp
f0113680:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113686:	50                   	push   %eax
f0113687:	e8 8f e7 fe ff       	call   f0101e1b <execute_command>
f011368c:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x1007FF y";execute_command(c7);
f011368f:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113695:	bb bd 3a 13 f0       	mov    $0xf0133abd,%ebx
f011369a:	ba 0f 00 00 00       	mov    $0xf,%edx
f011369f:	89 c7                	mov    %eax,%edi
f01136a1:	89 de                	mov    %ebx,%esi
f01136a3:	89 d1                	mov    %edx,%ecx
f01136a5:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01136a7:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f01136ad:	b9 55 00 00 00       	mov    $0x55,%ecx
f01136b2:	b0 00                	mov    $0x0,%al
f01136b4:	89 d7                	mov    %edx,%edi
f01136b6:	f3 aa                	rep stos %al,%es:(%edi)
f01136b8:	83 ec 0c             	sub    $0xc,%esp
f01136bb:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f01136c1:	50                   	push   %eax
f01136c2:	e8 54 e7 fe ff       	call   f0101e1b <execute_command>
f01136c7:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x100FFF z";execute_command(c8);
f01136ca:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01136d0:	bb 21 3b 13 f0       	mov    $0xf0133b21,%ebx
f01136d5:	ba 0f 00 00 00       	mov    $0xf,%edx
f01136da:	89 c7                	mov    %eax,%edi
f01136dc:	89 de                	mov    %ebx,%esi
f01136de:	89 d1                	mov    %edx,%ecx
f01136e0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01136e2:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f01136e8:	b9 55 00 00 00       	mov    $0x55,%ecx
f01136ed:	b0 00                	mov    $0x0,%al
f01136ef:	89 d7                	mov    %edx,%edi
f01136f1:	f3 aa                	rep stos %al,%es:(%edi)
f01136f3:	83 ec 0c             	sub    $0xc,%esp
f01136f6:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01136fc:	50                   	push   %eax
f01136fd:	e8 19 e7 fe ff       	call   f0101e1b <execute_command>
f0113702:	83 c4 10             	add    $0x10,%esp

		ch1 = (char*)0x000000; ch2 = (char*)0x100000;
f0113705:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f011370c:	c7 45 b8 00 00 10 00 	movl   $0x100000,-0x48(%ebp)
		ch3 = (char*)0x0007FF; ch4 = (char*)0x1007FF;
f0113713:	c7 45 b4 ff 07 00 00 	movl   $0x7ff,-0x4c(%ebp)
f011371a:	c7 45 b0 ff 07 10 00 	movl   $0x1007ff,-0x50(%ebp)
		ch5 = (char*)0x000FFF; ch6 = (char*)0x100FFF;
f0113721:	c7 45 ac ff 0f 00 00 	movl   $0xfff,-0x54(%ebp)
f0113728:	c7 45 a8 ff 0f 10 00 	movl   $0x100fff,-0x58(%ebp)
		ch7 = (char*)0x001000; ch8 = (char*)0x101000;
f011372f:	c7 45 a4 00 10 00 00 	movl   $0x1000,-0x5c(%ebp)
f0113736:	c7 45 a0 00 10 10 00 	movl   $0x101000,-0x60(%ebp)
		ch9 = (char*)0x0017FF; ch10= (char*)0x1017FF;
f011373d:	c7 45 9c ff 17 00 00 	movl   $0x17ff,-0x64(%ebp)
f0113744:	c7 45 98 ff 17 10 00 	movl   $0x1017ff,-0x68(%ebp)
		ch11= (char*)0x001FFF; ch12= (char*)0x101FFF;
f011374b:	c7 45 94 ff 1f 00 00 	movl   $0x1fff,-0x6c(%ebp)
f0113752:	c7 45 90 ff 1f 10 00 	movl   $0x101fff,-0x70(%ebp)

		tch[8] = *ch8 ;tch[10] = *ch10 ;tch[12] = *ch12 ;
f0113759:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011375c:	8a 00                	mov    (%eax),%al
f011375e:	88 85 a3 fe ff ff    	mov    %al,-0x15d(%ebp)
f0113764:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113767:	8a 00                	mov    (%eax),%al
f0113769:	88 85 a5 fe ff ff    	mov    %al,-0x15b(%ebp)
f011376f:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113772:	8a 00                	mov    (%eax),%al
f0113774:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f011377a:	e8 29 b1 ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f011377f:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x0, 0x100000, 6*kilo);
f0113782:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113785:	89 d0                	mov    %edx,%eax
f0113787:	01 c0                	add    %eax,%eax
f0113789:	01 d0                	add    %edx,%eax
f011378b:	01 c0                	add    %eax,%eax
f011378d:	50                   	push   %eax
f011378e:	68 00 00 10 00       	push   $0x100000
f0113793:	6a 00                	push   $0x0
f0113795:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113798:	e8 fc 73 ff ff       	call   f010ab99 <copy_paste_chunk>
f011379d:	83 c4 10             	add    $0x10,%esp
f01137a0:	89 45 88             	mov    %eax,-0x78(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01137a3:	e8 00 b1 ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f01137a8:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f01137ab:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != -1 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f01137b2:	83 7d 88 ff          	cmpl   $0xffffffff,-0x78(%ebp)
f01137b6:	75 08                	jne    f01137c0 <test_copy_paste_chunk+0x4a2>
f01137b8:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01137bb:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f01137be:	74 2b                	je     f01137eb <test_copy_paste_chunk+0x4cd>
		{
			warn("[EVAL] copy_paste_chunk: Failed (dest is read-only... operation should be denied) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01137c0:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01137c3:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01137c6:	83 ec 0c             	sub    $0xc,%esp
f01137c9:	50                   	push   %eax
f01137ca:	ff 75 88             	pushl  -0x78(%ebp)
f01137cd:	68 1c 35 13 f0       	push   $0xf013351c
f01137d2:	68 65 03 00 00       	push   $0x365
f01137d7:	68 f2 29 13 f0       	push   $0xf01329f2
f01137dc:	e8 73 d8 fe ff       	call   f0101054 <_warn>
f01137e1:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01137e4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f01137eb:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01137ef:	74 04                	je     f01137f5 <test_copy_paste_chunk+0x4d7>
f01137f1:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01137f5:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'x' || *ch3 != 'b' || *ch4 != 'y' || *ch5 != 'c' || *ch6 != 'z'
f01137fc:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01137ff:	8a 00                	mov    (%eax),%al
f0113801:	3c 61                	cmp    $0x61,%al
f0113803:	75 75                	jne    f011387a <test_copy_paste_chunk+0x55c>
f0113805:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113808:	8a 00                	mov    (%eax),%al
f011380a:	3c 78                	cmp    $0x78,%al
f011380c:	75 6c                	jne    f011387a <test_copy_paste_chunk+0x55c>
f011380e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113811:	8a 00                	mov    (%eax),%al
f0113813:	3c 62                	cmp    $0x62,%al
f0113815:	75 63                	jne    f011387a <test_copy_paste_chunk+0x55c>
f0113817:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011381a:	8a 00                	mov    (%eax),%al
f011381c:	3c 79                	cmp    $0x79,%al
f011381e:	75 5a                	jne    f011387a <test_copy_paste_chunk+0x55c>
f0113820:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113823:	8a 00                	mov    (%eax),%al
f0113825:	3c 63                	cmp    $0x63,%al
f0113827:	75 51                	jne    f011387a <test_copy_paste_chunk+0x55c>
f0113829:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011382c:	8a 00                	mov    (%eax),%al
f011382e:	3c 7a                	cmp    $0x7a,%al
f0113830:	75 48                	jne    f011387a <test_copy_paste_chunk+0x55c>
				||  *ch7 != 'd' || *ch8 != tch[8] || *ch9 != 'e' || *ch10 != tch[10] || *ch11!= 'f' || *ch12 != tch[12])
f0113832:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113835:	8a 00                	mov    (%eax),%al
f0113837:	3c 64                	cmp    $0x64,%al
f0113839:	75 3f                	jne    f011387a <test_copy_paste_chunk+0x55c>
f011383b:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011383e:	8a 10                	mov    (%eax),%dl
f0113840:	8a 85 a3 fe ff ff    	mov    -0x15d(%ebp),%al
f0113846:	38 c2                	cmp    %al,%dl
f0113848:	75 30                	jne    f011387a <test_copy_paste_chunk+0x55c>
f011384a:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011384d:	8a 00                	mov    (%eax),%al
f011384f:	3c 65                	cmp    $0x65,%al
f0113851:	75 27                	jne    f011387a <test_copy_paste_chunk+0x55c>
f0113853:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113856:	8a 10                	mov    (%eax),%dl
f0113858:	8a 85 a5 fe ff ff    	mov    -0x15b(%ebp),%al
f011385e:	38 c2                	cmp    %al,%dl
f0113860:	75 18                	jne    f011387a <test_copy_paste_chunk+0x55c>
f0113862:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113865:	8a 00                	mov    (%eax),%al
f0113867:	3c 66                	cmp    $0x66,%al
f0113869:	75 0f                	jne    f011387a <test_copy_paste_chunk+0x55c>
f011386b:	8b 45 90             	mov    -0x70(%ebp),%eax
f011386e:	8a 10                	mov    (%eax),%dl
f0113870:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0113876:	38 c2                	cmp    %al,%dl
f0113878:	74 21                	je     f011389b <test_copy_paste_chunk+0x57d>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f011387a:	83 ec 04             	sub    $0x4,%esp
f011387d:	68 80 35 13 f0       	push   $0xf0133580
f0113882:	68 6e 03 00 00       	push   $0x36e
f0113887:	68 f2 29 13 f0       	push   $0xf01329f2
f011388c:	e8 c3 d7 fe ff       	call   f0101054 <_warn>
f0113891:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113894:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f011389b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011389f:	74 04                	je     f01138a5 <test_copy_paste_chunk+0x587>
f01138a1:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01138a5:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE I: END \n") ;
f01138ac:	83 ec 0c             	sub    $0xc,%esp
f01138af:	68 ba 35 13 f0       	push   $0xf01335ba
f01138b4:	e8 a3 e2 fe ff       	call   f0101b5c <cprintf>
f01138b9:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: Destination page(s) exist & writable 40% */
	/*==================================================*/
	cprintf("\nCASE II: Destination page(s) exist & writable [40%]\n") ;
f01138bc:	83 ec 0c             	sub    $0xc,%esp
f01138bf:	68 cc 35 13 f0       	push   $0xf01335cc
f01138c4:	e8 93 e2 fe ff       	call   f0101b5c <cprintf>
f01138c9:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x200000", c1); execute_command(c1);
f01138cc:	83 ec 04             	sub    $0x4,%esp
f01138cf:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01138d5:	50                   	push   %eax
f01138d6:	68 02 36 13 f0       	push   $0xf0133602
f01138db:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01138e1:	50                   	push   %eax
f01138e2:	e8 c2 77 00 00       	call   f011b0a9 <strcconcat>
f01138e7:	83 c4 10             	add    $0x10,%esp
f01138ea:	83 ec 0c             	sub    $0xc,%esp
f01138ed:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01138f3:	50                   	push   %eax
f01138f4:	e8 22 e5 fe ff       	call   f0101e1b <execute_command>
f01138f9:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x201000", c1); execute_command(c1);
f01138fc:	83 ec 04             	sub    $0x4,%esp
f01138ff:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113905:	50                   	push   %eax
f0113906:	68 0c 36 13 f0       	push   $0xf013360c
f011390b:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113911:	50                   	push   %eax
f0113912:	e8 92 77 00 00       	call   f011b0a9 <strcconcat>
f0113917:	83 c4 10             	add    $0x10,%esp
f011391a:	83 ec 0c             	sub    $0xc,%esp
f011391d:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113923:	50                   	push   %eax
f0113924:	e8 f2 e4 fe ff       	call   f0101e1b <execute_command>
f0113929:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x200000 a";execute_command(c2);
f011392c:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0113932:	bb 85 3b 13 f0       	mov    $0xf0133b85,%ebx
f0113937:	ba 0f 00 00 00       	mov    $0xf,%edx
f011393c:	89 c7                	mov    %eax,%edi
f011393e:	89 de                	mov    %ebx,%esi
f0113940:	89 d1                	mov    %edx,%ecx
f0113942:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113944:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f011394a:	b9 55 00 00 00       	mov    $0x55,%ecx
f011394f:	b0 00                	mov    $0x0,%al
f0113951:	89 d7                	mov    %edx,%edi
f0113953:	f3 aa                	rep stos %al,%es:(%edi)
f0113955:	83 ec 0c             	sub    $0xc,%esp
f0113958:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f011395e:	50                   	push   %eax
f011395f:	e8 b7 e4 fe ff       	call   f0101e1b <execute_command>
f0113964:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x2007FF b";execute_command(c3);
f0113967:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f011396d:	bb e9 3b 13 f0       	mov    $0xf0133be9,%ebx
f0113972:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113977:	89 c7                	mov    %eax,%edi
f0113979:	89 de                	mov    %ebx,%esi
f011397b:	89 d1                	mov    %edx,%ecx
f011397d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011397f:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f0113985:	b9 55 00 00 00       	mov    $0x55,%ecx
f011398a:	b0 00                	mov    $0x0,%al
f011398c:	89 d7                	mov    %edx,%edi
f011398e:	f3 aa                	rep stos %al,%es:(%edi)
f0113990:	83 ec 0c             	sub    $0xc,%esp
f0113993:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0113999:	50                   	push   %eax
f011399a:	e8 7c e4 fe ff       	call   f0101e1b <execute_command>
f011399f:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x200FFF c";execute_command(c4);
f01139a2:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f01139a8:	bb 4d 3c 13 f0       	mov    $0xf0133c4d,%ebx
f01139ad:	ba 0f 00 00 00       	mov    $0xf,%edx
f01139b2:	89 c7                	mov    %eax,%edi
f01139b4:	89 de                	mov    %ebx,%esi
f01139b6:	89 d1                	mov    %edx,%ecx
f01139b8:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01139ba:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f01139c0:	b9 55 00 00 00       	mov    $0x55,%ecx
f01139c5:	b0 00                	mov    $0x0,%al
f01139c7:	89 d7                	mov    %edx,%edi
f01139c9:	f3 aa                	rep stos %al,%es:(%edi)
f01139cb:	83 ec 0c             	sub    $0xc,%esp
f01139ce:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f01139d4:	50                   	push   %eax
f01139d5:	e8 41 e4 fe ff       	call   f0101e1b <execute_command>
f01139da:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x201000 d";execute_command(c22);
f01139dd:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f01139e3:	bb b1 3c 13 f0       	mov    $0xf0133cb1,%ebx
f01139e8:	ba 0f 00 00 00       	mov    $0xf,%edx
f01139ed:	89 c7                	mov    %eax,%edi
f01139ef:	89 de                	mov    %ebx,%esi
f01139f1:	89 d1                	mov    %edx,%ecx
f01139f3:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01139f5:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f01139fb:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113a00:	b0 00                	mov    $0x0,%al
f0113a02:	89 d7                	mov    %edx,%edi
f0113a04:	f3 aa                	rep stos %al,%es:(%edi)
f0113a06:	83 ec 0c             	sub    $0xc,%esp
f0113a09:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0113a0f:	50                   	push   %eax
f0113a10:	e8 06 e4 fe ff       	call   f0101e1b <execute_command>
f0113a15:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x2017FF e";execute_command(c23);
f0113a18:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0113a1e:	bb 15 3d 13 f0       	mov    $0xf0133d15,%ebx
f0113a23:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113a28:	89 c7                	mov    %eax,%edi
f0113a2a:	89 de                	mov    %ebx,%esi
f0113a2c:	89 d1                	mov    %edx,%ecx
f0113a2e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113a30:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f0113a36:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113a3b:	b0 00                	mov    $0x0,%al
f0113a3d:	89 d7                	mov    %edx,%edi
f0113a3f:	f3 aa                	rep stos %al,%es:(%edi)
f0113a41:	83 ec 0c             	sub    $0xc,%esp
f0113a44:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0113a4a:	50                   	push   %eax
f0113a4b:	e8 cb e3 fe ff       	call   f0101e1b <execute_command>
f0113a50:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x201FFF f";execute_command(c24);
f0113a53:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0113a59:	bb 79 3d 13 f0       	mov    $0xf0133d79,%ebx
f0113a5e:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113a63:	89 c7                	mov    %eax,%edi
f0113a65:	89 de                	mov    %ebx,%esi
f0113a67:	89 d1                	mov    %edx,%ecx
f0113a69:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113a6b:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f0113a71:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113a76:	b0 00                	mov    $0x0,%al
f0113a78:	89 d7                	mov    %edx,%edi
f0113a7a:	f3 aa                	rep stos %al,%es:(%edi)
f0113a7c:	83 ec 0c             	sub    $0xc,%esp
f0113a7f:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0113a85:	50                   	push   %eax
f0113a86:	e8 90 e3 fe ff       	call   f0101e1b <execute_command>
f0113a8b:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x400000", c5); execute_command(c5);
f0113a8e:	83 ec 04             	sub    $0x4,%esp
f0113a91:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113a97:	50                   	push   %eax
f0113a98:	68 16 36 13 f0       	push   $0xf0133616
f0113a9d:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113aa3:	50                   	push   %eax
f0113aa4:	e8 00 76 00 00       	call   f011b0a9 <strcconcat>
f0113aa9:	83 c4 10             	add    $0x10,%esp
f0113aac:	83 ec 0c             	sub    $0xc,%esp
f0113aaf:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113ab5:	50                   	push   %eax
f0113ab6:	e8 60 e3 fe ff       	call   f0101e1b <execute_command>
f0113abb:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x401000", c5); execute_command(c5);
f0113abe:	83 ec 04             	sub    $0x4,%esp
f0113ac1:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113ac7:	50                   	push   %eax
f0113ac8:	68 20 36 13 f0       	push   $0xf0133620
f0113acd:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113ad3:	50                   	push   %eax
f0113ad4:	e8 d0 75 00 00       	call   f011b0a9 <strcconcat>
f0113ad9:	83 c4 10             	add    $0x10,%esp
f0113adc:	83 ec 0c             	sub    $0xc,%esp
f0113adf:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113ae5:	50                   	push   %eax
f0113ae6:	e8 30 e3 fe ff       	call   f0101e1b <execute_command>
f0113aeb:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x400000 x";execute_command(c6);
f0113aee:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113af4:	bb dd 3d 13 f0       	mov    $0xf0133ddd,%ebx
f0113af9:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113afe:	89 c7                	mov    %eax,%edi
f0113b00:	89 de                	mov    %ebx,%esi
f0113b02:	89 d1                	mov    %edx,%ecx
f0113b04:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113b06:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0113b0c:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113b11:	b0 00                	mov    $0x0,%al
f0113b13:	89 d7                	mov    %edx,%edi
f0113b15:	f3 aa                	rep stos %al,%es:(%edi)
f0113b17:	83 ec 0c             	sub    $0xc,%esp
f0113b1a:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113b20:	50                   	push   %eax
f0113b21:	e8 f5 e2 fe ff       	call   f0101e1b <execute_command>
f0113b26:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x4007FF y";execute_command(c7);
f0113b29:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113b2f:	bb 41 3e 13 f0       	mov    $0xf0133e41,%ebx
f0113b34:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113b39:	89 c7                	mov    %eax,%edi
f0113b3b:	89 de                	mov    %ebx,%esi
f0113b3d:	89 d1                	mov    %edx,%ecx
f0113b3f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113b41:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0113b47:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113b4c:	b0 00                	mov    $0x0,%al
f0113b4e:	89 d7                	mov    %edx,%edi
f0113b50:	f3 aa                	rep stos %al,%es:(%edi)
f0113b52:	83 ec 0c             	sub    $0xc,%esp
f0113b55:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113b5b:	50                   	push   %eax
f0113b5c:	e8 ba e2 fe ff       	call   f0101e1b <execute_command>
f0113b61:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x400FFF z";execute_command(c8);
f0113b64:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113b6a:	bb a5 3e 13 f0       	mov    $0xf0133ea5,%ebx
f0113b6f:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113b74:	89 c7                	mov    %eax,%edi
f0113b76:	89 de                	mov    %ebx,%esi
f0113b78:	89 d1                	mov    %edx,%ecx
f0113b7a:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113b7c:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0113b82:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113b87:	b0 00                	mov    $0x0,%al
f0113b89:	89 d7                	mov    %edx,%edi
f0113b8b:	f3 aa                	rep stos %al,%es:(%edi)
f0113b8d:	83 ec 0c             	sub    $0xc,%esp
f0113b90:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113b96:	50                   	push   %eax
f0113b97:	e8 7f e2 fe ff       	call   f0101e1b <execute_command>
f0113b9c:	83 c4 10             	add    $0x10,%esp

		//Test1
		ch1 = (char*)0x200000; ch2 = (char*)0x400000;
f0113b9f:	c7 45 bc 00 00 20 00 	movl   $0x200000,-0x44(%ebp)
f0113ba6:	c7 45 b8 00 00 40 00 	movl   $0x400000,-0x48(%ebp)
		ch3 = (char*)0x2007FF; ch4 = (char*)0x4007FF;
f0113bad:	c7 45 b4 ff 07 20 00 	movl   $0x2007ff,-0x4c(%ebp)
f0113bb4:	c7 45 b0 ff 07 40 00 	movl   $0x4007ff,-0x50(%ebp)
		ch5 = (char*)0x200FFF; ch6 = (char*)0x400FFF;
f0113bbb:	c7 45 ac ff 0f 20 00 	movl   $0x200fff,-0x54(%ebp)
f0113bc2:	c7 45 a8 ff 0f 40 00 	movl   $0x400fff,-0x58(%ebp)
		ch7 = (char*)0x201000; ch8 = (char*)0x401000;
f0113bc9:	c7 45 a4 00 10 20 00 	movl   $0x201000,-0x5c(%ebp)
f0113bd0:	c7 45 a0 00 10 40 00 	movl   $0x401000,-0x60(%ebp)
		ch9 = (char*)0x2017FF; ch10= (char*)0x4017FF;
f0113bd7:	c7 45 9c ff 17 20 00 	movl   $0x2017ff,-0x64(%ebp)
f0113bde:	c7 45 98 ff 17 40 00 	movl   $0x4017ff,-0x68(%ebp)
		ch11= (char*)0x201FFF; ch12= (char*)0x401FFF;
f0113be5:	c7 45 94 ff 1f 20 00 	movl   $0x201fff,-0x6c(%ebp)
f0113bec:	c7 45 90 ff 1f 40 00 	movl   $0x401fff,-0x70(%ebp)

		tch[12] = *ch12 ;
f0113bf3:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113bf6:	8a 00                	mov    (%eax),%al
f0113bf8:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113bfe:	e8 a5 ac ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f0113c03:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x200000, 0x400000, 6*kilo);
f0113c06:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113c09:	89 d0                	mov    %edx,%eax
f0113c0b:	01 c0                	add    %eax,%eax
f0113c0d:	01 d0                	add    %edx,%eax
f0113c0f:	01 c0                	add    %eax,%eax
f0113c11:	50                   	push   %eax
f0113c12:	68 00 00 40 00       	push   $0x400000
f0113c17:	68 00 00 20 00       	push   $0x200000
f0113c1c:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113c1f:	e8 75 6f ff ff       	call   f010ab99 <copy_paste_chunk>
f0113c24:	83 c4 10             	add    $0x10,%esp
f0113c27:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113c2a:	e8 79 ac ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f0113c2f:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f0113c32:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0113c39:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f0113c3d:	75 08                	jne    f0113c47 <test_copy_paste_chunk+0x929>
f0113c3f:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113c42:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0113c45:	74 2b                	je     f0113c72 <test_copy_paste_chunk+0x954>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113c47:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113c4a:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113c4d:	83 ec 0c             	sub    $0xc,%esp
f0113c50:	50                   	push   %eax
f0113c51:	ff 75 80             	pushl  -0x80(%ebp)
f0113c54:	68 2c 36 13 f0       	push   $0xf013362c
f0113c59:	68 9e 03 00 00       	push   $0x39e
f0113c5e:	68 f2 29 13 f0       	push   $0xf01329f2
f0113c63:	e8 ec d3 fe ff       	call   f0101054 <_warn>
f0113c68:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113c6b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113c72:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113c76:	74 04                	je     f0113c7c <test_copy_paste_chunk+0x95e>
f0113c78:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113c7c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1;
f0113c83:	c7 85 7c ff ff ff 01 	movl   $0x1,-0x84(%ebp)
f0113c8a:	00 00 00 
		if (CCP(proc_directory, 0x200000, 0x400000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0113c8d:	83 ec 08             	sub    $0x8,%esp
f0113c90:	6a 01                	push   $0x1
f0113c92:	6a 07                	push   $0x7
f0113c94:	6a 07                	push   $0x7
f0113c96:	6a 07                	push   $0x7
f0113c98:	6a 07                	push   $0x7
f0113c9a:	6a 01                	push   $0x1
f0113c9c:	68 00 20 00 00       	push   $0x2000
f0113ca1:	68 00 00 40 00       	push   $0x400000
f0113ca6:	68 00 00 20 00       	push   $0x200000
f0113cab:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113cae:	e8 bf 32 00 00       	call   f0116f72 <CCP>
f0113cb3:	83 c4 30             	add    $0x30,%esp
f0113cb6:	83 f8 01             	cmp    $0x1,%eax
f0113cb9:	74 2b                	je     f0113ce6 <test_copy_paste_chunk+0x9c8>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references)\n");
f0113cbb:	83 ec 04             	sub    $0x4,%esp
f0113cbe:	68 80 36 13 f0       	push   $0xf0133680
f0113cc3:	68 a7 03 00 00       	push   $0x3a7
f0113cc8:	68 f2 29 13 f0       	push   $0xf01329f2
f0113ccd:	e8 82 d3 fe ff       	call   f0101054 <_warn>
f0113cd2:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113cd5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0;
f0113cdc:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
f0113ce3:	00 00 00 
		}
		if (correct) eval += 5 ;
f0113ce6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113cea:	74 04                	je     f0113cf0 <test_copy_paste_chunk+0x9d2>
f0113cec:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113cf0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		*ch3 = 'y' ;	// wum 0x2007FF y
f0113cf7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113cfa:	c6 00 79             	movb   $0x79,(%eax)
		*ch6 = 'z' ;	// wum 0x400FFF z
f0113cfd:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113d00:	c6 00 7a             	movb   $0x7a,(%eax)
		*ch7 = 'w' ;	// wum 0x201000 w
f0113d03:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113d06:	c6 00 77             	movb   $0x77,(%eax)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z'
f0113d09:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113d0c:	8a 00                	mov    (%eax),%al
f0113d0e:	3c 61                	cmp    $0x61,%al
f0113d10:	75 69                	jne    f0113d7b <test_copy_paste_chunk+0xa5d>
f0113d12:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113d15:	8a 00                	mov    (%eax),%al
f0113d17:	3c 61                	cmp    $0x61,%al
f0113d19:	75 60                	jne    f0113d7b <test_copy_paste_chunk+0xa5d>
f0113d1b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113d1e:	8a 00                	mov    (%eax),%al
f0113d20:	3c 79                	cmp    $0x79,%al
f0113d22:	75 57                	jne    f0113d7b <test_copy_paste_chunk+0xa5d>
f0113d24:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113d27:	8a 00                	mov    (%eax),%al
f0113d29:	3c 62                	cmp    $0x62,%al
f0113d2b:	75 4e                	jne    f0113d7b <test_copy_paste_chunk+0xa5d>
f0113d2d:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113d30:	8a 00                	mov    (%eax),%al
f0113d32:	3c 63                	cmp    $0x63,%al
f0113d34:	75 45                	jne    f0113d7b <test_copy_paste_chunk+0xa5d>
f0113d36:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113d39:	8a 00                	mov    (%eax),%al
f0113d3b:	3c 7a                	cmp    $0x7a,%al
f0113d3d:	75 3c                	jne    f0113d7b <test_copy_paste_chunk+0xa5d>
				||  *ch7 != 'w' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'e' || *ch11!= 'f' || *ch12 != tch[12])
f0113d3f:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113d42:	8a 00                	mov    (%eax),%al
f0113d44:	3c 77                	cmp    $0x77,%al
f0113d46:	75 33                	jne    f0113d7b <test_copy_paste_chunk+0xa5d>
f0113d48:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0113d4b:	8a 00                	mov    (%eax),%al
f0113d4d:	3c 64                	cmp    $0x64,%al
f0113d4f:	75 2a                	jne    f0113d7b <test_copy_paste_chunk+0xa5d>
f0113d51:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0113d54:	8a 00                	mov    (%eax),%al
f0113d56:	3c 65                	cmp    $0x65,%al
f0113d58:	75 21                	jne    f0113d7b <test_copy_paste_chunk+0xa5d>
f0113d5a:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113d5d:	8a 00                	mov    (%eax),%al
f0113d5f:	3c 65                	cmp    $0x65,%al
f0113d61:	75 18                	jne    f0113d7b <test_copy_paste_chunk+0xa5d>
f0113d63:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113d66:	8a 00                	mov    (%eax),%al
f0113d68:	3c 66                	cmp    $0x66,%al
f0113d6a:	75 0f                	jne    f0113d7b <test_copy_paste_chunk+0xa5d>
f0113d6c:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113d6f:	8a 10                	mov    (%eax),%dl
f0113d71:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0113d77:	38 c2                	cmp    %al,%dl
f0113d79:	74 21                	je     f0113d9c <test_copy_paste_chunk+0xa7e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113d7b:	83 ec 04             	sub    $0x4,%esp
f0113d7e:	68 80 35 13 f0       	push   $0xf0133580
f0113d83:	68 b5 03 00 00       	push   $0x3b5
f0113d88:	68 f2 29 13 f0       	push   $0xf01329f2
f0113d8d:	e8 c2 d2 fe ff       	call   f0101054 <_warn>
f0113d92:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113d95:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0113d9c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113da0:	74 04                	je     f0113da6 <test_copy_paste_chunk+0xa88>
f0113da2:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113da6:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		//Test2
		*ch10 = 'x';	// wum 0x4017FF y
f0113dad:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113db0:	c6 00 78             	movb   $0x78,(%eax)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113db3:	e8 f0 aa ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f0113db8:	89 45 8c             	mov    %eax,-0x74(%ebp)

		ret = copy_paste_chunk(proc_directory, 0x400800, 0x200800, 3*kilo);
f0113dbb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113dbe:	89 c2                	mov    %eax,%edx
f0113dc0:	01 d2                	add    %edx,%edx
f0113dc2:	01 d0                	add    %edx,%eax
f0113dc4:	50                   	push   %eax
f0113dc5:	68 00 08 20 00       	push   $0x200800
f0113dca:	68 00 08 40 00       	push   $0x400800
f0113dcf:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113dd2:	e8 c2 6d ff ff       	call   f010ab99 <copy_paste_chunk>
f0113dd7:	83 c4 10             	add    $0x10,%esp
f0113dda:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113ddd:	e8 c6 aa ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f0113de2:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0113de5:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f0113de9:	75 08                	jne    f0113df3 <test_copy_paste_chunk+0xad5>
f0113deb:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113dee:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0113df1:	74 2b                	je     f0113e1e <test_copy_paste_chunk+0xb00>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113df3:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113df6:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113df9:	83 ec 0c             	sub    $0xc,%esp
f0113dfc:	50                   	push   %eax
f0113dfd:	ff 75 80             	pushl  -0x80(%ebp)
f0113e00:	68 2c 36 13 f0       	push   $0xf013362c
f0113e05:	68 c5 03 00 00       	push   $0x3c5
f0113e0a:	68 f2 29 13 f0       	push   $0xf01329f2
f0113e0f:	e8 40 d2 fe ff       	call   f0101054 <_warn>
f0113e14:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113e17:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113e1e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113e22:	74 04                	je     f0113e28 <test_copy_paste_chunk+0xb0a>
f0113e24:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113e28:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CCP(proc_directory, 0x400000, 0x200000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0113e2f:	83 ec 08             	sub    $0x8,%esp
f0113e32:	6a 01                	push   $0x1
f0113e34:	6a 07                	push   $0x7
f0113e36:	6a 07                	push   $0x7
f0113e38:	6a 07                	push   $0x7
f0113e3a:	6a 07                	push   $0x7
f0113e3c:	6a 01                	push   $0x1
f0113e3e:	68 00 20 00 00       	push   $0x2000
f0113e43:	68 00 00 20 00       	push   $0x200000
f0113e48:	68 00 00 40 00       	push   $0x400000
f0113e4d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113e50:	e8 1d 31 00 00       	call   f0116f72 <CCP>
f0113e55:	83 c4 30             	add    $0x30,%esp
f0113e58:	83 f8 01             	cmp    $0x1,%eax
f0113e5b:	74 21                	je     f0113e7e <test_copy_paste_chunk+0xb60>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0113e5d:	83 ec 04             	sub    $0x4,%esp
f0113e60:	68 cc 36 13 f0       	push   $0xf01336cc
f0113e65:	68 cd 03 00 00       	push   $0x3cd
f0113e6a:	68 f2 29 13 f0       	push   $0xf01329f2
f0113e6f:	e8 e0 d1 fe ff       	call   f0101054 <_warn>
f0113e74:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113e77:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113e7e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113e82:	74 04                	je     f0113e88 <test_copy_paste_chunk+0xb6a>
f0113e84:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113e88:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f0113e8f:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113e92:	8a 00                	mov    (%eax),%al
f0113e94:	3c 61                	cmp    $0x61,%al
f0113e96:	75 69                	jne    f0113f01 <test_copy_paste_chunk+0xbe3>
f0113e98:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113e9b:	8a 00                	mov    (%eax),%al
f0113e9d:	3c 61                	cmp    $0x61,%al
f0113e9f:	75 60                	jne    f0113f01 <test_copy_paste_chunk+0xbe3>
f0113ea1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113ea4:	8a 00                	mov    (%eax),%al
f0113ea6:	3c 79                	cmp    $0x79,%al
f0113ea8:	75 57                	jne    f0113f01 <test_copy_paste_chunk+0xbe3>
f0113eaa:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113ead:	8a 00                	mov    (%eax),%al
f0113eaf:	3c 62                	cmp    $0x62,%al
f0113eb1:	75 4e                	jne    f0113f01 <test_copy_paste_chunk+0xbe3>
f0113eb3:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113eb6:	8a 00                	mov    (%eax),%al
f0113eb8:	3c 7a                	cmp    $0x7a,%al
f0113eba:	75 45                	jne    f0113f01 <test_copy_paste_chunk+0xbe3>
f0113ebc:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113ebf:	8a 00                	mov    (%eax),%al
f0113ec1:	3c 7a                	cmp    $0x7a,%al
f0113ec3:	75 3c                	jne    f0113f01 <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f0113ec5:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113ec8:	8a 00                	mov    (%eax),%al
			correct = 0;
		}
		if (correct) eval += 5 ;
		correct = 1 ;

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f0113eca:	3c 64                	cmp    $0x64,%al
f0113ecc:	75 33                	jne    f0113f01 <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f0113ece:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0113ed1:	8a 00                	mov    (%eax),%al
f0113ed3:	3c 64                	cmp    $0x64,%al
f0113ed5:	75 2a                	jne    f0113f01 <test_copy_paste_chunk+0xbe3>
f0113ed7:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0113eda:	8a 00                	mov    (%eax),%al
f0113edc:	3c 65                	cmp    $0x65,%al
f0113ede:	75 21                	jne    f0113f01 <test_copy_paste_chunk+0xbe3>
f0113ee0:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113ee3:	8a 00                	mov    (%eax),%al
f0113ee5:	3c 78                	cmp    $0x78,%al
f0113ee7:	75 18                	jne    f0113f01 <test_copy_paste_chunk+0xbe3>
f0113ee9:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113eec:	8a 00                	mov    (%eax),%al
f0113eee:	3c 66                	cmp    $0x66,%al
f0113ef0:	75 0f                	jne    f0113f01 <test_copy_paste_chunk+0xbe3>
f0113ef2:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113ef5:	8a 10                	mov    (%eax),%dl
f0113ef7:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0113efd:	38 c2                	cmp    %al,%dl
f0113eff:	74 21                	je     f0113f22 <test_copy_paste_chunk+0xc04>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113f01:	83 ec 04             	sub    $0x4,%esp
f0113f04:	68 80 35 13 f0       	push   $0xf0133580
f0113f09:	68 d6 03 00 00       	push   $0x3d6
f0113f0e:	68 f2 29 13 f0       	push   $0xf01329f2
f0113f13:	e8 3c d1 fe ff       	call   f0101054 <_warn>
f0113f18:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113f1b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0113f22:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113f26:	74 04                	je     f0113f2c <test_copy_paste_chunk+0xc0e>
f0113f28:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113f2c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE II: END\n") ;
f0113f33:	83 ec 0c             	sub    $0xc,%esp
f0113f36:	68 17 37 13 f0       	push   $0xf0133717
f0113f3b:	e8 1c dc fe ff       	call   f0101b5c <cprintf>
f0113f40:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART III: Destination page(s) doesn't exist 40% */
	/*================================================*/
	cprintf("\nCASE III: Destination page(s) doesn't exist [40%]\n") ;
f0113f43:	83 ec 0c             	sub    $0xc,%esp
f0113f46:	68 28 37 13 f0       	push   $0xf0133728
f0113f4b:	e8 0c dc fe ff       	call   f0101b5c <cprintf>
f0113f50:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x800000", c1); execute_command(c1);
f0113f53:	83 ec 04             	sub    $0x4,%esp
f0113f56:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113f5c:	50                   	push   %eax
f0113f5d:	68 5c 37 13 f0       	push   $0xf013375c
f0113f62:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113f68:	50                   	push   %eax
f0113f69:	e8 3b 71 00 00       	call   f011b0a9 <strcconcat>
f0113f6e:	83 c4 10             	add    $0x10,%esp
f0113f71:	83 ec 0c             	sub    $0xc,%esp
f0113f74:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113f7a:	50                   	push   %eax
f0113f7b:	e8 9b de fe ff       	call   f0101e1b <execute_command>
f0113f80:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x801000", c1); execute_command(c1);
f0113f83:	83 ec 04             	sub    $0x4,%esp
f0113f86:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113f8c:	50                   	push   %eax
f0113f8d:	68 66 37 13 f0       	push   $0xf0133766
f0113f92:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113f98:	50                   	push   %eax
f0113f99:	e8 0b 71 00 00       	call   f011b0a9 <strcconcat>
f0113f9e:	83 c4 10             	add    $0x10,%esp
f0113fa1:	83 ec 0c             	sub    $0xc,%esp
f0113fa4:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113faa:	50                   	push   %eax
f0113fab:	e8 6b de fe ff       	call   f0101e1b <execute_command>
f0113fb0:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x802000", c1); execute_command(c1);
f0113fb3:	83 ec 04             	sub    $0x4,%esp
f0113fb6:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113fbc:	50                   	push   %eax
f0113fbd:	68 70 37 13 f0       	push   $0xf0133770
f0113fc2:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113fc8:	50                   	push   %eax
f0113fc9:	e8 db 70 00 00       	call   f011b0a9 <strcconcat>
f0113fce:	83 c4 10             	add    $0x10,%esp
f0113fd1:	83 ec 0c             	sub    $0xc,%esp
f0113fd4:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113fda:	50                   	push   %eax
f0113fdb:	e8 3b de fe ff       	call   f0101e1b <execute_command>
f0113fe0:	83 c4 10             	add    $0x10,%esp
		char c14[100] = "wum 0x800000 a"; execute_command(c14);
f0113fe3:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113fe9:	bb 09 3f 13 f0       	mov    $0xf0133f09,%ebx
f0113fee:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113ff3:	89 c7                	mov    %eax,%edi
f0113ff5:	89 de                	mov    %ebx,%esi
f0113ff7:	89 d1                	mov    %edx,%ecx
f0113ff9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113ffb:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0114001:	b9 55 00 00 00       	mov    $0x55,%ecx
f0114006:	b0 00                	mov    $0x0,%al
f0114008:	89 d7                	mov    %edx,%edi
f011400a:	f3 aa                	rep stos %al,%es:(%edi)
f011400c:	83 ec 0c             	sub    $0xc,%esp
f011400f:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0114015:	50                   	push   %eax
f0114016:	e8 00 de fe ff       	call   f0101e1b <execute_command>
f011401b:	83 c4 10             	add    $0x10,%esp
		char c15[100] = "wum 0x8017FF b"; execute_command(c15);
f011401e:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0114024:	bb 6d 3f 13 f0       	mov    $0xf0133f6d,%ebx
f0114029:	ba 0f 00 00 00       	mov    $0xf,%edx
f011402e:	89 c7                	mov    %eax,%edi
f0114030:	89 de                	mov    %ebx,%esi
f0114032:	89 d1                	mov    %edx,%ecx
f0114034:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114036:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f011403c:	b9 55 00 00 00       	mov    $0x55,%ecx
f0114041:	b0 00                	mov    $0x0,%al
f0114043:	89 d7                	mov    %edx,%edi
f0114045:	f3 aa                	rep stos %al,%es:(%edi)
f0114047:	83 ec 0c             	sub    $0xc,%esp
f011404a:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0114050:	50                   	push   %eax
f0114051:	e8 c5 dd fe ff       	call   f0101e1b <execute_command>
f0114056:	83 c4 10             	add    $0x10,%esp
		char c16[100] = "wum 0x802FFF c"; execute_command(c16);
f0114059:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f011405f:	bb d1 3f 13 f0       	mov    $0xf0133fd1,%ebx
f0114064:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114069:	89 c7                	mov    %eax,%edi
f011406b:	89 de                	mov    %ebx,%esi
f011406d:	89 d1                	mov    %edx,%ecx
f011406f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114071:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0114077:	b9 55 00 00 00       	mov    $0x55,%ecx
f011407c:	b0 00                	mov    $0x0,%al
f011407e:	89 d7                	mov    %edx,%edi
f0114080:	f3 aa                	rep stos %al,%es:(%edi)
f0114082:	83 ec 0c             	sub    $0xc,%esp
f0114085:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f011408b:	50                   	push   %eax
f011408c:	e8 8a dd fe ff       	call   f0101e1b <execute_command>
f0114091:	83 c4 10             	add    $0x10,%esp

		//Test3
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114094:	e8 0f a8 ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f0114099:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x800000, 0x900000, 12*kilo);
f011409c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011409f:	89 d0                	mov    %edx,%eax
f01140a1:	01 c0                	add    %eax,%eax
f01140a3:	01 d0                	add    %edx,%eax
f01140a5:	c1 e0 02             	shl    $0x2,%eax
f01140a8:	50                   	push   %eax
f01140a9:	68 00 00 90 00       	push   $0x900000
f01140ae:	68 00 00 80 00       	push   $0x800000
f01140b3:	ff 75 d4             	pushl  -0x2c(%ebp)
f01140b6:	e8 de 6a ff ff       	call   f010ab99 <copy_paste_chunk>
f01140bb:	83 c4 10             	add    $0x10,%esp
f01140be:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01140c4:	e8 df a7 ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f01140c9:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f01140cc:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f01140d3:	75 0b                	jne    f01140e0 <test_copy_paste_chunk+0xdc2>
f01140d5:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01140d8:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01140db:	83 f8 03             	cmp    $0x3,%eax
f01140de:	74 2e                	je     f011410e <test_copy_paste_chunk+0xdf0>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01140e0:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01140e3:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01140e6:	83 ec 0c             	sub    $0xc,%esp
f01140e9:	50                   	push   %eax
f01140ea:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f01140f0:	68 2c 36 13 f0       	push   $0xf013362c
f01140f5:	68 f4 03 00 00       	push   $0x3f4
f01140fa:	68 f2 29 13 f0       	push   $0xf01329f2
f01140ff:	e8 50 cf fe ff       	call   f0101054 <_warn>
f0114104:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114107:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f011410e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114112:	74 04                	je     f0114118 <test_copy_paste_chunk+0xdfa>
f0114114:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114118:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1 ;
f011411f:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x800000, 0x900000, 3*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0114126:	83 ec 08             	sub    $0x8,%esp
f0114129:	6a 01                	push   $0x1
f011412b:	6a 07                	push   $0x7
f011412d:	6a 07                	push   $0x7
f011412f:	6a 07                	push   $0x7
f0114131:	6a 07                	push   $0x7
f0114133:	6a 01                	push   $0x1
f0114135:	68 00 30 00 00       	push   $0x3000
f011413a:	68 00 00 90 00       	push   $0x900000
f011413f:	68 00 00 80 00       	push   $0x800000
f0114144:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114147:	e8 26 2e 00 00       	call   f0116f72 <CCP>
f011414c:	83 c4 30             	add    $0x30,%esp
f011414f:	83 f8 01             	cmp    $0x1,%eax
f0114152:	74 28                	je     f011417c <test_copy_paste_chunk+0xe5e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0114154:	83 ec 04             	sub    $0x4,%esp
f0114157:	68 cc 36 13 f0       	push   $0xf01336cc
f011415c:	68 fd 03 00 00       	push   $0x3fd
f0114161:	68 f2 29 13 f0       	push   $0xf01329f2
f0114166:	e8 e9 ce fe ff       	call   f0101054 <_warn>
f011416b:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011416e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0114175:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 5 ;
f011417c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114180:	74 04                	je     f0114186 <test_copy_paste_chunk+0xe68>
f0114182:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114186:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f011418d:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0114191:	0f 84 9e 00 00 00    	je     f0114235 <test_copy_paste_chunk+0xf17>
		{
			ch1 = (char*)0x800000; ch2 = (char*)0x900000;
f0114197:	c7 45 bc 00 00 80 00 	movl   $0x800000,-0x44(%ebp)
f011419e:	c7 45 b8 00 00 90 00 	movl   $0x900000,-0x48(%ebp)
			ch3 = (char*)0x8017FF; ch4 = (char*)0x9017FF;
f01141a5:	c7 45 b4 ff 17 80 00 	movl   $0x8017ff,-0x4c(%ebp)
f01141ac:	c7 45 b0 ff 17 90 00 	movl   $0x9017ff,-0x50(%ebp)
			ch5 = (char*)0x802FFF; ch6 = (char*)0x902FFF;
f01141b3:	c7 45 ac ff 2f 80 00 	movl   $0x802fff,-0x54(%ebp)
f01141ba:	c7 45 a8 ff 2f 90 00 	movl   $0x902fff,-0x58(%ebp)

			*ch3 = 'y';	//wum 0x8017FF y
f01141c1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01141c4:	c6 00 79             	movb   $0x79,(%eax)
			*ch6 = 'z';	//wum 0x902FFF z
f01141c7:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01141ca:	c6 00 7a             	movb   $0x7a,(%eax)

			if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z')
f01141cd:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01141d0:	8a 00                	mov    (%eax),%al
f01141d2:	3c 61                	cmp    $0x61,%al
f01141d4:	75 2d                	jne    f0114203 <test_copy_paste_chunk+0xee5>
f01141d6:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01141d9:	8a 00                	mov    (%eax),%al
f01141db:	3c 61                	cmp    $0x61,%al
f01141dd:	75 24                	jne    f0114203 <test_copy_paste_chunk+0xee5>
f01141df:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01141e2:	8a 00                	mov    (%eax),%al
f01141e4:	3c 79                	cmp    $0x79,%al
f01141e6:	75 1b                	jne    f0114203 <test_copy_paste_chunk+0xee5>
f01141e8:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01141eb:	8a 00                	mov    (%eax),%al
f01141ed:	3c 62                	cmp    $0x62,%al
f01141ef:	75 12                	jne    f0114203 <test_copy_paste_chunk+0xee5>
f01141f1:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01141f4:	8a 00                	mov    (%eax),%al
f01141f6:	3c 63                	cmp    $0x63,%al
f01141f8:	75 09                	jne    f0114203 <test_copy_paste_chunk+0xee5>
f01141fa:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01141fd:	8a 00                	mov    (%eax),%al
f01141ff:	3c 7a                	cmp    $0x7a,%al
f0114201:	74 21                	je     f0114224 <test_copy_paste_chunk+0xf06>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0114203:	83 ec 04             	sub    $0x4,%esp
f0114206:	68 80 35 13 f0       	push   $0xf0133580
f011420b:	68 0f 04 00 00       	push   $0x40f
f0114210:	68 f2 29 13 f0       	push   $0xf01329f2
f0114215:	e8 3a ce fe ff       	call   f0101054 <_warn>
f011421a:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011421d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 10 ;
f0114224:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114228:	74 04                	je     f011422e <test_copy_paste_chunk+0xf10>
f011422a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
			correct = 1 ;
f011422e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
		//Test4
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114235:	e8 6e a6 ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f011423a:	89 45 8c             	mov    %eax,-0x74(%ebp)
		SB(proc_directory, 0x901000, 2 , 0) ;
f011423d:	6a 00                	push   $0x0
f011423f:	6a 02                	push   $0x2
f0114241:	68 00 10 90 00       	push   $0x901000
f0114246:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114249:	e8 b1 2b 00 00       	call   f0116dff <SB>
f011424e:	83 c4 10             	add    $0x10,%esp
		SB(proc_directory, 0x902000, 2 , 0) ;
f0114251:	6a 00                	push   $0x0
f0114253:	6a 02                	push   $0x2
f0114255:	68 00 20 90 00       	push   $0x902000
f011425a:	ff 75 d4             	pushl  -0x2c(%ebp)
f011425d:	e8 9d 2b 00 00       	call   f0116dff <SB>
f0114262:	83 c4 10             	add    $0x10,%esp

		ret = copy_paste_chunk(proc_directory, 0x901000, 0xBFF000, 8*kilo);
f0114265:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114268:	c1 e0 03             	shl    $0x3,%eax
f011426b:	50                   	push   %eax
f011426c:	68 00 f0 bf 00       	push   $0xbff000
f0114271:	68 00 10 90 00       	push   $0x901000
f0114276:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114279:	e8 1b 69 ff ff       	call   f010ab99 <copy_paste_chunk>
f011427e:	83 c4 10             	add    $0x10,%esp
f0114281:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114287:	e8 1c a6 ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f011428c:	89 45 84             	mov    %eax,-0x7c(%ebp)
		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f011428f:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0114296:	75 0b                	jne    f01142a3 <test_copy_paste_chunk+0xf85>
f0114298:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011429b:	2b 45 84             	sub    -0x7c(%ebp),%eax
f011429e:	83 f8 03             	cmp    $0x3,%eax
f01142a1:	74 2e                	je     f01142d1 <test_copy_paste_chunk+0xfb3>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01142a3:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01142a6:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01142a9:	83 ec 0c             	sub    $0xc,%esp
f01142ac:	50                   	push   %eax
f01142ad:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f01142b3:	68 2c 36 13 f0       	push   $0xf013362c
f01142b8:	68 1f 04 00 00       	push   $0x41f
f01142bd:	68 f2 29 13 f0       	push   $0xf01329f2
f01142c2:	e8 8d cd fe ff       	call   f0101054 <_warn>
f01142c7:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01142ca:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01142d1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01142d5:	74 04                	je     f01142db <test_copy_paste_chunk+0xfbd>
f01142d7:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01142db:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		chkcnt = 1 ;
f01142e2:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x901000, 0xBFF000, 2*PAGE_SIZE, 1, 0x003, 0x007, 0x003, 0x007, CHK_COPY_PASTE) != 1)
f01142e9:	83 ec 08             	sub    $0x8,%esp
f01142ec:	6a 01                	push   $0x1
f01142ee:	6a 07                	push   $0x7
f01142f0:	6a 03                	push   $0x3
f01142f2:	6a 07                	push   $0x7
f01142f4:	6a 03                	push   $0x3
f01142f6:	6a 01                	push   $0x1
f01142f8:	68 00 20 00 00       	push   $0x2000
f01142fd:	68 00 f0 bf 00       	push   $0xbff000
f0114302:	68 00 10 90 00       	push   $0x901000
f0114307:	ff 75 d4             	pushl  -0x2c(%ebp)
f011430a:	e8 63 2c 00 00       	call   f0116f72 <CCP>
f011430f:	83 c4 30             	add    $0x30,%esp
f0114312:	83 f8 01             	cmp    $0x1,%eax
f0114315:	74 28                	je     f011433f <test_copy_paste_chunk+0x1021>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0114317:	83 ec 04             	sub    $0x4,%esp
f011431a:	68 cc 36 13 f0       	push   $0xf01336cc
f011431f:	68 28 04 00 00       	push   $0x428
f0114324:	68 f2 29 13 f0       	push   $0xf01329f2
f0114329:	e8 26 cd fe ff       	call   f0101054 <_warn>
f011432e:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114331:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0114338:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 10 ;
f011433f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114343:	74 04                	je     f0114349 <test_copy_paste_chunk+0x102b>
f0114345:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114349:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f0114350:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0114354:	74 72                	je     f01143c8 <test_copy_paste_chunk+0x10aa>
		{
			ch1 = (char*)0x9017FF; ch2 = (char*)0xBFF7FF; ch3 = (char*)0x902FFF;ch4 = (char*)0xC00FFF;
f0114356:	c7 45 bc ff 17 90 00 	movl   $0x9017ff,-0x44(%ebp)
f011435d:	c7 45 b8 ff f7 bf 00 	movl   $0xbff7ff,-0x48(%ebp)
f0114364:	c7 45 b4 ff 2f 90 00 	movl   $0x902fff,-0x4c(%ebp)
f011436b:	c7 45 b0 ff 0f c0 00 	movl   $0xc00fff,-0x50(%ebp)
			if (*ch1 != 'b' || *ch2 != 'b' || *ch3 != 'z' || *ch4 != 'z')
f0114372:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114375:	8a 00                	mov    (%eax),%al
f0114377:	3c 62                	cmp    $0x62,%al
f0114379:	75 1b                	jne    f0114396 <test_copy_paste_chunk+0x1078>
f011437b:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011437e:	8a 00                	mov    (%eax),%al
f0114380:	3c 62                	cmp    $0x62,%al
f0114382:	75 12                	jne    f0114396 <test_copy_paste_chunk+0x1078>
f0114384:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114387:	8a 00                	mov    (%eax),%al
f0114389:	3c 7a                	cmp    $0x7a,%al
f011438b:	75 09                	jne    f0114396 <test_copy_paste_chunk+0x1078>
f011438d:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0114390:	8a 00                	mov    (%eax),%al
f0114392:	3c 7a                	cmp    $0x7a,%al
f0114394:	74 21                	je     f01143b7 <test_copy_paste_chunk+0x1099>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0114396:	83 ec 04             	sub    $0x4,%esp
f0114399:	68 80 35 13 f0       	push   $0xf0133580
f011439e:	68 34 04 00 00       	push   $0x434
f01143a3:	68 f2 29 13 f0       	push   $0xf01329f2
f01143a8:	e8 a7 cc fe ff       	call   f0101054 <_warn>
f01143ad:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01143b0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f01143b7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01143bb:	74 04                	je     f01143c1 <test_copy_paste_chunk+0x10a3>
f01143bd:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01143c1:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f01143c8:	83 ec 0c             	sub    $0xc,%esp
f01143cb:	68 7a 37 13 f0       	push   $0xf013377a
f01143d0:	e8 87 d7 fe ff       	call   f0101b5c <cprintf>
f01143d5:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] copy_paste_chunk: FINISHED. Evaluation = %d\n", eval);
f01143d8:	83 ec 08             	sub    $0x8,%esp
f01143db:	ff 75 e4             	pushl  -0x1c(%ebp)
f01143de:	68 8c 37 13 f0       	push   $0xf013378c
f01143e3:	e8 74 d7 fe ff       	call   f0101b5c <cprintf>
f01143e8:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01143eb:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01143ef:	75 10                	jne    f0114401 <test_copy_paste_chunk+0x10e3>
		cprintf("Congratulations!! test copy_paste_chunk completed successfully.\n");
f01143f1:	83 ec 0c             	sub    $0xc,%esp
f01143f4:	68 c0 37 13 f0       	push   $0xf01337c0
f01143f9:	e8 5e d7 fe ff       	call   f0101b5c <cprintf>
f01143fe:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0114401:	a1 e0 6d 85 f0       	mov    0xf0856de0,%eax
f0114406:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0114409:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011440c:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f011440f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0114414:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0114417:	5b                   	pop    %ebx
f0114418:	5e                   	pop    %esi
f0114419:	5f                   	pop    %edi
f011441a:	5d                   	pop    %ebp
f011441b:	c3                   	ret    

f011441c <test_share_chunk>:

//===============================
// 3) TEST SHARE CHUNK:
//===============================
int test_share_chunk()
{
f011441c:	55                   	push   %ebp
f011441d:	89 e5                	mov    %esp,%ebp
f011441f:	57                   	push   %edi
f0114420:	56                   	push   %esi
f0114421:	53                   	push   %ebx
f0114422:	81 ec bc 00 00 00    	sub    $0xbc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0114428:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f011442e:	bb 8c 34 13 f0       	mov    $0xf013348c,%ebx
f0114433:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114438:	89 c7                	mov    %eax,%edi
f011443a:	89 de                	mov    %ebx,%esi
f011443c:	89 d1                	mov    %edx,%ecx
f011443e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114440:	8d 95 5d ff ff ff    	lea    -0xa3(%ebp),%edx
f0114446:	b9 23 00 00 00       	mov    $0x23,%ecx
f011444b:	b0 00                	mov    $0x0,%al
f011444d:	89 d7                	mov    %edx,%edi
f011444f:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0114451:	6a 00                	push   $0x0
f0114453:	6a 0a                	push   $0xa
f0114455:	6a 14                	push   $0x14
f0114457:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f011445d:	50                   	push   %eax
f011445e:	e8 fe 69 ff ff       	call   f010ae61 <env_create>
f0114463:	83 c4 10             	add    $0x10,%esp
f0114466:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0114469:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011446c:	8b 40 64             	mov    0x64(%eax),%eax
f011446f:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f0114472:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114475:	8b 40 68             	mov    0x68(%eax),%eax
f0114478:	89 45 80             	mov    %eax,-0x80(%ebp)
f011447b:	8b 45 80             	mov    -0x80(%ebp),%eax
f011447e:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f0114481:	83 ec 0c             	sub    $0xc,%esp
f0114484:	ff 75 cc             	pushl  -0x34(%ebp)
f0114487:	e8 b2 2a 00 00       	call   f0116f3e <ClearUserSpace>
f011448c:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f011448f:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0114496:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f011449d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct =1 ;
f01144a4:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 20% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [20%]\n") ;
f01144a8:	83 ec 0c             	sub    $0xc,%esp
f01144ab:	68 38 40 13 f0       	push   $0xf0134038
f01144b0:	e8 a7 d6 fe ff       	call   f0101b5c <cprintf>
f01144b5:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)0xF0100000;
f01144b8:	c7 45 bc 00 00 10 f0 	movl   $0xf0100000,-0x44(%ebp)
		ptr2 = (char*)0xF0104000;
f01144bf:	c7 45 b8 00 40 10 f0 	movl   $0xf0104000,-0x48(%ebp)
		tptr[1] = *ptr1 ;
f01144c6:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01144c9:	8a 00                	mov    (%eax),%al
f01144cb:	88 85 45 ff ff ff    	mov    %al,-0xbb(%ebp)
		tptr[2] = *ptr2 ;
f01144d1:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01144d4:	8a 00                	mov    (%eax),%al
f01144d6:	88 85 46 ff ff ff    	mov    %al,-0xba(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f01144dc:	e8 c7 a3 ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f01144e1:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0100000,0xF0104000, 6*kilo, PERM_WRITEABLE) ;
f01144e4:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01144e7:	89 d0                	mov    %edx,%eax
f01144e9:	01 c0                	add    %eax,%eax
f01144eb:	01 d0                	add    %edx,%eax
f01144ed:	01 c0                	add    %eax,%eax
f01144ef:	83 ec 0c             	sub    $0xc,%esp
f01144f2:	6a 02                	push   $0x2
f01144f4:	50                   	push   %eax
f01144f5:	68 00 40 10 f0       	push   $0xf0104000
f01144fa:	68 00 00 10 f0       	push   $0xf0100000
f01144ff:	ff 75 cc             	pushl  -0x34(%ebp)
f0114502:	e8 ac 66 ff ff       	call   f010abb3 <share_chunk>
f0114507:	83 c4 20             	add    $0x20,%esp
f011450a:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011450d:	e8 96 a3 ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f0114512:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0114515:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0114519:	75 08                	jne    f0114523 <test_share_chunk+0x107>
f011451b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011451e:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0114521:	74 28                	je     f011454b <test_share_chunk+0x12f>
		{
			warn("[EVAL] share_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter));
f0114523:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114526:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114529:	83 ec 0c             	sub    $0xc,%esp
f011452c:	50                   	push   %eax
f011452d:	ff 75 b0             	pushl  -0x50(%ebp)
f0114530:	68 64 40 13 f0       	push   $0xf0134064
f0114535:	68 70 04 00 00       	push   $0x470
f011453a:	68 f2 29 13 f0       	push   $0xf01329f2
f011453f:	e8 10 cb fe ff       	call   f0101054 <_warn>
f0114544:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114547:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011454b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011454f:	74 04                	je     f0114555 <test_share_chunk+0x139>
f0114551:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114555:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xF0100000, 0xF0104000, 8*kilo, 1, 0x003, 0x007, 0x003, 0x007, ~CHK_SHARE) == 0)
f0114559:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011455c:	c1 e0 03             	shl    $0x3,%eax
f011455f:	83 ec 08             	sub    $0x8,%esp
f0114562:	68 fd 00 00 00       	push   $0xfd
f0114567:	6a 07                	push   $0x7
f0114569:	6a 03                	push   $0x3
f011456b:	6a 07                	push   $0x7
f011456d:	6a 03                	push   $0x3
f011456f:	6a 01                	push   $0x1
f0114571:	50                   	push   %eax
f0114572:	68 00 40 10 f0       	push   $0xf0104000
f0114577:	68 00 00 10 f0       	push   $0xf0100000
f011457c:	ff 75 cc             	pushl  -0x34(%ebp)
f011457f:	e8 ee 29 00 00       	call   f0116f72 <CCP>
f0114584:	83 c4 30             	add    $0x30,%esp
f0114587:	85 c0                	test   %eax,%eax
f0114589:	75 1e                	jne    f01145a9 <test_share_chunk+0x18d>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011458b:	83 ec 04             	sub    $0x4,%esp
f011458e:	68 c0 40 13 f0       	push   $0xf01340c0
f0114593:	68 78 04 00 00       	push   $0x478
f0114598:	68 f2 29 13 f0       	push   $0xf01329f2
f011459d:	e8 b2 ca fe ff       	call   f0101054 <_warn>
f01145a2:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01145a5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01145a9:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01145ad:	74 04                	je     f01145b3 <test_share_chunk+0x197>
f01145af:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)

		*ptr1 = 'A' ;
f01145b3:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01145b6:	c6 00 41             	movb   $0x41,(%eax)
		*ptr2 = 'B' ;
f01145b9:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01145bc:	c6 00 42             	movb   $0x42,(%eax)

		if ((*ptr1) != 'A' || (*ptr2) != 'B')
f01145bf:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01145c2:	8a 00                	mov    (%eax),%al
f01145c4:	3c 41                	cmp    $0x41,%al
f01145c6:	75 09                	jne    f01145d1 <test_share_chunk+0x1b5>
f01145c8:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01145cb:	8a 00                	mov    (%eax),%al
f01145cd:	3c 42                	cmp    $0x42,%al
f01145cf:	74 1e                	je     f01145ef <test_share_chunk+0x1d3>
		{
			warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f01145d1:	83 ec 04             	sub    $0x4,%esp
f01145d4:	68 08 41 13 f0       	push   $0xf0134108
f01145d9:	68 82 04 00 00       	push   $0x482
f01145de:	68 f2 29 13 f0       	push   $0xf01329f2
f01145e3:	e8 6c ca fe ff       	call   f0101054 <_warn>
f01145e8:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01145eb:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01145ef:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01145f3:	74 04                	je     f01145f9 <test_share_chunk+0x1dd>
f01145f5:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01145f9:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		*ptr1 = tptr[1] ;
f01145fd:	8a 95 45 ff ff ff    	mov    -0xbb(%ebp),%dl
f0114603:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114606:	88 10                	mov    %dl,(%eax)
		*ptr2 = tptr[2] ;
f0114608:	8a 95 46 ff ff ff    	mov    -0xba(%ebp),%dl
f011460e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114611:	88 10                	mov    %dl,(%eax)
	}
	cprintf("\nCASE I: END\n") ;
f0114613:	83 ec 0c             	sub    $0xc,%esp
f0114616:	68 3d 41 13 f0       	push   $0xf013413d
f011461b:	e8 3c d5 fe ff       	call   f0101b5c <cprintf>
f0114620:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART II: Destination page(s) not exist [Supervisor] 25% */
	/*========================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor] [25%]\n") ;
f0114623:	83 ec 0c             	sub    $0xc,%esp
f0114626:	68 4c 41 13 f0       	push   $0xf013414c
f011462b:	e8 2c d5 fe ff       	call   f0101b5c <cprintf>
f0114630:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114633:	e8 70 a2 ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f0114638:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0000000,0x40000000, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f011463b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011463e:	c1 e0 05             	shl    $0x5,%eax
f0114641:	83 ec 0c             	sub    $0xc,%esp
f0114644:	68 02 0e 00 00       	push   $0xe02
f0114649:	50                   	push   %eax
f011464a:	68 00 00 00 40       	push   $0x40000000
f011464f:	68 00 00 00 f0       	push   $0xf0000000
f0114654:	ff 75 cc             	pushl  -0x34(%ebp)
f0114657:	e8 57 65 ff ff       	call   f010abb3 <share_chunk>
f011465c:	83 c4 20             	add    $0x20,%esp
f011465f:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114662:	e8 41 a2 ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f0114667:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (32*mega) / (4*mega))
f011466a:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f011466e:	75 1f                	jne    f011468f <test_share_chunk+0x273>
f0114670:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114673:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114676:	89 c1                	mov    %eax,%ecx
f0114678:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011467b:	c1 e0 05             	shl    $0x5,%eax
f011467e:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114681:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114688:	99                   	cltd   
f0114689:	f7 fb                	idiv   %ebx
f011468b:	39 c1                	cmp    %eax,%ecx
f011468d:	74 28                	je     f01146b7 <test_share_chunk+0x29b>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f011468f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114692:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114695:	83 ec 0c             	sub    $0xc,%esp
f0114698:	50                   	push   %eax
f0114699:	ff 75 a8             	pushl  -0x58(%ebp)
f011469c:	68 88 41 13 f0       	push   $0xf0134188
f01146a1:	68 9a 04 00 00       	push   $0x49a
f01146a6:	68 f2 29 13 f0       	push   $0xf01329f2
f01146ab:	e8 a4 c9 fe ff       	call   f0101054 <_warn>
f01146b0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01146b3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01146b7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01146bb:	74 04                	je     f01146c1 <test_share_chunk+0x2a5>
f01146bd:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01146c1:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f01146c5:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0xF0000000, 0x40000000, 32*mega, -1, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f01146cc:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01146cf:	c1 e0 05             	shl    $0x5,%eax
f01146d2:	83 ec 08             	sub    $0x8,%esp
f01146d5:	6a 02                	push   $0x2
f01146d7:	6a 07                	push   $0x7
f01146d9:	6a 03                	push   $0x3
f01146db:	68 07 0e 00 00       	push   $0xe07
f01146e0:	68 03 0e 00 00       	push   $0xe03
f01146e5:	6a ff                	push   $0xffffffff
f01146e7:	50                   	push   %eax
f01146e8:	68 00 00 00 40       	push   $0x40000000
f01146ed:	68 00 00 00 f0       	push   $0xf0000000
f01146f2:	ff 75 cc             	pushl  -0x34(%ebp)
f01146f5:	e8 78 28 00 00       	call   f0116f72 <CCP>
f01146fa:	83 c4 30             	add    $0x30,%esp
f01146fd:	85 c0                	test   %eax,%eax
f01146ff:	75 25                	jne    f0114726 <test_share_chunk+0x30a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114701:	83 ec 04             	sub    $0x4,%esp
f0114704:	68 c0 40 13 f0       	push   $0xf01340c0
f0114709:	68 a3 04 00 00       	push   $0x4a3
f011470e:	68 f2 29 13 f0       	push   $0xf01329f2
f0114713:	e8 3c c9 fe ff       	call   f0101054 <_warn>
f0114718:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011471b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f011471f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}

		if (CCP(proc_directory, 0xF0000000, 0x40000000, 12*kilo, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0114726:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114729:	89 d0                	mov    %edx,%eax
f011472b:	01 c0                	add    %eax,%eax
f011472d:	01 d0                	add    %edx,%eax
f011472f:	c1 e0 02             	shl    $0x2,%eax
f0114732:	83 ec 08             	sub    $0x8,%esp
f0114735:	6a 02                	push   $0x2
f0114737:	6a 07                	push   $0x7
f0114739:	6a 03                	push   $0x3
f011473b:	68 07 0e 00 00       	push   $0xe07
f0114740:	68 03 0e 00 00       	push   $0xe03
f0114745:	6a 02                	push   $0x2
f0114747:	50                   	push   %eax
f0114748:	68 00 00 00 40       	push   $0x40000000
f011474d:	68 00 00 00 f0       	push   $0xf0000000
f0114752:	ff 75 cc             	pushl  -0x34(%ebp)
f0114755:	e8 18 28 00 00       	call   f0116f72 <CCP>
f011475a:	83 c4 30             	add    $0x30,%esp
f011475d:	85 c0                	test   %eax,%eax
f011475f:	75 1e                	jne    f011477f <test_share_chunk+0x363>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114761:	83 ec 04             	sub    $0x4,%esp
f0114764:	68 c0 40 13 f0       	push   $0xf01340c0
f0114769:	68 aa 04 00 00       	push   $0x4aa
f011476e:	68 f2 29 13 f0       	push   $0xf01329f2
f0114773:	e8 dc c8 fe ff       	call   f0101054 <_warn>
f0114778:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011477b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011477f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114783:	74 04                	je     f0114789 <test_share_chunk+0x36d>
f0114785:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114789:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		extern char end_of_kernel[];
		uint32 endRange = ((uint32)end_of_kernel - KERNEL_BASE);
f011478d:	b8 d0 d6 87 f0       	mov    $0xf087d6d0,%eax
f0114792:	05 00 00 00 10       	add    $0x10000000,%eax
f0114797:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (CCP(proc_directory, 0xF0000000+PHYS_IO_MEM, 0x40000000+PHYS_IO_MEM, endRange - PHYS_IO_MEM, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f011479a:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011479d:	2d 00 00 0a 00       	sub    $0xa0000,%eax
f01147a2:	83 ec 08             	sub    $0x8,%esp
f01147a5:	6a 02                	push   $0x2
f01147a7:	6a 07                	push   $0x7
f01147a9:	6a 03                	push   $0x3
f01147ab:	68 07 0e 00 00       	push   $0xe07
f01147b0:	68 03 0e 00 00       	push   $0xe03
f01147b5:	6a 02                	push   $0x2
f01147b7:	50                   	push   %eax
f01147b8:	68 00 00 0a 40       	push   $0x400a0000
f01147bd:	68 00 00 0a f0       	push   $0xf00a0000
f01147c2:	ff 75 cc             	pushl  -0x34(%ebp)
f01147c5:	e8 a8 27 00 00       	call   f0116f72 <CCP>
f01147ca:	83 c4 30             	add    $0x30,%esp
f01147cd:	85 c0                	test   %eax,%eax
f01147cf:	75 1e                	jne    f01147ef <test_share_chunk+0x3d3>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01147d1:	83 ec 04             	sub    $0x4,%esp
f01147d4:	68 c0 40 13 f0       	push   $0xf01340c0
f01147d9:	68 b4 04 00 00       	push   $0x4b4
f01147de:	68 f2 29 13 f0       	push   $0xf01329f2
f01147e3:	e8 6c c8 fe ff       	call   f0101054 <_warn>
f01147e8:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01147eb:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01147ef:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01147f3:	74 04                	je     f01147f9 <test_share_chunk+0x3dd>
f01147f5:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01147f9:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f01147fd:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0114801:	0f 84 a4 00 00 00    	je     f01148ab <test_share_chunk+0x48f>
		{
			ptr1 = (char*)0xF00007FF; *ptr1 = 'A' ;
f0114807:	c7 45 bc ff 07 00 f0 	movl   $0xf00007ff,-0x44(%ebp)
f011480e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114811:	c6 00 41             	movb   $0x41,(%eax)
			ptr2 = (char*)0x400007FF;
f0114814:	c7 45 b8 ff 07 00 40 	movl   $0x400007ff,-0x48(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A')
f011481b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011481e:	8a 00                	mov    (%eax),%al
f0114820:	3c 41                	cmp    $0x41,%al
f0114822:	75 09                	jne    f011482d <test_share_chunk+0x411>
f0114824:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114827:	8a 00                	mov    (%eax),%al
f0114829:	3c 41                	cmp    $0x41,%al
f011482b:	74 1e                	je     f011484b <test_share_chunk+0x42f>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f011482d:	83 ec 04             	sub    $0x4,%esp
f0114830:	68 08 41 13 f0       	push   $0xf0134108
f0114835:	68 c1 04 00 00       	push   $0x4c1
f011483a:	68 f2 29 13 f0       	push   $0xf01329f2
f011483f:	e8 10 c8 fe ff       	call   f0101054 <_warn>
f0114844:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114847:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f011484b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011484f:	74 04                	je     f0114855 <test_share_chunk+0x439>
f0114851:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0114855:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

			ptr1 = (char*)0x41000FFF; *ptr1 = 'C' ;
f0114859:	c7 45 bc ff 0f 00 41 	movl   $0x41000fff,-0x44(%ebp)
f0114860:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114863:	c6 00 43             	movb   $0x43,(%eax)
			ptr2 = (char*)0xF1000FFF;
f0114866:	c7 45 b8 ff 0f 00 f1 	movl   $0xf1000fff,-0x48(%ebp)

			if ((*ptr1) != 'C' || (*ptr2) != 'C')
f011486d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114870:	8a 00                	mov    (%eax),%al
f0114872:	3c 43                	cmp    $0x43,%al
f0114874:	75 09                	jne    f011487f <test_share_chunk+0x463>
f0114876:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114879:	8a 00                	mov    (%eax),%al
f011487b:	3c 43                	cmp    $0x43,%al
f011487d:	74 1e                	je     f011489d <test_share_chunk+0x481>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f011487f:	83 ec 04             	sub    $0x4,%esp
f0114882:	68 08 41 13 f0       	push   $0xf0134108
f0114887:	68 cc 04 00 00       	push   $0x4cc
f011488c:	68 f2 29 13 f0       	push   $0xf01329f2
f0114891:	e8 be c7 fe ff       	call   f0101054 <_warn>
f0114896:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114899:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f011489d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01148a1:	74 04                	je     f01148a7 <test_share_chunk+0x48b>
f01148a3:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01148a7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f01148ab:	83 ec 0c             	sub    $0xc,%esp
f01148ae:	68 17 37 13 f0       	push   $0xf0133717
f01148b3:	e8 a4 d2 fe ff       	call   f0101b5c <cprintf>
f01148b8:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART III: Destination page(s) not exist [User r/w] 25%  */
	/*========================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [User r/w] [25%]\n") ;
f01148bb:	83 ec 0c             	sub    $0xc,%esp
f01148be:	68 d8 41 13 f0       	push   $0xf01341d8
f01148c3:	e8 94 d2 fe ff       	call   f0101b5c <cprintf>
f01148c8:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01148cb:	e8 d8 9f ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f01148d0:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x40000000,0x0, 648*kilo, PERM_WRITEABLE|PERM_USER) ;
f01148d3:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01148d6:	89 d0                	mov    %edx,%eax
f01148d8:	c1 e0 03             	shl    $0x3,%eax
f01148db:	01 d0                	add    %edx,%eax
f01148dd:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01148e4:	01 d0                	add    %edx,%eax
f01148e6:	c1 e0 03             	shl    $0x3,%eax
f01148e9:	83 ec 0c             	sub    $0xc,%esp
f01148ec:	6a 06                	push   $0x6
f01148ee:	50                   	push   %eax
f01148ef:	6a 00                	push   $0x0
f01148f1:	68 00 00 00 40       	push   $0x40000000
f01148f6:	ff 75 cc             	pushl  -0x34(%ebp)
f01148f9:	e8 b5 62 ff ff       	call   f010abb3 <share_chunk>
f01148fe:	83 c4 20             	add    $0x20,%esp
f0114901:	89 45 a0             	mov    %eax,-0x60(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114904:	e8 9f 9f ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f0114909:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f011490c:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
f0114910:	75 0b                	jne    f011491d <test_share_chunk+0x501>
f0114912:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114915:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114918:	83 f8 01             	cmp    $0x1,%eax
f011491b:	74 28                	je     f0114945 <test_share_chunk+0x529>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f011491d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114920:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114923:	83 ec 0c             	sub    $0xc,%esp
f0114926:	50                   	push   %eax
f0114927:	ff 75 a0             	pushl  -0x60(%ebp)
f011492a:	68 88 41 13 f0       	push   $0xf0134188
f011492f:	68 e2 04 00 00       	push   $0x4e2
f0114934:	68 f2 29 13 f0       	push   $0xf01329f2
f0114939:	e8 16 c7 fe ff       	call   f0101054 <_warn>
f011493e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114941:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114945:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114949:	74 04                	je     f011494f <test_share_chunk+0x533>
f011494b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011494f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0114953:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0x40000000, 0x0, PHYS_IO_MEM + 4*kilo, -1, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f011495a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011495d:	05 00 80 02 00       	add    $0x28000,%eax
f0114962:	c1 e0 02             	shl    $0x2,%eax
f0114965:	83 ec 08             	sub    $0x8,%esp
f0114968:	6a 02                	push   $0x2
f011496a:	6a 07                	push   $0x7
f011496c:	6a 03                	push   $0x3
f011496e:	6a 07                	push   $0x7
f0114970:	6a 07                	push   $0x7
f0114972:	6a ff                	push   $0xffffffff
f0114974:	50                   	push   %eax
f0114975:	6a 00                	push   $0x0
f0114977:	68 00 00 00 40       	push   $0x40000000
f011497c:	ff 75 cc             	pushl  -0x34(%ebp)
f011497f:	e8 ee 25 00 00       	call   f0116f72 <CCP>
f0114984:	83 c4 30             	add    $0x30,%esp
f0114987:	85 c0                	test   %eax,%eax
f0114989:	75 25                	jne    f01149b0 <test_share_chunk+0x594>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011498b:	83 ec 04             	sub    $0x4,%esp
f011498e:	68 c0 40 13 f0       	push   $0xf01340c0
f0114993:	68 eb 04 00 00       	push   $0x4eb
f0114998:	68 f2 29 13 f0       	push   $0xf01329f2
f011499d:	e8 b2 c6 fe ff       	call   f0101054 <_warn>
f01149a2:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01149a5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f01149a9:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}

		if (CCP(proc_directory, 0x40000000, 0x0, 12*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f01149b0:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01149b3:	89 d0                	mov    %edx,%eax
f01149b5:	01 c0                	add    %eax,%eax
f01149b7:	01 d0                	add    %edx,%eax
f01149b9:	c1 e0 02             	shl    $0x2,%eax
f01149bc:	83 ec 08             	sub    $0x8,%esp
f01149bf:	6a 02                	push   $0x2
f01149c1:	6a 07                	push   $0x7
f01149c3:	6a 03                	push   $0x3
f01149c5:	6a 07                	push   $0x7
f01149c7:	6a 07                	push   $0x7
f01149c9:	6a 03                	push   $0x3
f01149cb:	50                   	push   %eax
f01149cc:	6a 00                	push   $0x0
f01149ce:	68 00 00 00 40       	push   $0x40000000
f01149d3:	ff 75 cc             	pushl  -0x34(%ebp)
f01149d6:	e8 97 25 00 00       	call   f0116f72 <CCP>
f01149db:	83 c4 30             	add    $0x30,%esp
f01149de:	85 c0                	test   %eax,%eax
f01149e0:	75 1e                	jne    f0114a00 <test_share_chunk+0x5e4>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01149e2:	83 ec 04             	sub    $0x4,%esp
f01149e5:	68 c0 40 13 f0       	push   $0xf01340c0
f01149ea:	68 f2 04 00 00       	push   $0x4f2
f01149ef:	68 f2 29 13 f0       	push   $0xf01329f2
f01149f4:	e8 5b c6 fe ff       	call   f0101054 <_warn>
f01149f9:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01149fc:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114a00:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114a04:	74 04                	je     f0114a0a <test_share_chunk+0x5ee>
f0114a06:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114a0a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40003000, 0x3000, PHYS_IO_MEM - 12*kilo, 2, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0114a0e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114a11:	89 d0                	mov    %edx,%eax
f0114a13:	01 c0                	add    %eax,%eax
f0114a15:	01 d0                	add    %edx,%eax
f0114a17:	c1 e0 02             	shl    $0x2,%eax
f0114a1a:	f7 d8                	neg    %eax
f0114a1c:	05 00 00 0a 00       	add    $0xa0000,%eax
f0114a21:	83 ec 08             	sub    $0x8,%esp
f0114a24:	6a 02                	push   $0x2
f0114a26:	6a 07                	push   $0x7
f0114a28:	6a 03                	push   $0x3
f0114a2a:	6a 07                	push   $0x7
f0114a2c:	6a 07                	push   $0x7
f0114a2e:	6a 02                	push   $0x2
f0114a30:	50                   	push   %eax
f0114a31:	68 00 30 00 00       	push   $0x3000
f0114a36:	68 00 30 00 40       	push   $0x40003000
f0114a3b:	ff 75 cc             	pushl  -0x34(%ebp)
f0114a3e:	e8 2f 25 00 00       	call   f0116f72 <CCP>
f0114a43:	83 c4 30             	add    $0x30,%esp
f0114a46:	85 c0                	test   %eax,%eax
f0114a48:	75 1e                	jne    f0114a68 <test_share_chunk+0x64c>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114a4a:	83 ec 04             	sub    $0x4,%esp
f0114a4d:	68 c0 40 13 f0       	push   $0xf01340c0
f0114a52:	68 fa 04 00 00       	push   $0x4fa
f0114a57:	68 f2 29 13 f0       	push   $0xf01329f2
f0114a5c:	e8 f3 c5 fe ff       	call   f0101054 <_warn>
f0114a61:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114a64:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114a68:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114a6c:	74 04                	je     f0114a72 <test_share_chunk+0x656>
f0114a6e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114a72:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40000000+PHYS_IO_MEM, PHYS_IO_MEM, 4*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0114a76:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114a79:	c1 e0 02             	shl    $0x2,%eax
f0114a7c:	83 ec 08             	sub    $0x8,%esp
f0114a7f:	6a 02                	push   $0x2
f0114a81:	6a 07                	push   $0x7
f0114a83:	6a 03                	push   $0x3
f0114a85:	6a 07                	push   $0x7
f0114a87:	6a 07                	push   $0x7
f0114a89:	6a 03                	push   $0x3
f0114a8b:	50                   	push   %eax
f0114a8c:	68 00 00 0a 00       	push   $0xa0000
f0114a91:	68 00 00 0a 40       	push   $0x400a0000
f0114a96:	ff 75 cc             	pushl  -0x34(%ebp)
f0114a99:	e8 d4 24 00 00       	call   f0116f72 <CCP>
f0114a9e:	83 c4 30             	add    $0x30,%esp
f0114aa1:	85 c0                	test   %eax,%eax
f0114aa3:	75 1e                	jne    f0114ac3 <test_share_chunk+0x6a7>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114aa5:	83 ec 04             	sub    $0x4,%esp
f0114aa8:	68 c0 40 13 f0       	push   $0xf01340c0
f0114aad:	68 02 05 00 00       	push   $0x502
f0114ab2:	68 f2 29 13 f0       	push   $0xf01329f2
f0114ab7:	e8 98 c5 fe ff       	call   f0101054 <_warn>
f0114abc:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114abf:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114ac3:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114ac7:	74 04                	je     f0114acd <test_share_chunk+0x6b1>
f0114ac9:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114acd:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0114ad1:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0114ad5:	0f 84 92 00 00 00    	je     f0114b6d <test_share_chunk+0x751>
		{
			ptr1 = (char*)0x7FF;
f0114adb:	c7 45 bc ff 07 00 00 	movl   $0x7ff,-0x44(%ebp)
			ptr2 = (char*)0xF00007FF;
f0114ae2:	c7 45 b8 ff 07 00 f0 	movl   $0xf00007ff,-0x48(%ebp)
			ptr3 = (char*)0x400007FF;
f0114ae9:	c7 45 9c ff 07 00 40 	movl   $0x400007ff,-0x64(%ebp)
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
f0114af0:	c7 45 98 ff ff 09 00 	movl   $0x9ffff,-0x68(%ebp)
f0114af7:	8b 45 98             	mov    -0x68(%ebp),%eax
f0114afa:	c6 00 44             	movb   $0x44,(%eax)
			ptr5 = (char*)0xF009FFFF;
f0114afd:	c7 45 94 ff ff 09 f0 	movl   $0xf009ffff,-0x6c(%ebp)
			ptr6 = (char*)0x4009FFFF;
f0114b04:	c7 45 90 ff ff 09 40 	movl   $0x4009ffff,-0x70(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f0114b0b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114b0e:	8a 00                	mov    (%eax),%al
f0114b10:	3c 41                	cmp    $0x41,%al
f0114b12:	75 2d                	jne    f0114b41 <test_share_chunk+0x725>
f0114b14:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114b17:	8a 00                	mov    (%eax),%al
f0114b19:	3c 41                	cmp    $0x41,%al
f0114b1b:	75 24                	jne    f0114b41 <test_share_chunk+0x725>
f0114b1d:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0114b20:	8a 00                	mov    (%eax),%al
f0114b22:	3c 41                	cmp    $0x41,%al
f0114b24:	75 1b                	jne    f0114b41 <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f0114b26:	8b 45 98             	mov    -0x68(%ebp),%eax
f0114b29:	8a 00                	mov    (%eax),%al
			ptr3 = (char*)0x400007FF;
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
			ptr5 = (char*)0xF009FFFF;
			ptr6 = (char*)0x4009FFFF;

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f0114b2b:	3c 44                	cmp    $0x44,%al
f0114b2d:	75 12                	jne    f0114b41 <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f0114b2f:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114b32:	8a 00                	mov    (%eax),%al
f0114b34:	3c 44                	cmp    $0x44,%al
f0114b36:	75 09                	jne    f0114b41 <test_share_chunk+0x725>
f0114b38:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114b3b:	8a 00                	mov    (%eax),%al
f0114b3d:	3c 44                	cmp    $0x44,%al
f0114b3f:	74 1e                	je     f0114b5f <test_share_chunk+0x743>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0114b41:	83 ec 04             	sub    $0x4,%esp
f0114b44:	68 08 41 13 f0       	push   $0xf0134108
f0114b49:	68 14 05 00 00       	push   $0x514
f0114b4e:	68 f2 29 13 f0       	push   $0xf01329f2
f0114b53:	e8 fc c4 fe ff       	call   f0101054 <_warn>
f0114b58:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114b5b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0114b5f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114b63:	74 04                	je     f0114b69 <test_share_chunk+0x74d>
f0114b65:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0114b69:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f0114b6d:	83 ec 0c             	sub    $0xc,%esp
f0114b70:	68 7a 37 13 f0       	push   $0xf013377a
f0114b75:	e8 e2 cf fe ff       	call   f0101b5c <cprintf>
f0114b7a:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r] 30%     */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r] [30%]\n") ;
f0114b7d:	83 ec 0c             	sub    $0xc,%esp
f0114b80:	68 14 42 13 f0       	push   $0xf0134214
f0114b85:	e8 d2 cf fe ff       	call   f0101b5c <cprintf>
f0114b8a:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114b8d:	e8 16 9d ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f0114b92:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x9FC00,0x3FFC00, 7*kilo, PERM_USER) ;
f0114b95:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114b98:	89 d0                	mov    %edx,%eax
f0114b9a:	01 c0                	add    %eax,%eax
f0114b9c:	01 d0                	add    %edx,%eax
f0114b9e:	01 c0                	add    %eax,%eax
f0114ba0:	01 d0                	add    %edx,%eax
f0114ba2:	83 ec 0c             	sub    $0xc,%esp
f0114ba5:	6a 04                	push   $0x4
f0114ba7:	50                   	push   %eax
f0114ba8:	68 00 fc 3f 00       	push   $0x3ffc00
f0114bad:	68 00 fc 09 00       	push   $0x9fc00
f0114bb2:	ff 75 cc             	pushl  -0x34(%ebp)
f0114bb5:	e8 f9 5f ff ff       	call   f010abb3 <share_chunk>
f0114bba:	83 c4 20             	add    $0x20,%esp
f0114bbd:	89 45 8c             	mov    %eax,-0x74(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114bc0:	e8 e3 9c ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f0114bc5:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f0114bc8:	83 7d 8c 00          	cmpl   $0x0,-0x74(%ebp)
f0114bcc:	75 0b                	jne    f0114bd9 <test_share_chunk+0x7bd>
f0114bce:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114bd1:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114bd4:	83 f8 01             	cmp    $0x1,%eax
f0114bd7:	74 28                	je     f0114c01 <test_share_chunk+0x7e5>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0114bd9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114bdc:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114bdf:	83 ec 0c             	sub    $0xc,%esp
f0114be2:	50                   	push   %eax
f0114be3:	ff 75 8c             	pushl  -0x74(%ebp)
f0114be6:	68 88 41 13 f0       	push   $0xf0134188
f0114beb:	68 2a 05 00 00       	push   $0x52a
f0114bf0:	68 f2 29 13 f0       	push   $0xf01329f2
f0114bf5:	e8 5a c4 fe ff       	call   f0101054 <_warn>
f0114bfa:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114bfd:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0114c01:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114c05:	74 04                	je     f0114c0b <test_share_chunk+0x7ef>
f0114c07:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114c0b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0114c0f:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0x9F000, 0x3FF000, 12*kilo, -1, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0114c16:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114c19:	89 d0                	mov    %edx,%eax
f0114c1b:	01 c0                	add    %eax,%eax
f0114c1d:	01 d0                	add    %edx,%eax
f0114c1f:	c1 e0 02             	shl    $0x2,%eax
f0114c22:	83 ec 08             	sub    $0x8,%esp
f0114c25:	6a 02                	push   $0x2
f0114c27:	6a 07                	push   $0x7
f0114c29:	6a 07                	push   $0x7
f0114c2b:	6a 07                	push   $0x7
f0114c2d:	6a 05                	push   $0x5
f0114c2f:	6a ff                	push   $0xffffffff
f0114c31:	50                   	push   %eax
f0114c32:	68 00 f0 3f 00       	push   $0x3ff000
f0114c37:	68 00 f0 09 00       	push   $0x9f000
f0114c3c:	ff 75 cc             	pushl  -0x34(%ebp)
f0114c3f:	e8 2e 23 00 00       	call   f0116f72 <CCP>
f0114c44:	83 c4 30             	add    $0x30,%esp
f0114c47:	85 c0                	test   %eax,%eax
f0114c49:	75 25                	jne    f0114c70 <test_share_chunk+0x854>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114c4b:	83 ec 04             	sub    $0x4,%esp
f0114c4e:	68 c0 40 13 f0       	push   $0xf01340c0
f0114c53:	68 33 05 00 00       	push   $0x533
f0114c58:	68 f2 29 13 f0       	push   $0xf01329f2
f0114c5d:	e8 f2 c3 fe ff       	call   f0101054 <_warn>
f0114c62:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114c65:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0114c69:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 5 ;
f0114c70:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114c74:	74 04                	je     f0114c7a <test_share_chunk+0x85e>
f0114c76:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114c7a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x9F000, 0x3FF000, 4*kilo, 3, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0114c7e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114c81:	c1 e0 02             	shl    $0x2,%eax
f0114c84:	83 ec 08             	sub    $0x8,%esp
f0114c87:	6a 02                	push   $0x2
f0114c89:	6a 07                	push   $0x7
f0114c8b:	6a 07                	push   $0x7
f0114c8d:	6a 07                	push   $0x7
f0114c8f:	6a 05                	push   $0x5
f0114c91:	6a 03                	push   $0x3
f0114c93:	50                   	push   %eax
f0114c94:	68 00 f0 3f 00       	push   $0x3ff000
f0114c99:	68 00 f0 09 00       	push   $0x9f000
f0114c9e:	ff 75 cc             	pushl  -0x34(%ebp)
f0114ca1:	e8 cc 22 00 00       	call   f0116f72 <CCP>
f0114ca6:	83 c4 30             	add    $0x30,%esp
f0114ca9:	85 c0                	test   %eax,%eax
f0114cab:	75 1e                	jne    f0114ccb <test_share_chunk+0x8af>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114cad:	83 ec 04             	sub    $0x4,%esp
f0114cb0:	68 c0 40 13 f0       	push   $0xf01340c0
f0114cb5:	68 3c 05 00 00       	push   $0x53c
f0114cba:	68 f2 29 13 f0       	push   $0xf01329f2
f0114cbf:	e8 90 c3 fe ff       	call   f0101054 <_warn>
f0114cc4:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114cc7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114ccb:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114ccf:	74 04                	je     f0114cd5 <test_share_chunk+0x8b9>
f0114cd1:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114cd5:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xA0000, 0x400000, 8*kilo, 4, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0114cd9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114cdc:	c1 e0 03             	shl    $0x3,%eax
f0114cdf:	83 ec 08             	sub    $0x8,%esp
f0114ce2:	6a 02                	push   $0x2
f0114ce4:	6a 07                	push   $0x7
f0114ce6:	6a 07                	push   $0x7
f0114ce8:	6a 07                	push   $0x7
f0114cea:	6a 05                	push   $0x5
f0114cec:	6a 04                	push   $0x4
f0114cee:	50                   	push   %eax
f0114cef:	68 00 00 40 00       	push   $0x400000
f0114cf4:	68 00 00 0a 00       	push   $0xa0000
f0114cf9:	ff 75 cc             	pushl  -0x34(%ebp)
f0114cfc:	e8 71 22 00 00       	call   f0116f72 <CCP>
f0114d01:	83 c4 30             	add    $0x30,%esp
f0114d04:	85 c0                	test   %eax,%eax
f0114d06:	75 1e                	jne    f0114d26 <test_share_chunk+0x90a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114d08:	83 ec 04             	sub    $0x4,%esp
f0114d0b:	68 c0 40 13 f0       	push   $0xf01340c0
f0114d10:	68 44 05 00 00       	push   $0x544
f0114d15:	68 f2 29 13 f0       	push   $0xf01329f2
f0114d1a:	e8 35 c3 fe ff       	call   f0101054 <_warn>
f0114d1f:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114d22:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114d26:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114d2a:	74 04                	je     f0114d30 <test_share_chunk+0x914>
f0114d2c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114d30:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0114d34:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0114d38:	0f 84 b2 00 00 00    	je     f0114df0 <test_share_chunk+0x9d4>
		{
			ptr1 = (char*)0x0009FFFF;
f0114d3e:	c7 45 bc ff ff 09 00 	movl   $0x9ffff,-0x44(%ebp)
			ptr2 = (char*)0x003FFFFF;
f0114d45:	c7 45 b8 ff ff 3f 00 	movl   $0x3fffff,-0x48(%ebp)
			ptr3 = (char*)0x4009FFFF;
f0114d4c:	c7 45 9c ff ff 09 40 	movl   $0x4009ffff,-0x64(%ebp)
			ptr4 = (char*)0xF009FFFF;
f0114d53:	c7 45 98 ff ff 09 f0 	movl   $0xf009ffff,-0x68(%ebp)

			ptr5 = (char*)0x000A1001;
f0114d5a:	c7 45 94 01 10 0a 00 	movl   $0xa1001,-0x6c(%ebp)
			ptr6 = (char*)0x00401001;
f0114d61:	c7 45 90 01 10 40 00 	movl   $0x401001,-0x70(%ebp)
			ptr7 = (char*)0x400A1001;
f0114d68:	c7 45 88 01 10 0a 40 	movl   $0x400a1001,-0x78(%ebp)
			ptr8 = (char*)0xF00A1001;
f0114d6f:	c7 45 84 01 10 0a f0 	movl   $0xf00a1001,-0x7c(%ebp)

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f0114d76:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114d79:	8a 00                	mov    (%eax),%al
f0114d7b:	3c 44                	cmp    $0x44,%al
f0114d7d:	75 45                	jne    f0114dc4 <test_share_chunk+0x9a8>
f0114d7f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114d82:	8a 00                	mov    (%eax),%al
f0114d84:	3c 44                	cmp    $0x44,%al
f0114d86:	75 3c                	jne    f0114dc4 <test_share_chunk+0x9a8>
f0114d88:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0114d8b:	8a 00                	mov    (%eax),%al
f0114d8d:	3c 44                	cmp    $0x44,%al
f0114d8f:	75 33                	jne    f0114dc4 <test_share_chunk+0x9a8>
f0114d91:	8b 45 98             	mov    -0x68(%ebp),%eax
f0114d94:	8a 00                	mov    (%eax),%al
f0114d96:	3c 44                	cmp    $0x44,%al
f0114d98:	75 2a                	jne    f0114dc4 <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f0114d9a:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114d9d:	8a 10                	mov    (%eax),%dl
f0114d9f:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114da2:	8a 00                	mov    (%eax),%al
			ptr5 = (char*)0x000A1001;
			ptr6 = (char*)0x00401001;
			ptr7 = (char*)0x400A1001;
			ptr8 = (char*)0xF00A1001;

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f0114da4:	38 c2                	cmp    %al,%dl
f0114da6:	75 1c                	jne    f0114dc4 <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f0114da8:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114dab:	8a 10                	mov    (%eax),%dl
f0114dad:	8b 45 88             	mov    -0x78(%ebp),%eax
f0114db0:	8a 00                	mov    (%eax),%al
f0114db2:	38 c2                	cmp    %al,%dl
f0114db4:	75 0e                	jne    f0114dc4 <test_share_chunk+0x9a8>
f0114db6:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114db9:	8a 10                	mov    (%eax),%dl
f0114dbb:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0114dbe:	8a 00                	mov    (%eax),%al
f0114dc0:	38 c2                	cmp    %al,%dl
f0114dc2:	74 1e                	je     f0114de2 <test_share_chunk+0x9c6>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0114dc4:	83 ec 04             	sub    $0x4,%esp
f0114dc7:	68 08 41 13 f0       	push   $0xf0134108
f0114dcc:	68 59 05 00 00       	push   $0x559
f0114dd1:	68 f2 29 13 f0       	push   $0xf01329f2
f0114dd6:	e8 79 c2 fe ff       	call   f0101054 <_warn>
f0114ddb:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114dde:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0114de2:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114de6:	74 04                	je     f0114dec <test_share_chunk+0x9d0>
f0114de8:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0114dec:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE IV: END\n") ;
f0114df0:	83 ec 0c             	sub    $0xc,%esp
f0114df3:	68 4c 42 13 f0       	push   $0xf013424c
f0114df8:	e8 5f cd fe ff       	call   f0101b5c <cprintf>
f0114dfd:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] share_chunk: FINISHED. Evaluation = %d\n", eval);
f0114e00:	83 ec 08             	sub    $0x8,%esp
f0114e03:	ff 75 e4             	pushl  -0x1c(%ebp)
f0114e06:	68 5c 42 13 f0       	push   $0xf013425c
f0114e0b:	e8 4c cd fe ff       	call   f0101b5c <cprintf>
f0114e10:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0114e13:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0114e17:	75 10                	jne    f0114e29 <test_share_chunk+0xa0d>
		cprintf("Congratulations!! test share_chunk completed successfully.\n");
f0114e19:	83 ec 0c             	sub    $0xc,%esp
f0114e1c:	68 8c 42 13 f0       	push   $0xf013428c
f0114e21:	e8 36 cd fe ff       	call   f0101b5c <cprintf>
f0114e26:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0114e29:	a1 e0 6d 85 f0       	mov    0xf0856de0,%eax
f0114e2e:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0114e31:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0114e34:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0114e37:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0114e3c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0114e3f:	5b                   	pop    %ebx
f0114e40:	5e                   	pop    %esi
f0114e41:	5f                   	pop    %edi
f0114e42:	5d                   	pop    %ebp
f0114e43:	c3                   	ret    

f0114e44 <test_allocate_chunk>:

//===============================
// 4) TEST ALLOCATE CHUNK:
//===============================
int test_allocate_chunk()
{
f0114e44:	55                   	push   %ebp
f0114e45:	89 e5                	mov    %esp,%ebp
f0114e47:	57                   	push   %edi
f0114e48:	56                   	push   %esi
f0114e49:	53                   	push   %ebx
f0114e4a:	81 ec ac 00 00 00    	sub    $0xac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0114e50:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0114e56:	bb 8c 34 13 f0       	mov    $0xf013348c,%ebx
f0114e5b:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114e60:	89 c7                	mov    %eax,%edi
f0114e62:	89 de                	mov    %ebx,%esi
f0114e64:	89 d1                	mov    %edx,%ecx
f0114e66:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114e68:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f0114e6e:	b9 23 00 00 00       	mov    $0x23,%ecx
f0114e73:	b0 00                	mov    $0x0,%al
f0114e75:	89 d7                	mov    %edx,%edi
f0114e77:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0114e79:	6a 00                	push   $0x0
f0114e7b:	6a 0a                	push   $0xa
f0114e7d:	6a 14                	push   $0x14
f0114e7f:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0114e85:	50                   	push   %eax
f0114e86:	e8 d6 5f ff ff       	call   f010ae61 <env_create>
f0114e8b:	83 c4 10             	add    $0x10,%esp
f0114e8e:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0114e91:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114e94:	8b 40 64             	mov    0x64(%eax),%eax
f0114e97:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f0114e9a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114e9d:	8b 40 68             	mov    0x68(%eax),%eax
f0114ea0:	89 45 90             	mov    %eax,-0x70(%ebp)
f0114ea3:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114ea6:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f0114ea9:	83 ec 0c             	sub    $0xc,%esp
f0114eac:	ff 75 cc             	pushl  -0x34(%ebp)
f0114eaf:	e8 8a 20 00 00       	call   f0116f3e <ClearUserSpace>
f0114eb4:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0114eb7:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0114ebe:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f0114ec5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint8 correct =1 ;
f0114ecc:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 30% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [30%]\n") ;
f0114ed0:	83 ec 0c             	sub    $0xc,%esp
f0114ed3:	68 c8 42 13 f0       	push   $0xf01342c8
f0114ed8:	e8 7f cc fe ff       	call   f0101b5c <cprintf>
f0114edd:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)KERN_STACK_TOP - 1;
f0114ee0:	c7 45 e4 ff ff bf ef 	movl   $0xefbfffff,-0x1c(%ebp)
		ptr2 = (char*)KERN_STACK_TOP - 2;
f0114ee7:	c7 45 bc fe ff bf ef 	movl   $0xefbffffe,-0x44(%ebp)
		while ((ptr1 > (char*)(KERN_STACK_TOP - PAGE_SIZE)) && *ptr1 == 0)	ptr1-- ;
f0114eee:	eb 03                	jmp    f0114ef3 <test_allocate_chunk+0xaf>
f0114ef0:	ff 4d e4             	decl   -0x1c(%ebp)
f0114ef3:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f0114efa:	76 09                	jbe    f0114f05 <test_allocate_chunk+0xc1>
f0114efc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114eff:	8a 00                	mov    (%eax),%al
f0114f01:	84 c0                	test   %al,%al
f0114f03:	74 eb                	je     f0114ef0 <test_allocate_chunk+0xac>
		if (ptr1 == (char*)(KERN_STACK_TOP - PAGE_SIZE))	*ptr1 = 'A' ;
f0114f05:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f0114f0c:	75 06                	jne    f0114f14 <test_allocate_chunk+0xd0>
f0114f0e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114f11:	c6 00 41             	movb   $0x41,(%eax)
		tptr[1] = *ptr1 ;
f0114f14:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114f17:	8a 00                	mov    (%eax),%al
f0114f19:	88 85 55 ff ff ff    	mov    %al,-0xab(%ebp)
		tptr[2] = *ptr2 ;
f0114f1f:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114f22:	8a 00                	mov    (%eax),%al
f0114f24:	88 85 56 ff ff ff    	mov    %al,-0xaa(%ebp)
		cprintf("*ptr1 = %c\n", *ptr1) ;
f0114f2a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114f2d:	8a 00                	mov    (%eax),%al
f0114f2f:	0f be c0             	movsbl %al,%eax
f0114f32:	83 ec 08             	sub    $0x8,%esp
f0114f35:	50                   	push   %eax
f0114f36:	68 f2 42 13 f0       	push   $0xf01342f2
f0114f3b:	e8 1c cc fe ff       	call   f0101b5c <cprintf>
f0114f40:	83 c4 10             	add    $0x10,%esp
		cprintf("*ptr2 = %c\n", *ptr2) ;
f0114f43:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114f46:	8a 00                	mov    (%eax),%al
f0114f48:	0f be c0             	movsbl %al,%eax
f0114f4b:	83 ec 08             	sub    $0x8,%esp
f0114f4e:	50                   	push   %eax
f0114f4f:	68 fe 42 13 f0       	push   $0xf01342fe
f0114f54:	e8 03 cc fe ff       	call   f0101b5c <cprintf>
f0114f59:	83 c4 10             	add    $0x10,%esp
		uint32 old_perms = GP(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE) ;
f0114f5c:	83 ec 08             	sub    $0x8,%esp
f0114f5f:	68 00 f0 bf ef       	push   $0xefbff000
f0114f64:	ff 75 cc             	pushl  -0x34(%ebp)
f0114f67:	e8 b3 1f 00 00       	call   f0116f1f <GP>
f0114f6c:	83 c4 10             	add    $0x10,%esp
f0114f6f:	89 45 b8             	mov    %eax,-0x48(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114f72:	e8 31 99 ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f0114f77:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE, 4*kilo, PERM_WRITEABLE) ;
f0114f7a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114f7d:	c1 e0 02             	shl    $0x2,%eax
f0114f80:	6a 02                	push   $0x2
f0114f82:	50                   	push   %eax
f0114f83:	68 00 f0 bf ef       	push   $0xefbff000
f0114f88:	ff 75 cc             	pushl  -0x34(%ebp)
f0114f8b:	e8 3d 5c ff ff       	call   f010abcd <allocate_chunk>
f0114f90:	83 c4 10             	add    $0x10,%esp
f0114f93:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114f96:	e8 0d 99 ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f0114f9b:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0114f9e:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0114fa2:	75 08                	jne    f0114fac <test_allocate_chunk+0x168>
f0114fa4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114fa7:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0114faa:	74 2a                	je     f0114fd6 <test_allocate_chunk+0x192>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f0114fac:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114faf:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114fb2:	83 ec 08             	sub    $0x8,%esp
f0114fb5:	6a 00                	push   $0x0
f0114fb7:	50                   	push   %eax
f0114fb8:	ff 75 b0             	pushl  -0x50(%ebp)
f0114fbb:	68 0c 43 13 f0       	push   $0xf013430c
f0114fc0:	68 99 05 00 00       	push   $0x599
f0114fc5:	68 f2 29 13 f0       	push   $0xf01329f2
f0114fca:	e8 85 c0 fe ff       	call   f0101054 <_warn>
f0114fcf:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114fd2:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114fd6:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114fda:	74 04                	je     f0114fe0 <test_allocate_chunk+0x19c>
f0114fdc:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114fe0:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114fe4:	e8 bf 98 ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f0114fe9:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 5*kilo, 2*kilo, PERM_WRITEABLE) ;
f0114fec:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114fef:	01 c0                	add    %eax,%eax
f0114ff1:	89 c1                	mov    %eax,%ecx
f0114ff3:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114ff6:	89 d0                	mov    %edx,%eax
f0114ff8:	c1 e0 02             	shl    $0x2,%eax
f0114ffb:	01 d0                	add    %edx,%eax
f0114ffd:	f7 d8                	neg    %eax
f0114fff:	2d 00 00 40 10       	sub    $0x10400000,%eax
f0115004:	6a 02                	push   $0x2
f0115006:	51                   	push   %ecx
f0115007:	50                   	push   %eax
f0115008:	ff 75 cc             	pushl  -0x34(%ebp)
f011500b:	e8 bd 5b ff ff       	call   f010abcd <allocate_chunk>
f0115010:	83 c4 10             	add    $0x10,%esp
f0115013:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0115016:	e8 8d 98 ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f011501b:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f011501e:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0115022:	75 08                	jne    f011502c <test_allocate_chunk+0x1e8>
f0115024:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115027:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011502a:	74 2a                	je     f0115056 <test_allocate_chunk+0x212>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f011502c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011502f:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115032:	83 ec 08             	sub    $0x8,%esp
f0115035:	6a 00                	push   $0x0
f0115037:	50                   	push   %eax
f0115038:	ff 75 b0             	pushl  -0x50(%ebp)
f011503b:	68 0c 43 13 f0       	push   $0xf013430c
f0115040:	68 a7 05 00 00       	push   $0x5a7
f0115045:	68 f2 29 13 f0       	push   $0xf01329f2
f011504a:	e8 05 c0 fe ff       	call   f0101054 <_warn>
f011504f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115052:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0115056:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011505a:	74 04                	je     f0115060 <test_allocate_chunk+0x21c>
f011505c:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0115060:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (CCP(proc_directory, 0, KERN_STACK_TOP-1*PAGE_SIZE, 4*kilo, 1, old_perms, 0xFFF, 0, 0, CHK_ALLOC) == 0)
f0115064:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0115067:	c1 e0 02             	shl    $0x2,%eax
f011506a:	83 ec 08             	sub    $0x8,%esp
f011506d:	6a 03                	push   $0x3
f011506f:	6a 00                	push   $0x0
f0115071:	6a 00                	push   $0x0
f0115073:	68 ff 0f 00 00       	push   $0xfff
f0115078:	ff 75 b8             	pushl  -0x48(%ebp)
f011507b:	6a 01                	push   $0x1
f011507d:	50                   	push   %eax
f011507e:	68 00 f0 bf ef       	push   $0xefbff000
f0115083:	6a 00                	push   $0x0
f0115085:	ff 75 cc             	pushl  -0x34(%ebp)
f0115088:	e8 e5 1e 00 00       	call   f0116f72 <CCP>
f011508d:	83 c4 30             	add    $0x30,%esp
f0115090:	85 c0                	test   %eax,%eax
f0115092:	75 1e                	jne    f01150b2 <test_allocate_chunk+0x26e>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0115094:	83 ec 04             	sub    $0x4,%esp
f0115097:	68 74 43 13 f0       	push   $0xf0134374
f011509c:	68 af 05 00 00       	push   $0x5af
f01150a1:	68 f2 29 13 f0       	push   $0xf01329f2
f01150a6:	e8 a9 bf fe ff       	call   f0101054 <_warn>
f01150ab:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01150ae:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f01150b2:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01150b6:	74 04                	je     f01150bc <test_allocate_chunk+0x278>
f01150b8:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01150bc:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if ((*ptr1) != tptr[1] || (*ptr2) != tptr[2])
f01150c0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01150c3:	8a 10                	mov    (%eax),%dl
f01150c5:	8a 85 55 ff ff ff    	mov    -0xab(%ebp),%al
f01150cb:	38 c2                	cmp    %al,%dl
f01150cd:	75 0f                	jne    f01150de <test_allocate_chunk+0x29a>
f01150cf:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01150d2:	8a 10                	mov    (%eax),%dl
f01150d4:	8a 85 56 ff ff ff    	mov    -0xaa(%ebp),%al
f01150da:	38 c2                	cmp    %al,%dl
f01150dc:	74 1e                	je     f01150fc <test_allocate_chunk+0x2b8>
		{
			warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f01150de:	83 ec 04             	sub    $0x4,%esp
f01150e1:	68 c0 43 13 f0       	push   $0xf01343c0
f01150e6:	68 b7 05 00 00       	push   $0x5b7
f01150eb:	68 f2 29 13 f0       	push   $0xf01329f2
f01150f0:	e8 5f bf fe ff       	call   f0101054 <_warn>
f01150f5:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01150f8:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f01150fc:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115100:	74 04                	je     f0115106 <test_allocate_chunk+0x2c2>
f0115102:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0115106:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f011510a:	83 ec 0c             	sub    $0xc,%esp
f011510d:	68 3d 41 13 f0       	push   $0xf013413d
f0115112:	e8 45 ca fe ff       	call   f0101b5c <cprintf>
f0115117:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART II: Destination page(s) not exist [Supervisor r/w] 20% */
	/*============================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor r/w] [20%]\n") ;
f011511a:	83 ec 0c             	sub    $0xc,%esp
f011511d:	68 f8 43 13 f0       	push   $0xf01343f8
f0115122:	e8 35 ca fe ff       	call   f0101b5c <cprintf>
f0115127:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011512a:	e8 79 97 ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f011512f:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f0115132:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115135:	c1 e0 05             	shl    $0x5,%eax
f0115138:	68 02 0e 00 00       	push   $0xe02
f011513d:	50                   	push   %eax
f011513e:	6a 00                	push   $0x0
f0115140:	ff 75 cc             	pushl  -0x34(%ebp)
f0115143:	e8 85 5a ff ff       	call   f010abcd <allocate_chunk>
f0115148:	83 c4 10             	add    $0x10,%esp
f011514b:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011514e:	e8 55 97 ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f0115153:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((32*mega)/(4*mega) + (32*mega)/(4*kilo)))
f0115156:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f011515a:	75 36                	jne    f0115192 <test_allocate_chunk+0x34e>
f011515c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011515f:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115162:	89 c1                	mov    %eax,%ecx
f0115164:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115167:	c1 e0 05             	shl    $0x5,%eax
f011516a:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011516d:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115174:	99                   	cltd   
f0115175:	f7 fe                	idiv   %esi
f0115177:	89 c3                	mov    %eax,%ebx
f0115179:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011517c:	c1 e0 05             	shl    $0x5,%eax
f011517f:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115182:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115189:	99                   	cltd   
f011518a:	f7 fe                	idiv   %esi
f011518c:	01 d8                	add    %ebx,%eax
f011518e:	39 c1                	cmp    %eax,%ecx
f0115190:	74 54                	je     f01151e6 <test_allocate_chunk+0x3a2>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((32*mega)/(4*mega) + (32*mega)/(4*kilo)));
f0115192:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115195:	c1 e0 05             	shl    $0x5,%eax
f0115198:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011519b:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f01151a2:	99                   	cltd   
f01151a3:	f7 ff                	idiv   %edi
f01151a5:	89 c1                	mov    %eax,%ecx
f01151a7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01151aa:	c1 e0 05             	shl    $0x5,%eax
f01151ad:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01151b0:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01151b7:	99                   	cltd   
f01151b8:	f7 fe                	idiv   %esi
f01151ba:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f01151bd:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01151c0:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01151c3:	83 ec 08             	sub    $0x8,%esp
f01151c6:	52                   	push   %edx
f01151c7:	50                   	push   %eax
f01151c8:	ff 75 a8             	pushl  -0x58(%ebp)
f01151cb:	68 38 44 13 f0       	push   $0xf0134438
f01151d0:	68 cc 05 00 00       	push   $0x5cc
f01151d5:	68 f2 29 13 f0       	push   $0xf01329f2
f01151da:	e8 75 be fe ff       	call   f0101054 <_warn>
f01151df:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01151e2:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f01151e6:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01151ea:	74 04                	je     f01151f0 <test_allocate_chunk+0x3ac>
f01151ec:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01151f0:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f01151f4:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0, 0x0, 32*mega, 1, 0xE03, 0xE07, 0, 0, CHK_ALLOC) == 0)
f01151fb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01151fe:	c1 e0 05             	shl    $0x5,%eax
f0115201:	83 ec 08             	sub    $0x8,%esp
f0115204:	6a 03                	push   $0x3
f0115206:	6a 00                	push   $0x0
f0115208:	6a 00                	push   $0x0
f011520a:	68 07 0e 00 00       	push   $0xe07
f011520f:	68 03 0e 00 00       	push   $0xe03
f0115214:	6a 01                	push   $0x1
f0115216:	50                   	push   %eax
f0115217:	6a 00                	push   $0x0
f0115219:	6a 00                	push   $0x0
f011521b:	ff 75 cc             	pushl  -0x34(%ebp)
f011521e:	e8 4f 1d 00 00       	call   f0116f72 <CCP>
f0115223:	83 c4 30             	add    $0x30,%esp
f0115226:	85 c0                	test   %eax,%eax
f0115228:	75 25                	jne    f011524f <test_allocate_chunk+0x40b>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f011522a:	83 ec 04             	sub    $0x4,%esp
f011522d:	68 74 43 13 f0       	push   $0xf0134374
f0115232:	68 d5 05 00 00       	push   $0x5d5
f0115237:	68 f2 29 13 f0       	push   $0xf01329f2
f011523c:	e8 13 be fe ff       	call   f0101054 <_warn>
f0115241:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115244:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0115248:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}
		if (correct) eval += 10 ;
f011524f:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115253:	74 04                	je     f0115259 <test_allocate_chunk+0x415>
f0115255:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0115259:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f011525d:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0115261:	74 5a                	je     f01152bd <test_allocate_chunk+0x479>
		{
			ptr1 = (char*)(0x0+2*kilo); *ptr1 = 'K' ;
f0115263:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0115266:	01 c0                	add    %eax,%eax
f0115268:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011526b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011526e:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(0x0+2*mega); *ptr2 = 'M' ;
f0115271:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115274:	01 c0                	add    %eax,%eax
f0115276:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0115279:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011527c:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f011527f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0115282:	8a 00                	mov    (%eax),%al
f0115284:	3c 4b                	cmp    $0x4b,%al
f0115286:	75 09                	jne    f0115291 <test_allocate_chunk+0x44d>
f0115288:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011528b:	8a 00                	mov    (%eax),%al
f011528d:	3c 4d                	cmp    $0x4d,%al
f011528f:	74 1e                	je     f01152af <test_allocate_chunk+0x46b>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0115291:	83 ec 04             	sub    $0x4,%esp
f0115294:	68 c0 43 13 f0       	push   $0xf01343c0
f0115299:	68 e3 05 00 00       	push   $0x5e3
f011529e:	68 f2 29 13 f0       	push   $0xf01329f2
f01152a3:	e8 ac bd fe ff       	call   f0101054 <_warn>
f01152a8:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01152ab:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f01152af:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01152b3:	74 04                	je     f01152b9 <test_allocate_chunk+0x475>
f01152b5:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f01152b9:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f01152bd:	83 ec 0c             	sub    $0xc,%esp
f01152c0:	68 17 37 13 f0       	push   $0xf0133717
f01152c5:	e8 92 c8 fe ff       	call   f0101b5c <cprintf>
f01152ca:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART III: Destination page(s) not exist [Supervisor r] 15%  */
	/*============================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [Supervisor r] [15%]\n") ;
f01152cd:	83 ec 0c             	sub    $0xc,%esp
f01152d0:	68 98 44 13 f0       	push   $0xf0134498
f01152d5:	e8 82 c8 fe ff       	call   f0101b5c <cprintf>
f01152da:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01152dd:	e8 c6 95 ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f01152e2:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0+32*mega, 64*mega, 0) ;
f01152e5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01152e8:	c1 e0 06             	shl    $0x6,%eax
f01152eb:	89 c2                	mov    %eax,%edx
f01152ed:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01152f0:	c1 e0 05             	shl    $0x5,%eax
f01152f3:	6a 00                	push   $0x0
f01152f5:	52                   	push   %edx
f01152f6:	50                   	push   %eax
f01152f7:	ff 75 cc             	pushl  -0x34(%ebp)
f01152fa:	e8 ce 58 ff ff       	call   f010abcd <allocate_chunk>
f01152ff:	83 c4 10             	add    $0x10,%esp
f0115302:	89 45 a4             	mov    %eax,-0x5c(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0115305:	e8 9e 95 ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f011530a:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*mega) + (64*mega)/(4*kilo)))
f011530d:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
f0115311:	75 36                	jne    f0115349 <test_allocate_chunk+0x505>
f0115313:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115316:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115319:	89 c1                	mov    %eax,%ecx
f011531b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011531e:	c1 e0 06             	shl    $0x6,%eax
f0115321:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0115324:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f011532b:	99                   	cltd   
f011532c:	f7 ff                	idiv   %edi
f011532e:	89 c3                	mov    %eax,%ebx
f0115330:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115333:	c1 e0 06             	shl    $0x6,%eax
f0115336:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115339:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115340:	99                   	cltd   
f0115341:	f7 fe                	idiv   %esi
f0115343:	01 d8                	add    %ebx,%eax
f0115345:	39 c1                	cmp    %eax,%ecx
f0115347:	74 54                	je     f011539d <test_allocate_chunk+0x559>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*mega) + (64*mega)/(4*kilo)));
f0115349:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011534c:	c1 e0 06             	shl    $0x6,%eax
f011534f:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0115352:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115359:	99                   	cltd   
f011535a:	f7 fb                	idiv   %ebx
f011535c:	89 c1                	mov    %eax,%ecx
f011535e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115361:	c1 e0 06             	shl    $0x6,%eax
f0115364:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115367:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f011536e:	99                   	cltd   
f011536f:	f7 ff                	idiv   %edi
f0115371:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0115374:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115377:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011537a:	83 ec 08             	sub    $0x8,%esp
f011537d:	52                   	push   %edx
f011537e:	50                   	push   %eax
f011537f:	ff 75 a4             	pushl  -0x5c(%ebp)
f0115382:	68 38 44 13 f0       	push   $0xf0134438
f0115387:	68 f9 05 00 00       	push   $0x5f9
f011538c:	68 f2 29 13 f0       	push   $0xf01329f2
f0115391:	e8 be bc fe ff       	call   f0101054 <_warn>
f0115396:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115399:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f011539d:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01153a1:	74 04                	je     f01153a7 <test_allocate_chunk+0x563>
f01153a3:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01153a7:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f01153ab:	c7 45 a0 01 00 00 00 	movl   $0x1,-0x60(%ebp)
		if (CCP(proc_directory, 0, 0x0+32*mega, 64*mega, 1, 0x001, 0xE07, 0, 0, CHK_ALLOC) == 0)
f01153b2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01153b5:	c1 e0 06             	shl    $0x6,%eax
f01153b8:	89 c2                	mov    %eax,%edx
f01153ba:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01153bd:	c1 e0 05             	shl    $0x5,%eax
f01153c0:	83 ec 08             	sub    $0x8,%esp
f01153c3:	6a 03                	push   $0x3
f01153c5:	6a 00                	push   $0x0
f01153c7:	6a 00                	push   $0x0
f01153c9:	68 07 0e 00 00       	push   $0xe07
f01153ce:	6a 01                	push   $0x1
f01153d0:	6a 01                	push   $0x1
f01153d2:	52                   	push   %edx
f01153d3:	50                   	push   %eax
f01153d4:	6a 00                	push   $0x0
f01153d6:	ff 75 cc             	pushl  -0x34(%ebp)
f01153d9:	e8 94 1b 00 00       	call   f0116f72 <CCP>
f01153de:	83 c4 30             	add    $0x30,%esp
f01153e1:	85 c0                	test   %eax,%eax
f01153e3:	75 25                	jne    f011540a <test_allocate_chunk+0x5c6>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f01153e5:	83 ec 04             	sub    $0x4,%esp
f01153e8:	68 74 43 13 f0       	push   $0xf0134374
f01153ed:	68 02 06 00 00       	push   $0x602
f01153f2:	68 f2 29 13 f0       	push   $0xf01329f2
f01153f7:	e8 58 bc fe ff       	call   f0101054 <_warn>
f01153fc:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01153ff:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0115403:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%ebp)
		}
		if (correct) eval += 10 ;
f011540a:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011540e:	74 04                	je     f0115414 <test_allocate_chunk+0x5d0>
f0115410:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0115414:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE III: END\n") ;
f0115418:	83 ec 0c             	sub    $0xc,%esp
f011541b:	68 7a 37 13 f0       	push   $0xf013377a
f0115420:	e8 37 c7 fe ff       	call   f0101b5c <cprintf>
f0115425:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r/w] 20%  */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r/w] [20%]\n") ;
f0115428:	83 ec 0c             	sub    $0xc,%esp
f011542b:	68 d8 44 13 f0       	push   $0xf01344d8
f0115430:	e8 27 c7 fe ff       	call   f0101b5c <cprintf>
f0115435:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0115438:	e8 6b 94 ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f011543d:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, USER_HEAP_START, 64*mega, PERM_WRITEABLE|PERM_USER|PERM_AVAILABLE) ;
f0115440:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115443:	c1 e0 06             	shl    $0x6,%eax
f0115446:	68 06 0e 00 00       	push   $0xe06
f011544b:	50                   	push   %eax
f011544c:	68 00 00 00 80       	push   $0x80000000
f0115451:	ff 75 cc             	pushl  -0x34(%ebp)
f0115454:	e8 74 57 ff ff       	call   f010abcd <allocate_chunk>
f0115459:	83 c4 10             	add    $0x10,%esp
f011545c:	89 45 9c             	mov    %eax,-0x64(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011545f:	e8 44 94 ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f0115464:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*kilo)+(64*mega)/(4*mega)))
f0115467:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
f011546b:	75 36                	jne    f01154a3 <test_allocate_chunk+0x65f>
f011546d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115470:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115473:	89 c1                	mov    %eax,%ecx
f0115475:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115478:	c1 e0 06             	shl    $0x6,%eax
f011547b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011547e:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115485:	99                   	cltd   
f0115486:	f7 fb                	idiv   %ebx
f0115488:	89 c3                	mov    %eax,%ebx
f011548a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011548d:	c1 e0 06             	shl    $0x6,%eax
f0115490:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0115493:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f011549a:	99                   	cltd   
f011549b:	f7 fe                	idiv   %esi
f011549d:	01 d8                	add    %ebx,%eax
f011549f:	39 c1                	cmp    %eax,%ecx
f01154a1:	74 54                	je     f01154f7 <test_allocate_chunk+0x6b3>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*kilo)+(64*mega)/(4*mega)));
f01154a3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01154a6:	c1 e0 06             	shl    $0x6,%eax
f01154a9:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01154ac:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f01154b3:	99                   	cltd   
f01154b4:	f7 ff                	idiv   %edi
f01154b6:	89 c1                	mov    %eax,%ecx
f01154b8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01154bb:	c1 e0 06             	shl    $0x6,%eax
f01154be:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01154c1:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01154c8:	99                   	cltd   
f01154c9:	f7 fb                	idiv   %ebx
f01154cb:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f01154ce:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01154d1:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01154d4:	83 ec 08             	sub    $0x8,%esp
f01154d7:	52                   	push   %edx
f01154d8:	50                   	push   %eax
f01154d9:	ff 75 9c             	pushl  -0x64(%ebp)
f01154dc:	68 38 44 13 f0       	push   $0xf0134438
f01154e1:	68 18 06 00 00       	push   $0x618
f01154e6:	68 f2 29 13 f0       	push   $0xf01329f2
f01154eb:	e8 64 bb fe ff       	call   f0101054 <_warn>
f01154f0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01154f3:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f01154f7:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01154fb:	74 04                	je     f0115501 <test_allocate_chunk+0x6bd>
f01154fd:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0115501:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0115505:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0, USER_HEAP_START, 64*mega, 1, 0xE07, 0xE07, 0, 0, CHK_ALLOC) == 0)
f011550c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011550f:	c1 e0 06             	shl    $0x6,%eax
f0115512:	83 ec 08             	sub    $0x8,%esp
f0115515:	6a 03                	push   $0x3
f0115517:	6a 00                	push   $0x0
f0115519:	6a 00                	push   $0x0
f011551b:	68 07 0e 00 00       	push   $0xe07
f0115520:	68 07 0e 00 00       	push   $0xe07
f0115525:	6a 01                	push   $0x1
f0115527:	50                   	push   %eax
f0115528:	68 00 00 00 80       	push   $0x80000000
f011552d:	6a 00                	push   $0x0
f011552f:	ff 75 cc             	pushl  -0x34(%ebp)
f0115532:	e8 3b 1a 00 00       	call   f0116f72 <CCP>
f0115537:	83 c4 30             	add    $0x30,%esp
f011553a:	85 c0                	test   %eax,%eax
f011553c:	75 25                	jne    f0115563 <test_allocate_chunk+0x71f>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f011553e:	83 ec 04             	sub    $0x4,%esp
f0115541:	68 74 43 13 f0       	push   $0xf0134374
f0115546:	68 21 06 00 00       	push   $0x621
f011554b:	68 f2 29 13 f0       	push   $0xf01329f2
f0115550:	e8 ff ba fe ff       	call   f0101054 <_warn>
f0115555:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115558:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f011555c:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 10 ;
f0115563:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115567:	74 04                	je     f011556d <test_allocate_chunk+0x729>
f0115569:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f011556d:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f0115571:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0115575:	74 6f                	je     f01155e6 <test_allocate_chunk+0x7a2>
		{
			ptr1 = (char*)(USER_HEAP_START+2*kilo); *ptr1 = 'K' ;
f0115577:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011557a:	01 c0                	add    %eax,%eax
f011557c:	05 00 00 00 80       	add    $0x80000000,%eax
f0115581:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0115584:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0115587:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(USER_HEAP_START+22*mega);*ptr2 = 'M' ;
f011558a:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011558d:	89 d0                	mov    %edx,%eax
f011558f:	c1 e0 02             	shl    $0x2,%eax
f0115592:	01 d0                	add    %edx,%eax
f0115594:	01 c0                	add    %eax,%eax
f0115596:	01 d0                	add    %edx,%eax
f0115598:	01 c0                	add    %eax,%eax
f011559a:	05 00 00 00 80       	add    $0x80000000,%eax
f011559f:	89 45 bc             	mov    %eax,-0x44(%ebp)
f01155a2:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01155a5:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f01155a8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01155ab:	8a 00                	mov    (%eax),%al
f01155ad:	3c 4b                	cmp    $0x4b,%al
f01155af:	75 09                	jne    f01155ba <test_allocate_chunk+0x776>
f01155b1:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01155b4:	8a 00                	mov    (%eax),%al
f01155b6:	3c 4d                	cmp    $0x4d,%al
f01155b8:	74 1e                	je     f01155d8 <test_allocate_chunk+0x794>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f01155ba:	83 ec 04             	sub    $0x4,%esp
f01155bd:	68 c0 43 13 f0       	push   $0xf01343c0
f01155c2:	68 2f 06 00 00       	push   $0x62f
f01155c7:	68 f2 29 13 f0       	push   $0xf01329f2
f01155cc:	e8 83 ba fe ff       	call   f0101054 <_warn>
f01155d1:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01155d4:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f01155d8:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01155dc:	74 04                	je     f01155e2 <test_allocate_chunk+0x79e>
f01155de:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f01155e2:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		}
	}
	cprintf("\nCASE IV: END\n") ;
f01155e6:	83 ec 0c             	sub    $0xc,%esp
f01155e9:	68 4c 42 13 f0       	push   $0xf013424c
f01155ee:	e8 69 c5 fe ff       	call   f0101b5c <cprintf>
f01155f3:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART V: Destination page(s) not exist [User r] 15%     */
	/*========================================================*/
	cprintf("\nCASE V: Destination page(s) not exist [User r] [15%]\n") ;
f01155f6:	83 ec 0c             	sub    $0xc,%esp
f01155f9:	68 14 45 13 f0       	push   $0xf0134514
f01155fe:	e8 59 c5 fe ff       	call   f0101b5c <cprintf>
f0115603:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0115606:	e8 9d 92 ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f011560b:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory,0x403FFC00, 7*kilo, PERM_USER|PERM_AVAILABLE) ;
f011560e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115611:	89 d0                	mov    %edx,%eax
f0115613:	01 c0                	add    %eax,%eax
f0115615:	01 d0                	add    %edx,%eax
f0115617:	01 c0                	add    %eax,%eax
f0115619:	01 d0                	add    %edx,%eax
f011561b:	68 04 0e 00 00       	push   $0xe04
f0115620:	50                   	push   %eax
f0115621:	68 00 fc 3f 40       	push   $0x403ffc00
f0115626:	ff 75 cc             	pushl  -0x34(%ebp)
f0115629:	e8 9f 55 ff ff       	call   f010abcd <allocate_chunk>
f011562e:	83 c4 10             	add    $0x10,%esp
f0115631:	89 45 98             	mov    %eax,-0x68(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0115634:	e8 6f 92 ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f0115639:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (3+2))
f011563c:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0115640:	75 0b                	jne    f011564d <test_allocate_chunk+0x809>
f0115642:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115645:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115648:	83 f8 05             	cmp    $0x5,%eax
f011564b:	74 2a                	je     f0115677 <test_allocate_chunk+0x833>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, (3+2));
f011564d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115650:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115653:	83 ec 08             	sub    $0x8,%esp
f0115656:	6a 05                	push   $0x5
f0115658:	50                   	push   %eax
f0115659:	ff 75 98             	pushl  -0x68(%ebp)
f011565c:	68 38 44 13 f0       	push   $0xf0134438
f0115661:	68 46 06 00 00       	push   $0x646
f0115666:	68 f2 29 13 f0       	push   $0xf01329f2
f011566b:	e8 e4 b9 fe ff       	call   f0101054 <_warn>
f0115670:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115673:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0115677:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011567b:	74 04                	je     f0115681 <test_allocate_chunk+0x83d>
f011567d:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0115681:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0115685:	c7 45 94 01 00 00 00 	movl   $0x1,-0x6c(%ebp)
		if (CCP(proc_directory, 0, 0x403FF000, 12*kilo, 1, 0xE05, 0xE07, 0, 0, CHK_ALLOC) == 0)
f011568c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011568f:	89 d0                	mov    %edx,%eax
f0115691:	01 c0                	add    %eax,%eax
f0115693:	01 d0                	add    %edx,%eax
f0115695:	c1 e0 02             	shl    $0x2,%eax
f0115698:	83 ec 08             	sub    $0x8,%esp
f011569b:	6a 03                	push   $0x3
f011569d:	6a 00                	push   $0x0
f011569f:	6a 00                	push   $0x0
f01156a1:	68 07 0e 00 00       	push   $0xe07
f01156a6:	68 05 0e 00 00       	push   $0xe05
f01156ab:	6a 01                	push   $0x1
f01156ad:	50                   	push   %eax
f01156ae:	68 00 f0 3f 40       	push   $0x403ff000
f01156b3:	6a 00                	push   $0x0
f01156b5:	ff 75 cc             	pushl  -0x34(%ebp)
f01156b8:	e8 b5 18 00 00       	call   f0116f72 <CCP>
f01156bd:	83 c4 30             	add    $0x30,%esp
f01156c0:	85 c0                	test   %eax,%eax
f01156c2:	75 25                	jne    f01156e9 <test_allocate_chunk+0x8a5>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f01156c4:	83 ec 04             	sub    $0x4,%esp
f01156c7:	68 74 43 13 f0       	push   $0xf0134374
f01156cc:	68 4f 06 00 00       	push   $0x64f
f01156d1:	68 f2 29 13 f0       	push   $0xf01329f2
f01156d6:	e8 79 b9 fe ff       	call   f0101054 <_warn>
f01156db:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01156de:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f01156e2:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
		}
		if (correct) eval += 5 ;
f01156e9:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01156ed:	74 04                	je     f01156f3 <test_allocate_chunk+0x8af>
f01156ef:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01156f3:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

	}
	cprintf("\nCASE V: END\n") ;
f01156f7:	83 ec 0c             	sub    $0xc,%esp
f01156fa:	68 4b 45 13 f0       	push   $0xf013454b
f01156ff:	e8 58 c4 fe ff       	call   f0101b5c <cprintf>
f0115704:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] allocate_chunk: FINISHED. Evaluation = %d\n", eval);
f0115707:	83 ec 08             	sub    $0x8,%esp
f011570a:	ff 75 e0             	pushl  -0x20(%ebp)
f011570d:	68 5c 45 13 f0       	push   $0xf013455c
f0115712:	e8 45 c4 fe ff       	call   f0101b5c <cprintf>
f0115717:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f011571a:	83 7d e0 64          	cmpl   $0x64,-0x20(%ebp)
f011571e:	75 10                	jne    f0115730 <test_allocate_chunk+0x8ec>
		cprintf("Congratulations!! test allocate_chunk completed successfully.\n");
f0115720:	83 ec 0c             	sub    $0xc,%esp
f0115723:	68 90 45 13 f0       	push   $0xf0134590
f0115728:	e8 2f c4 fe ff       	call   f0101b5c <cprintf>
f011572d:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0115730:	a1 e0 6d 85 f0       	mov    0xf0856de0,%eax
f0115735:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0115738:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011573b:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f011573e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0115743:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0115746:	5b                   	pop    %ebx
f0115747:	5e                   	pop    %esi
f0115748:	5f                   	pop    %edi
f0115749:	5d                   	pop    %ebp
f011574a:	c3                   	ret    

f011574b <test_calculate_required_frames>:

//======================================
// 5) [+]TEST CALCULATE REQUIRED FRAMES:
//======================================
int test_calculate_required_frames()
{
f011574b:	55                   	push   %ebp
f011574c:	89 e5                	mov    %esp,%ebp
f011574e:	57                   	push   %edi
f011574f:	56                   	push   %esi
f0115750:	53                   	push   %ebx
f0115751:	81 ec fc 01 00 00    	sub    $0x1fc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0115757:	8d 45 8e             	lea    -0x72(%ebp),%eax
f011575a:	bb 8c 34 13 f0       	mov    $0xf013348c,%ebx
f011575f:	ba 0f 00 00 00       	mov    $0xf,%edx
f0115764:	89 c7                	mov    %eax,%edi
f0115766:	89 de                	mov    %ebx,%esi
f0115768:	89 d1                	mov    %edx,%ecx
f011576a:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011576c:	8d 55 9d             	lea    -0x63(%ebp),%edx
f011576f:	b9 23 00 00 00       	mov    $0x23,%ecx
f0115774:	b0 00                	mov    $0x0,%al
f0115776:	89 d7                	mov    %edx,%edi
f0115778:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f011577a:	6a 00                	push   $0x0
f011577c:	6a 0a                	push   $0xa
f011577e:	6a 14                	push   $0x14
f0115780:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115783:	50                   	push   %eax
f0115784:	e8 d8 56 ff ff       	call   f010ae61 <env_create>
f0115789:	83 c4 10             	add    $0x10,%esp
f011578c:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f011578f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115792:	8b 40 64             	mov    0x64(%eax),%eax
f0115795:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f0115798:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011579b:	8b 40 68             	mov    0x68(%eax),%eax
f011579e:	89 45 c0             	mov    %eax,-0x40(%ebp)
f01157a1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01157a4:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f01157a7:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f01157ae:	75 70 20 
f01157b1:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f01157b8:	00 00 00 
f01157bb:	8d 55 82             	lea    -0x7e(%ebp),%edx
f01157be:	b9 03 00 00 00       	mov    $0x3,%ecx
f01157c3:	b8 00 00 00 00       	mov    $0x0,%eax
f01157c8:	89 d7                	mov    %edx,%edi
f01157ca:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f01157cc:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01157cf:	8b 40 10             	mov    0x10(%eax),%eax
f01157d2:	83 ec 08             	sub    $0x8,%esp
f01157d5:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f01157db:	52                   	push   %edx
f01157dc:	50                   	push   %eax
f01157dd:	e8 ee 57 00 00       	call   f011afd0 <ltostr>
f01157e2:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f01157e5:	83 ec 04             	sub    $0x4,%esp
f01157e8:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01157ee:	50                   	push   %eax
f01157ef:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f01157f5:	50                   	push   %eax
f01157f6:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f01157fc:	50                   	push   %eax
f01157fd:	e8 a7 58 00 00       	call   f011b0a9 <strcconcat>
f0115802:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0115805:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f011580c:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0115813:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint32 res =0;
f011581a:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint8 correct = 1;
f0115821:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;

	ClearUserSpace(proc_directory);
f0115825:	83 ec 0c             	sub    $0xc,%esp
f0115828:	ff 75 d8             	pushl  -0x28(%ebp)
f011582b:	e8 0e 17 00 00       	call   f0116f3e <ClearUserSpace>
f0115830:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f0115833:	83 ec 0c             	sub    $0xc,%esp
f0115836:	68 d0 45 13 f0       	push   $0xf01345d0
f011583b:	e8 1c c3 fe ff       	call   f0101b5c <cprintf>
f0115840:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f0115843:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115846:	c1 e0 03             	shl    $0x3,%eax
f0115849:	83 ec 04             	sub    $0x4,%esp
f011584c:	50                   	push   %eax
f011584d:	6a 00                	push   $0x0
f011584f:	ff 75 d8             	pushl  -0x28(%ebp)
f0115852:	e8 c4 53 ff ff       	call   f010ac1b <calculate_required_frames>
f0115857:	83 c4 10             	add    $0x10,%esp
f011585a:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f011585d:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0115861:	74 23                	je     f0115886 <test_calculate_required_frames+0x13b>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0115863:	83 ec 0c             	sub    $0xc,%esp
f0115866:	6a 03                	push   $0x3
f0115868:	ff 75 c8             	pushl  -0x38(%ebp)
f011586b:	68 04 46 13 f0       	push   $0xf0134604
f0115870:	68 88 06 00 00       	push   $0x688
f0115875:	68 f2 29 13 f0       	push   $0xf01329f2
f011587a:	e8 d5 b7 fe ff       	call   f0101054 <_warn>
f011587f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115882:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115886:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011588a:	74 04                	je     f0115890 <test_calculate_required_frames+0x145>
f011588c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115890:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 4*mega);
f0115894:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115897:	c1 e0 02             	shl    $0x2,%eax
f011589a:	83 ec 04             	sub    $0x4,%esp
f011589d:	50                   	push   %eax
f011589e:	6a 00                	push   $0x0
f01158a0:	ff 75 d8             	pushl  -0x28(%ebp)
f01158a3:	e8 73 53 ff ff       	call   f010ac1b <calculate_required_frames>
f01158a8:	83 c4 10             	add    $0x10,%esp
f01158ab:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 1025)
f01158ae:	81 7d c8 01 04 00 00 	cmpl   $0x401,-0x38(%ebp)
f01158b5:	74 26                	je     f01158dd <test_calculate_required_frames+0x192>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 1025);
f01158b7:	83 ec 0c             	sub    $0xc,%esp
f01158ba:	68 01 04 00 00       	push   $0x401
f01158bf:	ff 75 c8             	pushl  -0x38(%ebp)
f01158c2:	68 04 46 13 f0       	push   $0xf0134604
f01158c7:	68 92 06 00 00       	push   $0x692
f01158cc:	68 f2 29 13 f0       	push   $0xf01329f2
f01158d1:	e8 7e b7 fe ff       	call   f0101054 <_warn>
f01158d6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01158d9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01158dd:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01158e1:	74 04                	je     f01158e7 <test_calculate_required_frames+0x19c>
f01158e3:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01158e7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f01158eb:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01158ee:	c1 e0 0a             	shl    $0xa,%eax
f01158f1:	83 ec 04             	sub    $0x4,%esp
f01158f4:	50                   	push   %eax
f01158f5:	6a 00                	push   $0x0
f01158f7:	ff 75 d8             	pushl  -0x28(%ebp)
f01158fa:	e8 1c 53 ff ff       	call   f010ac1b <calculate_required_frames>
f01158ff:	83 c4 10             	add    $0x10,%esp
f0115902:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)))
f0115905:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115908:	c1 e0 0a             	shl    $0xa,%eax
f011590b:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011590e:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115915:	99                   	cltd   
f0115916:	f7 fb                	idiv   %ebx
f0115918:	89 c1                	mov    %eax,%ecx
f011591a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011591d:	c1 e0 0a             	shl    $0xa,%eax
f0115920:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115923:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f011592a:	99                   	cltd   
f011592b:	f7 fe                	idiv   %esi
f011592d:	01 c8                	add    %ecx,%eax
f011592f:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0115932:	74 4c                	je     f0115980 <test_calculate_required_frames+0x235>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)));
f0115934:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115937:	c1 e0 0a             	shl    $0xa,%eax
f011593a:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011593d:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115944:	99                   	cltd   
f0115945:	f7 fb                	idiv   %ebx
f0115947:	89 c1                	mov    %eax,%ecx
f0115949:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011594c:	c1 e0 0a             	shl    $0xa,%eax
f011594f:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115952:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115959:	99                   	cltd   
f011595a:	f7 fe                	idiv   %esi
f011595c:	01 c8                	add    %ecx,%eax
f011595e:	83 ec 0c             	sub    $0xc,%esp
f0115961:	50                   	push   %eax
f0115962:	ff 75 c8             	pushl  -0x38(%ebp)
f0115965:	68 04 46 13 f0       	push   $0xf0134604
f011596a:	68 9c 06 00 00       	push   $0x69c
f011596f:	68 f2 29 13 f0       	push   $0xf01329f2
f0115974:	e8 db b6 fe ff       	call   f0101054 <_warn>
f0115979:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011597c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115980:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115984:	74 04                	je     f011598a <test_calculate_required_frames+0x23f>
f0115986:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011598a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test4
		res = calculate_required_frames(proc_directory, 0x1000, 6*kilo);
f011598e:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115991:	89 d0                	mov    %edx,%eax
f0115993:	01 c0                	add    %eax,%eax
f0115995:	01 d0                	add    %edx,%eax
f0115997:	01 c0                	add    %eax,%eax
f0115999:	83 ec 04             	sub    $0x4,%esp
f011599c:	50                   	push   %eax
f011599d:	68 00 10 00 00       	push   $0x1000
f01159a2:	ff 75 d8             	pushl  -0x28(%ebp)
f01159a5:	e8 71 52 ff ff       	call   f010ac1b <calculate_required_frames>
f01159aa:	83 c4 10             	add    $0x10,%esp
f01159ad:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f01159b0:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f01159b4:	74 23                	je     f01159d9 <test_calculate_required_frames+0x28e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f01159b6:	83 ec 0c             	sub    $0xc,%esp
f01159b9:	6a 03                	push   $0x3
f01159bb:	ff 75 c8             	pushl  -0x38(%ebp)
f01159be:	68 04 46 13 f0       	push   $0xf0134604
f01159c3:	68 a8 06 00 00       	push   $0x6a8
f01159c8:	68 f2 29 13 f0       	push   $0xf01329f2
f01159cd:	e8 82 b6 fe ff       	call   f0101054 <_warn>
f01159d2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01159d5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01159d9:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01159dd:	74 04                	je     f01159e3 <test_calculate_required_frames+0x298>
f01159df:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01159e3:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f01159e7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01159ea:	89 c2                	mov    %eax,%edx
f01159ec:	01 d2                	add    %edx,%edx
f01159ee:	01 d0                	add    %edx,%eax
f01159f0:	83 ec 04             	sub    $0x4,%esp
f01159f3:	50                   	push   %eax
f01159f4:	68 00 18 00 00       	push   $0x1800
f01159f9:	ff 75 d8             	pushl  -0x28(%ebp)
f01159fc:	e8 1a 52 ff ff       	call   f010ac1b <calculate_required_frames>
f0115a01:	83 c4 10             	add    $0x10,%esp
f0115a04:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0115a07:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0115a0b:	74 23                	je     f0115a30 <test_calculate_required_frames+0x2e5>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0115a0d:	83 ec 0c             	sub    $0xc,%esp
f0115a10:	6a 03                	push   $0x3
f0115a12:	ff 75 c8             	pushl  -0x38(%ebp)
f0115a15:	68 04 46 13 f0       	push   $0xf0134604
f0115a1a:	68 b2 06 00 00       	push   $0x6b2
f0115a1f:	68 f2 29 13 f0       	push   $0xf01329f2
f0115a24:	e8 2b b6 fe ff       	call   f0101054 <_warn>
f0115a29:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115a2c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115a30:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115a34:	74 04                	je     f0115a3a <test_calculate_required_frames+0x2ef>
f0115a36:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115a3a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f0115a3e:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115a41:	89 d0                	mov    %edx,%eax
f0115a43:	c1 e0 02             	shl    $0x2,%eax
f0115a46:	01 d0                	add    %edx,%eax
f0115a48:	01 c0                	add    %eax,%eax
f0115a4a:	83 ec 04             	sub    $0x4,%esp
f0115a4d:	50                   	push   %eax
f0115a4e:	68 00 00 40 00       	push   $0x400000
f0115a53:	ff 75 d8             	pushl  -0x28(%ebp)
f0115a56:	e8 c0 51 ff ff       	call   f010ac1b <calculate_required_frames>
f0115a5b:	83 c4 10             	add    $0x10,%esp
f0115a5e:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2563)
f0115a61:	81 7d c8 03 0a 00 00 	cmpl   $0xa03,-0x38(%ebp)
f0115a68:	74 26                	je     f0115a90 <test_calculate_required_frames+0x345>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f0115a6a:	83 ec 0c             	sub    $0xc,%esp
f0115a6d:	68 03 0a 00 00       	push   $0xa03
f0115a72:	ff 75 c8             	pushl  -0x38(%ebp)
f0115a75:	68 04 46 13 f0       	push   $0xf0134604
f0115a7a:	68 bc 06 00 00       	push   $0x6bc
f0115a7f:	68 f2 29 13 f0       	push   $0xf01329f2
f0115a84:	e8 cb b5 fe ff       	call   f0101054 <_warn>
f0115a89:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115a8c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115a90:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115a94:	74 04                	je     f0115a9a <test_calculate_required_frames+0x34f>
f0115a96:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115a9a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f0115a9e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115aa1:	01 c0                	add    %eax,%eax
f0115aa3:	83 ec 04             	sub    $0x4,%esp
f0115aa6:	50                   	push   %eax
f0115aa7:	68 00 00 70 00       	push   $0x700000
f0115aac:	ff 75 d8             	pushl  -0x28(%ebp)
f0115aaf:	e8 67 51 ff ff       	call   f010ac1b <calculate_required_frames>
f0115ab4:	83 c4 10             	add    $0x10,%esp
f0115ab7:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 514)
f0115aba:	81 7d c8 02 02 00 00 	cmpl   $0x202,-0x38(%ebp)
f0115ac1:	74 26                	je     f0115ae9 <test_calculate_required_frames+0x39e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 514);
f0115ac3:	83 ec 0c             	sub    $0xc,%esp
f0115ac6:	68 02 02 00 00       	push   $0x202
f0115acb:	ff 75 c8             	pushl  -0x38(%ebp)
f0115ace:	68 04 46 13 f0       	push   $0xf0134604
f0115ad3:	68 c8 06 00 00       	push   $0x6c8
f0115ad8:	68 f2 29 13 f0       	push   $0xf01329f2
f0115add:	e8 72 b5 fe ff       	call   f0101054 <_warn>
f0115ae2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115ae5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115ae9:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115aed:	74 04                	je     f0115af3 <test_calculate_required_frames+0x3a8>
f0115aef:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115af3:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f0115af7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115afa:	83 ec 04             	sub    $0x4,%esp
f0115afd:	50                   	push   %eax
f0115afe:	68 ff ff 3f 00       	push   $0x3fffff
f0115b03:	ff 75 d8             	pushl  -0x28(%ebp)
f0115b06:	e8 10 51 ff ff       	call   f010ac1b <calculate_required_frames>
f0115b0b:	83 c4 10             	add    $0x10,%esp
f0115b0e:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 4)
f0115b11:	83 7d c8 04          	cmpl   $0x4,-0x38(%ebp)
f0115b15:	74 23                	je     f0115b3a <test_calculate_required_frames+0x3ef>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 4);
f0115b17:	83 ec 0c             	sub    $0xc,%esp
f0115b1a:	6a 04                	push   $0x4
f0115b1c:	ff 75 c8             	pushl  -0x38(%ebp)
f0115b1f:	68 04 46 13 f0       	push   $0xf0134604
f0115b24:	68 d2 06 00 00       	push   $0x6d2
f0115b29:	68 f2 29 13 f0       	push   $0xf01329f2
f0115b2e:	e8 21 b5 fe ff       	call   f0101054 <_warn>
f0115b33:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115b36:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115b3a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115b3e:	74 04                	je     f0115b44 <test_calculate_required_frames+0x3f9>
f0115b40:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115b44:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0115b48:	83 ec 0c             	sub    $0xc,%esp
f0115b4b:	68 3d 41 13 f0       	push   $0xf013413d
f0115b50:	e8 07 c0 fe ff       	call   f0101b5c <cprintf>
f0115b55:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f0115b58:	83 ec 0c             	sub    $0xc,%esp
f0115b5b:	68 5c 46 13 f0       	push   $0xf013465c
f0115b60:	e8 f7 bf fe ff       	call   f0101b5c <cprintf>
f0115b65:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0115b68:	83 ec 04             	sub    $0x4,%esp
f0115b6b:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f0115b71:	50                   	push   %eax
f0115b72:	68 f6 34 13 f0       	push   $0xf01334f6
f0115b77:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115b7d:	50                   	push   %eax
f0115b7e:	e8 26 55 00 00       	call   f011b0a9 <strcconcat>
f0115b83:	83 c4 10             	add    $0x10,%esp
f0115b86:	83 ec 0c             	sub    $0xc,%esp
f0115b89:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f0115b8f:	50                   	push   %eax
f0115b90:	e8 86 c2 fe ff       	call   f0101e1b <execute_command>
f0115b95:	83 c4 10             	add    $0x10,%esp

		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f0115b98:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115b9b:	c1 e0 03             	shl    $0x3,%eax
f0115b9e:	83 ec 04             	sub    $0x4,%esp
f0115ba1:	50                   	push   %eax
f0115ba2:	6a 00                	push   $0x0
f0115ba4:	ff 75 d8             	pushl  -0x28(%ebp)
f0115ba7:	e8 6f 50 ff ff       	call   f010ac1b <calculate_required_frames>
f0115bac:	83 c4 10             	add    $0x10,%esp
f0115baf:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f0115bb2:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f0115bb9:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115bbc:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115bbf:	74 24                	je     f0115be5 <test_calculate_required_frames+0x49a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115bc1:	83 ec 0c             	sub    $0xc,%esp
f0115bc4:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115bc7:	ff 75 c8             	pushl  -0x38(%ebp)
f0115bca:	68 04 46 13 f0       	push   $0xf0134604
f0115bcf:	68 e6 06 00 00       	push   $0x6e6
f0115bd4:	68 f2 29 13 f0       	push   $0xf01329f2
f0115bd9:	e8 76 b4 fe ff       	call   f0101054 <_warn>
f0115bde:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115be1:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115be5:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115be9:	74 04                	je     f0115bef <test_calculate_required_frames+0x4a4>
f0115beb:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115bef:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f0115bf3:	83 ec 04             	sub    $0x4,%esp
f0115bf6:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115bfc:	50                   	push   %eax
f0115bfd:	68 03 35 13 f0       	push   $0xf0133503
f0115c02:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115c08:	50                   	push   %eax
f0115c09:	e8 9b 54 00 00       	call   f011b0a9 <strcconcat>
f0115c0e:	83 c4 10             	add    $0x10,%esp
f0115c11:	83 ec 0c             	sub    $0xc,%esp
f0115c14:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115c1a:	50                   	push   %eax
f0115c1b:	e8 fb c1 fe ff       	call   f0101e1b <execute_command>
f0115c20:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f0115c23:	83 ec 04             	sub    $0x4,%esp
f0115c26:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115c2c:	50                   	push   %eax
f0115c2d:	68 90 46 13 f0       	push   $0xf0134690
f0115c32:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115c38:	50                   	push   %eax
f0115c39:	e8 6b 54 00 00       	call   f011b0a9 <strcconcat>
f0115c3e:	83 c4 10             	add    $0x10,%esp
f0115c41:	83 ec 0c             	sub    $0xc,%esp
f0115c44:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115c4a:	50                   	push   %eax
f0115c4b:	e8 cb c1 fe ff       	call   f0101e1b <execute_command>
f0115c50:	83 c4 10             	add    $0x10,%esp

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 8*mega);
f0115c53:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115c56:	c1 e0 03             	shl    $0x3,%eax
f0115c59:	83 ec 04             	sub    $0x4,%esp
f0115c5c:	50                   	push   %eax
f0115c5d:	6a 00                	push   $0x0
f0115c5f:	ff 75 d8             	pushl  -0x28(%ebp)
f0115c62:	e8 b4 4f ff ff       	call   f010ac1b <calculate_required_frames>
f0115c67:	83 c4 10             	add    $0x10,%esp
f0115c6a:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 2047;
f0115c6d:	c7 45 c4 ff 07 00 00 	movl   $0x7ff,-0x3c(%ebp)
		if (res != expected)
f0115c74:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115c77:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115c7a:	74 24                	je     f0115ca0 <test_calculate_required_frames+0x555>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115c7c:	83 ec 0c             	sub    $0xc,%esp
f0115c7f:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115c82:	ff 75 c8             	pushl  -0x38(%ebp)
f0115c85:	68 04 46 13 f0       	push   $0xf0134604
f0115c8a:	68 f4 06 00 00       	push   $0x6f4
f0115c8f:	68 f2 29 13 f0       	push   $0xf01329f2
f0115c94:	e8 bb b3 fe ff       	call   f0101054 <_warn>
f0115c99:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115c9c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115ca0:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115ca4:	74 04                	je     f0115caa <test_calculate_required_frames+0x55f>
f0115ca6:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115caa:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f0115cae:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115cb1:	c1 e0 0a             	shl    $0xa,%eax
f0115cb4:	83 ec 04             	sub    $0x4,%esp
f0115cb7:	50                   	push   %eax
f0115cb8:	6a 00                	push   $0x0
f0115cba:	ff 75 d8             	pushl  -0x28(%ebp)
f0115cbd:	e8 59 4f ff ff       	call   f010ac1b <calculate_required_frames>
f0115cc2:	83 c4 10             	add    $0x10,%esp
f0115cc5:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)) - 2 - 1 - 2;
f0115cc8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115ccb:	c1 e0 0a             	shl    $0xa,%eax
f0115cce:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115cd1:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115cd8:	99                   	cltd   
f0115cd9:	f7 fb                	idiv   %ebx
f0115cdb:	89 c1                	mov    %eax,%ecx
f0115cdd:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115ce0:	c1 e0 0a             	shl    $0xa,%eax
f0115ce3:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115ce6:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115ced:	99                   	cltd   
f0115cee:	f7 fe                	idiv   %esi
f0115cf0:	01 c8                	add    %ecx,%eax
f0115cf2:	83 e8 05             	sub    $0x5,%eax
f0115cf5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (res != expected)
f0115cf8:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115cfb:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115cfe:	74 24                	je     f0115d24 <test_calculate_required_frames+0x5d9>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115d00:	83 ec 0c             	sub    $0xc,%esp
f0115d03:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115d06:	ff 75 c8             	pushl  -0x38(%ebp)
f0115d09:	68 04 46 13 f0       	push   $0xf0134604
f0115d0e:	68 ff 06 00 00       	push   $0x6ff
f0115d13:	68 f2 29 13 f0       	push   $0xf01329f2
f0115d18:	e8 37 b3 fe ff       	call   f0101054 <_warn>
f0115d1d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115d20:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115d24:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115d28:	74 04                	je     f0115d2e <test_calculate_required_frames+0x5e3>
f0115d2a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115d2e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f0115d32:	83 ec 04             	sub    $0x4,%esp
f0115d35:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115d3b:	50                   	push   %eax
f0115d3c:	68 9c 46 13 f0       	push   $0xf013469c
f0115d41:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115d47:	50                   	push   %eax
f0115d48:	e8 5c 53 00 00       	call   f011b0a9 <strcconcat>
f0115d4d:	83 c4 10             	add    $0x10,%esp
f0115d50:	83 ec 0c             	sub    $0xc,%esp
f0115d53:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115d59:	50                   	push   %eax
f0115d5a:	e8 bc c0 fe ff       	call   f0101e1b <execute_command>
f0115d5f:	83 c4 10             	add    $0x10,%esp

		//Test4
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f0115d62:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115d65:	89 c2                	mov    %eax,%edx
f0115d67:	01 d2                	add    %edx,%edx
f0115d69:	01 d0                	add    %edx,%eax
f0115d6b:	83 ec 04             	sub    $0x4,%esp
f0115d6e:	50                   	push   %eax
f0115d6f:	68 00 18 00 00       	push   $0x1800
f0115d74:	ff 75 d8             	pushl  -0x28(%ebp)
f0115d77:	e8 9f 4e ff ff       	call   f010ac1b <calculate_required_frames>
f0115d7c:	83 c4 10             	add    $0x10,%esp
f0115d7f:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f0115d82:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f0115d89:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115d8c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115d8f:	74 24                	je     f0115db5 <test_calculate_required_frames+0x66a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115d91:	83 ec 0c             	sub    $0xc,%esp
f0115d94:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115d97:	ff 75 c8             	pushl  -0x38(%ebp)
f0115d9a:	68 04 46 13 f0       	push   $0xf0134604
f0115d9f:	68 0e 07 00 00       	push   $0x70e
f0115da4:	68 f2 29 13 f0       	push   $0xf01329f2
f0115da9:	e8 a6 b2 fe ff       	call   f0101054 <_warn>
f0115dae:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115db1:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115db5:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115db9:	74 04                	je     f0115dbf <test_calculate_required_frames+0x674>
f0115dbb:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115dbf:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f0115dc3:	83 ec 04             	sub    $0x4,%esp
f0115dc6:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115dcc:	50                   	push   %eax
f0115dcd:	68 5c 37 13 f0       	push   $0xf013375c
f0115dd2:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115dd8:	50                   	push   %eax
f0115dd9:	e8 cb 52 00 00       	call   f011b0a9 <strcconcat>
f0115dde:	83 c4 10             	add    $0x10,%esp
f0115de1:	83 ec 0c             	sub    $0xc,%esp
f0115de4:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115dea:	50                   	push   %eax
f0115deb:	e8 2b c0 fe ff       	call   f0101e1b <execute_command>
f0115df0:	83 c4 10             	add    $0x10,%esp

		//Test5
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f0115df3:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115df6:	89 d0                	mov    %edx,%eax
f0115df8:	c1 e0 02             	shl    $0x2,%eax
f0115dfb:	01 d0                	add    %edx,%eax
f0115dfd:	01 c0                	add    %eax,%eax
f0115dff:	83 ec 04             	sub    $0x4,%esp
f0115e02:	50                   	push   %eax
f0115e03:	68 00 00 40 00       	push   $0x400000
f0115e08:	ff 75 d8             	pushl  -0x28(%ebp)
f0115e0b:	e8 0b 4e ff ff       	call   f010ac1b <calculate_required_frames>
f0115e10:	83 c4 10             	add    $0x10,%esp
f0115e13:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2561)
f0115e16:	81 7d c8 01 0a 00 00 	cmpl   $0xa01,-0x38(%ebp)
f0115e1d:	74 26                	je     f0115e45 <test_calculate_required_frames+0x6fa>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f0115e1f:	83 ec 0c             	sub    $0xc,%esp
f0115e22:	68 03 0a 00 00       	push   $0xa03
f0115e27:	ff 75 c8             	pushl  -0x38(%ebp)
f0115e2a:	68 04 46 13 f0       	push   $0xf0134604
f0115e2f:	68 1a 07 00 00       	push   $0x71a
f0115e34:	68 f2 29 13 f0       	push   $0xf01329f2
f0115e39:	e8 16 b2 fe ff       	call   f0101054 <_warn>
f0115e3e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115e41:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115e45:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115e49:	74 04                	je     f0115e4f <test_calculate_required_frames+0x704>
f0115e4b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115e4f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f0115e53:	83 ec 04             	sub    $0x4,%esp
f0115e56:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115e5c:	50                   	push   %eax
f0115e5d:	68 66 37 13 f0       	push   $0xf0133766
f0115e62:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115e68:	50                   	push   %eax
f0115e69:	e8 3b 52 00 00       	call   f011b0a9 <strcconcat>
f0115e6e:	83 c4 10             	add    $0x10,%esp
f0115e71:	83 ec 0c             	sub    $0xc,%esp
f0115e74:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115e7a:	50                   	push   %eax
f0115e7b:	e8 9b bf fe ff       	call   f0101e1b <execute_command>
f0115e80:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f0115e83:	83 ec 04             	sub    $0x4,%esp
f0115e86:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115e8c:	50                   	push   %eax
f0115e8d:	68 a4 46 13 f0       	push   $0xf01346a4
f0115e92:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115e98:	50                   	push   %eax
f0115e99:	e8 0b 52 00 00       	call   f011b0a9 <strcconcat>
f0115e9e:	83 c4 10             	add    $0x10,%esp
f0115ea1:	83 ec 0c             	sub    $0xc,%esp
f0115ea4:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115eaa:	50                   	push   %eax
f0115eab:	e8 6b bf fe ff       	call   f0101e1b <execute_command>
f0115eb0:	83 c4 10             	add    $0x10,%esp

		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f0115eb3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115eb6:	01 c0                	add    %eax,%eax
f0115eb8:	83 ec 04             	sub    $0x4,%esp
f0115ebb:	50                   	push   %eax
f0115ebc:	68 00 00 70 00       	push   $0x700000
f0115ec1:	ff 75 d8             	pushl  -0x28(%ebp)
f0115ec4:	e8 52 4d ff ff       	call   f010ac1b <calculate_required_frames>
f0115ec9:	83 c4 10             	add    $0x10,%esp
f0115ecc:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 510 ;
f0115ecf:	c7 45 c4 fe 01 00 00 	movl   $0x1fe,-0x3c(%ebp)
		if (res != expected)
f0115ed6:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115ed9:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115edc:	74 24                	je     f0115f02 <test_calculate_required_frames+0x7b7>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115ede:	83 ec 0c             	sub    $0xc,%esp
f0115ee1:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115ee4:	ff 75 c8             	pushl  -0x38(%ebp)
f0115ee7:	68 04 46 13 f0       	push   $0xf0134604
f0115eec:	68 2a 07 00 00       	push   $0x72a
f0115ef1:	68 f2 29 13 f0       	push   $0xf01329f2
f0115ef6:	e8 59 b1 fe ff       	call   f0101054 <_warn>
f0115efb:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115efe:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115f02:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115f06:	74 04                	je     f0115f0c <test_calculate_required_frames+0x7c1>
f0115f08:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115f0c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f0115f10:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115f13:	83 ec 04             	sub    $0x4,%esp
f0115f16:	50                   	push   %eax
f0115f17:	68 ff ff 3f 00       	push   $0x3fffff
f0115f1c:	ff 75 d8             	pushl  -0x28(%ebp)
f0115f1f:	e8 f7 4c ff ff       	call   f010ac1b <calculate_required_frames>
f0115f24:	83 c4 10             	add    $0x10,%esp
f0115f27:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 3 ;
f0115f2a:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (res != expected)
f0115f31:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115f34:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115f37:	74 24                	je     f0115f5d <test_calculate_required_frames+0x812>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115f39:	83 ec 0c             	sub    $0xc,%esp
f0115f3c:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115f3f:	ff 75 c8             	pushl  -0x38(%ebp)
f0115f42:	68 04 46 13 f0       	push   $0xf0134604
f0115f47:	68 35 07 00 00       	push   $0x735
f0115f4c:	68 f2 29 13 f0       	push   $0xf01329f2
f0115f51:	e8 fe b0 fe ff       	call   f0101054 <_warn>
f0115f56:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115f59:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115f5d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115f61:	74 04                	je     f0115f67 <test_calculate_required_frames+0x81c>
f0115f63:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115f67:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f0115f6b:	83 ec 0c             	sub    $0xc,%esp
f0115f6e:	68 17 37 13 f0       	push   $0xf0133717
f0115f73:	e8 e4 bb fe ff       	call   f0101b5c <cprintf>
f0115f78:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_required_frames: FINISHED. Evaluation = %d\n", eval);
f0115f7b:	83 ec 08             	sub    $0x8,%esp
f0115f7e:	ff 75 e4             	pushl  -0x1c(%ebp)
f0115f81:	68 b0 46 13 f0       	push   $0xf01346b0
f0115f86:	e8 d1 bb fe ff       	call   f0101b5c <cprintf>
f0115f8b:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0115f8e:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0115f92:	75 10                	jne    f0115fa4 <test_calculate_required_frames+0x859>
		cprintf("Congratulations!! test calculate_required_frames completed successfully.\n");
f0115f94:	83 ec 0c             	sub    $0xc,%esp
f0115f97:	68 f0 46 13 f0       	push   $0xf01346f0
f0115f9c:	e8 bb bb fe ff       	call   f0101b5c <cprintf>
f0115fa1:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0115fa4:	a1 e0 6d 85 f0       	mov    0xf0856de0,%eax
f0115fa9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0115fac:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0115faf:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0115fb2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0115fb7:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0115fba:	5b                   	pop    %ebx
f0115fbb:	5e                   	pop    %esi
f0115fbc:	5f                   	pop    %edi
f0115fbd:	5d                   	pop    %ebp
f0115fbe:	c3                   	ret    

f0115fbf <test_calculate_allocated_space>:

int test_calculate_allocated_space()
{
f0115fbf:	55                   	push   %ebp
f0115fc0:	89 e5                	mov    %esp,%ebp
f0115fc2:	57                   	push   %edi
f0115fc3:	56                   	push   %esi
f0115fc4:	53                   	push   %ebx
f0115fc5:	81 ec 0c 02 00 00    	sub    $0x20c,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0115fcb:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115fce:	bb 8c 34 13 f0       	mov    $0xf013348c,%ebx
f0115fd3:	ba 0f 00 00 00       	mov    $0xf,%edx
f0115fd8:	89 c7                	mov    %eax,%edi
f0115fda:	89 de                	mov    %ebx,%esi
f0115fdc:	89 d1                	mov    %edx,%ecx
f0115fde:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0115fe0:	8d 55 9d             	lea    -0x63(%ebp),%edx
f0115fe3:	b9 23 00 00 00       	mov    $0x23,%ecx
f0115fe8:	b0 00                	mov    $0x0,%al
f0115fea:	89 d7                	mov    %edx,%edi
f0115fec:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0115fee:	6a 00                	push   $0x0
f0115ff0:	6a 0a                	push   $0xa
f0115ff2:	6a 14                	push   $0x14
f0115ff4:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115ff7:	50                   	push   %eax
f0115ff8:	e8 64 4e ff ff       	call   f010ae61 <env_create>
f0115ffd:	83 c4 10             	add    $0x10,%esp
f0116000:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0116003:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116006:	8b 40 64             	mov    0x64(%eax),%eax
f0116009:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f011600c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011600f:	8b 40 68             	mov    0x68(%eax),%eax
f0116012:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0116015:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116018:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f011601b:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f0116022:	75 70 20 
f0116025:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f011602c:	00 00 00 
f011602f:	8d 55 82             	lea    -0x7e(%ebp),%edx
f0116032:	b9 03 00 00 00       	mov    $0x3,%ecx
f0116037:	b8 00 00 00 00       	mov    $0x0,%eax
f011603c:	89 d7                	mov    %edx,%edi
f011603e:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0116040:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116043:	8b 40 10             	mov    0x10(%eax),%eax
f0116046:	83 ec 08             	sub    $0x8,%esp
f0116049:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f011604f:	52                   	push   %edx
f0116050:	50                   	push   %eax
f0116051:	e8 7a 4f 00 00       	call   f011afd0 <ltostr>
f0116056:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0116059:	83 ec 04             	sub    $0x4,%esp
f011605c:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116062:	50                   	push   %eax
f0116063:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f0116069:	50                   	push   %eax
f011606a:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f0116070:	50                   	push   %eax
f0116071:	e8 33 50 00 00       	call   f011b0a9 <strcconcat>
f0116076:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0116079:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f0116080:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0116087:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct = 1;
f011608e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected_num_pages;
	uint32 expected_num_tables;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;
	uint32 num_pages = 0;
f0116092:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116099:	00 00 00 
	uint32 num_tables = 0;
f011609c:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01160a3:	00 00 00 
	ClearUserSpace(proc_directory);
f01160a6:	83 ec 0c             	sub    $0xc,%esp
f01160a9:	ff 75 d8             	pushl  -0x28(%ebp)
f01160ac:	e8 8d 0e 00 00       	call   f0116f3e <ClearUserSpace>
f01160b1:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f01160b4:	83 ec 0c             	sub    $0xc,%esp
f01160b7:	68 d0 45 13 f0       	push   $0xf01345d0
f01160bc:	e8 9b ba fe ff       	call   f0101b5c <cprintf>
f01160c1:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f01160c4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01160c7:	c1 e0 03             	shl    $0x3,%eax
f01160ca:	89 c2                	mov    %eax,%edx
f01160cc:	83 ec 0c             	sub    $0xc,%esp
f01160cf:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01160d5:	50                   	push   %eax
f01160d6:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01160dc:	50                   	push   %eax
f01160dd:	52                   	push   %edx
f01160de:	6a 00                	push   $0x0
f01160e0:	ff 75 d8             	pushl  -0x28(%ebp)
f01160e3:	e8 19 4b ff ff       	call   f010ac01 <calculate_allocated_space>
f01160e8:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01160eb:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01160f1:	85 c0                	test   %eax,%eax
f01160f3:	74 27                	je     f011611c <test_calculate_allocated_space+0x15d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01160f5:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01160fb:	83 ec 0c             	sub    $0xc,%esp
f01160fe:	6a 00                	push   $0x0
f0116100:	50                   	push   %eax
f0116101:	68 3c 47 13 f0       	push   $0xf013473c
f0116106:	68 6a 07 00 00       	push   $0x76a
f011610b:	68 f2 29 13 f0       	push   $0xf01329f2
f0116110:	e8 3f af fe ff       	call   f0101054 <_warn>
f0116115:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116118:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f011611c:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116122:	85 c0                	test   %eax,%eax
f0116124:	74 27                	je     f011614d <test_calculate_allocated_space+0x18e>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0116126:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011612c:	83 ec 0c             	sub    $0xc,%esp
f011612f:	6a 00                	push   $0x0
f0116131:	50                   	push   %eax
f0116132:	68 9c 47 13 f0       	push   $0xf013479c
f0116137:	68 6f 07 00 00       	push   $0x76f
f011613c:	68 f2 29 13 f0       	push   $0xf01329f2
f0116141:	e8 0e af fe ff       	call   f0101054 <_warn>
f0116146:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116149:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011614d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116151:	74 04                	je     f0116157 <test_calculate_allocated_space+0x198>
f0116153:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116157:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		num_tables = 0;
f011615b:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116162:	00 00 00 
		num_pages = 0;
f0116165:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011616c:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+4*mega, &num_tables, &num_pages);
f011616f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116172:	c1 e0 02             	shl    $0x2,%eax
f0116175:	89 c2                	mov    %eax,%edx
f0116177:	83 ec 0c             	sub    $0xc,%esp
f011617a:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116180:	50                   	push   %eax
f0116181:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116187:	50                   	push   %eax
f0116188:	52                   	push   %edx
f0116189:	6a 00                	push   $0x0
f011618b:	ff 75 d8             	pushl  -0x28(%ebp)
f011618e:	e8 6e 4a ff ff       	call   f010ac01 <calculate_allocated_space>
f0116193:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0116196:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011619c:	85 c0                	test   %eax,%eax
f011619e:	74 27                	je     f01161c7 <test_calculate_allocated_space+0x208>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01161a0:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01161a6:	83 ec 0c             	sub    $0xc,%esp
f01161a9:	6a 00                	push   $0x0
f01161ab:	50                   	push   %eax
f01161ac:	68 3c 47 13 f0       	push   $0xf013473c
f01161b1:	68 7b 07 00 00       	push   $0x77b
f01161b6:	68 f2 29 13 f0       	push   $0xf01329f2
f01161bb:	e8 94 ae fe ff       	call   f0101054 <_warn>
f01161c0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01161c3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f01161c7:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01161cd:	85 c0                	test   %eax,%eax
f01161cf:	74 27                	je     f01161f8 <test_calculate_allocated_space+0x239>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f01161d1:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01161d7:	83 ec 0c             	sub    $0xc,%esp
f01161da:	6a 00                	push   $0x0
f01161dc:	50                   	push   %eax
f01161dd:	68 9c 47 13 f0       	push   $0xf013479c
f01161e2:	68 80 07 00 00       	push   $0x780
f01161e7:	68 f2 29 13 f0       	push   $0xf01329f2
f01161ec:	e8 63 ae fe ff       	call   f0101054 <_warn>
f01161f1:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01161f4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01161f8:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01161fc:	74 04                	je     f0116202 <test_calculate_allocated_space+0x243>
f01161fe:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116202:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f0116206:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011620d:	00 00 00 
		num_pages = 0;
f0116210:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116217:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f011621a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011621d:	c1 e0 0a             	shl    $0xa,%eax
f0116220:	89 c2                	mov    %eax,%edx
f0116222:	83 ec 0c             	sub    $0xc,%esp
f0116225:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011622b:	50                   	push   %eax
f011622c:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116232:	50                   	push   %eax
f0116233:	52                   	push   %edx
f0116234:	6a 00                	push   $0x0
f0116236:	ff 75 d8             	pushl  -0x28(%ebp)
f0116239:	e8 c3 49 ff ff       	call   f010ac01 <calculate_allocated_space>
f011623e:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0116241:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116247:	85 c0                	test   %eax,%eax
f0116249:	74 27                	je     f0116272 <test_calculate_allocated_space+0x2b3>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f011624b:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116251:	83 ec 0c             	sub    $0xc,%esp
f0116254:	6a 00                	push   $0x0
f0116256:	50                   	push   %eax
f0116257:	68 3c 47 13 f0       	push   $0xf013473c
f011625c:	68 8c 07 00 00       	push   $0x78c
f0116261:	68 f2 29 13 f0       	push   $0xf01329f2
f0116266:	e8 e9 ad fe ff       	call   f0101054 <_warn>
f011626b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011626e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0116272:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116278:	85 c0                	test   %eax,%eax
f011627a:	74 27                	je     f01162a3 <test_calculate_allocated_space+0x2e4>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f011627c:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116282:	83 ec 0c             	sub    $0xc,%esp
f0116285:	6a 00                	push   $0x0
f0116287:	50                   	push   %eax
f0116288:	68 9c 47 13 f0       	push   $0xf013479c
f011628d:	68 91 07 00 00       	push   $0x791
f0116292:	68 f2 29 13 f0       	push   $0xf01329f2
f0116297:	e8 b8 ad fe ff       	call   f0101054 <_warn>
f011629c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011629f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01162a3:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01162a7:	74 04                	je     f01162ad <test_calculate_allocated_space+0x2ee>
f01162a9:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01162ad:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test4
		num_tables = 0;
f01162b1:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01162b8:	00 00 00 
		num_pages = 0;
f01162bb:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01162c2:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1000, 0x1000+6*kilo, &num_tables, &num_pages);
f01162c5:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01162c8:	89 d0                	mov    %edx,%eax
f01162ca:	01 c0                	add    %eax,%eax
f01162cc:	01 d0                	add    %edx,%eax
f01162ce:	01 c0                	add    %eax,%eax
f01162d0:	05 00 10 00 00       	add    $0x1000,%eax
f01162d5:	89 c2                	mov    %eax,%edx
f01162d7:	83 ec 0c             	sub    $0xc,%esp
f01162da:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01162e0:	50                   	push   %eax
f01162e1:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01162e7:	50                   	push   %eax
f01162e8:	52                   	push   %edx
f01162e9:	68 00 10 00 00       	push   $0x1000
f01162ee:	ff 75 d8             	pushl  -0x28(%ebp)
f01162f1:	e8 0b 49 ff ff       	call   f010ac01 <calculate_allocated_space>
f01162f6:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01162f9:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01162ff:	85 c0                	test   %eax,%eax
f0116301:	74 27                	je     f011632a <test_calculate_allocated_space+0x36b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0116303:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116309:	83 ec 0c             	sub    $0xc,%esp
f011630c:	6a 00                	push   $0x0
f011630e:	50                   	push   %eax
f011630f:	68 3c 47 13 f0       	push   $0xf013473c
f0116314:	68 9e 07 00 00       	push   $0x79e
f0116319:	68 f2 29 13 f0       	push   $0xf01329f2
f011631e:	e8 31 ad fe ff       	call   f0101054 <_warn>
f0116323:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116326:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f011632a:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116330:	85 c0                	test   %eax,%eax
f0116332:	74 27                	je     f011635b <test_calculate_allocated_space+0x39c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0116334:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011633a:	83 ec 0c             	sub    $0xc,%esp
f011633d:	6a 00                	push   $0x0
f011633f:	50                   	push   %eax
f0116340:	68 9c 47 13 f0       	push   $0xf013479c
f0116345:	68 a3 07 00 00       	push   $0x7a3
f011634a:	68 f2 29 13 f0       	push   $0xf01329f2
f011634f:	e8 00 ad fe ff       	call   f0101054 <_warn>
f0116354:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116357:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011635b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011635f:	74 04                	je     f0116365 <test_calculate_allocated_space+0x3a6>
f0116361:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116365:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		num_tables = 0;
f0116369:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116370:	00 00 00 
		num_pages = 0;
f0116373:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011637a:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f011637d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116380:	89 c2                	mov    %eax,%edx
f0116382:	01 d2                	add    %edx,%edx
f0116384:	01 d0                	add    %edx,%eax
f0116386:	05 00 18 00 00       	add    $0x1800,%eax
f011638b:	89 c2                	mov    %eax,%edx
f011638d:	83 ec 0c             	sub    $0xc,%esp
f0116390:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116396:	50                   	push   %eax
f0116397:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011639d:	50                   	push   %eax
f011639e:	52                   	push   %edx
f011639f:	68 00 18 00 00       	push   $0x1800
f01163a4:	ff 75 d8             	pushl  -0x28(%ebp)
f01163a7:	e8 55 48 ff ff       	call   f010ac01 <calculate_allocated_space>
f01163ac:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01163af:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01163b5:	85 c0                	test   %eax,%eax
f01163b7:	74 27                	je     f01163e0 <test_calculate_allocated_space+0x421>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01163b9:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01163bf:	83 ec 0c             	sub    $0xc,%esp
f01163c2:	6a 00                	push   $0x0
f01163c4:	50                   	push   %eax
f01163c5:	68 3c 47 13 f0       	push   $0xf013473c
f01163ca:	68 af 07 00 00       	push   $0x7af
f01163cf:	68 f2 29 13 f0       	push   $0xf01329f2
f01163d4:	e8 7b ac fe ff       	call   f0101054 <_warn>
f01163d9:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01163dc:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f01163e0:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01163e6:	85 c0                	test   %eax,%eax
f01163e8:	74 27                	je     f0116411 <test_calculate_allocated_space+0x452>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f01163ea:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01163f0:	83 ec 0c             	sub    $0xc,%esp
f01163f3:	6a 00                	push   $0x0
f01163f5:	50                   	push   %eax
f01163f6:	68 9c 47 13 f0       	push   $0xf013479c
f01163fb:	68 b4 07 00 00       	push   $0x7b4
f0116400:	68 f2 29 13 f0       	push   $0xf01329f2
f0116405:	e8 4a ac fe ff       	call   f0101054 <_warn>
f011640a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011640d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116411:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116415:	74 04                	je     f011641b <test_calculate_allocated_space+0x45c>
f0116417:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011641b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		num_tables = 0;
f011641f:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116426:	00 00 00 
		num_pages = 0;
f0116429:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116430:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f0116433:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0116436:	89 d0                	mov    %edx,%eax
f0116438:	c1 e0 02             	shl    $0x2,%eax
f011643b:	01 d0                	add    %edx,%eax
f011643d:	01 c0                	add    %eax,%eax
f011643f:	05 00 00 40 00       	add    $0x400000,%eax
f0116444:	89 c2                	mov    %eax,%edx
f0116446:	83 ec 0c             	sub    $0xc,%esp
f0116449:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011644f:	50                   	push   %eax
f0116450:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116456:	50                   	push   %eax
f0116457:	52                   	push   %edx
f0116458:	68 00 00 40 00       	push   $0x400000
f011645d:	ff 75 d8             	pushl  -0x28(%ebp)
f0116460:	e8 9c 47 ff ff       	call   f010ac01 <calculate_allocated_space>
f0116465:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0116468:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011646e:	85 c0                	test   %eax,%eax
f0116470:	74 27                	je     f0116499 <test_calculate_allocated_space+0x4da>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0116472:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116478:	83 ec 0c             	sub    $0xc,%esp
f011647b:	6a 00                	push   $0x0
f011647d:	50                   	push   %eax
f011647e:	68 3c 47 13 f0       	push   $0xf013473c
f0116483:	68 c0 07 00 00       	push   $0x7c0
f0116488:	68 f2 29 13 f0       	push   $0xf01329f2
f011648d:	e8 c2 ab fe ff       	call   f0101054 <_warn>
f0116492:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116495:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0116499:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011649f:	85 c0                	test   %eax,%eax
f01164a1:	74 27                	je     f01164ca <test_calculate_allocated_space+0x50b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f01164a3:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01164a9:	83 ec 0c             	sub    $0xc,%esp
f01164ac:	6a 00                	push   $0x0
f01164ae:	50                   	push   %eax
f01164af:	68 9c 47 13 f0       	push   $0xf013479c
f01164b4:	68 c5 07 00 00       	push   $0x7c5
f01164b9:	68 f2 29 13 f0       	push   $0xf01329f2
f01164be:	e8 91 ab fe ff       	call   f0101054 <_warn>
f01164c3:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01164c6:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01164ca:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01164ce:	74 04                	je     f01164d4 <test_calculate_allocated_space+0x515>
f01164d0:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01164d4:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test7
		num_tables = 0;
f01164d8:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01164df:	00 00 00 
		num_pages = 0;
f01164e2:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01164e9:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f01164ec:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01164ef:	05 00 00 38 00       	add    $0x380000,%eax
f01164f4:	01 c0                	add    %eax,%eax
f01164f6:	89 c2                	mov    %eax,%edx
f01164f8:	83 ec 0c             	sub    $0xc,%esp
f01164fb:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116501:	50                   	push   %eax
f0116502:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116508:	50                   	push   %eax
f0116509:	52                   	push   %edx
f011650a:	68 00 00 70 00       	push   $0x700000
f011650f:	ff 75 d8             	pushl  -0x28(%ebp)
f0116512:	e8 ea 46 ff ff       	call   f010ac01 <calculate_allocated_space>
f0116517:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f011651a:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116520:	85 c0                	test   %eax,%eax
f0116522:	74 27                	je     f011654b <test_calculate_allocated_space+0x58c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0116524:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011652a:	83 ec 0c             	sub    $0xc,%esp
f011652d:	6a 00                	push   $0x0
f011652f:	50                   	push   %eax
f0116530:	68 3c 47 13 f0       	push   $0xf013473c
f0116535:	68 d2 07 00 00       	push   $0x7d2
f011653a:	68 f2 29 13 f0       	push   $0xf01329f2
f011653f:	e8 10 ab fe ff       	call   f0101054 <_warn>
f0116544:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116547:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f011654b:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116551:	85 c0                	test   %eax,%eax
f0116553:	74 27                	je     f011657c <test_calculate_allocated_space+0x5bd>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0116555:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011655b:	83 ec 0c             	sub    $0xc,%esp
f011655e:	6a 00                	push   $0x0
f0116560:	50                   	push   %eax
f0116561:	68 9c 47 13 f0       	push   $0xf013479c
f0116566:	68 d7 07 00 00       	push   $0x7d7
f011656b:	68 f2 29 13 f0       	push   $0xf01329f2
f0116570:	e8 df aa fe ff       	call   f0101054 <_warn>
f0116575:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116578:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011657c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116580:	74 04                	je     f0116586 <test_calculate_allocated_space+0x5c7>
f0116582:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116586:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		num_tables = 0;
f011658a:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116591:	00 00 00 
		num_pages = 0;
f0116594:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011659b:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f011659e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01165a1:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f01165a6:	89 c2                	mov    %eax,%edx
f01165a8:	83 ec 0c             	sub    $0xc,%esp
f01165ab:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01165b1:	50                   	push   %eax
f01165b2:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01165b8:	50                   	push   %eax
f01165b9:	52                   	push   %edx
f01165ba:	68 ff ff 3f 00       	push   $0x3fffff
f01165bf:	ff 75 d8             	pushl  -0x28(%ebp)
f01165c2:	e8 3a 46 ff ff       	call   f010ac01 <calculate_allocated_space>
f01165c7:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01165ca:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01165d0:	85 c0                	test   %eax,%eax
f01165d2:	74 27                	je     f01165fb <test_calculate_allocated_space+0x63c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01165d4:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01165da:	83 ec 0c             	sub    $0xc,%esp
f01165dd:	6a 00                	push   $0x0
f01165df:	50                   	push   %eax
f01165e0:	68 3c 47 13 f0       	push   $0xf013473c
f01165e5:	68 e3 07 00 00       	push   $0x7e3
f01165ea:	68 f2 29 13 f0       	push   $0xf01329f2
f01165ef:	e8 60 aa fe ff       	call   f0101054 <_warn>
f01165f4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01165f7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f01165fb:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116601:	85 c0                	test   %eax,%eax
f0116603:	74 27                	je     f011662c <test_calculate_allocated_space+0x66d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0116605:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011660b:	83 ec 0c             	sub    $0xc,%esp
f011660e:	6a 00                	push   $0x0
f0116610:	50                   	push   %eax
f0116611:	68 9c 47 13 f0       	push   $0xf013479c
f0116616:	68 e8 07 00 00       	push   $0x7e8
f011661b:	68 f2 29 13 f0       	push   $0xf01329f2
f0116620:	e8 2f aa fe ff       	call   f0101054 <_warn>
f0116625:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116628:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011662c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116630:	74 04                	je     f0116636 <test_calculate_allocated_space+0x677>
f0116632:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116636:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f011663a:	83 ec 0c             	sub    $0xc,%esp
f011663d:	68 3d 41 13 f0       	push   $0xf013413d
f0116642:	e8 15 b5 fe ff       	call   f0101b5c <cprintf>
f0116647:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f011664a:	83 ec 0c             	sub    $0xc,%esp
f011664d:	68 5c 46 13 f0       	push   $0xf013465c
f0116652:	e8 05 b5 fe ff       	call   f0101b5c <cprintf>
f0116657:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f011665a:	83 ec 04             	sub    $0x4,%esp
f011665d:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f0116663:	50                   	push   %eax
f0116664:	68 f6 34 13 f0       	push   $0xf01334f6
f0116669:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011666f:	50                   	push   %eax
f0116670:	e8 34 4a 00 00       	call   f011b0a9 <strcconcat>
f0116675:	83 c4 10             	add    $0x10,%esp
f0116678:	83 ec 0c             	sub    $0xc,%esp
f011667b:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f0116681:	50                   	push   %eax
f0116682:	e8 94 b7 fe ff       	call   f0101e1b <execute_command>
f0116687:	83 c4 10             	add    $0x10,%esp

		num_tables = 0;
f011668a:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116691:	00 00 00 
		num_pages = 0;
f0116694:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011669b:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f011669e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01166a1:	c1 e0 03             	shl    $0x3,%eax
f01166a4:	89 c2                	mov    %eax,%edx
f01166a6:	83 ec 0c             	sub    $0xc,%esp
f01166a9:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01166af:	50                   	push   %eax
f01166b0:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01166b6:	50                   	push   %eax
f01166b7:	52                   	push   %edx
f01166b8:	6a 00                	push   $0x0
f01166ba:	ff 75 d8             	pushl  -0x28(%ebp)
f01166bd:	e8 3f 45 ff ff       	call   f010ac01 <calculate_allocated_space>
f01166c2:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f01166c5:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1 ;
f01166cc:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01166d3:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01166d9:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01166dc:	74 28                	je     f0116706 <test_calculate_allocated_space+0x747>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01166de:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01166e4:	83 ec 0c             	sub    $0xc,%esp
f01166e7:	ff 75 c8             	pushl  -0x38(%ebp)
f01166ea:	50                   	push   %eax
f01166eb:	68 3c 47 13 f0       	push   $0xf013473c
f01166f0:	68 ff 07 00 00       	push   $0x7ff
f01166f5:	68 f2 29 13 f0       	push   $0xf01329f2
f01166fa:	e8 55 a9 fe ff       	call   f0101054 <_warn>
f01166ff:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116702:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116706:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011670c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011670f:	74 28                	je     f0116739 <test_calculate_allocated_space+0x77a>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116711:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116717:	83 ec 0c             	sub    $0xc,%esp
f011671a:	ff 75 c4             	pushl  -0x3c(%ebp)
f011671d:	50                   	push   %eax
f011671e:	68 9c 47 13 f0       	push   $0xf013479c
f0116723:	68 04 08 00 00       	push   $0x804
f0116728:	68 f2 29 13 f0       	push   $0xf01329f2
f011672d:	e8 22 a9 fe ff       	call   f0101054 <_warn>
f0116732:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116735:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116739:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011673d:	74 04                	je     f0116743 <test_calculate_allocated_space+0x784>
f011673f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116743:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f0116747:	83 ec 04             	sub    $0x4,%esp
f011674a:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116750:	50                   	push   %eax
f0116751:	68 03 35 13 f0       	push   $0xf0133503
f0116756:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011675c:	50                   	push   %eax
f011675d:	e8 47 49 00 00       	call   f011b0a9 <strcconcat>
f0116762:	83 c4 10             	add    $0x10,%esp
f0116765:	83 ec 0c             	sub    $0xc,%esp
f0116768:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f011676e:	50                   	push   %eax
f011676f:	e8 a7 b6 fe ff       	call   f0101e1b <execute_command>
f0116774:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f0116777:	83 ec 04             	sub    $0x4,%esp
f011677a:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116780:	50                   	push   %eax
f0116781:	68 90 46 13 f0       	push   $0xf0134690
f0116786:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011678c:	50                   	push   %eax
f011678d:	e8 17 49 00 00       	call   f011b0a9 <strcconcat>
f0116792:	83 c4 10             	add    $0x10,%esp
f0116795:	83 ec 0c             	sub    $0xc,%esp
f0116798:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f011679e:	50                   	push   %eax
f011679f:	e8 77 b6 fe ff       	call   f0101e1b <execute_command>
f01167a4:	83 c4 10             	add    $0x10,%esp

		//Test2
		num_tables = 0;
f01167a7:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01167ae:	00 00 00 
		num_pages = 0;
f01167b1:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01167b8:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*mega, &num_tables, &num_pages);
f01167bb:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01167be:	c1 e0 03             	shl    $0x3,%eax
f01167c1:	89 c2                	mov    %eax,%edx
f01167c3:	83 ec 0c             	sub    $0xc,%esp
f01167c6:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01167cc:	50                   	push   %eax
f01167cd:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01167d3:	50                   	push   %eax
f01167d4:	52                   	push   %edx
f01167d5:	6a 00                	push   $0x0
f01167d7:	ff 75 d8             	pushl  -0x28(%ebp)
f01167da:	e8 22 44 ff ff       	call   f010ac01 <calculate_allocated_space>
f01167df:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f01167e2:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 2 ;
f01167e9:	c7 45 c4 02 00 00 00 	movl   $0x2,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01167f0:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01167f6:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01167f9:	74 28                	je     f0116823 <test_calculate_allocated_space+0x864>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01167fb:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116801:	83 ec 0c             	sub    $0xc,%esp
f0116804:	ff 75 c8             	pushl  -0x38(%ebp)
f0116807:	50                   	push   %eax
f0116808:	68 3c 47 13 f0       	push   $0xf013473c
f011680d:	68 15 08 00 00       	push   $0x815
f0116812:	68 f2 29 13 f0       	push   $0xf01329f2
f0116817:	e8 38 a8 fe ff       	call   f0101054 <_warn>
f011681c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011681f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116823:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116829:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011682c:	74 28                	je     f0116856 <test_calculate_allocated_space+0x897>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f011682e:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116834:	83 ec 0c             	sub    $0xc,%esp
f0116837:	ff 75 c4             	pushl  -0x3c(%ebp)
f011683a:	50                   	push   %eax
f011683b:	68 9c 47 13 f0       	push   $0xf013479c
f0116840:	68 1a 08 00 00       	push   $0x81a
f0116845:	68 f2 29 13 f0       	push   $0xf01329f2
f011684a:	e8 05 a8 fe ff       	call   f0101054 <_warn>
f011684f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116852:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116856:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011685a:	74 04                	je     f0116860 <test_calculate_allocated_space+0x8a1>
f011685c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116860:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f0116864:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011686b:	00 00 00 
		num_pages = 0;
f011686e:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116875:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f0116878:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011687b:	c1 e0 0a             	shl    $0xa,%eax
f011687e:	89 c2                	mov    %eax,%edx
f0116880:	83 ec 0c             	sub    $0xc,%esp
f0116883:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116889:	50                   	push   %eax
f011688a:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116890:	50                   	push   %eax
f0116891:	52                   	push   %edx
f0116892:	6a 00                	push   $0x0
f0116894:	ff 75 d8             	pushl  -0x28(%ebp)
f0116897:	e8 65 43 ff ff       	call   f010ac01 <calculate_allocated_space>
f011689c:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 + 1;
f011689f:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
		expected_num_pages = 1 + 1 + 1;
f01168a6:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01168ad:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01168b3:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01168b6:	74 28                	je     f01168e0 <test_calculate_allocated_space+0x921>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01168b8:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01168be:	83 ec 0c             	sub    $0xc,%esp
f01168c1:	ff 75 c8             	pushl  -0x38(%ebp)
f01168c4:	50                   	push   %eax
f01168c5:	68 3c 47 13 f0       	push   $0xf013473c
f01168ca:	68 28 08 00 00       	push   $0x828
f01168cf:	68 f2 29 13 f0       	push   $0xf01329f2
f01168d4:	e8 7b a7 fe ff       	call   f0101054 <_warn>
f01168d9:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01168dc:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01168e0:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01168e6:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01168e9:	74 28                	je     f0116913 <test_calculate_allocated_space+0x954>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01168eb:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01168f1:	83 ec 0c             	sub    $0xc,%esp
f01168f4:	ff 75 c4             	pushl  -0x3c(%ebp)
f01168f7:	50                   	push   %eax
f01168f8:	68 9c 47 13 f0       	push   $0xf013479c
f01168fd:	68 2d 08 00 00       	push   $0x82d
f0116902:	68 f2 29 13 f0       	push   $0xf01329f2
f0116907:	e8 48 a7 fe ff       	call   f0101054 <_warn>
f011690c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011690f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116913:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116917:	74 04                	je     f011691d <test_calculate_allocated_space+0x95e>
f0116919:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011691d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f0116921:	83 ec 04             	sub    $0x4,%esp
f0116924:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f011692a:	50                   	push   %eax
f011692b:	68 9c 46 13 f0       	push   $0xf013469c
f0116930:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116936:	50                   	push   %eax
f0116937:	e8 6d 47 00 00       	call   f011b0a9 <strcconcat>
f011693c:	83 c4 10             	add    $0x10,%esp
f011693f:	83 ec 0c             	sub    $0xc,%esp
f0116942:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116948:	50                   	push   %eax
f0116949:	e8 cd b4 fe ff       	call   f0101e1b <execute_command>
f011694e:	83 c4 10             	add    $0x10,%esp

		//Test4
		num_tables = 0;
f0116951:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116958:	00 00 00 
		num_pages = 0;
f011695b:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116962:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f0116965:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116968:	89 c2                	mov    %eax,%edx
f011696a:	01 d2                	add    %edx,%edx
f011696c:	01 d0                	add    %edx,%eax
f011696e:	05 00 18 00 00       	add    $0x1800,%eax
f0116973:	89 c2                	mov    %eax,%edx
f0116975:	83 ec 0c             	sub    $0xc,%esp
f0116978:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011697e:	50                   	push   %eax
f011697f:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116985:	50                   	push   %eax
f0116986:	52                   	push   %edx
f0116987:	68 00 18 00 00       	push   $0x1800
f011698c:	ff 75 d8             	pushl  -0x28(%ebp)
f011698f:	e8 6d 42 ff ff       	call   f010ac01 <calculate_allocated_space>
f0116994:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116997:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f011699e:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01169a5:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01169ab:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01169ae:	74 28                	je     f01169d8 <test_calculate_allocated_space+0xa19>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01169b0:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01169b6:	83 ec 0c             	sub    $0xc,%esp
f01169b9:	ff 75 c8             	pushl  -0x38(%ebp)
f01169bc:	50                   	push   %eax
f01169bd:	68 3c 47 13 f0       	push   $0xf013473c
f01169c2:	68 3e 08 00 00       	push   $0x83e
f01169c7:	68 f2 29 13 f0       	push   $0xf01329f2
f01169cc:	e8 83 a6 fe ff       	call   f0101054 <_warn>
f01169d1:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01169d4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01169d8:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01169de:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01169e1:	74 28                	je     f0116a0b <test_calculate_allocated_space+0xa4c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01169e3:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01169e9:	83 ec 0c             	sub    $0xc,%esp
f01169ec:	ff 75 c4             	pushl  -0x3c(%ebp)
f01169ef:	50                   	push   %eax
f01169f0:	68 9c 47 13 f0       	push   $0xf013479c
f01169f5:	68 43 08 00 00       	push   $0x843
f01169fa:	68 f2 29 13 f0       	push   $0xf01329f2
f01169ff:	e8 50 a6 fe ff       	call   f0101054 <_warn>
f0116a04:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116a07:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116a0b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116a0f:	74 04                	je     f0116a15 <test_calculate_allocated_space+0xa56>
f0116a11:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116a15:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f0116a19:	83 ec 04             	sub    $0x4,%esp
f0116a1c:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116a22:	50                   	push   %eax
f0116a23:	68 5c 37 13 f0       	push   $0xf013375c
f0116a28:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116a2e:	50                   	push   %eax
f0116a2f:	e8 75 46 00 00       	call   f011b0a9 <strcconcat>
f0116a34:	83 c4 10             	add    $0x10,%esp
f0116a37:	83 ec 0c             	sub    $0xc,%esp
f0116a3a:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116a40:	50                   	push   %eax
f0116a41:	e8 d5 b3 fe ff       	call   f0101e1b <execute_command>
f0116a46:	83 c4 10             	add    $0x10,%esp

		//Test5
		num_tables = 0;
f0116a49:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116a50:	00 00 00 
		num_pages = 0;
f0116a53:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116a5a:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f0116a5d:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0116a60:	89 d0                	mov    %edx,%eax
f0116a62:	c1 e0 02             	shl    $0x2,%eax
f0116a65:	01 d0                	add    %edx,%eax
f0116a67:	01 c0                	add    %eax,%eax
f0116a69:	05 00 00 40 00       	add    $0x400000,%eax
f0116a6e:	89 c2                	mov    %eax,%edx
f0116a70:	83 ec 0c             	sub    $0xc,%esp
f0116a73:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116a79:	50                   	push   %eax
f0116a7a:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116a80:	50                   	push   %eax
f0116a81:	52                   	push   %edx
f0116a82:	68 00 00 40 00       	push   $0x400000
f0116a87:	ff 75 d8             	pushl  -0x28(%ebp)
f0116a8a:	e8 72 41 ff ff       	call   f010ac01 <calculate_allocated_space>
f0116a8f:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116a92:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f0116a99:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116aa0:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116aa6:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116aa9:	74 28                	je     f0116ad3 <test_calculate_allocated_space+0xb14>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116aab:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116ab1:	83 ec 0c             	sub    $0xc,%esp
f0116ab4:	ff 75 c8             	pushl  -0x38(%ebp)
f0116ab7:	50                   	push   %eax
f0116ab8:	68 3c 47 13 f0       	push   $0xf013473c
f0116abd:	68 53 08 00 00       	push   $0x853
f0116ac2:	68 f2 29 13 f0       	push   $0xf01329f2
f0116ac7:	e8 88 a5 fe ff       	call   f0101054 <_warn>
f0116acc:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116acf:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116ad3:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116ad9:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116adc:	74 28                	je     f0116b06 <test_calculate_allocated_space+0xb47>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116ade:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116ae4:	83 ec 0c             	sub    $0xc,%esp
f0116ae7:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116aea:	50                   	push   %eax
f0116aeb:	68 9c 47 13 f0       	push   $0xf013479c
f0116af0:	68 58 08 00 00       	push   $0x858
f0116af5:	68 f2 29 13 f0       	push   $0xf01329f2
f0116afa:	e8 55 a5 fe ff       	call   f0101054 <_warn>
f0116aff:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116b02:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116b06:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116b0a:	74 04                	je     f0116b10 <test_calculate_allocated_space+0xb51>
f0116b0c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116b10:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f0116b14:	83 ec 04             	sub    $0x4,%esp
f0116b17:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116b1d:	50                   	push   %eax
f0116b1e:	68 66 37 13 f0       	push   $0xf0133766
f0116b23:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116b29:	50                   	push   %eax
f0116b2a:	e8 7a 45 00 00       	call   f011b0a9 <strcconcat>
f0116b2f:	83 c4 10             	add    $0x10,%esp
f0116b32:	83 ec 0c             	sub    $0xc,%esp
f0116b35:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116b3b:	50                   	push   %eax
f0116b3c:	e8 da b2 fe ff       	call   f0101e1b <execute_command>
f0116b41:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f0116b44:	83 ec 04             	sub    $0x4,%esp
f0116b47:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116b4d:	50                   	push   %eax
f0116b4e:	68 a4 46 13 f0       	push   $0xf01346a4
f0116b53:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116b59:	50                   	push   %eax
f0116b5a:	e8 4a 45 00 00       	call   f011b0a9 <strcconcat>
f0116b5f:	83 c4 10             	add    $0x10,%esp
f0116b62:	83 ec 0c             	sub    $0xc,%esp
f0116b65:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116b6b:	50                   	push   %eax
f0116b6c:	e8 aa b2 fe ff       	call   f0101e1b <execute_command>
f0116b71:	83 c4 10             	add    $0x10,%esp

		//Test6
		num_tables = 0;
f0116b74:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116b7b:	00 00 00 
		num_pages = 0;
f0116b7e:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116b85:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f0116b88:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116b8b:	05 00 00 38 00       	add    $0x380000,%eax
f0116b90:	01 c0                	add    %eax,%eax
f0116b92:	89 c2                	mov    %eax,%edx
f0116b94:	83 ec 0c             	sub    $0xc,%esp
f0116b97:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116b9d:	50                   	push   %eax
f0116b9e:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116ba4:	50                   	push   %eax
f0116ba5:	52                   	push   %edx
f0116ba6:	68 00 00 70 00       	push   $0x700000
f0116bab:	ff 75 d8             	pushl  -0x28(%ebp)
f0116bae:	e8 4e 40 ff ff       	call   f010ac01 <calculate_allocated_space>
f0116bb3:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116bb6:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 3;
f0116bbd:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116bc4:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116bca:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116bcd:	74 28                	je     f0116bf7 <test_calculate_allocated_space+0xc38>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116bcf:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116bd5:	83 ec 0c             	sub    $0xc,%esp
f0116bd8:	ff 75 c8             	pushl  -0x38(%ebp)
f0116bdb:	50                   	push   %eax
f0116bdc:	68 3c 47 13 f0       	push   $0xf013473c
f0116be1:	68 6a 08 00 00       	push   $0x86a
f0116be6:	68 f2 29 13 f0       	push   $0xf01329f2
f0116beb:	e8 64 a4 fe ff       	call   f0101054 <_warn>
f0116bf0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116bf3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116bf7:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116bfd:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116c00:	74 28                	je     f0116c2a <test_calculate_allocated_space+0xc6b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116c02:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116c08:	83 ec 0c             	sub    $0xc,%esp
f0116c0b:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116c0e:	50                   	push   %eax
f0116c0f:	68 9c 47 13 f0       	push   $0xf013479c
f0116c14:	68 6f 08 00 00       	push   $0x86f
f0116c19:	68 f2 29 13 f0       	push   $0xf01329f2
f0116c1e:	e8 31 a4 fe ff       	call   f0101054 <_warn>
f0116c23:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116c26:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116c2a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116c2e:	74 04                	je     f0116c34 <test_calculate_allocated_space+0xc75>
f0116c30:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116c34:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test7
		num_tables = 0;
f0116c38:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116c3f:	00 00 00 
		num_pages = 0;
f0116c42:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116c49:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f0116c4c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116c4f:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f0116c54:	89 c2                	mov    %eax,%edx
f0116c56:	83 ec 0c             	sub    $0xc,%esp
f0116c59:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116c5f:	50                   	push   %eax
f0116c60:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116c66:	50                   	push   %eax
f0116c67:	52                   	push   %edx
f0116c68:	68 ff ff 3f 00       	push   $0x3fffff
f0116c6d:	ff 75 d8             	pushl  -0x28(%ebp)
f0116c70:	e8 8c 3f ff ff       	call   f010ac01 <calculate_allocated_space>
f0116c75:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116c78:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 0;
f0116c7f:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116c86:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116c8c:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116c8f:	74 28                	je     f0116cb9 <test_calculate_allocated_space+0xcfa>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116c91:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116c97:	83 ec 0c             	sub    $0xc,%esp
f0116c9a:	ff 75 c8             	pushl  -0x38(%ebp)
f0116c9d:	50                   	push   %eax
f0116c9e:	68 3c 47 13 f0       	push   $0xf013473c
f0116ca3:	68 7d 08 00 00       	push   $0x87d
f0116ca8:	68 f2 29 13 f0       	push   $0xf01329f2
f0116cad:	e8 a2 a3 fe ff       	call   f0101054 <_warn>
f0116cb2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116cb5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116cb9:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116cbf:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116cc2:	74 28                	je     f0116cec <test_calculate_allocated_space+0xd2d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116cc4:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116cca:	83 ec 0c             	sub    $0xc,%esp
f0116ccd:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116cd0:	50                   	push   %eax
f0116cd1:	68 9c 47 13 f0       	push   $0xf013479c
f0116cd6:	68 82 08 00 00       	push   $0x882
f0116cdb:	68 f2 29 13 f0       	push   $0xf01329f2
f0116ce0:	e8 6f a3 fe ff       	call   f0101054 <_warn>
f0116ce5:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116ce8:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116cec:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116cf0:	74 04                	je     f0116cf6 <test_calculate_allocated_space+0xd37>
f0116cf2:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116cf6:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f0116cfa:	83 ec 0c             	sub    $0xc,%esp
f0116cfd:	68 17 37 13 f0       	push   $0xf0133717
f0116d02:	e8 55 ae fe ff       	call   f0101b5c <cprintf>
f0116d07:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_allocated_space: FINISHED. Evaluation = %d\n", eval);
f0116d0a:	83 ec 08             	sub    $0x8,%esp
f0116d0d:	ff 75 e4             	pushl  -0x1c(%ebp)
f0116d10:	68 f8 47 13 f0       	push   $0xf01347f8
f0116d15:	e8 42 ae fe ff       	call   f0101b5c <cprintf>
f0116d1a:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0116d1d:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0116d21:	75 10                	jne    f0116d33 <test_calculate_allocated_space+0xd74>
		cprintf("Congratulations!! test calculate_allocated_space completed successfully.\n");
f0116d23:	83 ec 0c             	sub    $0xc,%esp
f0116d26:	68 38 48 13 f0       	push   $0xf0134838
f0116d2b:	e8 2c ae fe ff       	call   f0101b5c <cprintf>
f0116d30:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0116d33:	a1 e0 6d 85 f0       	mov    0xf0856de0,%eax
f0116d38:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0116d3b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0116d3e:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0116d41:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0116d46:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0116d49:	5b                   	pop    %ebx
f0116d4a:	5e                   	pop    %esi
f0116d4b:	5f                   	pop    %edi
f0116d4c:	5d                   	pop    %ebp
f0116d4d:	c3                   	ret    

f0116d4e <CB>:
//===========================================================================
//===========================================================================
//===========================================================================

int CB(uint32 *ptr_dir, uint32 va, int bn)
{
f0116d4e:	55                   	push   %ebp
f0116d4f:	89 e5                	mov    %esp,%ebp
f0116d51:	83 ec 18             	sub    $0x18,%esp
	//assert(USE_KHEAP == 0) ;
	uint32 mask = 1<<bn;
f0116d54:	8b 45 10             	mov    0x10(%ebp),%eax
f0116d57:	ba 01 00 00 00       	mov    $0x1,%edx
f0116d5c:	88 c1                	mov    %al,%cl
f0116d5e:	d3 e2                	shl    %cl,%edx
f0116d60:	89 d0                	mov    %edx,%eax
f0116d62:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f0116d65:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116d68:	c1 e8 16             	shr    $0x16,%eax
f0116d6b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116d72:	8b 45 08             	mov    0x8(%ebp),%eax
f0116d75:	01 d0                	add    %edx,%eax
f0116d77:	8b 00                	mov    (%eax),%eax
f0116d79:	83 e0 01             	and    $0x1,%eax
f0116d7c:	85 c0                	test   %eax,%eax
f0116d7e:	75 07                	jne    f0116d87 <CB+0x39>
f0116d80:	b8 00 00 00 00       	mov    $0x0,%eax
f0116d85:	eb 76                	jmp    f0116dfd <CB+0xaf>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f0116d87:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116d8a:	c1 e8 16             	shr    $0x16,%eax
f0116d8d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116d94:	8b 45 08             	mov    0x8(%ebp),%eax
f0116d97:	01 d0                	add    %edx,%eax
f0116d99:	8b 00                	mov    (%eax),%eax
f0116d9b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116da0:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0116da3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116da6:	c1 e8 0c             	shr    $0xc,%eax
f0116da9:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0116dac:	a1 b8 e9 83 f0       	mov    0xf083e9b8,%eax
f0116db1:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0116db4:	72 17                	jb     f0116dcd <CB+0x7f>
f0116db6:	ff 75 f0             	pushl  -0x10(%ebp)
f0116db9:	68 84 48 13 f0       	push   $0xf0134884
f0116dbe:	68 9d 08 00 00       	push   $0x89d
f0116dc3:	68 f2 29 13 f0       	push   $0xf01329f2
f0116dc8:	e8 e2 a0 fe ff       	call   f0100eaf <_panic>
f0116dcd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116dd0:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0116dd5:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return ((table[((((uint32) (va)) >> 12) & 0x3FF)]&mask) == mask)? 1 : 0 ;
f0116dd8:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116ddb:	c1 e8 0c             	shr    $0xc,%eax
f0116dde:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116de3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116dea:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116ded:	01 d0                	add    %edx,%eax
f0116def:	8b 00                	mov    (%eax),%eax
f0116df1:	23 45 f4             	and    -0xc(%ebp),%eax
f0116df4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0116df7:	0f 94 c0             	sete   %al
f0116dfa:	0f b6 c0             	movzbl %al,%eax
}
f0116dfd:	c9                   	leave  
f0116dfe:	c3                   	ret    

f0116dff <SB>:
int SB(uint32 *ptr_dir, uint32 va, int bn , int v)
{
f0116dff:	55                   	push   %ebp
f0116e00:	89 e5                	mov    %esp,%ebp
f0116e02:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116e05:	68 b3 48 13 f0       	push   $0xf01348b3
f0116e0a:	68 c2 48 13 f0       	push   $0xf01348c2
f0116e0f:	68 a2 08 00 00       	push   $0x8a2
f0116e14:	68 f2 29 13 f0       	push   $0xf01329f2
f0116e19:	e8 91 a0 fe ff       	call   f0100eaf <_panic>

f0116e1e <CPs>:
	if (~v) table[((((uint32) (va)) >> 12) & 0x3FF)] &= ~mask ;
	else 	table[((((uint32) (va)) >> 12) & 0x3FF)] |= mask ;
	return 0;
}
int CPs(uint32 *ptr_dir, uint32 va, uint32 perms, uint32 which)
{
f0116e1e:	55                   	push   %ebp
f0116e1f:	89 e5                	mov    %esp,%ebp
f0116e21:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116e24:	68 b3 48 13 f0       	push   $0xf01348b3
f0116e29:	68 c2 48 13 f0       	push   $0xf01348c2
f0116e2e:	68 ac 08 00 00       	push   $0x8ac
f0116e33:	68 f2 29 13 f0       	push   $0xf01329f2
f0116e38:	e8 72 a0 fe ff       	call   f0100eaf <_panic>

f0116e3d <CA>:
	}
	return 1;
}

int CA(uint32 *ptr_dir, uint32 va)
{
f0116e3d:	55                   	push   %ebp
f0116e3e:	89 e5                	mov    %esp,%ebp
f0116e40:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116e43:	68 b3 48 13 f0       	push   $0xf01348b3
f0116e48:	68 c2 48 13 f0       	push   $0xf01348c2
f0116e4d:	68 bb 08 00 00       	push   $0x8bb
f0116e52:	68 f2 29 13 f0       	push   $0xf01329f2
f0116e57:	e8 53 a0 fe ff       	call   f0100eaf <_panic>

f0116e5c <CE>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return (table[((((uint32) (va)) >> 12) & 0x3FF)]&~0x00000FFF) + (va & 0xFFF);
}

int CE(uint32 *_d, uint32 va)
{
f0116e5c:	55                   	push   %ebp
f0116e5d:	89 e5                	mov    %esp,%ebp
f0116e5f:	83 ec 18             	sub    $0x18,%esp
	if (!(_d[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f0116e62:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116e65:	c1 e8 16             	shr    $0x16,%eax
f0116e68:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116e6f:	8b 45 08             	mov    0x8(%ebp),%eax
f0116e72:	01 d0                	add    %edx,%eax
f0116e74:	8b 00                	mov    (%eax),%eax
f0116e76:	83 e0 01             	and    $0x1,%eax
f0116e79:	85 c0                	test   %eax,%eax
f0116e7b:	75 07                	jne    f0116e84 <CE+0x28>
f0116e7d:	b8 00 00 00 00       	mov    $0x0,%eax
f0116e82:	eb 7a                	jmp    f0116efe <CE+0xa2>
	uint32 *_t = (STATIC_KERNEL_VIRTUAL_ADDRESS(_d[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f0116e84:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116e87:	c1 e8 16             	shr    $0x16,%eax
f0116e8a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116e91:	8b 45 08             	mov    0x8(%ebp),%eax
f0116e94:	01 d0                	add    %edx,%eax
f0116e96:	8b 00                	mov    (%eax),%eax
f0116e98:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116e9d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0116ea0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116ea3:	c1 e8 0c             	shr    $0xc,%eax
f0116ea6:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0116ea9:	a1 b8 e9 83 f0       	mov    0xf083e9b8,%eax
f0116eae:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f0116eb1:	72 17                	jb     f0116eca <CE+0x6e>
f0116eb3:	ff 75 f4             	pushl  -0xc(%ebp)
f0116eb6:	68 84 48 13 f0       	push   $0xf0134884
f0116ebb:	68 c4 08 00 00       	push   $0x8c4
f0116ec0:	68 f2 29 13 f0       	push   $0xf01329f2
f0116ec5:	e8 e5 9f fe ff       	call   f0100eaf <_panic>
f0116eca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116ecd:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0116ed2:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if ((_t[((((uint32) (va)) >> 12) & 0x3FF)])!=0) return 0;
f0116ed5:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116ed8:	c1 e8 0c             	shr    $0xc,%eax
f0116edb:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116ee0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116ee7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116eea:	01 d0                	add    %edx,%eax
f0116eec:	8b 00                	mov    (%eax),%eax
f0116eee:	85 c0                	test   %eax,%eax
f0116ef0:	74 07                	je     f0116ef9 <CE+0x9d>
f0116ef2:	b8 00 00 00 00       	mov    $0x0,%eax
f0116ef7:	eb 05                	jmp    f0116efe <CE+0xa2>
	return 1;
f0116ef9:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0116efe:	c9                   	leave  
f0116eff:	c3                   	ret    

f0116f00 <CP>:

int CP(uint32* pd, uint32 va, uint32 ps, uint32 pc)
{
f0116f00:	55                   	push   %ebp
f0116f01:	89 e5                	mov    %esp,%ebp
f0116f03:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116f06:	68 b3 48 13 f0       	push   $0xf01348b3
f0116f0b:	68 c2 48 13 f0       	push   $0xf01348c2
f0116f10:	68 cb 08 00 00       	push   $0x8cb
f0116f15:	68 f2 29 13 f0       	push   $0xf01329f2
f0116f1a:	e8 90 9f fe ff       	call   f0100eaf <_panic>

f0116f1f <GP>:
	}
	return 0;
}

uint32 GP(uint32 *ptr_dir, uint32 va)
{
f0116f1f:	55                   	push   %ebp
f0116f20:	89 e5                	mov    %esp,%ebp
f0116f22:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116f25:	68 b3 48 13 f0       	push   $0xf01348b3
f0116f2a:	68 c2 48 13 f0       	push   $0xf01348c2
f0116f2f:	68 db 08 00 00       	push   $0x8db
f0116f34:	68 f2 29 13 f0       	push   $0xf01329f2
f0116f39:	e8 71 9f fe ff       	call   f0100eaf <_panic>

f0116f3e <ClearUserSpace>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
f0116f3e:	55                   	push   %ebp
f0116f3f:	89 e5                	mov    %esp,%ebp
f0116f41:	83 ec 10             	sub    $0x10,%esp
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f0116f44:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0116f4b:	eb 18                	jmp    f0116f65 <ClearUserSpace+0x27>
		ptr_dir[i] = 0;
f0116f4d:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0116f50:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116f57:	8b 45 08             	mov    0x8(%ebp),%eax
f0116f5a:	01 d0                	add    %edx,%eax
f0116f5c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f0116f62:	ff 45 fc             	incl   -0x4(%ebp)
f0116f65:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0116f68:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f0116f6d:	76 de                	jbe    f0116f4d <ClearUserSpace+0xf>
		ptr_dir[i] = 0;
	}
}
f0116f6f:	90                   	nop
f0116f70:	c9                   	leave  
f0116f71:	c3                   	ret    

f0116f72 <CCP>:

int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
f0116f72:	55                   	push   %ebp
f0116f73:	89 e5                	mov    %esp,%ebp
f0116f75:	83 ec 38             	sub    $0x38,%esp
f0116f78:	8b 45 2c             	mov    0x2c(%ebp),%eax
f0116f7b:	88 45 d4             	mov    %al,-0x2c(%ebp)
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
f0116f7e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116f81:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116f86:	89 45 f4             	mov    %eax,-0xc(%ebp)
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));
f0116f89:	8b 45 10             	mov    0x10(%ebp),%eax
f0116f8c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116f91:	89 45 f0             	mov    %eax,-0x10(%ebp)

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f0116f94:	e9 ea 01 00 00       	jmp    f0117183 <CCP+0x211>
	{
		uint32* ptr_table1;
		uint32* ptr_table2;
		struct FrameInfo * pfi1 ;
		struct FrameInfo * pfi2 ;
		if (chk_type != CHK_ALLOC)
f0116f99:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0116f9d:	74 44                	je     f0116fe3 <CCP+0x71>
		{
			pfi1 = get_frame_info(ptr_dir, (uint32)ptrTemp1, &ptr_table1);
f0116f9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116fa2:	83 ec 04             	sub    $0x4,%esp
f0116fa5:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0116fa8:	52                   	push   %edx
f0116fa9:	50                   	push   %eax
f0116faa:	ff 75 08             	pushl  0x8(%ebp)
f0116fad:	e8 1b 26 ff ff       	call   f01095cd <get_frame_info>
f0116fb2:	83 c4 10             	add    $0x10,%esp
f0116fb5:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if (ptr_table1 == NULL)
f0116fb8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116fbb:	85 c0                	test   %eax,%eax
f0116fbd:	75 24                	jne    f0116fe3 <CCP+0x71>
			{
				warn("[EVAL] Failed. Table of address 1 = NULL\n");
f0116fbf:	83 ec 04             	sub    $0x4,%esp
f0116fc2:	68 d8 48 13 f0       	push   $0xf01348d8
f0116fc7:	68 f8 08 00 00       	push   $0x8f8
f0116fcc:	68 f2 29 13 f0       	push   $0xf01329f2
f0116fd1:	e8 7e a0 fe ff       	call   f0101054 <_warn>
f0116fd6:	83 c4 10             	add    $0x10,%esp
				return 0;
f0116fd9:	b8 00 00 00 00       	mov    $0x0,%eax
f0116fde:	e9 b6 01 00 00       	jmp    f0117199 <CCP+0x227>
			}
		}
		pfi2 = get_frame_info(ptr_dir, (uint32)ptrTemp2, &ptr_table2);
f0116fe3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116fe6:	83 ec 04             	sub    $0x4,%esp
f0116fe9:	8d 55 d8             	lea    -0x28(%ebp),%edx
f0116fec:	52                   	push   %edx
f0116fed:	50                   	push   %eax
f0116fee:	ff 75 08             	pushl  0x8(%ebp)
f0116ff1:	e8 d7 25 ff ff       	call   f01095cd <get_frame_info>
f0116ff6:	83 c4 10             	add    $0x10,%esp
f0116ff9:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (ptr_table2 == NULL)
f0116ffc:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0116fff:	85 c0                	test   %eax,%eax
f0117001:	75 24                	jne    f0117027 <CCP+0xb5>
		{
			warn("[EVAL] Failed. Table of address 2 = NULL\n");
f0117003:	83 ec 04             	sub    $0x4,%esp
f0117006:	68 04 49 13 f0       	push   $0xf0134904
f011700b:	68 ff 08 00 00       	push   $0x8ff
f0117010:	68 f2 29 13 f0       	push   $0xf01329f2
f0117015:	e8 3a a0 fe ff       	call   f0101054 <_warn>
f011701a:	83 c4 10             	add    $0x10,%esp
			return 0;
f011701d:	b8 00 00 00 00       	mov    $0x0,%eax
f0117022:	e9 72 01 00 00       	jmp    f0117199 <CCP+0x227>
		}
		if (chk_type == CHK_SHARE)
f0117027:	80 7d d4 02          	cmpb   $0x2,-0x2c(%ebp)
f011702b:	75 70                	jne    f011709d <CCP+0x12b>
		{
			uint32 fn1 = ptr_table1[PTX(ptrTemp1)] >> 12 ;
f011702d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0117030:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0117033:	c1 ea 0c             	shr    $0xc,%edx
f0117036:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011703c:	c1 e2 02             	shl    $0x2,%edx
f011703f:	01 d0                	add    %edx,%eax
f0117041:	8b 00                	mov    (%eax),%eax
f0117043:	c1 e8 0c             	shr    $0xc,%eax
f0117046:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 fn2 = ptr_table2[PTX(ptrTemp2)] >> 12 ;
f0117049:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011704c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011704f:	c1 ea 0c             	shr    $0xc,%edx
f0117052:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0117058:	c1 e2 02             	shl    $0x2,%edx
f011705b:	01 d0                	add    %edx,%eax
f011705d:	8b 00                	mov    (%eax),%eax
f011705f:	c1 e8 0c             	shr    $0xc,%eax
f0117062:	89 45 e4             	mov    %eax,-0x1c(%ebp)

			if(fn1 != fn2)
f0117065:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0117068:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011706b:	74 30                	je     f011709d <CCP+0x12b>
			{
				warn("[EVAL] Failed. Frame numbers not equal in the whole range!\nva1=%x, va2=%x, fn1=%x, fn2=%x\n", ptrTemp1, ptrTemp2, fn1, fn2);
f011706d:	83 ec 04             	sub    $0x4,%esp
f0117070:	ff 75 e4             	pushl  -0x1c(%ebp)
f0117073:	ff 75 e8             	pushl  -0x18(%ebp)
f0117076:	ff 75 f0             	pushl  -0x10(%ebp)
f0117079:	ff 75 f4             	pushl  -0xc(%ebp)
f011707c:	68 30 49 13 f0       	push   $0xf0134930
f0117081:	68 09 09 00 00       	push   $0x909
f0117086:	68 f2 29 13 f0       	push   $0xf01329f2
f011708b:	e8 c4 9f fe ff       	call   f0101054 <_warn>
f0117090:	83 c4 20             	add    $0x20,%esp
				return 0;
f0117093:	b8 00 00 00 00       	mov    $0x0,%eax
f0117098:	e9 fc 00 00 00       	jmp    f0117199 <CCP+0x227>
			}
		}
		if (ref != -1)
f011709d:	83 7d 18 ff          	cmpl   $0xffffffff,0x18(%ebp)
f01170a1:	74 52                	je     f01170f5 <CCP+0x183>
		{
			if (pfi2 == NULL || (*pfi2).references != ref)
f01170a3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01170a7:	74 0e                	je     f01170b7 <CCP+0x145>
f01170a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01170ac:	8b 40 08             	mov    0x8(%eax),%eax
f01170af:	0f b7 c0             	movzwl %ax,%eax
f01170b2:	3b 45 18             	cmp    0x18(%ebp),%eax
f01170b5:	74 3e                	je     f01170f5 <CCP+0x183>
			{
				warn("[EVAL] Failed. Num of frame references is not correct. MAKE SURE to use the functions of LAB5! va2=%x, ref2=%d\n", ptrTemp2, pfi2==NULL? 0 : (*pfi2).references);
f01170b7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01170bb:	74 0b                	je     f01170c8 <CCP+0x156>
f01170bd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01170c0:	8b 40 08             	mov    0x8(%eax),%eax
f01170c3:	0f b7 c0             	movzwl %ax,%eax
f01170c6:	eb 05                	jmp    f01170cd <CCP+0x15b>
f01170c8:	b8 00 00 00 00       	mov    $0x0,%eax
f01170cd:	83 ec 0c             	sub    $0xc,%esp
f01170d0:	50                   	push   %eax
f01170d1:	ff 75 f0             	pushl  -0x10(%ebp)
f01170d4:	68 8c 49 13 f0       	push   $0xf013498c
f01170d9:	68 11 09 00 00       	push   $0x911
f01170de:	68 f2 29 13 f0       	push   $0xf01329f2
f01170e3:	e8 6c 9f fe ff       	call   f0101054 <_warn>
f01170e8:	83 c4 20             	add    $0x20,%esp
				return 0;
f01170eb:	b8 00 00 00 00       	mov    $0x0,%eax
f01170f0:	e9 a4 00 00 00       	jmp    f0117199 <CCP+0x227>
			}
		}
		if (CPs(ptr_dir, (uint32)ptrTemp2, dst_perms, dst_to_chk) <= 0)
f01170f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01170f8:	ff 75 20             	pushl  0x20(%ebp)
f01170fb:	ff 75 1c             	pushl  0x1c(%ebp)
f01170fe:	50                   	push   %eax
f01170ff:	ff 75 08             	pushl  0x8(%ebp)
f0117102:	e8 17 fd ff ff       	call   f0116e1e <CPs>
f0117107:	83 c4 10             	add    $0x10,%esp
f011710a:	85 c0                	test   %eax,%eax
f011710c:	7f 21                	jg     f011712f <CCP+0x1bd>
		{
			warn("[EVAL] Failed. one or more permission in destination is not correct\n");
f011710e:	83 ec 04             	sub    $0x4,%esp
f0117111:	68 fc 49 13 f0       	push   $0xf01349fc
f0117116:	68 17 09 00 00       	push   $0x917
f011711b:	68 f2 29 13 f0       	push   $0xf01329f2
f0117120:	e8 2f 9f fe ff       	call   f0101054 <_warn>
f0117125:	83 c4 10             	add    $0x10,%esp
			return 0;
f0117128:	b8 00 00 00 00       	mov    $0x0,%eax
f011712d:	eb 6a                	jmp    f0117199 <CCP+0x227>
		}
		if (chk_type != CHK_ALLOC)
f011712f:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0117133:	74 3a                	je     f011716f <CCP+0x1fd>
		{
			if (CPs(ptr_dir, (uint32)ptrTemp1, src_perms, src_to_chk) <= 0)
f0117135:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0117138:	ff 75 28             	pushl  0x28(%ebp)
f011713b:	ff 75 24             	pushl  0x24(%ebp)
f011713e:	50                   	push   %eax
f011713f:	ff 75 08             	pushl  0x8(%ebp)
f0117142:	e8 d7 fc ff ff       	call   f0116e1e <CPs>
f0117147:	83 c4 10             	add    $0x10,%esp
f011714a:	85 c0                	test   %eax,%eax
f011714c:	7f 21                	jg     f011716f <CCP+0x1fd>
			{
				warn("[EVAL] Failed. one or more permission in source is not correct\n");
f011714e:	83 ec 04             	sub    $0x4,%esp
f0117151:	68 44 4a 13 f0       	push   $0xf0134a44
f0117156:	68 1e 09 00 00       	push   $0x91e
f011715b:	68 f2 29 13 f0       	push   $0xf01329f2
f0117160:	e8 ef 9e fe ff       	call   f0101054 <_warn>
f0117165:	83 c4 10             	add    $0x10,%esp
				return 0;
f0117168:	b8 00 00 00 00       	mov    $0x0,%eax
f011716d:	eb 2a                	jmp    f0117199 <CCP+0x227>
			}
		}
		if (chk_type != CHK_ALLOC)
f011716f:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0117173:	74 07                	je     f011717c <CCP+0x20a>
		{
			ptrTemp1 += PAGE_SIZE;
f0117175:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f011717c:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
f0117183:	8b 55 10             	mov    0x10(%ebp),%edx
f0117186:	8b 45 14             	mov    0x14(%ebp),%eax
f0117189:	01 d0                	add    %edx,%eax
f011718b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011718e:	0f 87 05 fe ff ff    	ja     f0116f99 <CCP+0x27>
		{
			ptrTemp1 += PAGE_SIZE;
		}
	}

	return 1;
f0117194:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0117199:	c9                   	leave  
f011719a:	c3                   	ret    

f011719b <test_priority_normal_and_higher>:

extern int sys_calculate_free_frames();

uint8 firstTime = 1;
void test_priority_normal_and_higher()
{
f011719b:	55                   	push   %ebp
f011719c:	89 e5                	mov    %esp,%ebp
f011719e:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f01171a1:	83 ec 04             	sub    $0x4,%esp
f01171a4:	68 84 4a 13 f0       	push   $0xf0134a84
f01171a9:	6a 0e                	push   $0xe
f01171ab:	68 94 4a 13 f0       	push   $0xf0134a94
f01171b0:	e8 fa 9c fe ff       	call   f0100eaf <_panic>

f01171b5 <test_priority_normal_and_lower>:
	}
#endif
}

void test_priority_normal_and_lower()
{
f01171b5:	55                   	push   %ebp
f01171b6:	89 e5                	mov    %esp,%ebp
f01171b8:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f01171bb:	83 ec 04             	sub    $0x4,%esp
f01171be:	68 84 4a 13 f0       	push   $0xf0134a84
f01171c3:	68 d7 00 00 00       	push   $0xd7
f01171c8:	68 94 4a 13 f0       	push   $0xf0134a94
f01171cd:	e8 dd 9c fe ff       	call   f0100eaf <_panic>

f01171d2 <get_kheap_strategy>:
static inline uint32 get_kheap_strategy(){return kheapPlacementStrategy ;}
f01171d2:	55                   	push   %ebp
f01171d3:	89 e5                	mov    %esp,%ebp
f01171d5:	a1 c4 69 85 f0       	mov    0xf08569c4,%eax
f01171da:	5d                   	pop    %ebp
f01171db:	c3                   	ret    

f01171dc <test_kmalloc>:


uint32 da_limit = KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE ;

int test_kmalloc(uint32 ALLOC_TYPE)
{
f01171dc:	55                   	push   %ebp
f01171dd:	89 e5                	mov    %esp,%ebp
f01171df:	83 ec 08             	sub    $0x8,%esp
	if (get_kheap_strategy() == KHP_PLACE_FIRSTFIT)
f01171e2:	e8 eb ff ff ff       	call   f01171d2 <get_kheap_strategy>
f01171e7:	83 f8 01             	cmp    $0x1,%eax
f01171ea:	75 34                	jne    f0117220 <test_kmalloc+0x44>
	{
		//Test FIRST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f01171ec:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01171f0:	75 0a                	jne    f01171fc <test_kmalloc+0x20>
			test_kmalloc_FF_page();
f01171f2:	e8 d3 03 00 00       	call   f01175ca <test_kmalloc_FF_page>
f01171f7:	e9 f3 00 00 00       	jmp    f01172ef <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f01171fc:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0117200:	75 0a                	jne    f011720c <test_kmalloc+0x30>
			test_kmalloc_FF_block();
f0117202:	e8 54 04 00 00       	call   f011765b <test_kmalloc_FF_block>
f0117207:	e9 e3 00 00 00       	jmp    f01172ef <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f011720c:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0117210:	0f 85 d9 00 00 00    	jne    f01172ef <test_kmalloc+0x113>
			test_kmalloc_FF_both();
f0117216:	e8 d1 04 00 00       	call   f01176ec <test_kmalloc_FF_both>
f011721b:	e9 cf 00 00 00       	jmp    f01172ef <test_kmalloc+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_BESTFIT)
f0117220:	e8 ad ff ff ff       	call   f01171d2 <get_kheap_strategy>
f0117225:	83 f8 02             	cmp    $0x2,%eax
f0117228:	75 34                	jne    f011725e <test_kmalloc+0x82>
	{
		//Test BEST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f011722a:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011722e:	75 0a                	jne    f011723a <test_kmalloc+0x5e>
			test_kmalloc_BF_page();
f0117230:	e8 cf 03 00 00       	call   f0117604 <test_kmalloc_BF_page>
f0117235:	e9 b5 00 00 00       	jmp    f01172ef <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f011723a:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011723e:	75 0a                	jne    f011724a <test_kmalloc+0x6e>
			test_kmalloc_BF_block();
f0117240:	e8 50 04 00 00       	call   f0117695 <test_kmalloc_BF_block>
f0117245:	e9 a5 00 00 00       	jmp    f01172ef <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f011724a:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f011724e:	0f 85 9b 00 00 00    	jne    f01172ef <test_kmalloc+0x113>
			test_kmalloc_BF_both();
f0117254:	e8 cd 04 00 00       	call   f0117726 <test_kmalloc_BF_both>
f0117259:	e9 91 00 00 00       	jmp    f01172ef <test_kmalloc+0x113>
	}
	else if(get_kheap_strategy() == KHP_PLACE_NEXTFIT)
f011725e:	e8 6f ff ff ff       	call   f01171d2 <get_kheap_strategy>
f0117263:	83 f8 03             	cmp    $0x3,%eax
f0117266:	75 27                	jne    f011728f <test_kmalloc+0xb3>
	{
		//Test NEXT FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f0117268:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011726c:	75 07                	jne    f0117275 <test_kmalloc+0x99>
			test_kmalloc_NF_page();
f011726e:	e8 74 03 00 00       	call   f01175e7 <test_kmalloc_NF_page>
f0117273:	eb 7a                	jmp    f01172ef <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f0117275:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0117279:	75 07                	jne    f0117282 <test_kmalloc+0xa6>
			test_kmalloc_NF_block();
f011727b:	e8 f8 03 00 00       	call   f0117678 <test_kmalloc_NF_block>
f0117280:	eb 6d                	jmp    f01172ef <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f0117282:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0117286:	75 67                	jne    f01172ef <test_kmalloc+0x113>
			test_kmalloc_NF_both();
f0117288:	e8 7c 04 00 00       	call   f0117709 <test_kmalloc_NF_both>
f011728d:	eb 60                	jmp    f01172ef <test_kmalloc+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_WORSTFIT)
f011728f:	e8 3e ff ff ff       	call   f01171d2 <get_kheap_strategy>
f0117294:	83 f8 04             	cmp    $0x4,%eax
f0117297:	75 27                	jne    f01172c0 <test_kmalloc+0xe4>
	{
		//Test WORST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f0117299:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011729d:	75 07                	jne    f01172a6 <test_kmalloc+0xca>
			test_kmalloc_WF_page();
f011729f:	e8 7d 03 00 00       	call   f0117621 <test_kmalloc_WF_page>
f01172a4:	eb 49                	jmp    f01172ef <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f01172a6:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01172aa:	75 07                	jne    f01172b3 <test_kmalloc+0xd7>
			test_kmalloc_WF_block();
f01172ac:	e8 01 04 00 00       	call   f01176b2 <test_kmalloc_WF_block>
f01172b1:	eb 3c                	jmp    f01172ef <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f01172b3:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01172b7:	75 36                	jne    f01172ef <test_kmalloc+0x113>
			test_kmalloc_WF_both();
f01172b9:	e8 85 04 00 00       	call   f0117743 <test_kmalloc_WF_both>
f01172be:	eb 2f                	jmp    f01172ef <test_kmalloc+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_CUSTOMFIT)
f01172c0:	e8 0d ff ff ff       	call   f01171d2 <get_kheap_strategy>
f01172c5:	83 f8 05             	cmp    $0x5,%eax
f01172c8:	75 25                	jne    f01172ef <test_kmalloc+0x113>
	{
		//Test CUSTOM FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f01172ca:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01172ce:	75 07                	jne    f01172d7 <test_kmalloc+0xfb>
			test_kmalloc_CF_page();
f01172d0:	e8 69 03 00 00       	call   f011763e <test_kmalloc_CF_page>
f01172d5:	eb 18                	jmp    f01172ef <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f01172d7:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01172db:	75 07                	jne    f01172e4 <test_kmalloc+0x108>
			test_kmalloc_CF_block();
f01172dd:	e8 ed 03 00 00       	call   f01176cf <test_kmalloc_CF_block>
f01172e2:	eb 0b                	jmp    f01172ef <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f01172e4:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01172e8:	75 05                	jne    f01172ef <test_kmalloc+0x113>
			test_kmalloc_CF_both();
f01172ea:	e8 71 04 00 00       	call   f0117760 <test_kmalloc_CF_both>
	}
	return 0;
f01172ef:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01172f4:	c9                   	leave  
f01172f5:	c3                   	ret    

f01172f6 <test_kfree>:

int test_kfree(uint32 ALLOC_TYPE)
{
f01172f6:	55                   	push   %ebp
f01172f7:	89 e5                	mov    %esp,%ebp
f01172f9:	83 ec 08             	sub    $0x8,%esp
	if (get_kheap_strategy() == KHP_PLACE_FIRSTFIT)
f01172fc:	e8 d1 fe ff ff       	call   f01171d2 <get_kheap_strategy>
f0117301:	83 f8 01             	cmp    $0x1,%eax
f0117304:	75 34                	jne    f011733a <test_kfree+0x44>
	{
		//Test FIRST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f0117306:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011730a:	75 0a                	jne    f0117316 <test_kfree+0x20>
			test_kfree_FF_page();
f011730c:	e8 6c 04 00 00       	call   f011777d <test_kfree_FF_page>
f0117311:	e9 f3 00 00 00       	jmp    f0117409 <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f0117316:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011731a:	75 0a                	jne    f0117326 <test_kfree+0x30>
			test_kfree_FF_block();
f011731c:	e8 ed 04 00 00       	call   f011780e <test_kfree_FF_block>
f0117321:	e9 e3 00 00 00       	jmp    f0117409 <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f0117326:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f011732a:	0f 85 d9 00 00 00    	jne    f0117409 <test_kfree+0x113>
			test_kfree_FF_both();
f0117330:	e8 6a 05 00 00       	call   f011789f <test_kfree_FF_both>
f0117335:	e9 cf 00 00 00       	jmp    f0117409 <test_kfree+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_BESTFIT)
f011733a:	e8 93 fe ff ff       	call   f01171d2 <get_kheap_strategy>
f011733f:	83 f8 02             	cmp    $0x2,%eax
f0117342:	75 34                	jne    f0117378 <test_kfree+0x82>
	{
		//Test BEST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f0117344:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0117348:	75 0a                	jne    f0117354 <test_kfree+0x5e>
			test_kfree_BF_page();
f011734a:	e8 68 04 00 00       	call   f01177b7 <test_kfree_BF_page>
f011734f:	e9 b5 00 00 00       	jmp    f0117409 <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f0117354:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0117358:	75 0a                	jne    f0117364 <test_kfree+0x6e>
			test_kfree_BF_block();
f011735a:	e8 e9 04 00 00       	call   f0117848 <test_kfree_BF_block>
f011735f:	e9 a5 00 00 00       	jmp    f0117409 <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f0117364:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0117368:	0f 85 9b 00 00 00    	jne    f0117409 <test_kfree+0x113>
			test_kfree_BF_both();
f011736e:	e8 66 05 00 00       	call   f01178d9 <test_kfree_BF_both>
f0117373:	e9 91 00 00 00       	jmp    f0117409 <test_kfree+0x113>
	}
	else if(get_kheap_strategy() == KHP_PLACE_NEXTFIT)
f0117378:	e8 55 fe ff ff       	call   f01171d2 <get_kheap_strategy>
f011737d:	83 f8 03             	cmp    $0x3,%eax
f0117380:	75 27                	jne    f01173a9 <test_kfree+0xb3>
	{
		//Test NEXT FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f0117382:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0117386:	75 07                	jne    f011738f <test_kfree+0x99>
			test_kfree_NF_page();
f0117388:	e8 0d 04 00 00       	call   f011779a <test_kfree_NF_page>
f011738d:	eb 7a                	jmp    f0117409 <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f011738f:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0117393:	75 07                	jne    f011739c <test_kfree+0xa6>
			test_kfree_NF_block();
f0117395:	e8 91 04 00 00       	call   f011782b <test_kfree_NF_block>
f011739a:	eb 6d                	jmp    f0117409 <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f011739c:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01173a0:	75 67                	jne    f0117409 <test_kfree+0x113>
			test_kfree_NF_both();
f01173a2:	e8 15 05 00 00       	call   f01178bc <test_kfree_NF_both>
f01173a7:	eb 60                	jmp    f0117409 <test_kfree+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_WORSTFIT)
f01173a9:	e8 24 fe ff ff       	call   f01171d2 <get_kheap_strategy>
f01173ae:	83 f8 04             	cmp    $0x4,%eax
f01173b1:	75 27                	jne    f01173da <test_kfree+0xe4>
	{
		//Test WORST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f01173b3:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01173b7:	75 07                	jne    f01173c0 <test_kfree+0xca>
			test_kfree_WF_page();
f01173b9:	e8 16 04 00 00       	call   f01177d4 <test_kfree_WF_page>
f01173be:	eb 49                	jmp    f0117409 <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f01173c0:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01173c4:	75 07                	jne    f01173cd <test_kfree+0xd7>
			test_kfree_WF_block();
f01173c6:	e8 9a 04 00 00       	call   f0117865 <test_kfree_WF_block>
f01173cb:	eb 3c                	jmp    f0117409 <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f01173cd:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01173d1:	75 36                	jne    f0117409 <test_kfree+0x113>
			test_kfree_WF_both();
f01173d3:	e8 1e 05 00 00       	call   f01178f6 <test_kfree_WF_both>
f01173d8:	eb 2f                	jmp    f0117409 <test_kfree+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_CUSTOMFIT)
f01173da:	e8 f3 fd ff ff       	call   f01171d2 <get_kheap_strategy>
f01173df:	83 f8 05             	cmp    $0x5,%eax
f01173e2:	75 25                	jne    f0117409 <test_kfree+0x113>
	{
		//Test CUSTOM FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f01173e4:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01173e8:	75 07                	jne    f01173f1 <test_kfree+0xfb>
			test_kfree_CF_page();
f01173ea:	e8 02 04 00 00       	call   f01177f1 <test_kfree_CF_page>
f01173ef:	eb 18                	jmp    f0117409 <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f01173f1:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01173f5:	75 07                	jne    f01173fe <test_kfree+0x108>
			test_kfree_CF_block();
f01173f7:	e8 86 04 00 00       	call   f0117882 <test_kfree_CF_block>
f01173fc:	eb 0b                	jmp    f0117409 <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f01173fe:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0117402:	75 05                	jne    f0117409 <test_kfree+0x113>
			test_kfree_CF_both();
f0117404:	e8 0a 05 00 00       	call   f0117913 <test_kfree_CF_both>
	}
	return 0;
f0117409:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011740e:	c9                   	leave  
f011740f:	c3                   	ret    

f0117410 <test_krealloc>:
int test_krealloc(uint32 ALLOC_TYPE)
{
f0117410:	55                   	push   %ebp
f0117411:	89 e5                	mov    %esp,%ebp
f0117413:	83 ec 08             	sub    $0x8,%esp
	if (get_kheap_strategy() == KHP_PLACE_FIRSTFIT)
f0117416:	e8 b7 fd ff ff       	call   f01171d2 <get_kheap_strategy>
f011741b:	83 f8 01             	cmp    $0x1,%eax
f011741e:	75 34                	jne    f0117454 <test_krealloc+0x44>
	{
		//Test FIRST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f0117420:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0117424:	75 0a                	jne    f0117430 <test_krealloc+0x20>
			test_krealloc_FF_page();
f0117426:	e8 05 05 00 00       	call   f0117930 <test_krealloc_FF_page>
f011742b:	e9 f3 00 00 00       	jmp    f0117523 <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f0117430:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0117434:	75 0a                	jne    f0117440 <test_krealloc+0x30>
			test_krealloc_FF_block();
f0117436:	e8 86 05 00 00       	call   f01179c1 <test_krealloc_FF_block>
f011743b:	e9 e3 00 00 00       	jmp    f0117523 <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f0117440:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0117444:	0f 85 d9 00 00 00    	jne    f0117523 <test_krealloc+0x113>
			test_krealloc_FF_both();
f011744a:	e8 03 06 00 00       	call   f0117a52 <test_krealloc_FF_both>
f011744f:	e9 cf 00 00 00       	jmp    f0117523 <test_krealloc+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_BESTFIT)
f0117454:	e8 79 fd ff ff       	call   f01171d2 <get_kheap_strategy>
f0117459:	83 f8 02             	cmp    $0x2,%eax
f011745c:	75 34                	jne    f0117492 <test_krealloc+0x82>
	{
		//Test BEST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f011745e:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0117462:	75 0a                	jne    f011746e <test_krealloc+0x5e>
			test_krealloc_BF_page();
f0117464:	e8 01 05 00 00       	call   f011796a <test_krealloc_BF_page>
f0117469:	e9 b5 00 00 00       	jmp    f0117523 <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f011746e:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0117472:	75 0a                	jne    f011747e <test_krealloc+0x6e>
			test_krealloc_BF_block();
f0117474:	e8 82 05 00 00       	call   f01179fb <test_krealloc_BF_block>
f0117479:	e9 a5 00 00 00       	jmp    f0117523 <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f011747e:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0117482:	0f 85 9b 00 00 00    	jne    f0117523 <test_krealloc+0x113>
			test_krealloc_BF_both();
f0117488:	e8 ff 05 00 00       	call   f0117a8c <test_krealloc_BF_both>
f011748d:	e9 91 00 00 00       	jmp    f0117523 <test_krealloc+0x113>
	}
	else if(get_kheap_strategy() == KHP_PLACE_NEXTFIT)
f0117492:	e8 3b fd ff ff       	call   f01171d2 <get_kheap_strategy>
f0117497:	83 f8 03             	cmp    $0x3,%eax
f011749a:	75 27                	jne    f01174c3 <test_krealloc+0xb3>
	{
		//Test NEXT FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f011749c:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01174a0:	75 07                	jne    f01174a9 <test_krealloc+0x99>
			test_krealloc_NF_page();
f01174a2:	e8 a6 04 00 00       	call   f011794d <test_krealloc_NF_page>
f01174a7:	eb 7a                	jmp    f0117523 <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f01174a9:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01174ad:	75 07                	jne    f01174b6 <test_krealloc+0xa6>
			test_krealloc_NF_block();
f01174af:	e8 2a 05 00 00       	call   f01179de <test_krealloc_NF_block>
f01174b4:	eb 6d                	jmp    f0117523 <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f01174b6:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01174ba:	75 67                	jne    f0117523 <test_krealloc+0x113>
			test_krealloc_NF_both();
f01174bc:	e8 ae 05 00 00       	call   f0117a6f <test_krealloc_NF_both>
f01174c1:	eb 60                	jmp    f0117523 <test_krealloc+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_WORSTFIT)
f01174c3:	e8 0a fd ff ff       	call   f01171d2 <get_kheap_strategy>
f01174c8:	83 f8 04             	cmp    $0x4,%eax
f01174cb:	75 27                	jne    f01174f4 <test_krealloc+0xe4>
	{
		//Test WORST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f01174cd:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01174d1:	75 07                	jne    f01174da <test_krealloc+0xca>
			test_krealloc_WF_page();
f01174d3:	e8 af 04 00 00       	call   f0117987 <test_krealloc_WF_page>
f01174d8:	eb 49                	jmp    f0117523 <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f01174da:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01174de:	75 07                	jne    f01174e7 <test_krealloc+0xd7>
			test_krealloc_WF_block();
f01174e0:	e8 33 05 00 00       	call   f0117a18 <test_krealloc_WF_block>
f01174e5:	eb 3c                	jmp    f0117523 <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f01174e7:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01174eb:	75 36                	jne    f0117523 <test_krealloc+0x113>
			test_krealloc_WF_both();
f01174ed:	e8 b7 05 00 00       	call   f0117aa9 <test_krealloc_WF_both>
f01174f2:	eb 2f                	jmp    f0117523 <test_krealloc+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_CUSTOMFIT)
f01174f4:	e8 d9 fc ff ff       	call   f01171d2 <get_kheap_strategy>
f01174f9:	83 f8 05             	cmp    $0x5,%eax
f01174fc:	75 25                	jne    f0117523 <test_krealloc+0x113>
	{
		//Test CUSTOM FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f01174fe:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0117502:	75 07                	jne    f011750b <test_krealloc+0xfb>
			test_krealloc_CF_page();
f0117504:	e8 9b 04 00 00       	call   f01179a4 <test_krealloc_CF_page>
f0117509:	eb 18                	jmp    f0117523 <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f011750b:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011750f:	75 07                	jne    f0117518 <test_krealloc+0x108>
			test_krealloc_CF_block();
f0117511:	e8 1f 05 00 00       	call   f0117a35 <test_krealloc_CF_block>
f0117516:	eb 0b                	jmp    f0117523 <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f0117518:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f011751c:	75 05                	jne    f0117523 <test_krealloc+0x113>
			test_krealloc_CF_both();
f011751e:	e8 a3 05 00 00       	call   f0117ac6 <test_krealloc_CF_both>
	}
	return 0;
f0117523:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0117528:	c9                   	leave  
f0117529:	c3                   	ret    

f011752a <test_fast_page_alloc>:

void* ptr_fast_allocations[(KERNEL_HEAP_MAX - KERNEL_HEAP_START)/PAGE_SIZE] = {0};
int test_fast_page_alloc()
{
f011752a:	55                   	push   %ebp
f011752b:	89 e5                	mov    %esp,%ebp
f011752d:	83 ec 08             	sub    $0x8,%esp
	if (get_kheap_strategy() == KHP_PLACE_FIRSTFIT)
f0117530:	e8 9d fc ff ff       	call   f01171d2 <get_kheap_strategy>
f0117535:	83 f8 01             	cmp    $0x1,%eax
f0117538:	75 07                	jne    f0117541 <test_fast_page_alloc+0x17>
	{
		test_fast_FF();
f011753a:	e8 a4 05 00 00       	call   f0117ae3 <test_fast_FF>
f011753f:	eb 42                	jmp    f0117583 <test_fast_page_alloc+0x59>
	}
	else if (get_kheap_strategy() == KHP_PLACE_NEXTFIT)
f0117541:	e8 8c fc ff ff       	call   f01171d2 <get_kheap_strategy>
f0117546:	83 f8 03             	cmp    $0x3,%eax
f0117549:	75 07                	jne    f0117552 <test_fast_page_alloc+0x28>
	{
		test_fast_NF();
f011754b:	e8 b0 05 00 00       	call   f0117b00 <test_fast_NF>
f0117550:	eb 31                	jmp    f0117583 <test_fast_page_alloc+0x59>
	}
	else if (get_kheap_strategy() == KHP_PLACE_BESTFIT)
f0117552:	e8 7b fc ff ff       	call   f01171d2 <get_kheap_strategy>
f0117557:	83 f8 02             	cmp    $0x2,%eax
f011755a:	75 07                	jne    f0117563 <test_fast_page_alloc+0x39>
	{
		test_fast_BF();
f011755c:	e8 bc 05 00 00       	call   f0117b1d <test_fast_BF>
f0117561:	eb 20                	jmp    f0117583 <test_fast_page_alloc+0x59>
	}
	else if (get_kheap_strategy() == KHP_PLACE_WORSTFIT)
f0117563:	e8 6a fc ff ff       	call   f01171d2 <get_kheap_strategy>
f0117568:	83 f8 04             	cmp    $0x4,%eax
f011756b:	75 07                	jne    f0117574 <test_fast_page_alloc+0x4a>
	{
		test_fast_WF();
f011756d:	e8 c8 05 00 00       	call   f0117b3a <test_fast_WF>
f0117572:	eb 0f                	jmp    f0117583 <test_fast_page_alloc+0x59>
	}
	else if (get_kheap_strategy() == KHP_PLACE_CUSTOMFIT)
f0117574:	e8 59 fc ff ff       	call   f01171d2 <get_kheap_strategy>
f0117579:	83 f8 05             	cmp    $0x5,%eax
f011757c:	75 05                	jne    f0117583 <test_fast_page_alloc+0x59>
	{
		test_fast_CF();
f011757e:	e8 d4 05 00 00       	call   f0117b57 <test_fast_CF>
	}
	return 0;
f0117583:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0117588:	c9                   	leave  
f0117589:	c3                   	ret    

f011758a <test_kheap_phys_addr>:

int test_kheap_phys_addr()
{
f011758a:	55                   	push   %ebp
f011758b:	89 e5                	mov    %esp,%ebp
f011758d:	81 ec 28 35 00 00    	sub    $0x3528,%esp
	panic("update is required!!");
f0117593:	83 ec 04             	sub    $0x4,%esp
f0117596:	68 b0 4a 13 f0       	push   $0xf0134ab0
f011759b:	68 28 01 00 00       	push   $0x128
f01175a0:	68 c5 4a 13 f0       	push   $0xf0134ac5
f01175a5:	e8 05 99 fe ff       	call   f0100eaf <_panic>

f01175aa <test_kheap_virt_addr>:
	return 1;

}

int test_kheap_virt_addr()
{
f01175aa:	55                   	push   %ebp
f01175ab:	89 e5                	mov    %esp,%ebp
f01175ad:	81 ec 08 01 00 00    	sub    $0x108,%esp
	panic("update is required!!");
f01175b3:	83 ec 04             	sub    $0x4,%esp
f01175b6:	68 b0 4a 13 f0       	push   $0xf0134ab0
f01175bb:	68 6d 02 00 00       	push   $0x26d
f01175c0:	68 c5 4a 13 f0       	push   $0xf0134ac5
f01175c5:	e8 e5 98 fe ff       	call   f0100eaf <_panic>

f01175ca <test_kmalloc_FF_page>:

/**********************************************************************************************/
/********************************** KMALLOC TESTING AREA **************************************/
/**********************************************************************************************/
int test_kmalloc_FF_page()
{
f01175ca:	55                   	push   %ebp
f01175cb:	89 e5                	mov    %esp,%ebp
f01175cd:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01175d0:	83 ec 04             	sub    $0x4,%esp
f01175d3:	68 dd 4a 13 f0       	push   $0xf0134add
f01175d8:	68 93 03 00 00       	push   $0x393
f01175dd:	68 c5 4a 13 f0       	push   $0xf0134ac5
f01175e2:	e8 c8 98 fe ff       	call   f0100eaf <_panic>

f01175e7 <test_kmalloc_NF_page>:
}
int test_kmalloc_NF_page()
{
f01175e7:	55                   	push   %ebp
f01175e8:	89 e5                	mov    %esp,%ebp
f01175ea:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01175ed:	83 ec 04             	sub    $0x4,%esp
f01175f0:	68 dd 4a 13 f0       	push   $0xf0134add
f01175f5:	68 97 03 00 00       	push   $0x397
f01175fa:	68 c5 4a 13 f0       	push   $0xf0134ac5
f01175ff:	e8 ab 98 fe ff       	call   f0100eaf <_panic>

f0117604 <test_kmalloc_BF_page>:
}
int test_kmalloc_BF_page()
{
f0117604:	55                   	push   %ebp
f0117605:	89 e5                	mov    %esp,%ebp
f0117607:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011760a:	83 ec 04             	sub    $0x4,%esp
f011760d:	68 dd 4a 13 f0       	push   $0xf0134add
f0117612:	68 9b 03 00 00       	push   $0x39b
f0117617:	68 c5 4a 13 f0       	push   $0xf0134ac5
f011761c:	e8 8e 98 fe ff       	call   f0100eaf <_panic>

f0117621 <test_kmalloc_WF_page>:
}
int test_kmalloc_WF_page()
{
f0117621:	55                   	push   %ebp
f0117622:	89 e5                	mov    %esp,%ebp
f0117624:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117627:	83 ec 04             	sub    $0x4,%esp
f011762a:	68 dd 4a 13 f0       	push   $0xf0134add
f011762f:	68 9f 03 00 00       	push   $0x39f
f0117634:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117639:	e8 71 98 fe ff       	call   f0100eaf <_panic>

f011763e <test_kmalloc_CF_page>:
}
int test_kmalloc_CF_page()
{
f011763e:	55                   	push   %ebp
f011763f:	89 e5                	mov    %esp,%ebp
f0117641:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117644:	83 ec 04             	sub    $0x4,%esp
f0117647:	68 dd 4a 13 f0       	push   $0xf0134add
f011764c:	68 a3 03 00 00       	push   $0x3a3
f0117651:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117656:	e8 54 98 fe ff       	call   f0100eaf <_panic>

f011765b <test_kmalloc_FF_block>:
}

int test_kmalloc_FF_block()
{
f011765b:	55                   	push   %ebp
f011765c:	89 e5                	mov    %esp,%ebp
f011765e:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117661:	83 ec 04             	sub    $0x4,%esp
f0117664:	68 dd 4a 13 f0       	push   $0xf0134add
f0117669:	68 a8 03 00 00       	push   $0x3a8
f011766e:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117673:	e8 37 98 fe ff       	call   f0100eaf <_panic>

f0117678 <test_kmalloc_NF_block>:
}
int test_kmalloc_NF_block()
{
f0117678:	55                   	push   %ebp
f0117679:	89 e5                	mov    %esp,%ebp
f011767b:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011767e:	83 ec 04             	sub    $0x4,%esp
f0117681:	68 dd 4a 13 f0       	push   $0xf0134add
f0117686:	68 ac 03 00 00       	push   $0x3ac
f011768b:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117690:	e8 1a 98 fe ff       	call   f0100eaf <_panic>

f0117695 <test_kmalloc_BF_block>:
}
int test_kmalloc_BF_block()
{
f0117695:	55                   	push   %ebp
f0117696:	89 e5                	mov    %esp,%ebp
f0117698:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011769b:	83 ec 04             	sub    $0x4,%esp
f011769e:	68 dd 4a 13 f0       	push   $0xf0134add
f01176a3:	68 b0 03 00 00       	push   $0x3b0
f01176a8:	68 c5 4a 13 f0       	push   $0xf0134ac5
f01176ad:	e8 fd 97 fe ff       	call   f0100eaf <_panic>

f01176b2 <test_kmalloc_WF_block>:
}
int test_kmalloc_WF_block()
{
f01176b2:	55                   	push   %ebp
f01176b3:	89 e5                	mov    %esp,%ebp
f01176b5:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01176b8:	83 ec 04             	sub    $0x4,%esp
f01176bb:	68 dd 4a 13 f0       	push   $0xf0134add
f01176c0:	68 b4 03 00 00       	push   $0x3b4
f01176c5:	68 c5 4a 13 f0       	push   $0xf0134ac5
f01176ca:	e8 e0 97 fe ff       	call   f0100eaf <_panic>

f01176cf <test_kmalloc_CF_block>:
}
int test_kmalloc_CF_block()
{
f01176cf:	55                   	push   %ebp
f01176d0:	89 e5                	mov    %esp,%ebp
f01176d2:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01176d5:	83 ec 04             	sub    $0x4,%esp
f01176d8:	68 dd 4a 13 f0       	push   $0xf0134add
f01176dd:	68 b8 03 00 00       	push   $0x3b8
f01176e2:	68 c5 4a 13 f0       	push   $0xf0134ac5
f01176e7:	e8 c3 97 fe ff       	call   f0100eaf <_panic>

f01176ec <test_kmalloc_FF_both>:
}

int test_kmalloc_FF_both()
{
f01176ec:	55                   	push   %ebp
f01176ed:	89 e5                	mov    %esp,%ebp
f01176ef:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01176f2:	83 ec 04             	sub    $0x4,%esp
f01176f5:	68 dd 4a 13 f0       	push   $0xf0134add
f01176fa:	68 bd 03 00 00       	push   $0x3bd
f01176ff:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117704:	e8 a6 97 fe ff       	call   f0100eaf <_panic>

f0117709 <test_kmalloc_NF_both>:
}
int test_kmalloc_NF_both()
{
f0117709:	55                   	push   %ebp
f011770a:	89 e5                	mov    %esp,%ebp
f011770c:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011770f:	83 ec 04             	sub    $0x4,%esp
f0117712:	68 dd 4a 13 f0       	push   $0xf0134add
f0117717:	68 c1 03 00 00       	push   $0x3c1
f011771c:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117721:	e8 89 97 fe ff       	call   f0100eaf <_panic>

f0117726 <test_kmalloc_BF_both>:
}
int test_kmalloc_BF_both()
{
f0117726:	55                   	push   %ebp
f0117727:	89 e5                	mov    %esp,%ebp
f0117729:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011772c:	83 ec 04             	sub    $0x4,%esp
f011772f:	68 dd 4a 13 f0       	push   $0xf0134add
f0117734:	68 c5 03 00 00       	push   $0x3c5
f0117739:	68 c5 4a 13 f0       	push   $0xf0134ac5
f011773e:	e8 6c 97 fe ff       	call   f0100eaf <_panic>

f0117743 <test_kmalloc_WF_both>:
}
int test_kmalloc_WF_both()
{
f0117743:	55                   	push   %ebp
f0117744:	89 e5                	mov    %esp,%ebp
f0117746:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117749:	83 ec 04             	sub    $0x4,%esp
f011774c:	68 dd 4a 13 f0       	push   $0xf0134add
f0117751:	68 c9 03 00 00       	push   $0x3c9
f0117756:	68 c5 4a 13 f0       	push   $0xf0134ac5
f011775b:	e8 4f 97 fe ff       	call   f0100eaf <_panic>

f0117760 <test_kmalloc_CF_both>:
}
int test_kmalloc_CF_both()
{
f0117760:	55                   	push   %ebp
f0117761:	89 e5                	mov    %esp,%ebp
f0117763:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117766:	83 ec 04             	sub    $0x4,%esp
f0117769:	68 dd 4a 13 f0       	push   $0xf0134add
f011776e:	68 cd 03 00 00       	push   $0x3cd
f0117773:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117778:	e8 32 97 fe ff       	call   f0100eaf <_panic>

f011777d <test_kfree_FF_page>:

/**********************************************************************************************/
/*********************************** KFREE TESTING AREA ***************************************/
/**********************************************************************************************/
int test_kfree_FF_page()
{
f011777d:	55                   	push   %ebp
f011777e:	89 e5                	mov    %esp,%ebp
f0117780:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117783:	83 ec 04             	sub    $0x4,%esp
f0117786:	68 dd 4a 13 f0       	push   $0xf0134add
f011778b:	68 d5 03 00 00       	push   $0x3d5
f0117790:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117795:	e8 15 97 fe ff       	call   f0100eaf <_panic>

f011779a <test_kfree_NF_page>:
}
int test_kfree_NF_page()
{
f011779a:	55                   	push   %ebp
f011779b:	89 e5                	mov    %esp,%ebp
f011779d:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01177a0:	83 ec 04             	sub    $0x4,%esp
f01177a3:	68 dd 4a 13 f0       	push   $0xf0134add
f01177a8:	68 d9 03 00 00       	push   $0x3d9
f01177ad:	68 c5 4a 13 f0       	push   $0xf0134ac5
f01177b2:	e8 f8 96 fe ff       	call   f0100eaf <_panic>

f01177b7 <test_kfree_BF_page>:
}
int test_kfree_BF_page()
{
f01177b7:	55                   	push   %ebp
f01177b8:	89 e5                	mov    %esp,%ebp
f01177ba:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01177bd:	83 ec 04             	sub    $0x4,%esp
f01177c0:	68 dd 4a 13 f0       	push   $0xf0134add
f01177c5:	68 dd 03 00 00       	push   $0x3dd
f01177ca:	68 c5 4a 13 f0       	push   $0xf0134ac5
f01177cf:	e8 db 96 fe ff       	call   f0100eaf <_panic>

f01177d4 <test_kfree_WF_page>:
}
int test_kfree_WF_page()
{
f01177d4:	55                   	push   %ebp
f01177d5:	89 e5                	mov    %esp,%ebp
f01177d7:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01177da:	83 ec 04             	sub    $0x4,%esp
f01177dd:	68 dd 4a 13 f0       	push   $0xf0134add
f01177e2:	68 e1 03 00 00       	push   $0x3e1
f01177e7:	68 c5 4a 13 f0       	push   $0xf0134ac5
f01177ec:	e8 be 96 fe ff       	call   f0100eaf <_panic>

f01177f1 <test_kfree_CF_page>:
}
int test_kfree_CF_page()
{
f01177f1:	55                   	push   %ebp
f01177f2:	89 e5                	mov    %esp,%ebp
f01177f4:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01177f7:	83 ec 04             	sub    $0x4,%esp
f01177fa:	68 dd 4a 13 f0       	push   $0xf0134add
f01177ff:	68 e5 03 00 00       	push   $0x3e5
f0117804:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117809:	e8 a1 96 fe ff       	call   f0100eaf <_panic>

f011780e <test_kfree_FF_block>:
}

int test_kfree_FF_block()
{
f011780e:	55                   	push   %ebp
f011780f:	89 e5                	mov    %esp,%ebp
f0117811:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117814:	83 ec 04             	sub    $0x4,%esp
f0117817:	68 dd 4a 13 f0       	push   $0xf0134add
f011781c:	68 ea 03 00 00       	push   $0x3ea
f0117821:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117826:	e8 84 96 fe ff       	call   f0100eaf <_panic>

f011782b <test_kfree_NF_block>:
}
int test_kfree_NF_block()
{
f011782b:	55                   	push   %ebp
f011782c:	89 e5                	mov    %esp,%ebp
f011782e:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117831:	83 ec 04             	sub    $0x4,%esp
f0117834:	68 dd 4a 13 f0       	push   $0xf0134add
f0117839:	68 ee 03 00 00       	push   $0x3ee
f011783e:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117843:	e8 67 96 fe ff       	call   f0100eaf <_panic>

f0117848 <test_kfree_BF_block>:
}
int test_kfree_BF_block()
{
f0117848:	55                   	push   %ebp
f0117849:	89 e5                	mov    %esp,%ebp
f011784b:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011784e:	83 ec 04             	sub    $0x4,%esp
f0117851:	68 dd 4a 13 f0       	push   $0xf0134add
f0117856:	68 f2 03 00 00       	push   $0x3f2
f011785b:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117860:	e8 4a 96 fe ff       	call   f0100eaf <_panic>

f0117865 <test_kfree_WF_block>:
}
int test_kfree_WF_block()
{
f0117865:	55                   	push   %ebp
f0117866:	89 e5                	mov    %esp,%ebp
f0117868:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011786b:	83 ec 04             	sub    $0x4,%esp
f011786e:	68 dd 4a 13 f0       	push   $0xf0134add
f0117873:	68 f6 03 00 00       	push   $0x3f6
f0117878:	68 c5 4a 13 f0       	push   $0xf0134ac5
f011787d:	e8 2d 96 fe ff       	call   f0100eaf <_panic>

f0117882 <test_kfree_CF_block>:
}
int test_kfree_CF_block()
{
f0117882:	55                   	push   %ebp
f0117883:	89 e5                	mov    %esp,%ebp
f0117885:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117888:	83 ec 04             	sub    $0x4,%esp
f011788b:	68 dd 4a 13 f0       	push   $0xf0134add
f0117890:	68 fa 03 00 00       	push   $0x3fa
f0117895:	68 c5 4a 13 f0       	push   $0xf0134ac5
f011789a:	e8 10 96 fe ff       	call   f0100eaf <_panic>

f011789f <test_kfree_FF_both>:
}

int test_kfree_FF_both()
{
f011789f:	55                   	push   %ebp
f01178a0:	89 e5                	mov    %esp,%ebp
f01178a2:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01178a5:	83 ec 04             	sub    $0x4,%esp
f01178a8:	68 dd 4a 13 f0       	push   $0xf0134add
f01178ad:	68 ff 03 00 00       	push   $0x3ff
f01178b2:	68 c5 4a 13 f0       	push   $0xf0134ac5
f01178b7:	e8 f3 95 fe ff       	call   f0100eaf <_panic>

f01178bc <test_kfree_NF_both>:
}
int test_kfree_NF_both()
{
f01178bc:	55                   	push   %ebp
f01178bd:	89 e5                	mov    %esp,%ebp
f01178bf:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01178c2:	83 ec 04             	sub    $0x4,%esp
f01178c5:	68 dd 4a 13 f0       	push   $0xf0134add
f01178ca:	68 03 04 00 00       	push   $0x403
f01178cf:	68 c5 4a 13 f0       	push   $0xf0134ac5
f01178d4:	e8 d6 95 fe ff       	call   f0100eaf <_panic>

f01178d9 <test_kfree_BF_both>:
}
int test_kfree_BF_both()
{
f01178d9:	55                   	push   %ebp
f01178da:	89 e5                	mov    %esp,%ebp
f01178dc:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01178df:	83 ec 04             	sub    $0x4,%esp
f01178e2:	68 dd 4a 13 f0       	push   $0xf0134add
f01178e7:	68 07 04 00 00       	push   $0x407
f01178ec:	68 c5 4a 13 f0       	push   $0xf0134ac5
f01178f1:	e8 b9 95 fe ff       	call   f0100eaf <_panic>

f01178f6 <test_kfree_WF_both>:
}
int test_kfree_WF_both()
{
f01178f6:	55                   	push   %ebp
f01178f7:	89 e5                	mov    %esp,%ebp
f01178f9:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01178fc:	83 ec 04             	sub    $0x4,%esp
f01178ff:	68 dd 4a 13 f0       	push   $0xf0134add
f0117904:	68 0b 04 00 00       	push   $0x40b
f0117909:	68 c5 4a 13 f0       	push   $0xf0134ac5
f011790e:	e8 9c 95 fe ff       	call   f0100eaf <_panic>

f0117913 <test_kfree_CF_both>:
}
int test_kfree_CF_both()
{
f0117913:	55                   	push   %ebp
f0117914:	89 e5                	mov    %esp,%ebp
f0117916:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117919:	83 ec 04             	sub    $0x4,%esp
f011791c:	68 dd 4a 13 f0       	push   $0xf0134add
f0117921:	68 0f 04 00 00       	push   $0x40f
f0117926:	68 c5 4a 13 f0       	push   $0xf0134ac5
f011792b:	e8 7f 95 fe ff       	call   f0100eaf <_panic>

f0117930 <test_krealloc_FF_page>:

/**********************************************************************************************/
/********************************** KREALLOC TESTING AREA *************************************/
/**********************************************************************************************/
int test_krealloc_FF_page()
{
f0117930:	55                   	push   %ebp
f0117931:	89 e5                	mov    %esp,%ebp
f0117933:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117936:	83 ec 04             	sub    $0x4,%esp
f0117939:	68 dd 4a 13 f0       	push   $0xf0134add
f011793e:	68 17 04 00 00       	push   $0x417
f0117943:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117948:	e8 62 95 fe ff       	call   f0100eaf <_panic>

f011794d <test_krealloc_NF_page>:
}
int test_krealloc_NF_page()
{
f011794d:	55                   	push   %ebp
f011794e:	89 e5                	mov    %esp,%ebp
f0117950:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117953:	83 ec 04             	sub    $0x4,%esp
f0117956:	68 dd 4a 13 f0       	push   $0xf0134add
f011795b:	68 1b 04 00 00       	push   $0x41b
f0117960:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117965:	e8 45 95 fe ff       	call   f0100eaf <_panic>

f011796a <test_krealloc_BF_page>:
}
int test_krealloc_BF_page()
{
f011796a:	55                   	push   %ebp
f011796b:	89 e5                	mov    %esp,%ebp
f011796d:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117970:	83 ec 04             	sub    $0x4,%esp
f0117973:	68 dd 4a 13 f0       	push   $0xf0134add
f0117978:	68 1f 04 00 00       	push   $0x41f
f011797d:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117982:	e8 28 95 fe ff       	call   f0100eaf <_panic>

f0117987 <test_krealloc_WF_page>:
}
int test_krealloc_WF_page()
{
f0117987:	55                   	push   %ebp
f0117988:	89 e5                	mov    %esp,%ebp
f011798a:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011798d:	83 ec 04             	sub    $0x4,%esp
f0117990:	68 dd 4a 13 f0       	push   $0xf0134add
f0117995:	68 23 04 00 00       	push   $0x423
f011799a:	68 c5 4a 13 f0       	push   $0xf0134ac5
f011799f:	e8 0b 95 fe ff       	call   f0100eaf <_panic>

f01179a4 <test_krealloc_CF_page>:
}
int test_krealloc_CF_page()
{
f01179a4:	55                   	push   %ebp
f01179a5:	89 e5                	mov    %esp,%ebp
f01179a7:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01179aa:	83 ec 04             	sub    $0x4,%esp
f01179ad:	68 dd 4a 13 f0       	push   $0xf0134add
f01179b2:	68 27 04 00 00       	push   $0x427
f01179b7:	68 c5 4a 13 f0       	push   $0xf0134ac5
f01179bc:	e8 ee 94 fe ff       	call   f0100eaf <_panic>

f01179c1 <test_krealloc_FF_block>:
}

int test_krealloc_FF_block()
{
f01179c1:	55                   	push   %ebp
f01179c2:	89 e5                	mov    %esp,%ebp
f01179c4:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01179c7:	83 ec 04             	sub    $0x4,%esp
f01179ca:	68 dd 4a 13 f0       	push   $0xf0134add
f01179cf:	68 2c 04 00 00       	push   $0x42c
f01179d4:	68 c5 4a 13 f0       	push   $0xf0134ac5
f01179d9:	e8 d1 94 fe ff       	call   f0100eaf <_panic>

f01179de <test_krealloc_NF_block>:
}
int test_krealloc_NF_block()
{
f01179de:	55                   	push   %ebp
f01179df:	89 e5                	mov    %esp,%ebp
f01179e1:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01179e4:	83 ec 04             	sub    $0x4,%esp
f01179e7:	68 dd 4a 13 f0       	push   $0xf0134add
f01179ec:	68 30 04 00 00       	push   $0x430
f01179f1:	68 c5 4a 13 f0       	push   $0xf0134ac5
f01179f6:	e8 b4 94 fe ff       	call   f0100eaf <_panic>

f01179fb <test_krealloc_BF_block>:
}
int test_krealloc_BF_block()
{
f01179fb:	55                   	push   %ebp
f01179fc:	89 e5                	mov    %esp,%ebp
f01179fe:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117a01:	83 ec 04             	sub    $0x4,%esp
f0117a04:	68 dd 4a 13 f0       	push   $0xf0134add
f0117a09:	68 34 04 00 00       	push   $0x434
f0117a0e:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117a13:	e8 97 94 fe ff       	call   f0100eaf <_panic>

f0117a18 <test_krealloc_WF_block>:
}
int test_krealloc_WF_block()
{
f0117a18:	55                   	push   %ebp
f0117a19:	89 e5                	mov    %esp,%ebp
f0117a1b:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117a1e:	83 ec 04             	sub    $0x4,%esp
f0117a21:	68 dd 4a 13 f0       	push   $0xf0134add
f0117a26:	68 38 04 00 00       	push   $0x438
f0117a2b:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117a30:	e8 7a 94 fe ff       	call   f0100eaf <_panic>

f0117a35 <test_krealloc_CF_block>:
}
int test_krealloc_CF_block()
{
f0117a35:	55                   	push   %ebp
f0117a36:	89 e5                	mov    %esp,%ebp
f0117a38:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117a3b:	83 ec 04             	sub    $0x4,%esp
f0117a3e:	68 dd 4a 13 f0       	push   $0xf0134add
f0117a43:	68 3c 04 00 00       	push   $0x43c
f0117a48:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117a4d:	e8 5d 94 fe ff       	call   f0100eaf <_panic>

f0117a52 <test_krealloc_FF_both>:
}

int test_krealloc_FF_both()
{
f0117a52:	55                   	push   %ebp
f0117a53:	89 e5                	mov    %esp,%ebp
f0117a55:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117a58:	83 ec 04             	sub    $0x4,%esp
f0117a5b:	68 dd 4a 13 f0       	push   $0xf0134add
f0117a60:	68 41 04 00 00       	push   $0x441
f0117a65:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117a6a:	e8 40 94 fe ff       	call   f0100eaf <_panic>

f0117a6f <test_krealloc_NF_both>:
}
int test_krealloc_NF_both()
{
f0117a6f:	55                   	push   %ebp
f0117a70:	89 e5                	mov    %esp,%ebp
f0117a72:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117a75:	83 ec 04             	sub    $0x4,%esp
f0117a78:	68 dd 4a 13 f0       	push   $0xf0134add
f0117a7d:	68 45 04 00 00       	push   $0x445
f0117a82:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117a87:	e8 23 94 fe ff       	call   f0100eaf <_panic>

f0117a8c <test_krealloc_BF_both>:
}
int test_krealloc_BF_both()
{
f0117a8c:	55                   	push   %ebp
f0117a8d:	89 e5                	mov    %esp,%ebp
f0117a8f:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117a92:	83 ec 04             	sub    $0x4,%esp
f0117a95:	68 dd 4a 13 f0       	push   $0xf0134add
f0117a9a:	68 49 04 00 00       	push   $0x449
f0117a9f:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117aa4:	e8 06 94 fe ff       	call   f0100eaf <_panic>

f0117aa9 <test_krealloc_WF_both>:
}
int test_krealloc_WF_both()
{
f0117aa9:	55                   	push   %ebp
f0117aaa:	89 e5                	mov    %esp,%ebp
f0117aac:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117aaf:	83 ec 04             	sub    $0x4,%esp
f0117ab2:	68 dd 4a 13 f0       	push   $0xf0134add
f0117ab7:	68 4d 04 00 00       	push   $0x44d
f0117abc:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117ac1:	e8 e9 93 fe ff       	call   f0100eaf <_panic>

f0117ac6 <test_krealloc_CF_both>:
}
int test_krealloc_CF_both()
{
f0117ac6:	55                   	push   %ebp
f0117ac7:	89 e5                	mov    %esp,%ebp
f0117ac9:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117acc:	83 ec 04             	sub    $0x4,%esp
f0117acf:	68 dd 4a 13 f0       	push   $0xf0134add
f0117ad4:	68 51 04 00 00       	push   $0x451
f0117ad9:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117ade:	e8 cc 93 fe ff       	call   f0100eaf <_panic>

f0117ae3 <test_fast_FF>:

/**********************************************************************************************/
/*************************** FAST PAGE ALLOCATOR TESTING AREA *********************************/
/**********************************************************************************************/
int test_fast_FF()
{
f0117ae3:	55                   	push   %ebp
f0117ae4:	89 e5                	mov    %esp,%ebp
f0117ae6:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117ae9:	83 ec 04             	sub    $0x4,%esp
f0117aec:	68 dd 4a 13 f0       	push   $0xf0134add
f0117af1:	68 59 04 00 00       	push   $0x459
f0117af6:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117afb:	e8 af 93 fe ff       	call   f0100eaf <_panic>

f0117b00 <test_fast_NF>:
}
int test_fast_NF()
{
f0117b00:	55                   	push   %ebp
f0117b01:	89 e5                	mov    %esp,%ebp
f0117b03:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117b06:	83 ec 04             	sub    $0x4,%esp
f0117b09:	68 dd 4a 13 f0       	push   $0xf0134add
f0117b0e:	68 5d 04 00 00       	push   $0x45d
f0117b13:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117b18:	e8 92 93 fe ff       	call   f0100eaf <_panic>

f0117b1d <test_fast_BF>:
}
int test_fast_BF()
{
f0117b1d:	55                   	push   %ebp
f0117b1e:	89 e5                	mov    %esp,%ebp
f0117b20:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117b23:	83 ec 04             	sub    $0x4,%esp
f0117b26:	68 dd 4a 13 f0       	push   $0xf0134add
f0117b2b:	68 61 04 00 00       	push   $0x461
f0117b30:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117b35:	e8 75 93 fe ff       	call   f0100eaf <_panic>

f0117b3a <test_fast_WF>:
}
int test_fast_WF()
{
f0117b3a:	55                   	push   %ebp
f0117b3b:	89 e5                	mov    %esp,%ebp
f0117b3d:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117b40:	83 ec 04             	sub    $0x4,%esp
f0117b43:	68 dd 4a 13 f0       	push   $0xf0134add
f0117b48:	68 65 04 00 00       	push   $0x465
f0117b4d:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117b52:	e8 58 93 fe ff       	call   f0100eaf <_panic>

f0117b57 <test_fast_CF>:
}
int test_fast_CF()
{
f0117b57:	55                   	push   %ebp
f0117b58:	89 e5                	mov    %esp,%ebp
f0117b5a:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117b5d:	83 ec 04             	sub    $0x4,%esp
f0117b60:	68 dd 4a 13 f0       	push   $0xf0134add
f0117b65:	68 69 04 00 00       	push   $0x469
f0117b6a:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117b6f:	e8 3b 93 fe ff       	call   f0100eaf <_panic>

f0117b74 <test_three_creation_functions>:

int initFreeFrames;
int initFreeDiskFrames ;
uint8 firstCall = 1 ;
int test_three_creation_functions()
{
f0117b74:	55                   	push   %ebp
f0117b75:	89 e5                	mov    %esp,%ebp
f0117b77:	57                   	push   %edi
f0117b78:	56                   	push   %esi
f0117b79:	53                   	push   %ebx
f0117b7a:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	if (firstCall)
f0117b80:	a0 a8 01 18 f0       	mov    0xf01801a8,%al
f0117b85:	84 c0                	test   %al,%al
f0117b87:	74 56                	je     f0117bdf <test_three_creation_functions+0x6b>
	{
		firstCall = 0;
f0117b89:	c6 05 a8 01 18 f0 00 	movb   $0x0,0xf01801a8
		initFreeFrames = sys_calculate_free_frames() ;
f0117b90:	e8 13 6d ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f0117b95:	a3 c8 d4 87 f0       	mov    %eax,0xf087d4c8
		initFreeDiskFrames = pf_calculate_free_frames() ;
f0117b9a:	e8 8a dc fe ff       	call   f0105829 <pf_calculate_free_frames>
f0117b9f:	a3 c4 d4 87 f0       	mov    %eax,0xf087d4c4
		//Run simple user program
		{
			char command[100] = "run fos_add 4096";
f0117ba4:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f0117baa:	bb b5 4c 13 f0       	mov    $0xf0134cb5,%ebx
f0117baf:	ba 11 00 00 00       	mov    $0x11,%edx
f0117bb4:	89 c7                	mov    %eax,%edi
f0117bb6:	89 de                	mov    %ebx,%esi
f0117bb8:	89 d1                	mov    %edx,%ecx
f0117bba:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0117bbc:	8d 95 7d ff ff ff    	lea    -0x83(%ebp),%edx
f0117bc2:	b9 53 00 00 00       	mov    $0x53,%ecx
f0117bc7:	b0 00                	mov    $0x0,%al
f0117bc9:	89 d7                	mov    %edx,%edi
f0117bcb:	f3 aa                	rep stos %al,%es:(%edi)
			execute_command(command) ;
f0117bcd:	83 ec 0c             	sub    $0xc,%esp
f0117bd0:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f0117bd6:	50                   	push   %eax
f0117bd7:	e8 3f a2 fe ff       	call   f0101e1b <execute_command>
f0117bdc:	83 c4 10             	add    $0x10,%esp
		}
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
f0117bdf:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		struct Env * ptr_env = NULL;
f0117be6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0117bed:	a1 a0 e7 83 f0       	mov    0xf083e7a0,%eax
f0117bf2:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0117bf5:	eb 2b                	jmp    f0117c22 <test_three_creation_functions+0xae>
		{
			if (strcmp(ptr_env->prog_name, "fos_add") == 0)
f0117bf7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0117bfa:	83 c0 20             	add    $0x20,%eax
f0117bfd:	83 ec 08             	sub    $0x8,%esp
f0117c00:	68 f6 4a 13 f0       	push   $0xf0134af6
f0117c05:	50                   	push   %eax
f0117c06:	e8 7c 2f 00 00       	call   f011ab87 <strcmp>
f0117c0b:	83 c4 10             	add    $0x10,%esp
f0117c0e:	85 c0                	test   %eax,%eax
f0117c10:	75 08                	jne    f0117c1a <test_three_creation_functions+0xa6>
			{
				e = ptr_env ;
f0117c12:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0117c15:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				break;
f0117c18:	eb 2f                	jmp    f0117c49 <test_three_creation_functions+0xd5>
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
		struct Env * ptr_env = NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0117c1a:	a1 a8 e7 83 f0       	mov    0xf083e7a8,%eax
f0117c1f:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0117c22:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0117c26:	74 08                	je     f0117c30 <test_three_creation_functions+0xbc>
f0117c28:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0117c2b:	8b 40 08             	mov    0x8(%eax),%eax
f0117c2e:	eb 05                	jmp    f0117c35 <test_three_creation_functions+0xc1>
f0117c30:	b8 00 00 00 00       	mov    $0x0,%eax
f0117c35:	a3 a8 e7 83 f0       	mov    %eax,0xf083e7a8
f0117c3a:	a1 a8 e7 83 f0       	mov    0xf083e7a8,%eax
f0117c3f:	85 c0                	test   %eax,%eax
f0117c41:	75 b4                	jne    f0117bf7 <test_three_creation_functions+0x83>
f0117c43:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0117c47:	75 ae                	jne    f0117bf7 <test_three_creation_functions+0x83>
			{
				e = ptr_env ;
				break;
			}
		}
		if (e->pageFaultsCounter != 0)
f0117c49:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0117c4c:	8b 80 98 05 00 00    	mov    0x598(%eax),%eax
f0117c52:	85 c0                	test   %eax,%eax
f0117c54:	74 17                	je     f0117c6d <test_three_creation_functions+0xf9>
			panic("Page fault is occur while not expected to. Review the three creation functions");
f0117c56:	83 ec 04             	sub    $0x4,%esp
f0117c59:	68 00 4b 13 f0       	push   $0xf0134b00
f0117c5e:	68 90 04 00 00       	push   $0x490
f0117c63:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117c68:	e8 42 92 fe ff       	call   f0100eaf <_panic>

#if USE_KHEAP
		int pagesInWS = LIST_SIZE(&(e->page_WS_list));
f0117c6d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0117c70:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0117c76:	89 45 dc             	mov    %eax,-0x24(%ebp)
#else
		int pagesInWS = env_page_ws_get_size(e);
#endif
		int curFreeFrames = sys_calculate_free_frames() ;
f0117c79:	e8 2a 6c ff ff       	call   f010e8a8 <sys_calculate_free_frames>
f0117c7e:	89 45 d8             	mov    %eax,-0x28(%ebp)
		int curFreeDiskFrames = pf_calculate_free_frames() ;
f0117c81:	e8 a3 db fe ff       	call   f0105829 <pf_calculate_free_frames>
f0117c86:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		//cprintf("\ndiff in page file = %d, pages in WS = %d\n", initFreeDiskFrames - curFreeDiskFrames, pagesInWS);
		if ((initFreeDiskFrames - curFreeDiskFrames) != pagesInWS) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0117c89:	a1 c4 d4 87 f0       	mov    0xf087d4c4,%eax
f0117c8e:	2b 45 d4             	sub    -0x2c(%ebp),%eax
f0117c91:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0117c94:	74 17                	je     f0117cad <test_three_creation_functions+0x139>
f0117c96:	83 ec 04             	sub    $0x4,%esp
f0117c99:	68 50 4b 13 f0       	push   $0xf0134b50
f0117c9e:	68 9a 04 00 00       	push   $0x49a
f0117ca3:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117ca8:	e8 02 92 fe ff       	call   f0100eaf <_panic>
		//cprintf("\ndiff in mem frames = %d, pages in WS = %d\n", initFreeFrames - curFreeFrames, pagesInWS);
		if ((initFreeFrames - curFreeFrames) != 12/*WS*/ + 2*1/*DIR*/ + 2*3/*Tables*/ + 1 /*user WS table*/ + pagesInWS) panic("Wrong allocation: pages are not loaded successfully into memory");
f0117cad:	a1 c8 d4 87 f0       	mov    0xf087d4c8,%eax
f0117cb2:	2b 45 d8             	sub    -0x28(%ebp),%eax
f0117cb5:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0117cb8:	83 c2 15             	add    $0x15,%edx
f0117cbb:	39 d0                	cmp    %edx,%eax
f0117cbd:	74 17                	je     f0117cd6 <test_three_creation_functions+0x162>
f0117cbf:	83 ec 04             	sub    $0x4,%esp
f0117cc2:	68 b8 4b 13 f0       	push   $0xf0134bb8
f0117cc7:	68 9c 04 00 00       	push   $0x49c
f0117ccc:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117cd1:	e8 d9 91 fe ff       	call   f0100eaf <_panic>

		//allocate 4 KB
		char *ptr = kmalloc(4*kilo);
f0117cd6:	83 ec 0c             	sub    $0xc,%esp
f0117cd9:	68 00 10 00 00       	push   $0x1000
f0117cde:	e8 53 1e ff ff       	call   f0109b36 <kmalloc>
f0117ce3:	83 c4 10             	add    $0x10,%esp
f0117ce6:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if ((uint32) ptr !=  (ACTUAL_START + (12+2*1+2*3+1)*PAGE_SIZE)) panic("Wrong start address for the allocated space... make sure you create the dir, table and page WS in KERNEL HEAP");
f0117ce9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0117cec:	3d 00 60 01 f8       	cmp    $0xf8016000,%eax
f0117cf1:	74 17                	je     f0117d0a <test_three_creation_functions+0x196>
f0117cf3:	83 ec 04             	sub    $0x4,%esp
f0117cf6:	68 f8 4b 13 f0       	push   $0xf0134bf8
f0117cfb:	68 a0 04 00 00       	push   $0x4a0
f0117d00:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117d05:	e8 a5 91 fe ff       	call   f0100eaf <_panic>
	}

	cprintf("\nCongratulations!! test the 3 creation functions is completed successfully.\n");
f0117d0a:	83 ec 0c             	sub    $0xc,%esp
f0117d0d:	68 68 4c 13 f0       	push   $0xf0134c68
f0117d12:	e8 45 9e fe ff       	call   f0101b5c <cprintf>
f0117d17:	83 c4 10             	add    $0x10,%esp

	return 1;
f0117d1a:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0117d1f:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0117d22:	5b                   	pop    %ebx
f0117d23:	5e                   	pop    %esi
f0117d24:	5f                   	pop    %edi
f0117d25:	5d                   	pop    %ebp
f0117d26:	c3                   	ret    

f0117d27 <test_kfreeall>:


extern void kfreeall() ;

int test_kfreeall()
{
f0117d27:	55                   	push   %ebp
f0117d28:	89 e5                	mov    %esp,%ebp
f0117d2a:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117d2d:	83 ec 04             	sub    $0x4,%esp
f0117d30:	68 dd 4a 13 f0       	push   $0xf0134add
f0117d35:	68 ae 04 00 00       	push   $0x4ae
f0117d3a:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117d3f:	e8 6b 91 fe ff       	call   f0100eaf <_panic>

f0117d44 <test_kexpand>:


extern void kexpand(uint32 newSize) ;

int test_kexpand()
{
f0117d44:	55                   	push   %ebp
f0117d45:	89 e5                	mov    %esp,%ebp
f0117d47:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117d4a:	83 ec 04             	sub    $0x4,%esp
f0117d4d:	68 dd 4a 13 f0       	push   $0xf0134add
f0117d52:	68 b6 04 00 00       	push   $0x4b6
f0117d57:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117d5c:	e8 4e 91 fe ff       	call   f0100eaf <_panic>

f0117d61 <test_kshrink>:
}

extern void kshrink(uint32 newSize) ;

int test_kshrink()
{
f0117d61:	55                   	push   %ebp
f0117d62:	89 e5                	mov    %esp,%ebp
f0117d64:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117d67:	83 ec 04             	sub    $0x4,%esp
f0117d6a:	68 dd 4a 13 f0       	push   $0xf0134add
f0117d6f:	68 bd 04 00 00       	push   $0x4bd
f0117d74:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117d79:	e8 31 91 fe ff       	call   f0100eaf <_panic>

f0117d7e <test_kfreelast>:
}


int test_kfreelast()
{
f0117d7e:	55                   	push   %ebp
f0117d7f:	89 e5                	mov    %esp,%ebp
f0117d81:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117d84:	83 ec 04             	sub    $0x4,%esp
f0117d87:	68 dd 4a 13 f0       	push   $0xf0134add
f0117d8c:	68 c3 04 00 00       	push   $0x4c3
f0117d91:	68 c5 4a 13 f0       	push   $0xf0134ac5
f0117d96:	e8 14 91 fe ff       	call   f0100eaf <_panic>

f0117d9b <print_order>:
uint8 firstTimeTest = 1;
int prog_orders[TOTAL_TEST_VALUES+1][INSTANCES_NUMBER] = {0};
int env_count[TOTAL_TEST_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
f0117d9b:	55                   	push   %ebp
f0117d9c:	89 e5                	mov    %esp,%ebp
f0117d9e:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < TOTAL_TEST_VALUES; i++)
f0117da1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0117da8:	e9 84 00 00 00       	jmp    f0117e31 <print_order+0x96>
	{
		cprintf("\t[%d]: ", i);
f0117dad:	83 ec 08             	sub    $0x8,%esp
f0117db0:	ff 75 f4             	pushl  -0xc(%ebp)
f0117db3:	68 20 4d 13 f0       	push   $0xf0134d20
f0117db8:	e8 9f 9d fe ff       	call   f0101b5c <cprintf>
f0117dbd:	83 c4 10             	add    $0x10,%esp
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f0117dc0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117dc7:	eb 4c                	jmp    f0117e15 <print_order+0x7a>
		{
			if (prog_orders[i][j] == 0)
f0117dc9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0117dcc:	89 d0                	mov    %edx,%eax
f0117dce:	c1 e0 02             	shl    $0x2,%eax
f0117dd1:	01 d0                	add    %edx,%eax
f0117dd3:	c1 e0 03             	shl    $0x3,%eax
f0117dd6:	89 c2                	mov    %eax,%edx
f0117dd8:	8b 45 08             	mov    0x8(%ebp),%eax
f0117ddb:	01 c2                	add    %eax,%edx
f0117ddd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0117de0:	8b 04 82             	mov    (%edx,%eax,4),%eax
f0117de3:	85 c0                	test   %eax,%eax
f0117de5:	74 36                	je     f0117e1d <print_order+0x82>
				break;
			cprintf("%d, ", prog_orders[i][j]);
f0117de7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0117dea:	89 d0                	mov    %edx,%eax
f0117dec:	c1 e0 02             	shl    $0x2,%eax
f0117def:	01 d0                	add    %edx,%eax
f0117df1:	c1 e0 03             	shl    $0x3,%eax
f0117df4:	89 c2                	mov    %eax,%edx
f0117df6:	8b 45 08             	mov    0x8(%ebp),%eax
f0117df9:	01 c2                	add    %eax,%edx
f0117dfb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0117dfe:	8b 04 82             	mov    (%edx,%eax,4),%eax
f0117e01:	83 ec 08             	sub    $0x8,%esp
f0117e04:	50                   	push   %eax
f0117e05:	68 28 4d 13 f0       	push   $0xf0134d28
f0117e0a:	e8 4d 9d fe ff       	call   f0101b5c <cprintf>
f0117e0f:	83 c4 10             	add    $0x10,%esp
void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_TEST_VALUES; i++)
	{
		cprintf("\t[%d]: ", i);
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f0117e12:	ff 45 f0             	incl   -0x10(%ebp)
f0117e15:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f0117e19:	7e ae                	jle    f0117dc9 <print_order+0x2e>
f0117e1b:	eb 01                	jmp    f0117e1e <print_order+0x83>
		{
			if (prog_orders[i][j] == 0)
				break;
f0117e1d:	90                   	nop
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
f0117e1e:	83 ec 0c             	sub    $0xc,%esp
f0117e21:	68 2d 4d 13 f0       	push   $0xf0134d2d
f0117e26:	e8 31 9d fe ff       	call   f0101b5c <cprintf>
f0117e2b:	83 c4 10             	add    $0x10,%esp
int prog_orders[TOTAL_TEST_VALUES+1][INSTANCES_NUMBER] = {0};
int env_count[TOTAL_TEST_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_TEST_VALUES; i++)
f0117e2e:	ff 45 f4             	incl   -0xc(%ebp)
f0117e31:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
f0117e35:	0f 8e 72 ff ff ff    	jle    f0117dad <print_order+0x12>
				break;
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
	}
}
f0117e3b:	90                   	nop
f0117e3c:	c9                   	leave  
f0117e3d:	c3                   	ret    

f0117e3e <find_in_range>:

int find_in_range(int env_id, int start, int count)
{
f0117e3e:	55                   	push   %ebp
f0117e3f:	89 e5                	mov    %esp,%ebp
f0117e41:	83 ec 28             	sub    $0x28,%esp
	int ret = -1;
f0117e44:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
	acquire_kspinlock(&ProcessQueues.qlock);
f0117e4b:	83 ec 0c             	sub    $0xc,%esp
f0117e4e:	68 20 e7 83 f0       	push   $0xf083e720
f0117e53:	e8 23 7f ff ff       	call   f010fd7b <acquire_kspinlock>
f0117e58:	83 c4 10             	add    $0x10,%esp
	{
		struct Env *env = NULL;
f0117e5b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		int i = 0, end = start + count;
f0117e62:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0117e69:	8b 55 0c             	mov    0xc(%ebp),%edx
f0117e6c:	8b 45 10             	mov    0x10(%ebp),%eax
f0117e6f:	01 d0                	add    %edx,%eax
f0117e71:	89 45 e8             	mov    %eax,-0x18(%ebp)

		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f0117e74:	a1 ac e7 83 f0       	mov    0xf083e7ac,%eax
f0117e79:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		env = LIST_LAST(&ProcessQueues.env_exit_queue);
f0117e7c:	a1 a4 e7 83 f0       	mov    0xf083e7a4,%eax
f0117e81:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
f0117e84:	ff 75 e8             	pushl  -0x18(%ebp)
f0117e87:	ff 75 0c             	pushl  0xc(%ebp)
f0117e8a:	ff 75 08             	pushl  0x8(%ebp)
f0117e8d:	68 30 4d 13 f0       	push   $0xf0134d30
f0117e92:	e8 c5 9c fe ff       	call   f0101b5c <cprintf>
f0117e97:	83 c4 10             	add    $0x10,%esp
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f0117e9a:	eb 34                	jmp    f0117ed0 <find_in_range+0x92>
			//LIST_FOREACH_R(env, &env_exit_queue)
		{
			if (i < start)
f0117e9c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117e9f:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0117ea2:	7d 05                	jge    f0117ea9 <find_in_range+0x6b>
			{
				i++;
f0117ea4:	ff 45 ec             	incl   -0x14(%ebp)
				continue;
f0117ea7:	eb 1e                	jmp    f0117ec7 <find_in_range+0x89>
			}
			if (i >= end)
f0117ea9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117eac:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117eaf:	7d 29                	jge    f0117eda <find_in_range+0x9c>
				//return -1;
				break;

			if (env_id == env->env_id)
f0117eb1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0117eb4:	8b 40 10             	mov    0x10(%eax),%eax
f0117eb7:	3b 45 08             	cmp    0x8(%ebp),%eax
f0117eba:	75 08                	jne    f0117ec4 <find_in_range+0x86>
			{
				ret = i;
f0117ebc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117ebf:	89 45 f4             	mov    %eax,-0xc(%ebp)
				break;
f0117ec2:	eb 17                	jmp    f0117edb <find_in_range+0x9d>
			}
			i++;
f0117ec4:	ff 45 ec             	incl   -0x14(%ebp)
		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
		env = LIST_LAST(&ProcessQueues.env_exit_queue);

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f0117ec7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0117eca:	8b 40 0c             	mov    0xc(%eax),%eax
f0117ecd:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0117ed0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117ed3:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0117ed6:	7c c4                	jl     f0117e9c <find_in_range+0x5e>
f0117ed8:	eb 01                	jmp    f0117edb <find_in_range+0x9d>
				i++;
				continue;
			}
			if (i >= end)
				//return -1;
				break;
f0117eda:	90                   	nop
				break;
			}
			i++;
		}
	}
	release_kspinlock(&ProcessQueues.qlock);
f0117edb:	83 ec 0c             	sub    $0xc,%esp
f0117ede:	68 20 e7 83 f0       	push   $0xf083e720
f0117ee3:	e8 38 7f ff ff       	call   f010fe20 <release_kspinlock>
f0117ee8:	83 c4 10             	add    $0x10,%esp
	return ret;
f0117eeb:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0117eee:	c9                   	leave  
f0117eef:	c3                   	ret    

f0117ef0 <test_bsd_nice_0>:


void test_bsd_nice_0()
{
f0117ef0:	55                   	push   %ebp
f0117ef1:	89 e5                	mov    %esp,%ebp
f0117ef3:	83 ec 08             	sub    $0x8,%esp
	panic("Not Implemented");
f0117ef6:	83 ec 04             	sub    $0x4,%esp
f0117ef9:	68 61 4d 13 f0       	push   $0xf0134d61
f0117efe:	6a 49                	push   $0x49
f0117f00:	68 71 4d 13 f0       	push   $0xf0134d71
f0117f05:	e8 a5 8f fe ff       	call   f0100eaf <_panic>

f0117f0a <test_bsd_nice_1>:
}


void test_bsd_nice_1()
{
f0117f0a:	55                   	push   %ebp
f0117f0b:	89 e5                	mov    %esp,%ebp
f0117f0d:	83 ec 08             	sub    $0x8,%esp
	panic("Not Implemented");
f0117f10:	83 ec 04             	sub    $0x4,%esp
f0117f13:	68 61 4d 13 f0       	push   $0xf0134d61
f0117f18:	6a 4f                	push   $0x4f
f0117f1a:	68 71 4d 13 f0       	push   $0xf0134d71
f0117f1f:	e8 8b 8f fe ff       	call   f0100eaf <_panic>

f0117f24 <test_bsd_nice_2>:
}

void test_bsd_nice_2()
{
f0117f24:	55                   	push   %ebp
f0117f25:	89 e5                	mov    %esp,%ebp
f0117f27:	83 ec 08             	sub    $0x8,%esp
	panic("Not Implemented");
f0117f2a:	83 ec 04             	sub    $0x4,%esp
f0117f2d:	68 61 4d 13 f0       	push   $0xf0134d61
f0117f32:	6a 54                	push   $0x54
f0117f34:	68 71 4d 13 f0       	push   $0xf0134d71
f0117f39:	e8 71 8f fe ff       	call   f0100eaf <_panic>

f0117f3e <test_priorityRR_0>:
}


void test_priorityRR_0()
{
f0117f3e:	55                   	push   %ebp
f0117f3f:	89 e5                	mov    %esp,%ebp
f0117f41:	57                   	push   %edi
f0117f42:	56                   	push   %esi
f0117f43:	53                   	push   %ebx
f0117f44:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTest)
f0117f47:	a0 a9 01 18 f0       	mov    0xf01801a9,%al
f0117f4c:	84 c0                	test   %al,%al
f0117f4e:	0f 84 bd 01 00 00    	je     f0118111 <test_priorityRR_0+0x1d3>
	{
		firstTimeTest = 0;
f0117f54:	c6 05 a9 01 18 f0 00 	movb   $0x0,0xf01801a9
		int priority_values[] = {0, 2, 4, 6, 8};
f0117f5b:	8d 45 b8             	lea    -0x48(%ebp),%eax
f0117f5e:	bb cc 4e 13 f0       	mov    $0xf0134ecc,%ebx
f0117f63:	ba 05 00 00 00       	mov    $0x5,%edx
f0117f68:	89 c7                	mov    %eax,%edi
f0117f6a:	89 de                	mov    %ebx,%esi
f0117f6c:	89 d1                	mov    %edx,%ecx
f0117f6e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f0117f70:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0117f77:	e9 66 01 00 00       	jmp    f01180e2 <test_priorityRR_0+0x1a4>
		{
			struct Env *env ;
			if (i == 4)
f0117f7c:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
f0117f80:	75 1b                	jne    f0117f9d <test_priorityRR_0+0x5f>
			{
				env = env_create("priRR_fib_small", 500, 0, 0);
f0117f82:	6a 00                	push   $0x0
f0117f84:	6a 00                	push   $0x0
f0117f86:	68 f4 01 00 00       	push   $0x1f4
f0117f8b:	68 8d 4d 13 f0       	push   $0xf0134d8d
f0117f90:	e8 cc 2e ff ff       	call   f010ae61 <env_create>
f0117f95:	83 c4 10             	add    $0x10,%esp
f0117f98:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0117f9b:	eb 19                	jmp    f0117fb6 <test_priorityRR_0+0x78>
			}
			else
			{
				env = env_create("priRR_fib", 500, 0, 0);
f0117f9d:	6a 00                	push   $0x0
f0117f9f:	6a 00                	push   $0x0
f0117fa1:	68 f4 01 00 00       	push   $0x1f4
f0117fa6:	68 9d 4d 13 f0       	push   $0xf0134d9d
f0117fab:	e8 b1 2e ff ff       	call   f010ae61 <env_create>
f0117fb0:	83 c4 10             	add    $0x10,%esp
f0117fb3:	89 45 e0             	mov    %eax,-0x20(%ebp)
			}
			int priority_index = i % TOTAL_TEST_VALUES;
f0117fb6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0117fb9:	b9 05 00 00 00       	mov    $0x5,%ecx
f0117fbe:	99                   	cltd   
f0117fbf:	f7 f9                	idiv   %ecx
f0117fc1:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_priority(env->env_id, priority_values[priority_index]);
f0117fc4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0117fc7:	8b 54 85 b8          	mov    -0x48(%ebp,%eax,4),%edx
f0117fcb:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0117fce:	8b 40 10             	mov    0x10(%eax),%eax
f0117fd1:	83 ec 08             	sub    $0x8,%esp
f0117fd4:	52                   	push   %edx
f0117fd5:	50                   	push   %eax
f0117fd6:	e8 83 f6 fe ff       	call   f010765e <env_set_priority>
f0117fdb:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f0117fde:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0117fe2:	75 14                	jne    f0117ff8 <test_priorityRR_0+0xba>
				panic("Loading programs failed\n");
f0117fe4:	83 ec 04             	sub    $0x4,%esp
f0117fe7:	68 a7 4d 13 f0       	push   $0xf0134da7
f0117fec:	6a 6c                	push   $0x6c
f0117fee:	68 71 4d 13 f0       	push   $0xf0134d71
f0117ff3:	e8 b7 8e fe ff       	call   f0100eaf <_panic>
			if (env->page_WS_max_size != 500)
f0117ff8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0117ffb:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0118001:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f0118006:	74 14                	je     f011801c <test_priorityRR_0+0xde>
				panic("The program working set size is not correct\n");
f0118008:	83 ec 04             	sub    $0x4,%esp
f011800b:	68 c0 4d 13 f0       	push   $0xf0134dc0
f0118010:	6a 6e                	push   $0x6e
f0118012:	68 71 4d 13 f0       	push   $0xf0134d71
f0118017:	e8 93 8e fe ff       	call   f0100eaf <_panic>

			switch (priority_values[priority_index])
f011801c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011801f:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f0118023:	83 f8 08             	cmp    $0x8,%eax
f0118026:	0f 87 a5 00 00 00    	ja     f01180d1 <test_priorityRR_0+0x193>
f011802c:	8b 04 85 e0 4e 13 f0 	mov    -0xfecb120(,%eax,4),%eax
f0118033:	ff e0                	jmp    *%eax
			{
			case 0:
				prog_orders[0][env_count[0]++] = env->env_id;
f0118035:	a1 10 e5 83 f0       	mov    0xf083e510,%eax
f011803a:	8d 50 01             	lea    0x1(%eax),%edx
f011803d:	89 15 10 e5 83 f0    	mov    %edx,0xf083e510
f0118043:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0118046:	8b 52 10             	mov    0x10(%edx),%edx
f0118049:	89 14 85 20 e4 83 f0 	mov    %edx,-0xf7c1be0(,%eax,4)
				break;
f0118050:	eb 7f                	jmp    f01180d1 <test_priorityRR_0+0x193>
			case 2:
				prog_orders[1][env_count[1]++] = env->env_id;
f0118052:	a1 14 e5 83 f0       	mov    0xf083e514,%eax
f0118057:	8d 50 01             	lea    0x1(%eax),%edx
f011805a:	89 15 14 e5 83 f0    	mov    %edx,0xf083e514
f0118060:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0118063:	8b 52 10             	mov    0x10(%edx),%edx
f0118066:	83 c0 0a             	add    $0xa,%eax
f0118069:	89 14 85 20 e4 83 f0 	mov    %edx,-0xf7c1be0(,%eax,4)
				break;
f0118070:	eb 5f                	jmp    f01180d1 <test_priorityRR_0+0x193>
			case 4:
				prog_orders[2][env_count[2]++] = env->env_id;
f0118072:	a1 18 e5 83 f0       	mov    0xf083e518,%eax
f0118077:	8d 50 01             	lea    0x1(%eax),%edx
f011807a:	89 15 18 e5 83 f0    	mov    %edx,0xf083e518
f0118080:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0118083:	8b 52 10             	mov    0x10(%edx),%edx
f0118086:	83 c0 14             	add    $0x14,%eax
f0118089:	89 14 85 20 e4 83 f0 	mov    %edx,-0xf7c1be0(,%eax,4)
				break;
f0118090:	eb 3f                	jmp    f01180d1 <test_priorityRR_0+0x193>
			case 6:
				prog_orders[3][env_count[3]++] = env->env_id;
f0118092:	a1 1c e5 83 f0       	mov    0xf083e51c,%eax
f0118097:	8d 50 01             	lea    0x1(%eax),%edx
f011809a:	89 15 1c e5 83 f0    	mov    %edx,0xf083e51c
f01180a0:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01180a3:	8b 52 10             	mov    0x10(%edx),%edx
f01180a6:	83 c0 1e             	add    $0x1e,%eax
f01180a9:	89 14 85 20 e4 83 f0 	mov    %edx,-0xf7c1be0(,%eax,4)
				break;
f01180b0:	eb 1f                	jmp    f01180d1 <test_priorityRR_0+0x193>
			case 8:
				prog_orders[4][env_count[4]++] = env->env_id;
f01180b2:	a1 20 e5 83 f0       	mov    0xf083e520,%eax
f01180b7:	8d 50 01             	lea    0x1(%eax),%edx
f01180ba:	89 15 20 e5 83 f0    	mov    %edx,0xf083e520
f01180c0:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01180c3:	8b 52 10             	mov    0x10(%edx),%edx
f01180c6:	83 c0 28             	add    $0x28,%eax
f01180c9:	89 14 85 20 e4 83 f0 	mov    %edx,-0xf7c1be0(,%eax,4)
				break;
f01180d0:	90                   	nop
			}
			sched_new_env(env);
f01180d1:	83 ec 0c             	sub    $0xc,%esp
f01180d4:	ff 75 e0             	pushl  -0x20(%ebp)
f01180d7:	e8 ad e5 fe ff       	call   f0106689 <sched_new_env>
f01180dc:	83 c4 10             	add    $0x10,%esp
{
	if (firstTimeTest)
	{
		firstTimeTest = 0;
		int priority_values[] = {0, 2, 4, 6, 8};
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f01180df:	ff 45 e4             	incl   -0x1c(%ebp)
f01180e2:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
f01180e6:	0f 8e 90 fe ff ff    	jle    f0117f7c <test_priorityRR_0+0x3e>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f01180ec:	83 ec 0c             	sub    $0xc,%esp
f01180ef:	68 f0 4d 13 f0       	push   $0xf0134df0
f01180f4:	e8 63 9a fe ff       	call   f0101b5c <cprintf>
f01180f9:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f01180fc:	83 ec 0c             	sub    $0xc,%esp
f01180ff:	68 3f 4e 13 f0       	push   $0xf0134e3f
f0118104:	e8 12 9d fe ff       	call   f0101e1b <execute_command>
f0118109:	83 c4 10             	add    $0x10,%esp
f011810c:	e9 c3 00 00 00       	jmp    f01181d4 <test_priorityRR_0+0x296>
	}
	else
	{
		cprintf("> Checking...\n");
f0118111:	83 ec 0c             	sub    $0xc,%esp
f0118114:	68 46 4e 13 f0       	push   $0xf0134e46
f0118119:	e8 3e 9a fe ff       	call   f0101b5c <cprintf>
f011811e:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f0118121:	e8 af ec fe ff       	call   f0106dd5 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f0118126:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		for (int i = 0; i < TOTAL_TEST_VALUES; i++)
f011812d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f0118134:	e9 8a 00 00 00       	jmp    f01181c3 <test_priorityRR_0+0x285>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f0118139:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f0118140:	eb 55                	jmp    f0118197 <test_priorityRR_0+0x259>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, env_count[i]);
f0118142:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0118145:	8b 14 85 10 e5 83 f0 	mov    -0xf7c1af0(,%eax,4),%edx
f011814c:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011814f:	89 c8                	mov    %ecx,%eax
f0118151:	c1 e0 02             	shl    $0x2,%eax
f0118154:	01 c8                	add    %ecx,%eax
f0118156:	01 c0                	add    %eax,%eax
f0118158:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
f011815b:	01 c8                	add    %ecx,%eax
f011815d:	8b 04 85 20 e4 83 f0 	mov    -0xf7c1be0(,%eax,4),%eax
f0118164:	83 ec 04             	sub    $0x4,%esp
f0118167:	52                   	push   %edx
f0118168:	ff 75 dc             	pushl  -0x24(%ebp)
f011816b:	50                   	push   %eax
f011816c:	e8 cd fc ff ff       	call   f0117e3e <find_in_range>
f0118171:	83 c4 10             	add    $0x10,%esp
f0118174:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f0118177:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011817b:	75 17                	jne    f0118194 <test_priorityRR_0+0x256>
					panic("The programs' order of finishing is not correct\n");
f011817d:	83 ec 04             	sub    $0x4,%esp
f0118180:	68 58 4e 13 f0       	push   $0xf0134e58
f0118185:	68 94 00 00 00       	push   $0x94
f011818a:	68 71 4d 13 f0       	push   $0xf0134d71
f011818f:	e8 1b 8d fe ff       	call   f0100eaf <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_TEST_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f0118194:	ff 45 d4             	incl   -0x2c(%ebp)
f0118197:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011819a:	89 d0                	mov    %edx,%eax
f011819c:	c1 e0 02             	shl    $0x2,%eax
f011819f:	01 d0                	add    %edx,%eax
f01181a1:	01 c0                	add    %eax,%eax
f01181a3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01181a6:	01 d0                	add    %edx,%eax
f01181a8:	8b 04 85 20 e4 83 f0 	mov    -0xf7c1be0(,%eax,4),%eax
f01181af:	85 c0                	test   %eax,%eax
f01181b1:	75 8f                	jne    f0118142 <test_priorityRR_0+0x204>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, env_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += env_count[i];
f01181b3:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01181b6:	8b 04 85 10 e5 83 f0 	mov    -0xf7c1af0(,%eax,4),%eax
f01181bd:	01 45 dc             	add    %eax,-0x24(%ebp)
	{
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_TEST_VALUES; i++)
f01181c0:	ff 45 d8             	incl   -0x28(%ebp)
f01181c3:	83 7d d8 04          	cmpl   $0x4,-0x28(%ebp)
f01181c7:	0f 8e 6c ff ff ff    	jle    f0118139 <test_priorityRR_0+0x1fb>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += env_count[i];
		}
		firstTimeTest = 0;
f01181cd:	c6 05 a9 01 18 f0 00 	movb   $0x0,0xf01801a9
	}
	cprintf("\nCongratulations!! test_priorityRR_0 completed successfully.\n");
f01181d4:	83 ec 0c             	sub    $0xc,%esp
f01181d7:	68 8c 4e 13 f0       	push   $0xf0134e8c
f01181dc:	e8 7b 99 fe ff       	call   f0101b5c <cprintf>
f01181e1:	83 c4 10             	add    $0x10,%esp
}
f01181e4:	90                   	nop
f01181e5:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01181e8:	5b                   	pop    %ebx
f01181e9:	5e                   	pop    %esi
f01181ea:	5f                   	pop    %edi
f01181eb:	5d                   	pop    %ebp
f01181ec:	c3                   	ret    

f01181ed <test_priorityRR_1>:

void test_priorityRR_1()
{
f01181ed:	55                   	push   %ebp
f01181ee:	89 e5                	mov    %esp,%ebp
f01181f0:	83 ec 28             	sub    $0x28,%esp
	if (firstTimeTest)
f01181f3:	a0 a9 01 18 f0       	mov    0xf01801a9,%al
f01181f8:	84 c0                	test   %al,%al
f01181fa:	0f 84 ad 01 00 00    	je     f01183ad <test_priorityRR_1+0x1c0>
	{
		rsttst();
f0118200:	e8 2e 07 00 00       	call   f0118933 <rsttst>
		firstTimeTest = 0;
f0118205:	c6 05 a9 01 18 f0 00 	movb   $0x0,0xf01801a9
		struct Env *fibPri0Env = env_create("priRR_fib", 500, 0, 0);
f011820c:	6a 00                	push   $0x0
f011820e:	6a 00                	push   $0x0
f0118210:	68 f4 01 00 00       	push   $0x1f4
f0118215:	68 9d 4d 13 f0       	push   $0xf0134d9d
f011821a:	e8 42 2c ff ff       	call   f010ae61 <env_create>
f011821f:	83 c4 10             	add    $0x10,%esp
f0118222:	89 45 ec             	mov    %eax,-0x14(%ebp)
		struct Env *fibPri4Env = env_create("priRR_fib_pri4", 500, 0, 0);
f0118225:	6a 00                	push   $0x0
f0118227:	6a 00                	push   $0x0
f0118229:	68 f4 01 00 00       	push   $0x1f4
f011822e:	68 04 4f 13 f0       	push   $0xf0134f04
f0118233:	e8 29 2c ff ff       	call   f010ae61 <env_create>
f0118238:	83 c4 10             	add    $0x10,%esp
f011823b:	89 45 e8             	mov    %eax,-0x18(%ebp)
		struct Env *fibPri8Env = env_create("priRR_fib_pri8", 500, 0, 0);
f011823e:	6a 00                	push   $0x0
f0118240:	6a 00                	push   $0x0
f0118242:	68 f4 01 00 00       	push   $0x1f4
f0118247:	68 13 4f 13 f0       	push   $0xf0134f13
f011824c:	e8 10 2c ff ff       	call   f010ae61 <env_create>
f0118251:	83 c4 10             	add    $0x10,%esp
f0118254:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		struct Env *fibPri2ParentEnv = env_create("priRR_fib_create", 500, 0, 0);
f0118257:	6a 00                	push   $0x0
f0118259:	6a 00                	push   $0x0
f011825b:	68 f4 01 00 00       	push   $0x1f4
f0118260:	68 22 4f 13 f0       	push   $0xf0134f22
f0118265:	e8 f7 2b ff ff       	call   f010ae61 <env_create>
f011826a:	83 c4 10             	add    $0x10,%esp
f011826d:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if (fibPri0Env == NULL || fibPri4Env == NULL || fibPri8Env == NULL || fibPri2ParentEnv == NULL)
f0118270:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0118274:	74 12                	je     f0118288 <test_priorityRR_1+0x9b>
f0118276:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011827a:	74 0c                	je     f0118288 <test_priorityRR_1+0x9b>
f011827c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0118280:	74 06                	je     f0118288 <test_priorityRR_1+0x9b>
f0118282:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0118286:	75 17                	jne    f011829f <test_priorityRR_1+0xb2>
			panic("Loading programs failed\n");
f0118288:	83 ec 04             	sub    $0x4,%esp
f011828b:	68 a7 4d 13 f0       	push   $0xf0134da7
f0118290:	68 a8 00 00 00       	push   $0xa8
f0118295:	68 71 4d 13 f0       	push   $0xf0134d71
f011829a:	e8 10 8c fe ff       	call   f0100eaf <_panic>
		if (fibPri0Env->page_WS_max_size != 500 || fibPri4Env->page_WS_max_size != 500 || fibPri8Env->page_WS_max_size != 500 || fibPri2ParentEnv->page_WS_max_size != 500)
f011829f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01182a2:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01182a8:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f01182ad:	75 30                	jne    f01182df <test_priorityRR_1+0xf2>
f01182af:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01182b2:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01182b8:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f01182bd:	75 20                	jne    f01182df <test_priorityRR_1+0xf2>
f01182bf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01182c2:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01182c8:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f01182cd:	75 10                	jne    f01182df <test_priorityRR_1+0xf2>
f01182cf:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01182d2:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01182d8:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f01182dd:	74 17                	je     f01182f6 <test_priorityRR_1+0x109>
			panic("The programs should be initially loaded with the given working set size.\n");
f01182df:	83 ec 04             	sub    $0x4,%esp
f01182e2:	68 34 4f 13 f0       	push   $0xf0134f34
f01182e7:	68 aa 00 00 00       	push   $0xaa
f01182ec:	68 71 4d 13 f0       	push   $0xf0134d71
f01182f1:	e8 b9 8b fe ff       	call   f0100eaf <_panic>
		sched_new_env(fibPri8Env);
f01182f6:	83 ec 0c             	sub    $0xc,%esp
f01182f9:	ff 75 e4             	pushl  -0x1c(%ebp)
f01182fc:	e8 88 e3 fe ff       	call   f0106689 <sched_new_env>
f0118301:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibPri0Env);
f0118304:	83 ec 0c             	sub    $0xc,%esp
f0118307:	ff 75 ec             	pushl  -0x14(%ebp)
f011830a:	e8 7a e3 fe ff       	call   f0106689 <sched_new_env>
f011830f:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibPri4Env);
f0118312:	83 ec 0c             	sub    $0xc,%esp
f0118315:	ff 75 e8             	pushl  -0x18(%ebp)
f0118318:	e8 6c e3 fe ff       	call   f0106689 <sched_new_env>
f011831d:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibPri2ParentEnv);
f0118320:	83 ec 0c             	sub    $0xc,%esp
f0118323:	ff 75 e0             	pushl  -0x20(%ebp)
f0118326:	e8 5e e3 fe ff       	call   f0106689 <sched_new_env>
f011832b:	83 c4 10             	add    $0x10,%esp
		env_set_priority(fibPri2ParentEnv->env_id, 6);
f011832e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0118331:	8b 40 10             	mov    0x10(%eax),%eax
f0118334:	83 ec 08             	sub    $0x8,%esp
f0118337:	6a 06                	push   $0x6
f0118339:	50                   	push   %eax
f011833a:	e8 1f f3 fe ff       	call   f010765e <env_set_priority>
f011833f:	83 c4 10             	add    $0x10,%esp

		prog_orders[0][0] = fibPri0Env->env_id;
f0118342:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118345:	8b 40 10             	mov    0x10(%eax),%eax
f0118348:	a3 20 e4 83 f0       	mov    %eax,0xf083e420
		prog_orders[1][0] = fibPri4Env->env_id;
f011834d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0118350:	8b 40 10             	mov    0x10(%eax),%eax
f0118353:	a3 48 e4 83 f0       	mov    %eax,0xf083e448
		prog_orders[2][0] = fibPri2ParentEnv->env_id ; //id of the parent
f0118358:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011835b:	8b 40 10             	mov    0x10(%eax),%eax
f011835e:	a3 70 e4 83 f0       	mov    %eax,0xf083e470
		prog_orders[3][0] = fibPri2ParentEnv->env_id + 1; //id of the 1st created child fib
f0118363:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0118366:	8b 40 10             	mov    0x10(%eax),%eax
f0118369:	40                   	inc    %eax
f011836a:	a3 98 e4 83 f0       	mov    %eax,0xf083e498
		prog_orders[4][0] = fibPri8Env->env_id;
f011836f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118372:	8b 40 10             	mov    0x10(%eax),%eax
f0118375:	a3 c0 e4 83 f0       	mov    %eax,0xf083e4c0
		prog_orders[5][0] = fibPri2ParentEnv->env_id + 2; //id of the 2nd created child fib
f011837a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011837d:	8b 40 10             	mov    0x10(%eax),%eax
f0118380:	83 c0 02             	add    $0x2,%eax
f0118383:	a3 e8 e4 83 f0       	mov    %eax,0xf083e4e8

		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f0118388:	83 ec 0c             	sub    $0xc,%esp
f011838b:	68 f0 4d 13 f0       	push   $0xf0134df0
f0118390:	e8 c7 97 fe ff       	call   f0101b5c <cprintf>
f0118395:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f0118398:	83 ec 0c             	sub    $0xc,%esp
f011839b:	68 3f 4e 13 f0       	push   $0xf0134e3f
f01183a0:	e8 76 9a fe ff       	call   f0101e1b <execute_command>
f01183a5:	83 c4 10             	add    $0x10,%esp
f01183a8:	e9 c0 00 00 00       	jmp    f011846d <test_priorityRR_1+0x280>
	}
	else
	{
		cprintf("> Checking...\n");
f01183ad:	83 ec 0c             	sub    $0xc,%esp
f01183b0:	68 46 4e 13 f0       	push   $0xf0134e46
f01183b5:	e8 a2 97 fe ff       	call   f0101b5c <cprintf>
f01183ba:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f01183bd:	e8 13 ea fe ff       	call   f0106dd5 <sched_print_all>
		// print_order(prog_orders);
		int i = 0;
f01183c2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct Env *env = NULL;
f01183c9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		acquire_kspinlock(&ProcessQueues.qlock);
f01183d0:	83 ec 0c             	sub    $0xc,%esp
f01183d3:	68 20 e7 83 f0       	push   $0xf083e720
f01183d8:	e8 9e 79 ff ff       	call   f010fd7b <acquire_kspinlock>
f01183dd:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f01183e0:	a1 ac e7 83 f0       	mov    0xf083e7ac,%eax
f01183e5:	89 45 dc             	mov    %eax,-0x24(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f01183e8:	a1 a4 e7 83 f0       	mov    0xf083e7a4,%eax
f01183ed:	89 45 f0             	mov    %eax,-0x10(%ebp)
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f01183f0:	eb 63                	jmp    f0118455 <test_priorityRR_1+0x268>
				//LIST_FOREACH_R(env, &env_exit_queue)
			{
				cprintf("%s - id=%d, priority=%d\n", env->prog_name, env->env_id, env->priority);
f01183f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01183f5:	8b 50 1c             	mov    0x1c(%eax),%edx
f01183f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01183fb:	8b 40 10             	mov    0x10(%eax),%eax
f01183fe:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f0118401:	83 c1 20             	add    $0x20,%ecx
f0118404:	52                   	push   %edx
f0118405:	50                   	push   %eax
f0118406:	51                   	push   %ecx
f0118407:	68 7e 4f 13 f0       	push   $0xf0134f7e
f011840c:	e8 4b 97 fe ff       	call   f0101b5c <cprintf>
f0118411:	83 c4 10             	add    $0x10,%esp
				if (prog_orders[i][0] != env->env_id)
f0118414:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0118417:	89 d0                	mov    %edx,%eax
f0118419:	c1 e0 02             	shl    $0x2,%eax
f011841c:	01 d0                	add    %edx,%eax
f011841e:	c1 e0 03             	shl    $0x3,%eax
f0118421:	05 20 e4 83 f0       	add    $0xf083e420,%eax
f0118426:	8b 10                	mov    (%eax),%edx
f0118428:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011842b:	8b 40 10             	mov    0x10(%eax),%eax
f011842e:	39 c2                	cmp    %eax,%edx
f0118430:	74 17                	je     f0118449 <test_priorityRR_1+0x25c>
					panic("The programs' order of finishing is not correct\n");
f0118432:	83 ec 04             	sub    $0x4,%esp
f0118435:	68 58 4e 13 f0       	push   $0xf0134e58
f011843a:	68 cc 00 00 00       	push   $0xcc
f011843f:	68 71 4d 13 f0       	push   $0xf0134d71
f0118444:	e8 66 8a fe ff       	call   f0100eaf <_panic>
				i++;
f0118449:	ff 45 f4             	incl   -0xc(%ebp)
		acquire_kspinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011844c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011844f:	8b 40 0c             	mov    0xc(%eax),%eax
f0118452:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0118455:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118458:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011845b:	7c 95                	jl     f01183f2 <test_priorityRR_1+0x205>
				if (prog_orders[i][0] != env->env_id)
					panic("The programs' order of finishing is not correct\n");
				i++;
			}
		}
		release_kspinlock(&ProcessQueues.qlock);
f011845d:	83 ec 0c             	sub    $0xc,%esp
f0118460:	68 20 e7 83 f0       	push   $0xf083e720
f0118465:	e8 b6 79 ff ff       	call   f010fe20 <release_kspinlock>
f011846a:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("\nCongratulations!! test_priorityRR_1 completed successfully.\n");
f011846d:	83 ec 0c             	sub    $0xc,%esp
f0118470:	68 98 4f 13 f0       	push   $0xf0134f98
f0118475:	e8 e2 96 fe ff       	call   f0101b5c <cprintf>
f011847a:	83 c4 10             	add    $0x10,%esp
}
f011847d:	90                   	nop
f011847e:	c9                   	leave  
f011847f:	c3                   	ret    

f0118480 <test_priorityRR_2>:

void test_priorityRR_2()
{
f0118480:	55                   	push   %ebp
f0118481:	89 e5                	mov    %esp,%ebp
f0118483:	57                   	push   %edi
f0118484:	56                   	push   %esi
f0118485:	53                   	push   %ebx
f0118486:	83 ec 6c             	sub    $0x6c,%esp
	if (firstTimeTest)
f0118489:	a0 a9 01 18 f0       	mov    0xf01801a9,%al
f011848e:	84 c0                	test   %al,%al
f0118490:	0f 84 6c 02 00 00    	je     f0118702 <test_priorityRR_2+0x282>
	{
		firstTimeTest = 0;
f0118496:	c6 05 a9 01 18 f0 00 	movb   $0x0,0xf01801a9
		int priority_values[] = {0, 2, 4, 6};
f011849d:	8d 45 a8             	lea    -0x58(%ebp),%eax
f01184a0:	bb 18 50 13 f0       	mov    $0xf0135018,%ebx
f01184a5:	ba 04 00 00 00       	mov    $0x4,%edx
f01184aa:	89 c7                	mov    %eax,%edi
f01184ac:	89 de                	mov    %ebx,%esi
f01184ae:	89 d1                	mov    %edx,%ecx
f01184b0:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER - 2; i++)
f01184b2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f01184b9:	e9 41 01 00 00       	jmp    f01185ff <test_priorityRR_2+0x17f>
		{
			struct Env *env = env_create("priRR_fib", 500, 0, 0);
f01184be:	6a 00                	push   $0x0
f01184c0:	6a 00                	push   $0x0
f01184c2:	68 f4 01 00 00       	push   $0x1f4
f01184c7:	68 9d 4d 13 f0       	push   $0xf0134d9d
f01184cc:	e8 90 29 ff ff       	call   f010ae61 <env_create>
f01184d1:	83 c4 10             	add    $0x10,%esp
f01184d4:	89 45 cc             	mov    %eax,-0x34(%ebp)
			int priority_index = i % (TOTAL_TEST_VALUES-1);
f01184d7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01184da:	25 03 00 00 80       	and    $0x80000003,%eax
f01184df:	85 c0                	test   %eax,%eax
f01184e1:	79 05                	jns    f01184e8 <test_priorityRR_2+0x68>
f01184e3:	48                   	dec    %eax
f01184e4:	83 c8 fc             	or     $0xfffffffc,%eax
f01184e7:	40                   	inc    %eax
f01184e8:	89 45 c8             	mov    %eax,-0x38(%ebp)
			env_set_priority(env->env_id, priority_values[priority_index]);
f01184eb:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01184ee:	8b 54 85 a8          	mov    -0x58(%ebp,%eax,4),%edx
f01184f2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01184f5:	8b 40 10             	mov    0x10(%eax),%eax
f01184f8:	83 ec 08             	sub    $0x8,%esp
f01184fb:	52                   	push   %edx
f01184fc:	50                   	push   %eax
f01184fd:	e8 5c f1 fe ff       	call   f010765e <env_set_priority>
f0118502:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f0118505:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f0118509:	75 17                	jne    f0118522 <test_priorityRR_2+0xa2>
				panic("Loading programs failed\n");
f011850b:	83 ec 04             	sub    $0x4,%esp
f011850e:	68 a7 4d 13 f0       	push   $0xf0134da7
f0118513:	68 e1 00 00 00       	push   $0xe1
f0118518:	68 71 4d 13 f0       	push   $0xf0134d71
f011851d:	e8 8d 89 fe ff       	call   f0100eaf <_panic>
			if (env->page_WS_max_size != 500)
f0118522:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0118525:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011852b:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f0118530:	74 17                	je     f0118549 <test_priorityRR_2+0xc9>
				panic("The program working set size is not correct\n");
f0118532:	83 ec 04             	sub    $0x4,%esp
f0118535:	68 c0 4d 13 f0       	push   $0xf0134dc0
f011853a:	68 e3 00 00 00       	push   $0xe3
f011853f:	68 71 4d 13 f0       	push   $0xf0134d71
f0118544:	e8 66 89 fe ff       	call   f0100eaf <_panic>

			switch (priority_values[priority_index])
f0118549:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011854c:	8b 44 85 a8          	mov    -0x58(%ebp,%eax,4),%eax
f0118550:	83 f8 02             	cmp    $0x2,%eax
f0118553:	74 3a                	je     f011858f <test_priorityRR_2+0x10f>
f0118555:	83 f8 02             	cmp    $0x2,%eax
f0118558:	7f 09                	jg     f0118563 <test_priorityRR_2+0xe3>
f011855a:	85 c0                	test   %eax,%eax
f011855c:	74 11                	je     f011856f <test_priorityRR_2+0xef>
f011855e:	e9 8b 00 00 00       	jmp    f01185ee <test_priorityRR_2+0x16e>
f0118563:	83 f8 04             	cmp    $0x4,%eax
f0118566:	74 47                	je     f01185af <test_priorityRR_2+0x12f>
f0118568:	83 f8 06             	cmp    $0x6,%eax
f011856b:	74 62                	je     f01185cf <test_priorityRR_2+0x14f>
f011856d:	eb 7f                	jmp    f01185ee <test_priorityRR_2+0x16e>
			{
			case 0:
				prog_orders[1][env_count[1]++] = env->env_id;
f011856f:	a1 14 e5 83 f0       	mov    0xf083e514,%eax
f0118574:	8d 50 01             	lea    0x1(%eax),%edx
f0118577:	89 15 14 e5 83 f0    	mov    %edx,0xf083e514
f011857d:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0118580:	8b 52 10             	mov    0x10(%edx),%edx
f0118583:	83 c0 0a             	add    $0xa,%eax
f0118586:	89 14 85 20 e4 83 f0 	mov    %edx,-0xf7c1be0(,%eax,4)
				break;
f011858d:	eb 5f                	jmp    f01185ee <test_priorityRR_2+0x16e>
			case 2:
				prog_orders[2][env_count[2]++] = env->env_id;
f011858f:	a1 18 e5 83 f0       	mov    0xf083e518,%eax
f0118594:	8d 50 01             	lea    0x1(%eax),%edx
f0118597:	89 15 18 e5 83 f0    	mov    %edx,0xf083e518
f011859d:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01185a0:	8b 52 10             	mov    0x10(%edx),%edx
f01185a3:	83 c0 14             	add    $0x14,%eax
f01185a6:	89 14 85 20 e4 83 f0 	mov    %edx,-0xf7c1be0(,%eax,4)
				break;
f01185ad:	eb 3f                	jmp    f01185ee <test_priorityRR_2+0x16e>
			case 4:
				prog_orders[3][env_count[3]++] = env->env_id;
f01185af:	a1 1c e5 83 f0       	mov    0xf083e51c,%eax
f01185b4:	8d 50 01             	lea    0x1(%eax),%edx
f01185b7:	89 15 1c e5 83 f0    	mov    %edx,0xf083e51c
f01185bd:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01185c0:	8b 52 10             	mov    0x10(%edx),%edx
f01185c3:	83 c0 1e             	add    $0x1e,%eax
f01185c6:	89 14 85 20 e4 83 f0 	mov    %edx,-0xf7c1be0(,%eax,4)
				break;
f01185cd:	eb 1f                	jmp    f01185ee <test_priorityRR_2+0x16e>
			case 6:
				prog_orders[4][env_count[4]++] = env->env_id;
f01185cf:	a1 20 e5 83 f0       	mov    0xf083e520,%eax
f01185d4:	8d 50 01             	lea    0x1(%eax),%edx
f01185d7:	89 15 20 e5 83 f0    	mov    %edx,0xf083e520
f01185dd:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01185e0:	8b 52 10             	mov    0x10(%edx),%edx
f01185e3:	83 c0 28             	add    $0x28,%eax
f01185e6:	89 14 85 20 e4 83 f0 	mov    %edx,-0xf7c1be0(,%eax,4)
				break;
f01185ed:	90                   	nop
			}
			sched_new_env(env);
f01185ee:	83 ec 0c             	sub    $0xc,%esp
f01185f1:	ff 75 cc             	pushl  -0x34(%ebp)
f01185f4:	e8 90 e0 fe ff       	call   f0106689 <sched_new_env>
f01185f9:	83 c4 10             	add    $0x10,%esp
{
	if (firstTimeTest)
	{
		firstTimeTest = 0;
		int priority_values[] = {0, 2, 4, 6};
		for (int i = 0; i < INSTANCES_NUMBER - 2; i++)
f01185fc:	ff 45 e4             	incl   -0x1c(%ebp)
f01185ff:	83 7d e4 07          	cmpl   $0x7,-0x1c(%ebp)
f0118603:	0f 8e b5 fe ff ff    	jle    f01184be <test_priorityRR_2+0x3e>
				break;
			}
			sched_new_env(env);
		}

		int priority_values2[] = {0, 1, 2, 3, 4, 5, 6, 7 };
f0118609:	8d 45 88             	lea    -0x78(%ebp),%eax
f011860c:	bb 40 50 13 f0       	mov    $0xf0135040,%ebx
f0118611:	ba 08 00 00 00       	mov    $0x8,%edx
f0118616:	89 c7                	mov    %eax,%edi
f0118618:	89 de                	mov    %ebx,%esi
f011861a:	89 d1                	mov    %edx,%ecx
f011861c:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER - 2; i++)
f011861e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0118625:	e9 a9 00 00 00       	jmp    f01186d3 <test_priorityRR_2+0x253>
		{
			struct Env *env = env_create("priRR_fib_small", 500, 0, 0);
f011862a:	6a 00                	push   $0x0
f011862c:	6a 00                	push   $0x0
f011862e:	68 f4 01 00 00       	push   $0x1f4
f0118633:	68 8d 4d 13 f0       	push   $0xf0134d8d
f0118638:	e8 24 28 ff ff       	call   f010ae61 <env_create>
f011863d:	83 c4 10             	add    $0x10,%esp
f0118640:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			int priority_index = i ;
f0118643:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0118646:	89 45 c0             	mov    %eax,-0x40(%ebp)
			env_set_priority(env->env_id, priority_values2[priority_index]);
f0118649:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011864c:	8b 54 85 88          	mov    -0x78(%ebp,%eax,4),%edx
f0118650:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0118653:	8b 40 10             	mov    0x10(%eax),%eax
f0118656:	83 ec 08             	sub    $0x8,%esp
f0118659:	52                   	push   %edx
f011865a:	50                   	push   %eax
f011865b:	e8 fe ef fe ff       	call   f010765e <env_set_priority>
f0118660:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f0118663:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f0118667:	75 17                	jne    f0118680 <test_priorityRR_2+0x200>
				panic("Loading programs failed\n");
f0118669:	83 ec 04             	sub    $0x4,%esp
f011866c:	68 a7 4d 13 f0       	push   $0xf0134da7
f0118671:	68 fe 00 00 00       	push   $0xfe
f0118676:	68 71 4d 13 f0       	push   $0xf0134d71
f011867b:	e8 2f 88 fe ff       	call   f0100eaf <_panic>
			if (env->page_WS_max_size != 500)
f0118680:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0118683:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0118689:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011868e:	74 17                	je     f01186a7 <test_priorityRR_2+0x227>
				panic("The program working set size is not correct\n");
f0118690:	83 ec 04             	sub    $0x4,%esp
f0118693:	68 c0 4d 13 f0       	push   $0xf0134dc0
f0118698:	68 00 01 00 00       	push   $0x100
f011869d:	68 71 4d 13 f0       	push   $0xf0134d71
f01186a2:	e8 08 88 fe ff       	call   f0100eaf <_panic>

			prog_orders[0][env_count[0]++] = env->env_id;
f01186a7:	a1 10 e5 83 f0       	mov    0xf083e510,%eax
f01186ac:	8d 50 01             	lea    0x1(%eax),%edx
f01186af:	89 15 10 e5 83 f0    	mov    %edx,0xf083e510
f01186b5:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01186b8:	8b 52 10             	mov    0x10(%edx),%edx
f01186bb:	89 14 85 20 e4 83 f0 	mov    %edx,-0xf7c1be0(,%eax,4)

			sched_new_env(env);
f01186c2:	83 ec 0c             	sub    $0xc,%esp
f01186c5:	ff 75 c4             	pushl  -0x3c(%ebp)
f01186c8:	e8 bc df fe ff       	call   f0106689 <sched_new_env>
f01186cd:	83 c4 10             	add    $0x10,%esp
			}
			sched_new_env(env);
		}

		int priority_values2[] = {0, 1, 2, 3, 4, 5, 6, 7 };
		for (int i = 0; i < INSTANCES_NUMBER - 2; i++)
f01186d0:	ff 45 e0             	incl   -0x20(%ebp)
f01186d3:	83 7d e0 07          	cmpl   $0x7,-0x20(%ebp)
f01186d7:	0f 8e 4d ff ff ff    	jle    f011862a <test_priorityRR_2+0x1aa>
			prog_orders[0][env_count[0]++] = env->env_id;

			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f01186dd:	83 ec 0c             	sub    $0xc,%esp
f01186e0:	68 f0 4d 13 f0       	push   $0xf0134df0
f01186e5:	e8 72 94 fe ff       	call   f0101b5c <cprintf>
f01186ea:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f01186ed:	83 ec 0c             	sub    $0xc,%esp
f01186f0:	68 3f 4e 13 f0       	push   $0xf0134e3f
f01186f5:	e8 21 97 fe ff       	call   f0101e1b <execute_command>
f01186fa:	83 c4 10             	add    $0x10,%esp
f01186fd:	e9 36 01 00 00       	jmp    f0118838 <test_priorityRR_2+0x3b8>
	}
	else
	{
		cprintf("> Checking...\n");
f0118702:	83 ec 0c             	sub    $0xc,%esp
f0118705:	68 46 4e 13 f0       	push   $0xf0134e46
f011870a:	e8 4d 94 fe ff       	call   f0101b5c <cprintf>
f011870f:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f0118712:	e8 be e6 fe ff       	call   f0106dd5 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f0118717:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		for (int i = 0; i < TOTAL_TEST_VALUES; i++)
f011871e:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f0118725:	e9 fd 00 00 00       	jmp    f0118827 <test_priorityRR_2+0x3a7>
		{
			if (i == 0) //small programs should finish in their strict order
f011872a:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f011872e:	75 6d                	jne    f011879d <test_priorityRR_2+0x31d>
			{
				for (int j = 0; j < INSTANCES_NUMBER - 2; j++)
f0118730:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f0118737:	eb 4c                	jmp    f0118785 <test_priorityRR_2+0x305>
				{
					int exist = find_in_range(prog_orders[i][j], j, 1);
f0118739:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011873c:	89 d0                	mov    %edx,%eax
f011873e:	c1 e0 02             	shl    $0x2,%eax
f0118741:	01 d0                	add    %edx,%eax
f0118743:	01 c0                	add    %eax,%eax
f0118745:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0118748:	01 d0                	add    %edx,%eax
f011874a:	8b 04 85 20 e4 83 f0 	mov    -0xf7c1be0(,%eax,4),%eax
f0118751:	83 ec 04             	sub    $0x4,%esp
f0118754:	6a 01                	push   $0x1
f0118756:	ff 75 d4             	pushl  -0x2c(%ebp)
f0118759:	50                   	push   %eax
f011875a:	e8 df f6 ff ff       	call   f0117e3e <find_in_range>
f011875f:	83 c4 10             	add    $0x10,%esp
f0118762:	89 45 bc             	mov    %eax,-0x44(%ebp)
					if (exist == -1)
f0118765:	83 7d bc ff          	cmpl   $0xffffffff,-0x44(%ebp)
f0118769:	75 17                	jne    f0118782 <test_priorityRR_2+0x302>
						panic("The programs' order of finishing is not correct\n");
f011876b:	83 ec 04             	sub    $0x4,%esp
f011876e:	68 58 4e 13 f0       	push   $0xf0134e58
f0118773:	68 18 01 00 00       	push   $0x118
f0118778:	68 71 4d 13 f0       	push   $0xf0134d71
f011877d:	e8 2d 87 fe ff       	call   f0100eaf <_panic>
		int start_idx = 0;
		for (int i = 0; i < TOTAL_TEST_VALUES; i++)
		{
			if (i == 0) //small programs should finish in their strict order
			{
				for (int j = 0; j < INSTANCES_NUMBER - 2; j++)
f0118782:	ff 45 d4             	incl   -0x2c(%ebp)
f0118785:	83 7d d4 07          	cmpl   $0x7,-0x2c(%ebp)
f0118789:	7e ae                	jle    f0118739 <test_priorityRR_2+0x2b9>
				{
					int exist = find_in_range(prog_orders[i][j], j, 1);
					if (exist == -1)
						panic("The programs' order of finishing is not correct\n");
				}
				start_idx += env_count[i];
f011878b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011878e:	8b 04 85 10 e5 83 f0 	mov    -0xf7c1af0(,%eax,4),%eax
f0118795:	01 45 dc             	add    %eax,-0x24(%ebp)
f0118798:	e9 87 00 00 00       	jmp    f0118824 <test_priorityRR_2+0x3a4>
			}
			else
			{
				for (int j = 0; prog_orders[i][j] != 0; j++)
f011879d:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f01187a4:	eb 55                	jmp    f01187fb <test_priorityRR_2+0x37b>
				{
					int exist = find_in_range(prog_orders[i][j], start_idx, env_count[i]);
f01187a6:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01187a9:	8b 14 85 10 e5 83 f0 	mov    -0xf7c1af0(,%eax,4),%edx
f01187b0:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f01187b3:	89 c8                	mov    %ecx,%eax
f01187b5:	c1 e0 02             	shl    $0x2,%eax
f01187b8:	01 c8                	add    %ecx,%eax
f01187ba:	01 c0                	add    %eax,%eax
f01187bc:	8b 4d d0             	mov    -0x30(%ebp),%ecx
f01187bf:	01 c8                	add    %ecx,%eax
f01187c1:	8b 04 85 20 e4 83 f0 	mov    -0xf7c1be0(,%eax,4),%eax
f01187c8:	83 ec 04             	sub    $0x4,%esp
f01187cb:	52                   	push   %edx
f01187cc:	ff 75 dc             	pushl  -0x24(%ebp)
f01187cf:	50                   	push   %eax
f01187d0:	e8 69 f6 ff ff       	call   f0117e3e <find_in_range>
f01187d5:	83 c4 10             	add    $0x10,%esp
f01187d8:	89 45 b8             	mov    %eax,-0x48(%ebp)
					if (exist == -1)
f01187db:	83 7d b8 ff          	cmpl   $0xffffffff,-0x48(%ebp)
f01187df:	75 17                	jne    f01187f8 <test_priorityRR_2+0x378>
						panic("The programs' order of finishing is not correct\n");
f01187e1:	83 ec 04             	sub    $0x4,%esp
f01187e4:	68 58 4e 13 f0       	push   $0xf0134e58
f01187e9:	68 22 01 00 00       	push   $0x122
f01187ee:	68 71 4d 13 f0       	push   $0xf0134d71
f01187f3:	e8 b7 86 fe ff       	call   f0100eaf <_panic>
				}
				start_idx += env_count[i];
			}
			else
			{
				for (int j = 0; prog_orders[i][j] != 0; j++)
f01187f8:	ff 45 d0             	incl   -0x30(%ebp)
f01187fb:	8b 55 d8             	mov    -0x28(%ebp),%edx
f01187fe:	89 d0                	mov    %edx,%eax
f0118800:	c1 e0 02             	shl    $0x2,%eax
f0118803:	01 d0                	add    %edx,%eax
f0118805:	01 c0                	add    %eax,%eax
f0118807:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011880a:	01 d0                	add    %edx,%eax
f011880c:	8b 04 85 20 e4 83 f0 	mov    -0xf7c1be0(,%eax,4),%eax
f0118813:	85 c0                	test   %eax,%eax
f0118815:	75 8f                	jne    f01187a6 <test_priorityRR_2+0x326>
				{
					int exist = find_in_range(prog_orders[i][j], start_idx, env_count[i]);
					if (exist == -1)
						panic("The programs' order of finishing is not correct\n");
				}
				start_idx += env_count[i];
f0118817:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011881a:	8b 04 85 10 e5 83 f0 	mov    -0xf7c1af0(,%eax,4),%eax
f0118821:	01 45 dc             	add    %eax,-0x24(%ebp)
	{
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_TEST_VALUES; i++)
f0118824:	ff 45 d8             	incl   -0x28(%ebp)
f0118827:	83 7d d8 04          	cmpl   $0x4,-0x28(%ebp)
f011882b:	0f 8e f9 fe ff ff    	jle    f011872a <test_priorityRR_2+0x2aa>
						panic("The programs' order of finishing is not correct\n");
				}
				start_idx += env_count[i];
			}
		}
		firstTimeTest = 0;
f0118831:	c6 05 a9 01 18 f0 00 	movb   $0x0,0xf01801a9
	}
	cprintf("\nCongratulations!! test_priorityRR_2 completed successfully.\n");
f0118838:	83 ec 0c             	sub    $0xc,%esp
f011883b:	68 d8 4f 13 f0       	push   $0xf0134fd8
f0118840:	e8 17 93 fe ff       	call   f0101b5c <cprintf>
f0118845:	83 c4 10             	add    $0x10,%esp
}
f0118848:	90                   	nop
f0118849:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011884c:	5b                   	pop    %ebx
f011884d:	5e                   	pop    %esi
f011884e:	5f                   	pop    %edi
f011884f:	5d                   	pop    %ebp
f0118850:	c3                   	ret    

f0118851 <__mk_fix>:
fixed_point_t;

/* Returns a fixed-point number with F as its internal value. */
static inline fixed_point_t
__mk_fix (int f)
{
f0118851:	55                   	push   %ebp
f0118852:	89 e5                	mov    %esp,%ebp
f0118854:	83 ec 10             	sub    $0x10,%esp
  fixed_point_t x;
  x.f = f;
f0118857:	8b 45 0c             	mov    0xc(%ebp),%eax
f011885a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return x;
f011885d:	8b 45 08             	mov    0x8(%ebp),%eax
f0118860:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0118863:	89 10                	mov    %edx,(%eax)
}
f0118865:	8b 45 08             	mov    0x8(%ebp),%eax
f0118868:	c9                   	leave  
f0118869:	c2 04 00             	ret    $0x4

f011886c <fix_round>:
}

/* Returns X rounded to the nearest integer. */
static inline int
fix_round (fixed_point_t x)
{
f011886c:	55                   	push   %ebp
f011886d:	89 e5                	mov    %esp,%ebp
	if (x.f >= 0)
f011886f:	8b 45 08             	mov    0x8(%ebp),%eax
f0118872:	85 c0                	test   %eax,%eax
f0118874:	78 16                	js     f011888c <fix_round+0x20>
		return (x.f + FIX_F / 2) / FIX_F;
f0118876:	8b 45 08             	mov    0x8(%ebp),%eax
f0118879:	05 00 20 00 00       	add    $0x2000,%eax
f011887e:	85 c0                	test   %eax,%eax
f0118880:	79 05                	jns    f0118887 <fix_round+0x1b>
f0118882:	05 ff 3f 00 00       	add    $0x3fff,%eax
f0118887:	c1 f8 0e             	sar    $0xe,%eax
f011888a:	eb 14                	jmp    f01188a0 <fix_round+0x34>
	else
		return (x.f - FIX_F / 2) / FIX_F;
f011888c:	8b 45 08             	mov    0x8(%ebp),%eax
f011888f:	2d 00 20 00 00       	sub    $0x2000,%eax
f0118894:	85 c0                	test   %eax,%eax
f0118896:	79 05                	jns    f011889d <fix_round+0x31>
f0118898:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011889d:	c1 f8 0e             	sar    $0xe,%eax
}
f01188a0:	5d                   	pop    %ebp
f01188a1:	c3                   	ret    

f01188a2 <fix_scale>:
}

/* Returns X * N. */
static inline fixed_point_t
fix_scale (fixed_point_t x, int n)
{
f01188a2:	55                   	push   %ebp
f01188a3:	89 e5                	mov    %esp,%ebp
f01188a5:	83 ec 08             	sub    $0x8,%esp
	assert (n >= 0);
f01188a8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01188ac:	79 16                	jns    f01188c4 <fix_scale+0x22>
f01188ae:	68 60 50 13 f0       	push   $0xf0135060
f01188b3:	68 67 50 13 f0       	push   $0xf0135067
f01188b8:	6a 5a                	push   $0x5a
f01188ba:	68 7c 50 13 f0       	push   $0xf013507c
f01188bf:	e8 eb 85 fe ff       	call   f0100eaf <_panic>
  return __mk_fix (x.f * n);
f01188c4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01188c7:	0f af 45 10          	imul   0x10(%ebp),%eax
f01188cb:	89 c2                	mov    %eax,%edx
f01188cd:	8b 45 08             	mov    0x8(%ebp),%eax
f01188d0:	83 ec 08             	sub    $0x8,%esp
f01188d3:	52                   	push   %edx
f01188d4:	50                   	push   %eax
f01188d5:	e8 77 ff ff ff       	call   f0118851 <__mk_fix>
f01188da:	83 c4 0c             	add    $0xc,%esp
}
f01188dd:	8b 45 08             	mov    0x8(%ebp),%eax
f01188e0:	c9                   	leave  
f01188e1:	c2 04 00             	ret    $0x4

f01188e4 <to_frame_number>:
struct FrameInfo *get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table);
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);

static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f01188e4:	55                   	push   %ebp
f01188e5:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f01188e7:	8b 45 08             	mov    0x8(%ebp),%eax
f01188ea:	8b 15 08 6b 85 f0    	mov    0xf0856b08,%edx
f01188f0:	29 d0                	sub    %edx,%eax
f01188f2:	c1 f8 02             	sar    $0x2,%eax
f01188f5:	89 c2                	mov    %eax,%edx
f01188f7:	89 d0                	mov    %edx,%eax
f01188f9:	c1 e0 02             	shl    $0x2,%eax
f01188fc:	01 d0                	add    %edx,%eax
f01188fe:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0118905:	01 c8                	add    %ecx,%eax
f0118907:	01 c0                	add    %eax,%eax
f0118909:	01 d0                	add    %edx,%eax
f011890b:	89 c1                	mov    %eax,%ecx
f011890d:	c1 e1 08             	shl    $0x8,%ecx
f0118910:	01 c8                	add    %ecx,%eax
f0118912:	89 c1                	mov    %eax,%ecx
f0118914:	c1 e1 10             	shl    $0x10,%ecx
f0118917:	01 c8                	add    %ecx,%eax
f0118919:	c1 e0 02             	shl    $0x2,%eax
f011891c:	01 d0                	add    %edx,%eax
}
f011891e:	5d                   	pop    %ebp
f011891f:	c3                   	ret    

f0118920 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f0118920:	55                   	push   %ebp
f0118921:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0118923:	ff 75 08             	pushl  0x8(%ebp)
f0118926:	e8 b9 ff ff ff       	call   f01188e4 <to_frame_number>
f011892b:	83 c4 04             	add    $0x4,%esp
f011892e:	c1 e0 0c             	shl    $0xc,%eax
}
f0118931:	c9                   	leave  
f0118932:	c3                   	ret    

f0118933 <rsttst>:
#include "../cons/console.h"

#include <kern/trap/fault_handler.h>

void rsttst()
{
f0118933:	55                   	push   %ebp
f0118934:	89 e5                	mov    %esp,%ebp
f0118936:	83 ec 08             	sub    $0x8,%esp
	init_kspinlock(&tstcntlock, "tstcnt lock");
f0118939:	83 ec 08             	sub    $0x8,%esp
f011893c:	68 90 50 13 f0       	push   $0xf0135090
f0118941:	68 00 6e 85 f0       	push   $0xf0856e00
f0118946:	e8 ff 73 ff ff       	call   f010fd4a <init_kspinlock>
f011894b:	83 c4 10             	add    $0x10,%esp
	acquire_kspinlock(&tstcntlock);
f011894e:	83 ec 0c             	sub    $0xc,%esp
f0118951:	68 00 6e 85 f0       	push   $0xf0856e00
f0118956:	e8 20 74 ff ff       	call   f010fd7b <acquire_kspinlock>
f011895b:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt = 0;
f011895e:	c7 05 68 e6 83 f0 00 	movl   $0x0,0xf083e668
f0118965:	00 00 00 
	}
	release_kspinlock(&tstcntlock);
f0118968:	83 ec 0c             	sub    $0xc,%esp
f011896b:	68 00 6e 85 f0       	push   $0xf0856e00
f0118970:	e8 ab 74 ff ff       	call   f010fe20 <release_kspinlock>
f0118975:	83 c4 10             	add    $0x10,%esp
}
f0118978:	90                   	nop
f0118979:	c9                   	leave  
f011897a:	c3                   	ret    

f011897b <inctst>:
void inctst()
{
f011897b:	55                   	push   %ebp
f011897c:	89 e5                	mov    %esp,%ebp
f011897e:	83 ec 08             	sub    $0x8,%esp
	acquire_kspinlock(&tstcntlock);
f0118981:	83 ec 0c             	sub    $0xc,%esp
f0118984:	68 00 6e 85 f0       	push   $0xf0856e00
f0118989:	e8 ed 73 ff ff       	call   f010fd7b <acquire_kspinlock>
f011898e:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++;
f0118991:	a1 68 e6 83 f0       	mov    0xf083e668,%eax
f0118996:	40                   	inc    %eax
f0118997:	a3 68 e6 83 f0       	mov    %eax,0xf083e668
	}
	release_kspinlock(&tstcntlock);
f011899c:	83 ec 0c             	sub    $0xc,%esp
f011899f:	68 00 6e 85 f0       	push   $0xf0856e00
f01189a4:	e8 77 74 ff ff       	call   f010fe20 <release_kspinlock>
f01189a9:	83 c4 10             	add    $0x10,%esp
}
f01189ac:	90                   	nop
f01189ad:	c9                   	leave  
f01189ae:	c3                   	ret    

f01189af <gettst>:
uint32 gettst()
{
f01189af:	55                   	push   %ebp
f01189b0:	89 e5                	mov    %esp,%ebp
	return tstcnt;
f01189b2:	a1 68 e6 83 f0       	mov    0xf083e668,%eax
}
f01189b7:	5d                   	pop    %ebp
f01189b8:	c3                   	ret    

f01189b9 <tst>:

void tst(uint32 n, uint32 v1, uint32 v2, char c, int inv)
{
f01189b9:	55                   	push   %ebp
f01189ba:	89 e5                	mov    %esp,%ebp
f01189bc:	83 ec 28             	sub    $0x28,%esp
f01189bf:	8b 45 14             	mov    0x14(%ebp),%eax
f01189c2:	88 45 e4             	mov    %al,-0x1c(%ebp)
	int chk = 0;
f01189c5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (c)
f01189cc:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
f01189d0:	83 f8 65             	cmp    $0x65,%eax
f01189d3:	74 5d                	je     f0118a32 <tst+0x79>
f01189d5:	83 f8 65             	cmp    $0x65,%eax
f01189d8:	7f 0a                	jg     f01189e4 <tst+0x2b>
f01189da:	83 f8 62             	cmp    $0x62,%eax
f01189dd:	74 73                	je     f0118a52 <tst+0x99>
f01189df:	e9 91 00 00 00       	jmp    f0118a75 <tst+0xbc>
f01189e4:	83 f8 67             	cmp    $0x67,%eax
f01189e7:	74 29                	je     f0118a12 <tst+0x59>
f01189e9:	83 f8 6c             	cmp    $0x6c,%eax
f01189ec:	0f 85 83 00 00 00    	jne    f0118a75 <tst+0xbc>
	{
	case 'l':
		if (n < v1)
f01189f2:	8b 45 08             	mov    0x8(%ebp),%eax
f01189f5:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01189f8:	73 09                	jae    f0118a03 <tst+0x4a>
			chk = 1;
f01189fa:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f0118a01:	eb 68                	jmp    f0118a6b <tst+0xb2>
	switch (c)
	{
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
f0118a03:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f0118a07:	74 62                	je     f0118a6b <tst+0xb2>
			chk = 1;
f0118a09:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f0118a10:	eb 59                	jmp    f0118a6b <tst+0xb2>
	case 'g':
		if (n > v1)
f0118a12:	8b 45 08             	mov    0x8(%ebp),%eax
f0118a15:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0118a18:	76 09                	jbe    f0118a23 <tst+0x6a>
			chk = 1;
f0118a1a:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f0118a21:	eb 4b                	jmp    f0118a6e <tst+0xb5>
			chk = 1;
		break;
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
f0118a23:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f0118a27:	74 45                	je     f0118a6e <tst+0xb5>
			chk = 1;
f0118a29:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f0118a30:	eb 3c                	jmp    f0118a6e <tst+0xb5>
	case 'e':
		if (n == v1)
f0118a32:	8b 45 08             	mov    0x8(%ebp),%eax
f0118a35:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0118a38:	75 09                	jne    f0118a43 <tst+0x8a>
			chk = 1;
f0118a3a:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f0118a41:	eb 2e                	jmp    f0118a71 <tst+0xb8>
			chk = 1;
		break;
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
f0118a43:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f0118a47:	74 28                	je     f0118a71 <tst+0xb8>
			chk = 1;
f0118a49:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f0118a50:	eb 1f                	jmp    f0118a71 <tst+0xb8>
	case 'b':
		if (n >= v1 && n <= v2)
f0118a52:	8b 45 08             	mov    0x8(%ebp),%eax
f0118a55:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0118a58:	72 1a                	jb     f0118a74 <tst+0xbb>
f0118a5a:	8b 45 08             	mov    0x8(%ebp),%eax
f0118a5d:	3b 45 10             	cmp    0x10(%ebp),%eax
f0118a60:	77 12                	ja     f0118a74 <tst+0xbb>
			chk = 1;
f0118a62:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f0118a69:	eb 09                	jmp    f0118a74 <tst+0xbb>
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f0118a6b:	90                   	nop
f0118a6c:	eb 07                	jmp    f0118a75 <tst+0xbc>
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f0118a6e:	90                   	nop
f0118a6f:	eb 04                	jmp    f0118a75 <tst+0xbc>
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f0118a71:	90                   	nop
f0118a72:	eb 01                	jmp    f0118a75 <tst+0xbc>
	case 'b':
		if (n >= v1 && n <= v2)
			chk = 1;
		break;
f0118a74:	90                   	nop
	}

	if (chk == 0) panic("Error!! test fails");
f0118a75:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0118a79:	75 14                	jne    f0118a8f <tst+0xd6>
f0118a7b:	83 ec 04             	sub    $0x4,%esp
f0118a7e:	68 9c 50 13 f0       	push   $0xf013509c
f0118a83:	6a 49                	push   $0x49
f0118a85:	68 af 50 13 f0       	push   $0xf01350af
f0118a8a:	e8 20 84 fe ff       	call   f0100eaf <_panic>

	acquire_kspinlock(&tstcntlock);
f0118a8f:	83 ec 0c             	sub    $0xc,%esp
f0118a92:	68 00 6e 85 f0       	push   $0xf0856e00
f0118a97:	e8 df 72 ff ff       	call   f010fd7b <acquire_kspinlock>
f0118a9c:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++ ;
f0118a9f:	a1 68 e6 83 f0       	mov    0xf083e668,%eax
f0118aa4:	40                   	inc    %eax
f0118aa5:	a3 68 e6 83 f0       	mov    %eax,0xf083e668
	}
	release_kspinlock(&tstcntlock);
f0118aaa:	83 ec 0c             	sub    $0xc,%esp
f0118aad:	68 00 6e 85 f0       	push   $0xf0856e00
f0118ab2:	e8 69 73 ff ff       	call   f010fe20 <release_kspinlock>
f0118ab7:	83 c4 10             	add    $0x10,%esp

	return;
f0118aba:	90                   	nop
}
f0118abb:	c9                   	leave  
f0118abc:	c3                   	ret    

f0118abd <chktst>:

void chktst(uint32 n)
{
f0118abd:	55                   	push   %ebp
f0118abe:	89 e5                	mov    %esp,%ebp
f0118ac0:	83 ec 18             	sub    $0x18,%esp
	int __tstcnt;
	acquire_kspinlock(&tstcntlock);
f0118ac3:	83 ec 0c             	sub    $0xc,%esp
f0118ac6:	68 00 6e 85 f0       	push   $0xf0856e00
f0118acb:	e8 ab 72 ff ff       	call   f010fd7b <acquire_kspinlock>
f0118ad0:	83 c4 10             	add    $0x10,%esp
	{
		__tstcnt = tstcnt;
f0118ad3:	a1 68 e6 83 f0       	mov    0xf083e668,%eax
f0118ad8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}
	release_kspinlock(&tstcntlock);
f0118adb:	83 ec 0c             	sub    $0xc,%esp
f0118ade:	68 00 6e 85 f0       	push   $0xf0856e00
f0118ae3:	e8 38 73 ff ff       	call   f010fe20 <release_kspinlock>
f0118ae8:	83 c4 10             	add    $0x10,%esp
	if (__tstcnt == n)
f0118aeb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118aee:	3b 45 08             	cmp    0x8(%ebp),%eax
f0118af1:	75 12                	jne    f0118b05 <chktst+0x48>
		cprintf("\nCongratulations... test runs successfully\n");
f0118af3:	83 ec 0c             	sub    $0xc,%esp
f0118af6:	68 c8 50 13 f0       	push   $0xf01350c8
f0118afb:	e8 5c 90 fe ff       	call   f0101b5c <cprintf>
f0118b00:	83 c4 10             	add    $0x10,%esp
	else
		panic("Error!! test fails at final");
}
f0118b03:	eb 14                	jmp    f0118b19 <chktst+0x5c>
	}
	release_kspinlock(&tstcntlock);
	if (__tstcnt == n)
		cprintf("\nCongratulations... test runs successfully\n");
	else
		panic("Error!! test fails at final");
f0118b05:	83 ec 04             	sub    $0x4,%esp
f0118b08:	68 f4 50 13 f0       	push   $0xf01350f4
f0118b0d:	6a 5f                	push   $0x5f
f0118b0f:	68 af 50 13 f0       	push   $0xf01350af
f0118b14:	e8 96 83 fe ff       	call   f0100eaf <_panic>
}
f0118b19:	c9                   	leave  
f0118b1a:	c3                   	ret    

f0118b1b <nearest_pow2_ceil>:

inline unsigned int nearest_pow2_ceil(unsigned int x) {
f0118b1b:	55                   	push   %ebp
f0118b1c:	89 e5                	mov    %esp,%ebp
f0118b1e:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f0118b21:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0118b25:	77 07                	ja     f0118b2e <nearest_pow2_ceil+0x13>
f0118b27:	b8 01 00 00 00       	mov    $0x1,%eax
f0118b2c:	eb 20                	jmp    f0118b4e <nearest_pow2_ceil+0x33>
	int power = 2;
f0118b2e:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f0118b35:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f0118b38:	eb 08                	jmp    f0118b42 <nearest_pow2_ceil+0x27>
		power <<= 1;
f0118b3a:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0118b3d:	01 c0                	add    %eax,%eax
f0118b3f:	89 45 fc             	mov    %eax,-0x4(%ebp)

inline unsigned int nearest_pow2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	int power = 2;
	x--;
	while (x >>= 1) {
f0118b42:	d1 6d 08             	shrl   0x8(%ebp)
f0118b45:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0118b49:	75 ef                	jne    f0118b3a <nearest_pow2_ceil+0x1f>
		power <<= 1;
	}
	return power;
f0118b4b:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0118b4e:	c9                   	leave  
f0118b4f:	c3                   	ret    

f0118b50 <log2_ceil>:
inline unsigned int log2_ceil(unsigned int x) {
f0118b50:	55                   	push   %ebp
f0118b51:	89 e5                	mov    %esp,%ebp
f0118b53:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f0118b56:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0118b5a:	77 07                	ja     f0118b63 <log2_ceil+0x13>
f0118b5c:	b8 01 00 00 00       	mov    $0x1,%eax
f0118b61:	eb 1b                	jmp    f0118b7e <log2_ceil+0x2e>
	//int power = 2;
	int bits_cnt = 2 ;
f0118b63:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f0118b6a:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f0118b6d:	eb 03                	jmp    f0118b72 <log2_ceil+0x22>
		//power <<= 1;
		bits_cnt++ ;
f0118b6f:	ff 45 fc             	incl   -0x4(%ebp)
inline unsigned int log2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	//int power = 2;
	int bits_cnt = 2 ;
	x--;
	while (x >>= 1) {
f0118b72:	d1 6d 08             	shrl   0x8(%ebp)
f0118b75:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0118b79:	75 f4                	jne    f0118b6f <log2_ceil+0x1f>
		//power <<= 1;
		bits_cnt++ ;
	}
	return bits_cnt;
f0118b7b:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0118b7e:	c9                   	leave  
f0118b7f:	c3                   	ret    

f0118b80 <fixedPt2Str>:

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
f0118b80:	55                   	push   %ebp
f0118b81:	89 e5                	mov    %esp,%ebp
f0118b83:	83 ec 78             	sub    $0x78,%esp
	int mulFactor = 1;
f0118b86:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	for (int i = 0; i < num_dec_digits; ++i) {
f0118b8d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118b94:	eb 12                	jmp    f0118ba8 <fixedPt2Str+0x28>
		mulFactor *= 10;
f0118b96:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0118b99:	89 d0                	mov    %edx,%eax
f0118b9b:	c1 e0 02             	shl    $0x2,%eax
f0118b9e:	01 d0                	add    %edx,%eax
f0118ba0:	01 c0                	add    %eax,%eax
f0118ba2:	89 45 f4             	mov    %eax,-0xc(%ebp)

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
	int mulFactor = 1;
	for (int i = 0; i < num_dec_digits; ++i) {
f0118ba5:	ff 45 f0             	incl   -0x10(%ebp)
f0118ba8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0118bab:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0118bae:	7c e6                	jl     f0118b96 <fixedPt2Str+0x16>
		mulFactor *= 10;
	}
	int scaledVal = fix_round(fix_scale(f, mulFactor)) ;
f0118bb0:	8d 45 dc             	lea    -0x24(%ebp),%eax
f0118bb3:	83 ec 04             	sub    $0x4,%esp
f0118bb6:	ff 75 f4             	pushl  -0xc(%ebp)
f0118bb9:	ff 75 08             	pushl  0x8(%ebp)
f0118bbc:	50                   	push   %eax
f0118bbd:	e8 e0 fc ff ff       	call   f01188a2 <fix_scale>
f0118bc2:	83 c4 0c             	add    $0xc,%esp
f0118bc5:	83 ec 0c             	sub    $0xc,%esp
f0118bc8:	ff 75 dc             	pushl  -0x24(%ebp)
f0118bcb:	e8 9c fc ff ff       	call   f011886c <fix_round>
f0118bd0:	83 c4 10             	add    $0x10,%esp
f0118bd3:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int integer = scaledVal/mulFactor;
f0118bd6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0118bd9:	99                   	cltd   
f0118bda:	f7 7d f4             	idivl  -0xc(%ebp)
f0118bdd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int fraction = scaledVal%mulFactor;
f0118be0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0118be3:	99                   	cltd   
f0118be4:	f7 7d f4             	idivl  -0xc(%ebp)
f0118be7:	89 55 e0             	mov    %edx,-0x20(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
f0118bea:	83 ec 08             	sub    $0x8,%esp
f0118bed:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0118bf0:	50                   	push   %eax
f0118bf1:	ff 75 e4             	pushl  -0x1c(%ebp)
f0118bf4:	e8 d7 23 00 00       	call   f011afd0 <ltostr>
f0118bf9:	83 c4 10             	add    $0x10,%esp
	char fractPart[20] ; ltostr(fraction, fractPart);
f0118bfc:	83 ec 08             	sub    $0x8,%esp
f0118bff:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f0118c02:	50                   	push   %eax
f0118c03:	ff 75 e0             	pushl  -0x20(%ebp)
f0118c06:	e8 c5 23 00 00       	call   f011afd0 <ltostr>
f0118c0b:	83 c4 10             	add    $0x10,%esp
	int tmp = mulFactor / 10;
f0118c0e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0118c11:	b8 67 66 66 66       	mov    $0x66666667,%eax
f0118c16:	f7 e9                	imul   %ecx
f0118c18:	c1 fa 02             	sar    $0x2,%edx
f0118c1b:	89 c8                	mov    %ecx,%eax
f0118c1d:	c1 f8 1f             	sar    $0x1f,%eax
f0118c20:	29 c2                	sub    %eax,%edx
f0118c22:	89 d0                	mov    %edx,%eax
f0118c24:	89 45 ec             	mov    %eax,-0x14(%ebp)

	char zeros[10] = "";
f0118c27:	c7 45 aa 00 00 00 00 	movl   $0x0,-0x56(%ebp)
f0118c2e:	c7 45 ae 00 00 00 00 	movl   $0x0,-0x52(%ebp)
f0118c35:	66 c7 45 b2 00 00    	movw   $0x0,-0x4e(%ebp)
	while (fraction < tmp)
f0118c3b:	eb 31                	jmp    f0118c6e <fixedPt2Str+0xee>
	{
		strcconcat("0", zeros, zeros);
f0118c3d:	83 ec 04             	sub    $0x4,%esp
f0118c40:	8d 45 aa             	lea    -0x56(%ebp),%eax
f0118c43:	50                   	push   %eax
f0118c44:	8d 45 aa             	lea    -0x56(%ebp),%eax
f0118c47:	50                   	push   %eax
f0118c48:	68 10 51 13 f0       	push   $0xf0135110
f0118c4d:	e8 57 24 00 00       	call   f011b0a9 <strcconcat>
f0118c52:	83 c4 10             	add    $0x10,%esp
		tmp /= 10;
f0118c55:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0118c58:	b8 67 66 66 66       	mov    $0x66666667,%eax
f0118c5d:	f7 e9                	imul   %ecx
f0118c5f:	c1 fa 02             	sar    $0x2,%edx
f0118c62:	89 c8                	mov    %ecx,%eax
f0118c64:	c1 f8 1f             	sar    $0x1f,%eax
f0118c67:	29 c2                	sub    %eax,%edx
f0118c69:	89 d0                	mov    %edx,%eax
f0118c6b:	89 45 ec             	mov    %eax,-0x14(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
	char fractPart[20] ; ltostr(fraction, fractPart);
	int tmp = mulFactor / 10;

	char zeros[10] = "";
	while (fraction < tmp)
f0118c6e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0118c71:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118c74:	7c c7                	jl     f0118c3d <fixedPt2Str+0xbd>
	{
		strcconcat("0", zeros, zeros);
		tmp /= 10;
	}
	char fractPart2[20];
	strcconcat(zeros, fractPart, fractPart2);
f0118c76:	83 ec 04             	sub    $0x4,%esp
f0118c79:	8d 45 96             	lea    -0x6a(%ebp),%eax
f0118c7c:	50                   	push   %eax
f0118c7d:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f0118c80:	50                   	push   %eax
f0118c81:	8d 45 aa             	lea    -0x56(%ebp),%eax
f0118c84:	50                   	push   %eax
f0118c85:	e8 1f 24 00 00       	call   f011b0a9 <strcconcat>
f0118c8a:	83 c4 10             	add    $0x10,%esp

	//cprintf("integer = %d, intPart = %s - fraction = %d, fractPart = %s\n", integer, intPart, fraction , fractPart2);
	strcconcat(intPart, ".", intPart);
f0118c8d:	83 ec 04             	sub    $0x4,%esp
f0118c90:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0118c93:	50                   	push   %eax
f0118c94:	68 12 51 13 f0       	push   $0xf0135112
f0118c99:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0118c9c:	50                   	push   %eax
f0118c9d:	e8 07 24 00 00       	call   f011b0a9 <strcconcat>
f0118ca2:	83 c4 10             	add    $0x10,%esp
	strcconcat(intPart, fractPart2, output);
f0118ca5:	83 ec 04             	sub    $0x4,%esp
f0118ca8:	ff 75 10             	pushl  0x10(%ebp)
f0118cab:	8d 45 96             	lea    -0x6a(%ebp),%eax
f0118cae:	50                   	push   %eax
f0118caf:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0118cb2:	50                   	push   %eax
f0118cb3:	e8 f1 23 00 00       	call   f011b0a9 <strcconcat>
f0118cb8:	83 c4 10             	add    $0x10,%esp

}
f0118cbb:	90                   	nop
f0118cbc:	c9                   	leave  
f0118cbd:	c3                   	ret    

f0118cbe <sys_utilities>:
struct kspinlock __tstchan_lk__;
int __firstTimeSleepLock = 1;
struct sleeplock __tstslplk__;

void sys_utilities(char* utilityName, int value)
{
f0118cbe:	55                   	push   %ebp
f0118cbf:	89 e5                	mov    %esp,%ebp
f0118cc1:	81 ec c8 00 00 00    	sub    $0xc8,%esp
	if (strncmp(utilityName, "__BSDSetNice@", strlen("__BSDSetNice@")) == 0)
f0118cc7:	83 ec 0c             	sub    $0xc,%esp
f0118cca:	68 14 51 13 f0       	push   $0xf0135114
f0118ccf:	e8 a7 1d 00 00       	call   f011aa7b <strlen>
f0118cd4:	83 c4 10             	add    $0x10,%esp
f0118cd7:	83 ec 04             	sub    $0x4,%esp
f0118cda:	50                   	push   %eax
f0118cdb:	68 14 51 13 f0       	push   $0xf0135114
f0118ce0:	ff 75 08             	pushl  0x8(%ebp)
f0118ce3:	e8 d7 1e 00 00       	call   f011abbf <strncmp>
f0118ce8:	83 c4 10             	add    $0x10,%esp
f0118ceb:	85 c0                	test   %eax,%eax
f0118ced:	0f 85 8a 00 00 00    	jne    f0118d7d <sys_utilities+0xbf>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f0118cf3:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0118cf6:	50                   	push   %eax
f0118cf7:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
f0118cfd:	50                   	push   %eax
f0118cfe:	68 22 51 13 f0       	push   $0xf0135122
f0118d03:	ff 75 08             	pushl  0x8(%ebp)
f0118d06:	e8 34 24 00 00       	call   f011b13f <strsplit>
f0118d0b:	83 c4 10             	add    $0x10,%esp
		int envID = strtol(tokens[1], NULL, 10);
f0118d0e:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0118d14:	83 ec 04             	sub    $0x4,%esp
f0118d17:	6a 0a                	push   $0xa
f0118d19:	6a 00                	push   $0x0
f0118d1b:	50                   	push   %eax
f0118d1c:	e8 69 21 00 00       	call   f011ae8a <strtol>
f0118d21:	83 c4 10             	add    $0x10,%esp
f0118d24:	89 45 98             	mov    %eax,-0x68(%ebp)
		struct Env* env = NULL ;
f0118d27:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
		envid2env(envID, &env, 0);
f0118d2e:	83 ec 04             	sub    $0x4,%esp
f0118d31:	6a 00                	push   $0x0
f0118d33:	8d 45 90             	lea    -0x70(%ebp),%eax
f0118d36:	50                   	push   %eax
f0118d37:	ff 75 98             	pushl  -0x68(%ebp)
f0118d3a:	e8 29 2d ff ff       	call   f010ba68 <envid2env>
f0118d3f:	83 c4 10             	add    $0x10,%esp
		assert(env->env_id == envID) ;
f0118d42:	8b 45 90             	mov    -0x70(%ebp),%eax
f0118d45:	8b 40 10             	mov    0x10(%eax),%eax
f0118d48:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0118d4b:	74 19                	je     f0118d66 <sys_utilities+0xa8>
f0118d4d:	68 24 51 13 f0       	push   $0xf0135124
f0118d52:	68 67 50 13 f0       	push   $0xf0135067
f0118d57:	68 a5 00 00 00       	push   $0xa5
f0118d5c:	68 af 50 13 f0       	push   $0xf01350af
f0118d61:	e8 49 81 fe ff       	call   f0100eaf <_panic>
		env_set_nice(env, value);
f0118d66:	8b 45 90             	mov    -0x70(%ebp),%eax
f0118d69:	83 ec 08             	sub    $0x8,%esp
f0118d6c:	ff 75 0c             	pushl  0xc(%ebp)
f0118d6f:	50                   	push   %eax
f0118d70:	e8 92 e8 fe ff       	call   f0107607 <env_set_nice>
f0118d75:	83 c4 10             	add    $0x10,%esp
f0118d78:	e9 8d 07 00 00       	jmp    f011950a <sys_utilities+0x84c>
	}
	else if (strncmp(utilityName, "__PRIRRSetPriority@", strlen("__PRIRRSetPriority@")) == 0)
f0118d7d:	83 ec 0c             	sub    $0xc,%esp
f0118d80:	68 39 51 13 f0       	push   $0xf0135139
f0118d85:	e8 f1 1c 00 00       	call   f011aa7b <strlen>
f0118d8a:	83 c4 10             	add    $0x10,%esp
f0118d8d:	83 ec 04             	sub    $0x4,%esp
f0118d90:	50                   	push   %eax
f0118d91:	68 39 51 13 f0       	push   $0xf0135139
f0118d96:	ff 75 08             	pushl  0x8(%ebp)
f0118d99:	e8 21 1e 00 00       	call   f011abbf <strncmp>
f0118d9e:	83 c4 10             	add    $0x10,%esp
f0118da1:	85 c0                	test   %eax,%eax
f0118da3:	0f 85 89 00 00 00    	jne    f0118e32 <sys_utilities+0x174>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f0118da9:	8d 45 8c             	lea    -0x74(%ebp),%eax
f0118dac:	50                   	push   %eax
f0118dad:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
f0118db3:	50                   	push   %eax
f0118db4:	68 22 51 13 f0       	push   $0xf0135122
f0118db9:	ff 75 08             	pushl  0x8(%ebp)
f0118dbc:	e8 7e 23 00 00       	call   f011b13f <strsplit>
f0118dc1:	83 c4 10             	add    $0x10,%esp
		int envID = strtol(tokens[1], NULL, 10);
f0118dc4:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0118dca:	83 ec 04             	sub    $0x4,%esp
f0118dcd:	6a 0a                	push   $0xa
f0118dcf:	6a 00                	push   $0x0
f0118dd1:	50                   	push   %eax
f0118dd2:	e8 b3 20 00 00       	call   f011ae8a <strtol>
f0118dd7:	83 c4 10             	add    $0x10,%esp
f0118dda:	89 45 9c             	mov    %eax,-0x64(%ebp)
		struct Env* env = NULL ;
f0118ddd:	c7 45 88 00 00 00 00 	movl   $0x0,-0x78(%ebp)
		envid2env(envID, &env, 0);
f0118de4:	83 ec 04             	sub    $0x4,%esp
f0118de7:	6a 00                	push   $0x0
f0118de9:	8d 45 88             	lea    -0x78(%ebp),%eax
f0118dec:	50                   	push   %eax
f0118ded:	ff 75 9c             	pushl  -0x64(%ebp)
f0118df0:	e8 73 2c ff ff       	call   f010ba68 <envid2env>
f0118df5:	83 c4 10             	add    $0x10,%esp
		assert(env->env_id == envID) ;
f0118df8:	8b 45 88             	mov    -0x78(%ebp),%eax
f0118dfb:	8b 40 10             	mov    0x10(%eax),%eax
f0118dfe:	3b 45 9c             	cmp    -0x64(%ebp),%eax
f0118e01:	74 19                	je     f0118e1c <sys_utilities+0x15e>
f0118e03:	68 24 51 13 f0       	push   $0xf0135124
f0118e08:	68 67 50 13 f0       	push   $0xf0135067
f0118e0d:	68 b1 00 00 00       	push   $0xb1
f0118e12:	68 af 50 13 f0       	push   $0xf01350af
f0118e17:	e8 93 80 fe ff       	call   f0100eaf <_panic>
		env_set_priority(envID, value);
f0118e1c:	83 ec 08             	sub    $0x8,%esp
f0118e1f:	ff 75 0c             	pushl  0xc(%ebp)
f0118e22:	ff 75 9c             	pushl  -0x64(%ebp)
f0118e25:	e8 34 e8 fe ff       	call   f010765e <env_set_priority>
f0118e2a:	83 c4 10             	add    $0x10,%esp
f0118e2d:	e9 d8 06 00 00       	jmp    f011950a <sys_utilities+0x84c>
	}
	else if (strncmp(utilityName, "__CheckExitOrder@", strlen("__CheckExitOrder@")) == 0)
f0118e32:	83 ec 0c             	sub    $0xc,%esp
f0118e35:	68 4d 51 13 f0       	push   $0xf013514d
f0118e3a:	e8 3c 1c 00 00       	call   f011aa7b <strlen>
f0118e3f:	83 c4 10             	add    $0x10,%esp
f0118e42:	83 ec 04             	sub    $0x4,%esp
f0118e45:	50                   	push   %eax
f0118e46:	68 4d 51 13 f0       	push   $0xf013514d
f0118e4b:	ff 75 08             	pushl  0x8(%ebp)
f0118e4e:	e8 6c 1d 00 00       	call   f011abbf <strncmp>
f0118e53:	83 c4 10             	add    $0x10,%esp
f0118e56:	85 c0                	test   %eax,%eax
f0118e58:	0f 85 ba 01 00 00    	jne    f0119018 <sys_utilities+0x35a>
	{
		int* numOfInstances = (int*) value ;
f0118e5e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0118e61:	89 45 a8             	mov    %eax,-0x58(%ebp)
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f0118e64:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0118e67:	50                   	push   %eax
f0118e68:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
f0118e6e:	50                   	push   %eax
f0118e6f:	68 22 51 13 f0       	push   $0xf0135122
f0118e74:	ff 75 08             	pushl  0x8(%ebp)
f0118e77:	e8 c3 22 00 00       	call   f011b13f <strsplit>
f0118e7c:	83 c4 10             	add    $0x10,%esp
		char *progName = tokens[1];
f0118e7f:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0118e85:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		struct Env* env = NULL ;
f0118e88:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		bool chkAscending = 1;
f0118e8f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		int prevEnvID = -1 ;
f0118e96:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)

		if (*numOfInstances < 0)
f0118e9d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118ea0:	8b 00                	mov    (%eax),%eax
f0118ea2:	85 c0                	test   %eax,%eax
f0118ea4:	79 1c                	jns    f0118ec2 <sys_utilities+0x204>
		{
			chkAscending = 0;
f0118ea6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			*numOfInstances *= -1;
f0118ead:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118eb0:	8b 00                	mov    (%eax),%eax
f0118eb2:	f7 d8                	neg    %eax
f0118eb4:	89 c2                	mov    %eax,%edx
f0118eb6:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118eb9:	89 10                	mov    %edx,(%eax)
			prevEnvID = 1<<30 ;
f0118ebb:	c7 45 ec 00 00 00 40 	movl   $0x40000000,-0x14(%ebp)
		}
		bool success = 1;
f0118ec2:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

		acquire_kspinlock(&ProcessQueues.qlock);
f0118ec9:	83 ec 0c             	sub    $0xc,%esp
f0118ecc:	68 20 e7 83 f0       	push   $0xf083e720
f0118ed1:	e8 a5 6e ff ff       	call   f010fd7b <acquire_kspinlock>
f0118ed6:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f0118ed9:	a1 ac e7 83 f0       	mov    0xf083e7ac,%eax
f0118ede:	89 45 a0             	mov    %eax,-0x60(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f0118ee1:	a1 a4 e7 83 f0       	mov    0xf083e7a4,%eax
f0118ee6:	89 45 f4             	mov    %eax,-0xc(%ebp)
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f0118ee9:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118eec:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0118eef:	eb 6c                	jmp    f0118f5d <sys_utilities+0x29f>
			{
				if (strcmp(env->prog_name, progName) != 0)
f0118ef1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118ef4:	83 c0 20             	add    $0x20,%eax
f0118ef7:	83 ec 08             	sub    $0x8,%esp
f0118efa:	ff 75 a4             	pushl  -0x5c(%ebp)
f0118efd:	50                   	push   %eax
f0118efe:	e8 84 1c 00 00       	call   f011ab87 <strcmp>
f0118f03:	83 c4 10             	add    $0x10,%esp
f0118f06:	85 c0                	test   %eax,%eax
f0118f08:	75 46                	jne    f0118f50 <sys_utilities+0x292>
					continue;
				(*numOfInstances)-- ;
f0118f0a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118f0d:	8b 00                	mov    (%eax),%eax
f0118f0f:	8d 50 ff             	lea    -0x1(%eax),%edx
f0118f12:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118f15:	89 10                	mov    %edx,(%eax)

				//cprintf("%s: prevID = %d, nextID = %d\n", progName, prevEnvID, env->env_id);
				if (chkAscending)
f0118f17:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118f1b:	74 14                	je     f0118f31 <sys_utilities+0x273>
				{
					if (prevEnvID > env->env_id)
f0118f1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118f20:	8b 40 10             	mov    0x10(%eax),%eax
f0118f23:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118f26:	7d 1d                	jge    f0118f45 <sys_utilities+0x287>
					{
						success = 0;
f0118f28:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f0118f2f:	eb 32                	jmp    f0118f63 <sys_utilities+0x2a5>
					}
				}
				else
				{
					if (prevEnvID < env->env_id)
f0118f31:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118f34:	8b 40 10             	mov    0x10(%eax),%eax
f0118f37:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118f3a:	7e 09                	jle    f0118f45 <sys_utilities+0x287>
					{
						success = 0;
f0118f3c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f0118f43:	eb 1e                	jmp    f0118f63 <sys_utilities+0x2a5>
					}
				}
				prevEnvID = env->env_id;
f0118f45:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118f48:	8b 40 10             	mov    0x10(%eax),%eax
f0118f4b:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0118f4e:	eb 01                	jmp    f0118f51 <sys_utilities+0x293>
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
			{
				if (strcmp(env->prog_name, progName) != 0)
					continue;
f0118f50:	90                   	nop
		acquire_kspinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f0118f51:	ff 4d e4             	decl   -0x1c(%ebp)
f0118f54:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118f57:	8b 40 0c             	mov    0xc(%eax),%eax
f0118f5a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0118f5d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0118f61:	7f 8e                	jg     f0118ef1 <sys_utilities+0x233>
					}
				}
				prevEnvID = env->env_id;
			}
		}
		release_kspinlock(&ProcessQueues.qlock);
f0118f63:	83 ec 0c             	sub    $0xc,%esp
f0118f66:	68 20 e7 83 f0       	push   $0xf083e720
f0118f6b:	e8 b0 6e ff ff       	call   f010fe20 <release_kspinlock>
f0118f70:	83 c4 10             	add    $0x10,%esp
		if (*numOfInstances != 0 || success == 0)
f0118f73:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118f76:	8b 00                	mov    (%eax),%eax
f0118f78:	85 c0                	test   %eax,%eax
f0118f7a:	75 06                	jne    f0118f82 <sys_utilities+0x2c4>
f0118f7c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0118f80:	75 4b                	jne    f0118fcd <sys_utilities+0x30f>
		{
			cons_lock();
f0118f82:	e8 fa 8a fe ff       	call   f0101a81 <cons_lock>
			{
				cprintf("###########################################\n");
f0118f87:	83 ec 0c             	sub    $0xc,%esp
f0118f8a:	68 60 51 13 f0       	push   $0xf0135160
f0118f8f:	e8 c8 8b fe ff       	call   f0101b5c <cprintf>
f0118f94:	83 c4 10             	add    $0x10,%esp
				cprintf("%s: check exit order is FAILED\n", progName);
f0118f97:	83 ec 08             	sub    $0x8,%esp
f0118f9a:	ff 75 a4             	pushl  -0x5c(%ebp)
f0118f9d:	68 90 51 13 f0       	push   $0xf0135190
f0118fa2:	e8 b5 8b fe ff       	call   f0101b5c <cprintf>
f0118fa7:	83 c4 10             	add    $0x10,%esp
				cprintf("###########################################\n");
f0118faa:	83 ec 0c             	sub    $0xc,%esp
f0118fad:	68 60 51 13 f0       	push   $0xf0135160
f0118fb2:	e8 a5 8b fe ff       	call   f0101b5c <cprintf>
f0118fb7:	83 c4 10             	add    $0x10,%esp
			}
			cons_unlock();
f0118fba:	e8 09 8b fe ff       	call   f0101ac8 <cons_unlock>
			*numOfInstances = 0; //to indicate the failure of test
f0118fbf:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118fc2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0118fc8:	e9 3d 05 00 00       	jmp    f011950a <sys_utilities+0x84c>
		}
		else
		{
			cons_lock();
f0118fcd:	e8 af 8a fe ff       	call   f0101a81 <cons_lock>
			{
				cprintf("####################################################\n");
f0118fd2:	83 ec 0c             	sub    $0xc,%esp
f0118fd5:	68 b0 51 13 f0       	push   $0xf01351b0
f0118fda:	e8 7d 8b fe ff       	call   f0101b5c <cprintf>
f0118fdf:	83 c4 10             	add    $0x10,%esp
				cprintf("%s: check exit order is SUCCEEDED\n", progName);
f0118fe2:	83 ec 08             	sub    $0x8,%esp
f0118fe5:	ff 75 a4             	pushl  -0x5c(%ebp)
f0118fe8:	68 e8 51 13 f0       	push   $0xf01351e8
f0118fed:	e8 6a 8b fe ff       	call   f0101b5c <cprintf>
f0118ff2:	83 c4 10             	add    $0x10,%esp
				cprintf("####################################################\n");
f0118ff5:	83 ec 0c             	sub    $0xc,%esp
f0118ff8:	68 b0 51 13 f0       	push   $0xf01351b0
f0118ffd:	e8 5a 8b fe ff       	call   f0101b5c <cprintf>
f0119002:	83 c4 10             	add    $0x10,%esp
			}
			cons_unlock();
f0119005:	e8 be 8a fe ff       	call   f0101ac8 <cons_unlock>
			*numOfInstances = 1; //to indicate the success of test
f011900a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011900d:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
f0119013:	e9 f2 04 00 00       	jmp    f011950a <sys_utilities+0x84c>
		}
	}
	else if (strncmp(utilityName, "__NthClkRepl@", strlen("__NthClkRepl@")) == 0)
f0119018:	83 ec 0c             	sub    $0xc,%esp
f011901b:	68 0b 52 13 f0       	push   $0xf013520b
f0119020:	e8 56 1a 00 00       	call   f011aa7b <strlen>
f0119025:	83 c4 10             	add    $0x10,%esp
f0119028:	83 ec 04             	sub    $0x4,%esp
f011902b:	50                   	push   %eax
f011902c:	68 0b 52 13 f0       	push   $0xf013520b
f0119031:	ff 75 08             	pushl  0x8(%ebp)
f0119034:	e8 86 1b 00 00       	call   f011abbf <strncmp>
f0119039:	83 c4 10             	add    $0x10,%esp
f011903c:	85 c0                	test   %eax,%eax
f011903e:	75 76                	jne    f01190b6 <sys_utilities+0x3f8>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f0119040:	8d 45 80             	lea    -0x80(%ebp),%eax
f0119043:	50                   	push   %eax
f0119044:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
f011904a:	50                   	push   %eax
f011904b:	68 22 51 13 f0       	push   $0xf0135122
f0119050:	ff 75 08             	pushl  0x8(%ebp)
f0119053:	e8 e7 20 00 00       	call   f011b13f <strsplit>
f0119058:	83 c4 10             	add    $0x10,%esp
		int type = strtol(tokens[1], NULL, 10);
f011905b:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0119061:	83 ec 04             	sub    $0x4,%esp
f0119064:	6a 0a                	push   $0xa
f0119066:	6a 00                	push   $0x0
f0119068:	50                   	push   %eax
f0119069:	e8 1c 1e 00 00       	call   f011ae8a <strtol>
f011906e:	83 c4 10             	add    $0x10,%esp
f0119071:	89 45 ac             	mov    %eax,-0x54(%ebp)
		int N = value;
f0119074:	8b 45 0c             	mov    0xc(%ebp),%eax
f0119077:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if (type == 2)
f011907a:	83 7d ac 02          	cmpl   $0x2,-0x54(%ebp)
f011907e:	75 03                	jne    f0119083 <sys_utilities+0x3c5>
			N *= -1;
f0119080:	f7 5d e0             	negl   -0x20(%ebp)
		setPageReplacmentAlgorithmNchanceCLOCK(N);
f0119083:	83 ec 0c             	sub    $0xc,%esp
f0119086:	ff 75 e0             	pushl  -0x20(%ebp)
f0119089:	e8 5f 67 ff ff       	call   f010f7ed <setPageReplacmentAlgorithmNchanceCLOCK>
f011908e:	83 c4 10             	add    $0x10,%esp
		cons_lock();
f0119091:	e8 eb 89 fe ff       	call   f0101a81 <cons_lock>
		{
			cprintf("\n*********************************************************"
f0119096:	83 ec 04             	sub    $0x4,%esp
f0119099:	ff 75 e0             	pushl  -0x20(%ebp)
f011909c:	ff 75 ac             	pushl  -0x54(%ebp)
f011909f:	68 1c 52 13 f0       	push   $0xf013521c
f01190a4:	e8 b3 8a fe ff       	call   f0101b5c <cprintf>
f01190a9:	83 c4 10             	add    $0x10,%esp
					"\nPAGE REPLACEMENT IS SET TO Nth Clock type = %d (N = %d)."
					"\n*********************************************************\n", type, N);
		}
		cons_unlock();
f01190ac:	e8 17 8a fe ff       	call   f0101ac8 <cons_unlock>
f01190b1:	e9 54 04 00 00       	jmp    f011950a <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__Sleep__") == 0)
f01190b6:	83 ec 08             	sub    $0x8,%esp
f01190b9:	68 cb 52 13 f0       	push   $0xf01352cb
f01190be:	ff 75 08             	pushl  0x8(%ebp)
f01190c1:	e8 c1 1a 00 00       	call   f011ab87 <strcmp>
f01190c6:	83 c4 10             	add    $0x10,%esp
f01190c9:	85 c0                	test   %eax,%eax
f01190cb:	75 77                	jne    f0119144 <sys_utilities+0x486>
	{
		if (__firstTimeSleep)
f01190cd:	a1 ac 01 18 f0       	mov    0xf01801ac,%eax
f01190d2:	85 c0                	test   %eax,%eax
f01190d4:	74 34                	je     f011910a <sys_utilities+0x44c>
		{
			__firstTimeSleep = 0;
f01190d6:	c7 05 ac 01 18 f0 00 	movl   $0x0,0xf01801ac
f01190dd:	00 00 00 
			init_channel(&__tstchan__, "Test Channel");
f01190e0:	83 ec 08             	sub    $0x8,%esp
f01190e3:	68 d5 52 13 f0       	push   $0xf01352d5
f01190e8:	68 e0 d4 87 f0       	push   $0xf087d4e0
f01190ed:	e8 61 70 ff ff       	call   f0110153 <init_channel>
f01190f2:	83 c4 10             	add    $0x10,%esp
			init_kspinlock(&__tstchan_lk__, "Test Channel Lock");
f01190f5:	83 ec 08             	sub    $0x8,%esp
f01190f8:	68 e2 52 13 f0       	push   $0xf01352e2
f01190fd:	68 60 d6 87 f0       	push   $0xf087d660
f0119102:	e8 43 6c ff ff       	call   f010fd4a <init_kspinlock>
f0119107:	83 c4 10             	add    $0x10,%esp
		}
		acquire_kspinlock(&__tstchan_lk__);
f011910a:	83 ec 0c             	sub    $0xc,%esp
f011910d:	68 60 d6 87 f0       	push   $0xf087d660
f0119112:	e8 64 6c ff ff       	call   f010fd7b <acquire_kspinlock>
f0119117:	83 c4 10             	add    $0x10,%esp
		sleep(&__tstchan__, &__tstchan_lk__);
f011911a:	83 ec 08             	sub    $0x8,%esp
f011911d:	68 60 d6 87 f0       	push   $0xf087d660
f0119122:	68 e0 d4 87 f0       	push   $0xf087d4e0
f0119127:	e8 54 70 ff ff       	call   f0110180 <sleep>
f011912c:	83 c4 10             	add    $0x10,%esp
		release_kspinlock(&__tstchan_lk__);
f011912f:	83 ec 0c             	sub    $0xc,%esp
f0119132:	68 60 d6 87 f0       	push   $0xf087d660
f0119137:	e8 e4 6c ff ff       	call   f010fe20 <release_kspinlock>
f011913c:	83 c4 10             	add    $0x10,%esp
f011913f:	e9 c6 03 00 00       	jmp    f011950a <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__WakeupOne__") == 0)
f0119144:	83 ec 08             	sub    $0x8,%esp
f0119147:	68 f4 52 13 f0       	push   $0xf01352f4
f011914c:	ff 75 08             	pushl  0x8(%ebp)
f011914f:	e8 33 1a 00 00       	call   f011ab87 <strcmp>
f0119154:	83 c4 10             	add    $0x10,%esp
f0119157:	85 c0                	test   %eax,%eax
f0119159:	75 15                	jne    f0119170 <sys_utilities+0x4b2>
	{
		wakeup_one(&__tstchan__);
f011915b:	83 ec 0c             	sub    $0xc,%esp
f011915e:	68 e0 d4 87 f0       	push   $0xf087d4e0
f0119163:	e8 32 70 ff ff       	call   f011019a <wakeup_one>
f0119168:	83 c4 10             	add    $0x10,%esp
f011916b:	e9 9a 03 00 00       	jmp    f011950a <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__WakeupAll__") == 0)
f0119170:	83 ec 08             	sub    $0x8,%esp
f0119173:	68 02 53 13 f0       	push   $0xf0135302
f0119178:	ff 75 08             	pushl  0x8(%ebp)
f011917b:	e8 07 1a 00 00       	call   f011ab87 <strcmp>
f0119180:	83 c4 10             	add    $0x10,%esp
f0119183:	85 c0                	test   %eax,%eax
f0119185:	75 15                	jne    f011919c <sys_utilities+0x4de>
	{
		wakeup_all(&__tstchan__);
f0119187:	83 ec 0c             	sub    $0xc,%esp
f011918a:	68 e0 d4 87 f0       	push   $0xf087d4e0
f011918f:	e8 20 70 ff ff       	call   f01101b4 <wakeup_all>
f0119194:	83 c4 10             	add    $0x10,%esp
f0119197:	e9 6e 03 00 00       	jmp    f011950a <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__GetChanQueueSize__") == 0)
f011919c:	83 ec 08             	sub    $0x8,%esp
f011919f:	68 10 53 13 f0       	push   $0xf0135310
f01191a4:	ff 75 08             	pushl  0x8(%ebp)
f01191a7:	e8 db 19 00 00       	call   f011ab87 <strcmp>
f01191ac:	83 c4 10             	add    $0x10,%esp
f01191af:	85 c0                	test   %eax,%eax
f01191b1:	75 17                	jne    f01191ca <sys_utilities+0x50c>
	{
		int* numOfProcesses = (int*) value ;
f01191b3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01191b6:	89 45 b0             	mov    %eax,-0x50(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstchan__.queue);
f01191b9:	a1 ec d4 87 f0       	mov    0xf087d4ec,%eax
f01191be:	89 c2                	mov    %eax,%edx
f01191c0:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01191c3:	89 10                	mov    %edx,(%eax)
f01191c5:	e9 40 03 00 00       	jmp    f011950a <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__GetReadyQueueSize__") == 0)
f01191ca:	83 ec 08             	sub    $0x8,%esp
f01191cd:	68 25 53 13 f0       	push   $0xf0135325
f01191d2:	ff 75 08             	pushl  0x8(%ebp)
f01191d5:	e8 ad 19 00 00       	call   f011ab87 <strcmp>
f01191da:	83 c4 10             	add    $0x10,%esp
f01191dd:	85 c0                	test   %eax,%eax
f01191df:	75 1a                	jne    f01191fb <sys_utilities+0x53d>
	{
		int* numOfProcesses = (int*) value ;
f01191e1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01191e4:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		*numOfProcesses = LIST_SIZE(&ProcessQueues.env_ready_queues[0]);
f01191e7:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f01191ec:	8b 40 0c             	mov    0xc(%eax),%eax
f01191ef:	89 c2                	mov    %eax,%edx
f01191f1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01191f4:	89 10                	mov    %edx,(%eax)
f01191f6:	e9 0f 03 00 00       	jmp    f011950a <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__AcquireSleepLock__") == 0)
f01191fb:	83 ec 08             	sub    $0x8,%esp
f01191fe:	68 3b 53 13 f0       	push   $0xf013533b
f0119203:	ff 75 08             	pushl  0x8(%ebp)
f0119206:	e8 7c 19 00 00       	call   f011ab87 <strcmp>
f011920b:	83 c4 10             	add    $0x10,%esp
f011920e:	85 c0                	test   %eax,%eax
f0119210:	75 3d                	jne    f011924f <sys_utilities+0x591>
	{
		if (__firstTimeSleepLock)
f0119212:	a1 b0 01 18 f0       	mov    0xf01801b0,%eax
f0119217:	85 c0                	test   %eax,%eax
f0119219:	74 1f                	je     f011923a <sys_utilities+0x57c>
		{
			__firstTimeSleepLock = 0;
f011921b:	c7 05 b0 01 18 f0 00 	movl   $0x0,0xf01801b0
f0119222:	00 00 00 
			init_sleeplock(&__tstslplk__, "Test Sleep Lock");
f0119225:	83 ec 08             	sub    $0x8,%esp
f0119228:	68 50 53 13 f0       	push   $0xf0135350
f011922d:	68 40 d5 87 f0       	push   $0xf087d540
f0119232:	e8 da 6d ff ff       	call   f0110011 <init_sleeplock>
f0119237:	83 c4 10             	add    $0x10,%esp
		}
		acquire_sleeplock(&__tstslplk__);
f011923a:	83 ec 0c             	sub    $0xc,%esp
f011923d:	68 40 d5 87 f0       	push   $0xf087d540
f0119242:	e8 78 6e ff ff       	call   f01100bf <acquire_sleeplock>
f0119247:	83 c4 10             	add    $0x10,%esp
f011924a:	e9 bb 02 00 00       	jmp    f011950a <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__ReleaseSleepLock__") == 0)
f011924f:	83 ec 08             	sub    $0x8,%esp
f0119252:	68 60 53 13 f0       	push   $0xf0135360
f0119257:	ff 75 08             	pushl  0x8(%ebp)
f011925a:	e8 28 19 00 00       	call   f011ab87 <strcmp>
f011925f:	83 c4 10             	add    $0x10,%esp
f0119262:	85 c0                	test   %eax,%eax
f0119264:	75 15                	jne    f011927b <sys_utilities+0x5bd>
	{
		release_sleeplock(&__tstslplk__);
f0119266:	83 ec 0c             	sub    $0xc,%esp
f0119269:	68 40 d5 87 f0       	push   $0xf087d540
f011926e:	e8 66 6e ff ff       	call   f01100d9 <release_sleeplock>
f0119273:	83 c4 10             	add    $0x10,%esp
f0119276:	e9 8f 02 00 00       	jmp    f011950a <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__GetLockQueueSize__") == 0)
f011927b:	83 ec 08             	sub    $0x8,%esp
f011927e:	68 75 53 13 f0       	push   $0xf0135375
f0119283:	ff 75 08             	pushl  0x8(%ebp)
f0119286:	e8 fc 18 00 00       	call   f011ab87 <strcmp>
f011928b:	83 c4 10             	add    $0x10,%esp
f011928e:	85 c0                	test   %eax,%eax
f0119290:	75 17                	jne    f01192a9 <sys_utilities+0x5eb>
	{
		int* numOfProcesses = (int*) value ;
f0119292:	8b 45 0c             	mov    0xc(%ebp),%eax
f0119295:	89 45 b8             	mov    %eax,-0x48(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstslplk__.chan.queue);
f0119298:	a1 c0 d5 87 f0       	mov    0xf087d5c0,%eax
f011929d:	89 c2                	mov    %eax,%edx
f011929f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01192a2:	89 10                	mov    %edx,(%eax)
f01192a4:	e9 61 02 00 00       	jmp    f011950a <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__GetLockValue__") == 0)
f01192a9:	83 ec 08             	sub    $0x8,%esp
f01192ac:	68 8a 53 13 f0       	push   $0xf013538a
f01192b1:	ff 75 08             	pushl  0x8(%ebp)
f01192b4:	e8 ce 18 00 00       	call   f011ab87 <strcmp>
f01192b9:	83 c4 10             	add    $0x10,%esp
f01192bc:	85 c0                	test   %eax,%eax
f01192be:	75 16                	jne    f01192d6 <sys_utilities+0x618>
	{
		int* lockVal = (int*) value ;
f01192c0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01192c3:	89 45 bc             	mov    %eax,-0x44(%ebp)
		*lockVal =__tstslplk__.locked;
f01192c6:	8b 15 40 d5 87 f0    	mov    0xf087d540,%edx
f01192cc:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01192cf:	89 10                	mov    %edx,(%eax)
f01192d1:	e9 34 02 00 00       	jmp    f011950a <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__GetLockOwner__") == 0)
f01192d6:	83 ec 08             	sub    $0x8,%esp
f01192d9:	68 9b 53 13 f0       	push   $0xf013539b
f01192de:	ff 75 08             	pushl  0x8(%ebp)
f01192e1:	e8 a1 18 00 00       	call   f011ab87 <strcmp>
f01192e6:	83 c4 10             	add    $0x10,%esp
f01192e9:	85 c0                	test   %eax,%eax
f01192eb:	75 17                	jne    f0119304 <sys_utilities+0x646>
	{
		uint32* lockOwnerID = (uint32*) value ;
f01192ed:	8b 45 0c             	mov    0xc(%ebp),%eax
f01192f0:	89 45 c0             	mov    %eax,-0x40(%ebp)
		*lockOwnerID =__tstslplk__.pid;
f01192f3:	a1 44 d6 87 f0       	mov    0xf087d644,%eax
f01192f8:	89 c2                	mov    %eax,%edx
f01192fa:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01192fd:	89 10                	mov    %edx,(%eax)
f01192ff:	e9 06 02 00 00       	jmp    f011950a <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__GetConsLockedCnt__") == 0)
f0119304:	83 ec 08             	sub    $0x8,%esp
f0119307:	68 ac 53 13 f0       	push   $0xf01353ac
f011930c:	ff 75 08             	pushl  0x8(%ebp)
f011930f:	e8 73 18 00 00       	call   f011ab87 <strcmp>
f0119314:	83 c4 10             	add    $0x10,%esp
f0119317:	85 c0                	test   %eax,%eax
f0119319:	75 22                	jne    f011933d <sys_utilities+0x67f>
	{
		uint32* consLockCnt = (uint32*) value ;
f011931b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011931e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		*consLockCnt = queue_size(&(conslock.chan.queue));
f0119321:	83 ec 0c             	sub    $0xc,%esp
f0119324:	68 d4 e5 83 f0       	push   $0xf083e5d4
f0119329:	e8 c5 cb fe ff       	call   f0105ef3 <queue_size>
f011932e:	83 c4 10             	add    $0x10,%esp
f0119331:	89 c2                	mov    %eax,%edx
f0119333:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0119336:	89 10                	mov    %edx,(%eax)
f0119338:	e9 cd 01 00 00       	jmp    f011950a <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__tmpReleaseConsLock__") == 0)
f011933d:	83 ec 08             	sub    $0x8,%esp
f0119340:	68 c1 53 13 f0       	push   $0xf01353c1
f0119345:	ff 75 08             	pushl  0x8(%ebp)
f0119348:	e8 3a 18 00 00       	call   f011ab87 <strcmp>
f011934d:	83 c4 10             	add    $0x10,%esp
f0119350:	85 c0                	test   %eax,%eax
f0119352:	0f 84 b2 01 00 00    	je     f011950a <sys_utilities+0x84c>
	/*else if (strcmp(utilityName, "__getKernelSBreak__") == 0)
	{
		uint32* ksbrk = (uint32*) value ;
		*ksbrk = (uint32)sbrk(0);
	}*/
	else if (strcmp(utilityName, "__changeInterruptStatus__") == 0)
f0119358:	83 ec 08             	sub    $0x8,%esp
f011935b:	68 d8 53 13 f0       	push   $0xf01353d8
f0119360:	ff 75 08             	pushl  0x8(%ebp)
f0119363:	e8 1f 18 00 00       	call   f011ab87 <strcmp>
f0119368:	83 c4 10             	add    $0x10,%esp
f011936b:	85 c0                	test   %eax,%eax
f011936d:	0f 85 96 00 00 00    	jne    f0119409 <sys_utilities+0x74b>
	{
		if (value == 0)
f0119373:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0119377:	75 43                	jne    f01193bc <sys_utilities+0x6fe>
		{
			kclock_stop();
f0119379:	e8 9d c8 fe ff       	call   f0105c1b <kclock_stop>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f011937e:	fa                   	cli    
			cli();
			struct Env * p = get_cpu_proc();
f011937f:	e8 94 26 ff ff       	call   f010ba18 <get_cpu_proc>
f0119384:	89 45 cc             	mov    %eax,-0x34(%ebp)
			if (p == NULL)
f0119387:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f011938b:	75 17                	jne    f01193a4 <sys_utilities+0x6e6>
			{
				panic("cons_lock: no running process to block");
f011938d:	83 ec 04             	sub    $0x4,%esp
f0119390:	68 f4 53 13 f0       	push   $0xf01353f4
f0119395:	68 67 01 00 00       	push   $0x167
f011939a:	68 af 50 13 f0       	push   $0xf01350af
f011939f:	e8 0b 7b fe ff       	call   f0100eaf <_panic>
			}
			p->env_tf->tf_eflags &= ~FL_IF ;
f01193a4:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01193a7:	8b 00                	mov    (%eax),%eax
f01193a9:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01193ac:	8b 12                	mov    (%edx),%edx
f01193ae:	8b 52 38             	mov    0x38(%edx),%edx
f01193b1:	80 e6 fd             	and    $0xfd,%dh
f01193b4:	89 50 38             	mov    %edx,0x38(%eax)
f01193b7:	e9 4e 01 00 00       	jmp    f011950a <sys_utilities+0x84c>
			//cprintf("\nINTERRUPT WILL BE DISABLED\n");
		}
		else if (value == 1)
f01193bc:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f01193c0:	0f 85 44 01 00 00    	jne    f011950a <sys_utilities+0x84c>
		{
			kclock_stop();
f01193c6:	e8 50 c8 fe ff       	call   f0105c1b <kclock_stop>
f01193cb:	fa                   	cli    
			cli();
			struct Env * p = get_cpu_proc();
f01193cc:	e8 47 26 ff ff       	call   f010ba18 <get_cpu_proc>
f01193d1:	89 45 c8             	mov    %eax,-0x38(%ebp)
			if (p == NULL)
f01193d4:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f01193d8:	75 17                	jne    f01193f1 <sys_utilities+0x733>
			{
				panic("cons_unlock: no running process to block");
f01193da:	83 ec 04             	sub    $0x4,%esp
f01193dd:	68 1c 54 13 f0       	push   $0xf013541c
f01193e2:	68 73 01 00 00       	push   $0x173
f01193e7:	68 af 50 13 f0       	push   $0xf01350af
f01193ec:	e8 be 7a fe ff       	call   f0100eaf <_panic>
			}
			p->env_tf->tf_eflags |= FL_IF ;
f01193f1:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01193f4:	8b 00                	mov    (%eax),%eax
f01193f6:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01193f9:	8b 12                	mov    (%edx),%edx
f01193fb:	8b 52 38             	mov    0x38(%edx),%edx
f01193fe:	80 ce 02             	or     $0x2,%dh
f0119401:	89 50 38             	mov    %edx,0x38(%eax)
f0119404:	e9 01 01 00 00       	jmp    f011950a <sys_utilities+0x84c>
			//cprintf("\nINTERRUPT WILL BE ENABLED\n");
		}
	}
	else if (strncmp(utilityName, "__getProcState@", strlen("__getProcState@")) == 0)
f0119409:	83 ec 0c             	sub    $0xc,%esp
f011940c:	68 45 54 13 f0       	push   $0xf0135445
f0119411:	e8 65 16 00 00       	call   f011aa7b <strlen>
f0119416:	83 c4 10             	add    $0x10,%esp
f0119419:	83 ec 04             	sub    $0x4,%esp
f011941c:	50                   	push   %eax
f011941d:	68 45 54 13 f0       	push   $0xf0135445
f0119422:	ff 75 08             	pushl  0x8(%ebp)
f0119425:	e8 95 17 00 00       	call   f011abbf <strncmp>
f011942a:	83 c4 10             	add    $0x10,%esp
f011942d:	85 c0                	test   %eax,%eax
f011942f:	0f 85 ac 00 00 00    	jne    f01194e1 <sys_utilities+0x823>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f0119435:	8d 85 7c ff ff ff    	lea    -0x84(%ebp),%eax
f011943b:	50                   	push   %eax
f011943c:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
f0119442:	50                   	push   %eax
f0119443:	68 22 51 13 f0       	push   $0xf0135122
f0119448:	ff 75 08             	pushl  0x8(%ebp)
f011944b:	e8 ef 1c 00 00       	call   f011b13f <strsplit>
f0119450:	83 c4 10             	add    $0x10,%esp
		int envID = strtol(tokens[1], NULL, 10);
f0119453:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0119459:	83 ec 04             	sub    $0x4,%esp
f011945c:	6a 0a                	push   $0xa
f011945e:	6a 00                	push   $0x0
f0119460:	50                   	push   %eax
f0119461:	e8 24 1a 00 00       	call   f011ae8a <strtol>
f0119466:	83 c4 10             	add    $0x10,%esp
f0119469:	89 45 dc             	mov    %eax,-0x24(%ebp)
		struct Env* env = NULL ;
f011946c:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f0119473:	00 00 00 
		int ret = envid2env(envID, &env, 0);
f0119476:	83 ec 04             	sub    $0x4,%esp
f0119479:	6a 00                	push   $0x0
f011947b:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0119481:	50                   	push   %eax
f0119482:	ff 75 dc             	pushl  -0x24(%ebp)
f0119485:	e8 de 25 ff ff       	call   f010ba68 <envid2env>
f011948a:	83 c4 10             	add    $0x10,%esp
f011948d:	89 45 d8             	mov    %eax,-0x28(%ebp)
		uint32* procState = (uint32*) value ;
f0119490:	8b 45 0c             	mov    0xc(%ebp),%eax
f0119493:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if (ret == E_BAD_ENV)
f0119496:	83 7d d8 fe          	cmpl   $0xfffffffe,-0x28(%ebp)
f011949a:	75 0e                	jne    f01194aa <sys_utilities+0x7ec>
		{
			//cprintf("\n\n<<<<<<<<<<< BAD ENV >>>>>>>>>>>\n\n");
			*procState = E_BAD_ENV;
f011949c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011949f:	c7 00 fe ff ff ff    	movl   $0xfffffffe,(%eax)
f01194a5:	e9 5d 01 00 00       	jmp    f0119607 <sys_utilities+0x949>
			return;
		}
		else
		{
			assert(env->env_id == envID) ;
f01194aa:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01194b0:	8b 40 10             	mov    0x10(%eax),%eax
f01194b3:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01194b6:	74 19                	je     f01194d1 <sys_utilities+0x813>
f01194b8:	68 24 51 13 f0       	push   $0xf0135124
f01194bd:	68 67 50 13 f0       	push   $0xf0135067
f01194c2:	68 8b 01 00 00       	push   $0x18b
f01194c7:	68 af 50 13 f0       	push   $0xf01350af
f01194cc:	e8 de 79 fe ff       	call   f0100eaf <_panic>
			*procState = env->env_status;
f01194d1:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01194d7:	8b 50 18             	mov    0x18(%eax),%edx
f01194da:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01194dd:	89 10                	mov    %edx,(%eax)
f01194df:	eb 29                	jmp    f011950a <sys_utilities+0x84c>
		}
	}
	else if (strcmp(utilityName, "__IsOPTRepl__") == 0)
f01194e1:	83 ec 08             	sub    $0x8,%esp
f01194e4:	68 55 54 13 f0       	push   $0xf0135455
f01194e9:	ff 75 08             	pushl  0x8(%ebp)
f01194ec:	e8 96 16 00 00       	call   f011ab87 <strcmp>
f01194f1:	83 c4 10             	add    $0x10,%esp
f01194f4:	85 c0                	test   %eax,%eax
f01194f6:	75 12                	jne    f011950a <sys_utilities+0x84c>
	{
		uint32* isOPTRepl = (uint32*) value ;
f01194f8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01194fb:	89 45 d0             	mov    %eax,-0x30(%ebp)
		*isOPTRepl = isPageReplacmentAlgorithmOPTIMAL();
f01194fe:	e8 bd 63 ff ff       	call   f010f8c0 <isPageReplacmentAlgorithmOPTIMAL>
f0119503:	89 c2                	mov    %eax,%edx
f0119505:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0119508:	89 10                	mov    %edx,(%eax)
	}
	if ((int)value < 0)
f011950a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011950e:	0f 89 f3 00 00 00    	jns    f0119607 <sys_utilities+0x949>
	{
		if (strcmp(utilityName, "__ReplStrat__") == 0)
f0119514:	83 ec 08             	sub    $0x8,%esp
f0119517:	68 63 54 13 f0       	push   $0xf0135463
f011951c:	ff 75 08             	pushl  0x8(%ebp)
f011951f:	e8 63 16 00 00       	call   f011ab87 <strcmp>
f0119524:	83 c4 10             	add    $0x10,%esp
f0119527:	85 c0                	test   %eax,%eax
f0119529:	0f 85 d8 00 00 00    	jne    f0119607 <sys_utilities+0x949>
		{
			switch (value)
f011952f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0119532:	83 c0 08             	add    $0x8,%eax
f0119535:	83 f8 07             	cmp    $0x7,%eax
f0119538:	0f 87 c8 00 00 00    	ja     f0119606 <sys_utilities+0x948>
f011953e:	8b 04 85 b0 57 13 f0 	mov    -0xfeca850(,%eax,4),%eax
f0119545:	ff e0                	jmp    *%eax
			{
			case -PG_REP_FIFO:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO FIFO.\n*************************************\n");
f0119547:	83 ec 0c             	sub    $0xc,%esp
f011954a:	68 74 54 13 f0       	push   $0xf0135474
f011954f:	e8 08 86 fe ff       	call   f0101b5c <cprintf>
f0119554:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmFIFO();
f0119557:	e8 61 62 ff ff       	call   f010f7bd <setPageReplacmentAlgorithmFIFO>
				break;
f011955c:	e9 a6 00 00 00       	jmp    f0119607 <sys_utilities+0x949>
			case -PG_REP_CLOCK:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO CLOCK.\n*************************************\n");
f0119561:	83 ec 0c             	sub    $0xc,%esp
f0119564:	68 e4 54 13 f0       	push   $0xf01354e4
f0119569:	e8 ee 85 fe ff       	call   f0101b5c <cprintf>
f011956e:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmCLOCK();
f0119571:	e8 37 62 ff ff       	call   f010f7ad <setPageReplacmentAlgorithmCLOCK>
				break;
f0119576:	e9 8c 00 00 00       	jmp    f0119607 <sys_utilities+0x949>
			case -PG_REP_MODIFIEDCLOCK:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO MODIFIED CLOCK.\n*************************************\n");
f011957b:	83 ec 0c             	sub    $0xc,%esp
f011957e:	68 54 55 13 f0       	push   $0xf0135554
f0119583:	e8 d4 85 fe ff       	call   f0101b5c <cprintf>
f0119588:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmModifiedCLOCK();
f011958b:	e8 3d 62 ff ff       	call   f010f7cd <setPageReplacmentAlgorithmModifiedCLOCK>
				break;
f0119590:	eb 75                	jmp    f0119607 <sys_utilities+0x949>
			case -PG_REP_OPTIMAL:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO OPTIMAL.\n*************************************\n");
f0119592:	83 ec 0c             	sub    $0xc,%esp
f0119595:	68 d0 55 13 f0       	push   $0xf01355d0
f011959a:	e8 bd 85 fe ff       	call   f0101b5c <cprintf>
f011959f:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmOPTIMAL();
f01195a2:	e8 6c 62 ff ff       	call   f010f813 <setPageReplacmentAlgorithmOPTIMAL>
				break;
f01195a7:	eb 5e                	jmp    f0119607 <sys_utilities+0x949>
			case -PG_REP_LRU_TIME_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU AGING.\n*************************************\n");
f01195a9:	83 ec 0c             	sub    $0xc,%esp
f01195ac:	68 44 56 13 f0       	push   $0xf0135644
f01195b1:	e8 a6 85 fe ff       	call   f0101b5c <cprintf>
f01195b6:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX);
f01195b9:	83 ec 0c             	sub    $0xc,%esp
f01195bc:	6a 01                	push   $0x1
f01195be:	e8 b7 61 ff ff       	call   f010f77a <setPageReplacmentAlgorithmLRU>
f01195c3:	83 c4 10             	add    $0x10,%esp
				break;
f01195c6:	eb 3f                	jmp    f0119607 <sys_utilities+0x949>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
f01195c8:	83 ec 0c             	sub    $0xc,%esp
f01195cb:	68 b8 56 13 f0       	push   $0xf01356b8
f01195d0:	e8 87 85 fe ff       	call   f0101b5c <cprintf>
f01195d5:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
f01195d8:	83 ec 0c             	sub    $0xc,%esp
f01195db:	6a 02                	push   $0x2
f01195dd:	e8 98 61 ff ff       	call   f010f77a <setPageReplacmentAlgorithmLRU>
f01195e2:	83 c4 10             	add    $0x10,%esp
				break;
f01195e5:	eb 20                	jmp    f0119607 <sys_utilities+0x949>
			case -PG_REP_NchanceCLOCK:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO Nth Clock Normal (N=1).\n*************************************\n");
f01195e7:	83 ec 0c             	sub    $0xc,%esp
f01195ea:	68 2c 57 13 f0       	push   $0xf013572c
f01195ef:	e8 68 85 fe ff       	call   f0101b5c <cprintf>
f01195f4:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmNchanceCLOCK(1);
f01195f7:	83 ec 0c             	sub    $0xc,%esp
f01195fa:	6a 01                	push   $0x1
f01195fc:	e8 ec 61 ff ff       	call   f010f7ed <setPageReplacmentAlgorithmNchanceCLOCK>
f0119601:	83 c4 10             	add    $0x10,%esp
				break;
f0119604:	eb 01                	jmp    f0119607 <sys_utilities+0x949>
			default:
				break;
f0119606:	90                   	nop
			}
		}
	}
	/*****************************************************************************************/

}
f0119607:	c9                   	leave  
f0119608:	c3                   	ret    

f0119609 <detect_loop_in_FrameInfo_list>:
/*=======================================*/
void detect_loop_in_FrameInfo_list(struct FrameInfo_List* fi_list)
{
f0119609:	55                   	push   %ebp
f011960a:	89 e5                	mov    %esp,%ebp
f011960c:	83 ec 18             	sub    $0x18,%esp
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
f011960f:	8b 45 08             	mov    0x8(%ebp),%eax
f0119612:	8b 00                	mov    (%eax),%eax
f0119614:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);
f0119617:	8b 45 08             	mov    0x8(%ebp),%eax
f011961a:	8b 00                	mov    (%eax),%eax
f011961c:	89 45 f0             	mov    %eax,-0x10(%ebp)


	while (slowPtr && fastPtr) {
f011961f:	eb 52                	jmp    f0119673 <detect_loop_in_FrameInfo_list+0x6a>
		fastPtr = LIST_NEXT(fastPtr); // advance the fast pointer
f0119621:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0119624:	8b 00                	mov    (%eax),%eax
f0119626:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) // and check if its equal to the slow pointer
f0119629:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011962c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011962f:	75 12                	jne    f0119643 <detect_loop_in_FrameInfo_list+0x3a>
		{
			cprintf("loop detected in modiflist\n");
f0119631:	83 ec 0c             	sub    $0xc,%esp
f0119634:	68 d0 57 13 f0       	push   $0xf01357d0
f0119639:	e8 1e 85 fe ff       	call   f0101b5c <cprintf>
f011963e:	83 c4 10             	add    $0x10,%esp
			break;
f0119641:	eb 3f                	jmp    f0119682 <detect_loop_in_FrameInfo_list+0x79>
		}

		if (fastPtr == NULL) {
f0119643:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0119647:	74 38                	je     f0119681 <detect_loop_in_FrameInfo_list+0x78>
			break; // since fastPtr is NULL we reached the tail
		}

		fastPtr = LIST_NEXT(fastPtr); //advance and check again
f0119649:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011964c:	8b 00                	mov    (%eax),%eax
f011964e:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) {
f0119651:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0119654:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119657:	75 12                	jne    f011966b <detect_loop_in_FrameInfo_list+0x62>
			cprintf("loop detected in list\n");
f0119659:	83 ec 0c             	sub    $0xc,%esp
f011965c:	68 ec 57 13 f0       	push   $0xf01357ec
f0119661:	e8 f6 84 fe ff       	call   f0101b5c <cprintf>
f0119666:	83 c4 10             	add    $0x10,%esp
			break;
f0119669:	eb 17                	jmp    f0119682 <detect_loop_in_FrameInfo_list+0x79>
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
f011966b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011966e:	8b 00                	mov    (%eax),%eax
f0119670:	89 45 f4             	mov    %eax,-0xc(%ebp)
{
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);


	while (slowPtr && fastPtr) {
f0119673:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0119677:	74 09                	je     f0119682 <detect_loop_in_FrameInfo_list+0x79>
f0119679:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011967d:	75 a2                	jne    f0119621 <detect_loop_in_FrameInfo_list+0x18>
f011967f:	eb 01                	jmp    f0119682 <detect_loop_in_FrameInfo_list+0x79>
			cprintf("loop detected in modiflist\n");
			break;
		}

		if (fastPtr == NULL) {
			break; // since fastPtr is NULL we reached the tail
f0119681:	90                   	nop
			break;
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
	}
	cprintf("finished  loop detection\n");
f0119682:	83 ec 0c             	sub    $0xc,%esp
f0119685:	68 03 58 13 f0       	push   $0xf0135803
f011968a:	e8 cd 84 fe ff       	call   f0101b5c <cprintf>
f011968f:	83 c4 10             	add    $0x10,%esp
}
f0119692:	90                   	nop
f0119693:	c9                   	leave  
f0119694:	c3                   	ret    

f0119695 <scarce_memory>:

void scarce_memory()
{
f0119695:	55                   	push   %ebp
f0119696:	89 e5                	mov    %esp,%ebp
f0119698:	83 ec 28             	sub    $0x28,%esp
	uint32 total_size_tobe_allocated = ((100 - memory_scarce_threshold_percentage)*number_of_frames)/100;
f011969b:	a1 f0 e8 83 f0       	mov    0xf083e8f0,%eax
f01196a0:	ba 64 00 00 00       	mov    $0x64,%edx
f01196a5:	29 c2                	sub    %eax,%edx
f01196a7:	a1 b8 e9 83 f0       	mov    0xf083e9b8,%eax
f01196ac:	0f af c2             	imul   %edx,%eax
f01196af:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f01196b4:	f7 e2                	mul    %edx
f01196b6:	89 d0                	mov    %edx,%eax
f01196b8:	c1 e8 05             	shr    $0x5,%eax
f01196bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//	cprintf("total_size_tobe_allocated %d\n", number_of_frames);
	if (((100 - memory_scarce_threshold_percentage)*number_of_frames) % 100 > 0)
f01196be:	a1 f0 e8 83 f0       	mov    0xf083e8f0,%eax
f01196c3:	ba 64 00 00 00       	mov    $0x64,%edx
f01196c8:	29 c2                	sub    %eax,%edx
f01196ca:	a1 b8 e9 83 f0       	mov    0xf083e9b8,%eax
f01196cf:	89 d1                	mov    %edx,%ecx
f01196d1:	0f af c8             	imul   %eax,%ecx
f01196d4:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f01196d9:	f7 e1                	mul    %ecx
f01196db:	c1 ea 05             	shr    $0x5,%edx
f01196de:	89 d0                	mov    %edx,%eax
f01196e0:	c1 e0 02             	shl    $0x2,%eax
f01196e3:	01 d0                	add    %edx,%eax
f01196e5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01196ec:	01 d0                	add    %edx,%eax
f01196ee:	c1 e0 02             	shl    $0x2,%eax
f01196f1:	29 c1                	sub    %eax,%ecx
f01196f3:	89 ca                	mov    %ecx,%edx
f01196f5:	85 d2                	test   %edx,%edx
f01196f7:	74 03                	je     f01196fc <scarce_memory+0x67>
		total_size_tobe_allocated++;
f01196f9:	ff 45 f4             	incl   -0xc(%ebp)

	int fflSize = 0;
f01196fc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	acquire_kspinlock(&MemFrameLists.mfllock);
f0119703:	83 ec 0c             	sub    $0xc,%esp
f0119706:	68 e0 e7 83 f0       	push   $0xf083e7e0
f011970b:	e8 6b 66 ff ff       	call   f010fd7b <acquire_kspinlock>
f0119710:	83 c4 10             	add    $0x10,%esp
	{
		fflSize = LIST_SIZE(&MemFrameLists.free_frame_list);
f0119713:	a1 cc e7 83 f0       	mov    0xf083e7cc,%eax
f0119718:	89 45 ec             	mov    %eax,-0x14(%ebp)

		uint32 size_of_already_allocated = number_of_frames - fflSize ;
f011971b:	8b 15 b8 e9 83 f0    	mov    0xf083e9b8,%edx
f0119721:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0119724:	29 c2                	sub    %eax,%edx
f0119726:	89 d0                	mov    %edx,%eax
f0119728:	89 45 e8             	mov    %eax,-0x18(%ebp)
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
f011972b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011972e:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0119731:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
f0119734:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011973b:	eb 12                	jmp    f011974f <scarce_memory+0xba>
		{
			allocate_frame(&ptr_tmp_FI) ;
f011973d:	83 ec 0c             	sub    $0xc,%esp
f0119740:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0119743:	50                   	push   %eax
f0119744:	e8 f9 f8 fe ff       	call   f0109042 <allocate_frame>
f0119749:	83 c4 10             	add    $0x10,%esp
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011974c:	ff 45 f0             	incl   -0x10(%ebp)
f011974f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0119752:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0119755:	76 e6                	jbe    f011973d <scarce_memory+0xa8>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_kspinlock(&MemFrameLists.mfllock);
f0119757:	83 ec 0c             	sub    $0xc,%esp
f011975a:	68 e0 e7 83 f0       	push   $0xf083e7e0
f011975f:	e8 bc 66 ff ff       	call   f010fe20 <release_kspinlock>
f0119764:	83 c4 10             	add    $0x10,%esp

}
f0119767:	90                   	nop
f0119768:	c9                   	leave  
f0119769:	c3                   	ret    

f011976a <calc_no_pages_tobe_removed_from_ready_exit_queues>:

uint32 calc_no_pages_tobe_removed_from_ready_exit_queues(uint32 WS_or_MEMORY_flag)
{
f011976a:	55                   	push   %ebp
f011976b:	89 e5                	mov    %esp,%ebp
f011976d:	83 ec 48             	sub    $0x48,%esp
	uint32 no_of_pages_tobe_removed_from_ready = 0;
f0119770:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 no_of_pages_tobe_removed_from_exit = 0;
f0119777:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 no_of_pages_tobe_removed_from_curenv = 0;
f011977e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc();
f0119785:	e8 8e 22 ff ff       	call   f010ba18 <get_cpu_proc>
f011978a:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f011978d:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0119791:	75 19                	jne    f01197ac <calc_no_pages_tobe_removed_from_ready_exit_queues+0x42>
f0119793:	68 1d 58 13 f0       	push   $0xf013581d
f0119798:	68 67 50 13 f0       	push   $0xf0135067
f011979d:	68 fd 01 00 00       	push   $0x1fd
f01197a2:	68 af 50 13 f0       	push   $0xf01350af
f01197a7:	e8 03 77 fe ff       	call   f0100eaf <_panic>
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
f01197ac:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01197b0:	0f 85 d6 01 00 00    	jne    f011998c <calc_no_pages_tobe_removed_from_ready_exit_queues+0x222>
	{
		acquire_kspinlock(&ProcessQueues.qlock);
f01197b6:	83 ec 0c             	sub    $0xc,%esp
f01197b9:	68 20 e7 83 f0       	push   $0xf083e720
f01197be:	e8 b8 65 ff ff       	call   f010fd7b <acquire_kspinlock>
f01197c3:	83 c4 10             	add    $0x10,%esp
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f01197c6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f01197cd:	e9 d2 00 00 00       	jmp    f01198a4 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x13a>
			{
				struct Env * ptr_ready_env = NULL;
f01197d2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f01197d9:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f01197de:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01197e1:	c1 e2 04             	shl    $0x4,%edx
f01197e4:	01 d0                	add    %edx,%eax
f01197e6:	8b 00                	mov    (%eax),%eax
f01197e8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01197eb:	eb 7c                	jmp    f0119869 <calc_no_pages_tobe_removed_from_ready_exit_queues+0xff>
				{
#if USE_KHEAP
					int num_of_pages_in_WS = LIST_SIZE(&(ptr_ready_env->page_WS_list));
f01197ed:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01197f0:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f01197f6:	89 45 cc             	mov    %eax,-0x34(%ebp)
#else
					int num_of_pages_in_WS = env_page_ws_get_size(ptr_ready_env);
#endif
					int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f01197f9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01197fc:	8b 90 94 05 00 00    	mov    0x594(%eax),%edx
f0119802:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0119805:	0f af c2             	imul   %edx,%eax
f0119808:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011980d:	f7 e2                	mul    %edx
f011980f:	89 d0                	mov    %edx,%eax
f0119811:	c1 e8 05             	shr    $0x5,%eax
f0119814:	89 45 e0             	mov    %eax,-0x20(%ebp)
					if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f0119817:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011981a:	8b 90 94 05 00 00    	mov    0x594(%eax),%edx
f0119820:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0119823:	89 d1                	mov    %edx,%ecx
f0119825:	0f af c8             	imul   %eax,%ecx
f0119828:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011982d:	f7 e1                	mul    %ecx
f011982f:	c1 ea 05             	shr    $0x5,%edx
f0119832:	89 d0                	mov    %edx,%eax
f0119834:	c1 e0 02             	shl    $0x2,%eax
f0119837:	01 d0                	add    %edx,%eax
f0119839:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0119840:	01 d0                	add    %edx,%eax
f0119842:	c1 e0 02             	shl    $0x2,%eax
f0119845:	29 c1                	sub    %eax,%ecx
f0119847:	89 ca                	mov    %ecx,%edx
f0119849:	85 d2                	test   %edx,%edx
f011984b:	74 03                	je     f0119850 <calc_no_pages_tobe_removed_from_ready_exit_queues+0xe6>
						num_of_pages_to_be_removed++;
f011984d:	ff 45 e0             	incl   -0x20(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
f0119850:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0119853:	01 45 f4             	add    %eax,-0xc(%ebp)
		acquire_kspinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
			{
				struct Env * ptr_ready_env = NULL;
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f0119856:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f011985b:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011985e:	c1 e2 04             	shl    $0x4,%edx
f0119861:	01 d0                	add    %edx,%eax
f0119863:	8b 40 08             	mov    0x8(%eax),%eax
f0119866:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0119869:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f011986e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0119871:	c1 e2 04             	shl    $0x4,%edx
f0119874:	01 d0                	add    %edx,%eax
f0119876:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011987a:	74 08                	je     f0119884 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11a>
f011987c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011987f:	8b 52 08             	mov    0x8(%edx),%edx
f0119882:	eb 05                	jmp    f0119889 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11f>
f0119884:	ba 00 00 00 00       	mov    $0x0,%edx
f0119889:	89 50 08             	mov    %edx,0x8(%eax)
f011988c:	8b 40 08             	mov    0x8(%eax),%eax
f011988f:	85 c0                	test   %eax,%eax
f0119891:	0f 85 56 ff ff ff    	jne    f01197ed <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
f0119897:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011989b:	0f 85 4c ff ff ff    	jne    f01197ed <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
	assert(cur_env != NULL);
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
	{
		acquire_kspinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f01198a1:	ff 45 e8             	incl   -0x18(%ebp)
f01198a4:	a0 60 6d 85 f0       	mov    0xf0856d60,%al
f01198a9:	0f b6 c0             	movzbl %al,%eax
f01198ac:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01198af:	0f 8f 1d ff ff ff    	jg     f01197d2 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x68>
						num_of_pages_to_be_removed++;
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
f01198b5:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f01198bc:	a1 a0 e7 83 f0       	mov    0xf083e7a0,%eax
f01198c1:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01198c4:	eb 1a                	jmp    f01198e0 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x176>
			{
#if USE_KHEAP
				int num_of_pages_in_WS = LIST_SIZE(&(ptr_exit_env->page_WS_list));
f01198c6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01198c9:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f01198cf:	89 45 c8             	mov    %eax,-0x38(%ebp)
#else
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
f01198d2:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01198d5:	01 45 f0             	add    %eax,-0x10(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f01198d8:	a1 a8 e7 83 f0       	mov    0xf083e7a8,%eax
f01198dd:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01198e0:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01198e4:	74 08                	je     f01198ee <calc_no_pages_tobe_removed_from_ready_exit_queues+0x184>
f01198e6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01198e9:	8b 40 08             	mov    0x8(%eax),%eax
f01198ec:	eb 05                	jmp    f01198f3 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x189>
f01198ee:	b8 00 00 00 00       	mov    $0x0,%eax
f01198f3:	a3 a8 e7 83 f0       	mov    %eax,0xf083e7a8
f01198f8:	a1 a8 e7 83 f0       	mov    0xf083e7a8,%eax
f01198fd:	85 c0                	test   %eax,%eax
f01198ff:	75 c5                	jne    f01198c6 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
f0119901:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0119905:	75 bf                	jne    f01198c6 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
			}
		}
		release_kspinlock(&ProcessQueues.qlock);
f0119907:	83 ec 0c             	sub    $0xc,%esp
f011990a:	68 20 e7 83 f0       	push   $0xf083e720
f011990f:	e8 0c 65 ff ff       	call   f010fe20 <release_kspinlock>
f0119914:	83 c4 10             	add    $0x10,%esp
		if(cur_env != NULL)
f0119917:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011991b:	0f 84 d4 00 00 00    	je     f01199f5 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		{
#if USE_KHEAP
			int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f0119921:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0119924:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f011992a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
#else
			int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
			int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011992d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0119930:	8b 90 94 05 00 00    	mov    0x594(%eax),%edx
f0119936:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0119939:	0f af c2             	imul   %edx,%eax
f011993c:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f0119941:	f7 e2                	mul    %edx
f0119943:	89 d0                	mov    %edx,%eax
f0119945:	c1 e8 05             	shr    $0x5,%eax
f0119948:	89 45 d8             	mov    %eax,-0x28(%ebp)
			if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011994b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011994e:	8b 90 94 05 00 00    	mov    0x594(%eax),%edx
f0119954:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0119957:	89 d1                	mov    %edx,%ecx
f0119959:	0f af c8             	imul   %eax,%ecx
f011995c:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0119961:	f7 e1                	mul    %ecx
f0119963:	c1 ea 05             	shr    $0x5,%edx
f0119966:	89 d0                	mov    %edx,%eax
f0119968:	c1 e0 02             	shl    $0x2,%eax
f011996b:	01 d0                	add    %edx,%eax
f011996d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0119974:	01 d0                	add    %edx,%eax
f0119976:	c1 e0 02             	shl    $0x2,%eax
f0119979:	29 c1                	sub    %eax,%ecx
f011997b:	89 ca                	mov    %ecx,%edx
f011997d:	85 d2                	test   %edx,%edx
f011997f:	74 03                	je     f0119984 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x21a>
				num_of_pages_to_be_removed++;
f0119981:	ff 45 d8             	incl   -0x28(%ebp)
			no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f0119984:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0119987:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011998a:	eb 69                	jmp    f01199f5 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		}
	}
	else	// THEN RAPID PROCESS SHALL BE FREED ONLY
	{
#if USE_KHEAP
		int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f011998c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011998f:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0119995:	89 45 c0             	mov    %eax,-0x40(%ebp)
#else
		int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
		int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f0119998:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011999b:	8b 90 94 05 00 00    	mov    0x594(%eax),%edx
f01199a1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01199a4:	0f af c2             	imul   %edx,%eax
f01199a7:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f01199ac:	f7 e2                	mul    %edx
f01199ae:	89 d0                	mov    %edx,%eax
f01199b0:	c1 e8 05             	shr    $0x5,%eax
f01199b3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f01199b6:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01199b9:	8b 90 94 05 00 00    	mov    0x594(%eax),%edx
f01199bf:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01199c2:	89 d1                	mov    %edx,%ecx
f01199c4:	0f af c8             	imul   %eax,%ecx
f01199c7:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f01199cc:	f7 e1                	mul    %ecx
f01199ce:	c1 ea 05             	shr    $0x5,%edx
f01199d1:	89 d0                	mov    %edx,%eax
f01199d3:	c1 e0 02             	shl    $0x2,%eax
f01199d6:	01 d0                	add    %edx,%eax
f01199d8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01199df:	01 d0                	add    %edx,%eax
f01199e1:	c1 e0 02             	shl    $0x2,%eax
f01199e4:	29 c1                	sub    %eax,%ecx
f01199e6:	89 ca                	mov    %ecx,%edx
f01199e8:	85 d2                	test   %edx,%edx
f01199ea:	74 03                	je     f01199ef <calc_no_pages_tobe_removed_from_ready_exit_queues+0x285>
			num_of_pages_to_be_removed++;
f01199ec:	ff 45 d4             	incl   -0x2c(%ebp)
		no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f01199ef:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01199f2:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}

	return no_of_pages_tobe_removed_from_curenv + no_of_pages_tobe_removed_from_ready + no_of_pages_tobe_removed_from_exit;
f01199f5:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01199f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01199fb:	01 c2                	add    %eax,%edx
f01199fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0119a00:	01 d0                	add    %edx,%eax
}
f0119a02:	c9                   	leave  
f0119a03:	c3                   	ret    

f0119a04 <schenv>:


void schenv()
{
f0119a04:	55                   	push   %ebp
f0119a05:	89 e5                	mov    %esp,%ebp
f0119a07:	83 ec 18             	sub    $0x18,%esp

	__nl = 0;
f0119a0a:	c6 05 dc 6d 85 f0 00 	movb   $0x0,0xf0856ddc
	__ne = NULL;
f0119a11:	c7 05 f4 6a 85 f0 00 	movl   $0x0,0xf0856af4
f0119a18:	00 00 00 
	acquire_kspinlock(&ProcessQueues.qlock);
f0119a1b:	83 ec 0c             	sub    $0xc,%esp
f0119a1e:	68 20 e7 83 f0       	push   $0xf083e720
f0119a23:	e8 53 63 ff ff       	call   f010fd7b <acquire_kspinlock>
f0119a28:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f0119a2b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119a32:	eb 3f                	jmp    f0119a73 <schenv+0x6f>
		{
			if (queue_size(&(ProcessQueues.env_ready_queues[i])))
f0119a34:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0119a39:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119a3c:	c1 e2 04             	shl    $0x4,%edx
f0119a3f:	01 d0                	add    %edx,%eax
f0119a41:	83 ec 0c             	sub    $0xc,%esp
f0119a44:	50                   	push   %eax
f0119a45:	e8 a9 c4 fe ff       	call   f0105ef3 <queue_size>
f0119a4a:	83 c4 10             	add    $0x10,%esp
f0119a4d:	85 c0                	test   %eax,%eax
f0119a4f:	74 1f                	je     f0119a70 <schenv+0x6c>
			{
				__ne = LIST_LAST(&(ProcessQueues.env_ready_queues[i]));
f0119a51:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0119a56:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119a59:	c1 e2 04             	shl    $0x4,%edx
f0119a5c:	01 d0                	add    %edx,%eax
f0119a5e:	8b 40 04             	mov    0x4(%eax),%eax
f0119a61:	a3 f4 6a 85 f0       	mov    %eax,0xf0856af4
				__nl = i;
f0119a66:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119a69:	a2 dc 6d 85 f0       	mov    %al,0xf0856ddc
				break;
f0119a6e:	eb 10                	jmp    f0119a80 <schenv+0x7c>

	__nl = 0;
	__ne = NULL;
	acquire_kspinlock(&ProcessQueues.qlock);
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f0119a70:	ff 45 f4             	incl   -0xc(%ebp)
f0119a73:	a0 60 6d 85 f0       	mov    0xf0856d60,%al
f0119a78:	0f b6 c0             	movzbl %al,%eax
f0119a7b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119a7e:	7f b4                	jg     f0119a34 <schenv+0x30>
				__nl = i;
				break;
			}
		}
	}
	release_kspinlock(&ProcessQueues.qlock);
f0119a80:	83 ec 0c             	sub    $0xc,%esp
f0119a83:	68 20 e7 83 f0       	push   $0xf083e720
f0119a88:	e8 93 63 ff ff       	call   f010fe20 <release_kspinlock>
f0119a8d:	83 c4 10             	add    $0x10,%esp
	struct Env* cur_env = get_cpu_proc();
f0119a90:	e8 83 1f ff ff       	call   f010ba18 <get_cpu_proc>
f0119a95:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL)
f0119a98:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0119a9c:	0f 84 82 00 00 00    	je     f0119b24 <schenv+0x120>
	{
		if (__ne != NULL)
f0119aa2:	a1 f4 6a 85 f0       	mov    0xf0856af4,%eax
f0119aa7:	85 c0                	test   %eax,%eax
f0119aa9:	74 49                	je     f0119af4 <schenv+0xf0>
		{
			if ((__pl + 1) < __nl)
f0119aab:	a0 01 e7 83 f0       	mov    0xf083e701,%al
f0119ab0:	0f b6 c0             	movzbl %al,%eax
f0119ab3:	8d 50 01             	lea    0x1(%eax),%edx
f0119ab6:	a0 dc 6d 85 f0       	mov    0xf0856ddc,%al
f0119abb:	0f b6 c0             	movzbl %al,%eax
f0119abe:	39 c2                	cmp    %eax,%edx
f0119ac0:	7d 62                	jge    f0119b24 <schenv+0x120>
			{
				__ne = cur_env;
f0119ac2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0119ac5:	a3 f4 6a 85 f0       	mov    %eax,0xf0856af4
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f0119aca:	a0 01 e7 83 f0       	mov    0xf083e701,%al
f0119acf:	0f b6 c0             	movzbl %al,%eax
f0119ad2:	8a 15 60 6d 85 f0    	mov    0xf0856d60,%dl
f0119ad8:	0f b6 d2             	movzbl %dl,%edx
f0119adb:	4a                   	dec    %edx
f0119adc:	39 d0                	cmp    %edx,%eax
f0119ade:	7d 08                	jge    f0119ae8 <schenv+0xe4>
f0119ae0:	a0 01 e7 83 f0       	mov    0xf083e701,%al
f0119ae5:	40                   	inc    %eax
f0119ae6:	eb 05                	jmp    f0119aed <schenv+0xe9>
f0119ae8:	a0 01 e7 83 f0       	mov    0xf083e701,%al
f0119aed:	a2 dc 6d 85 f0       	mov    %al,0xf0856ddc
		{
			__ne = cur_env;
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
		}
	}
}
f0119af2:	eb 30                	jmp    f0119b24 <schenv+0x120>
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
			}
		}
		else
		{
			__ne = cur_env;
f0119af4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0119af7:	a3 f4 6a 85 f0       	mov    %eax,0xf0856af4
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f0119afc:	a0 01 e7 83 f0       	mov    0xf083e701,%al
f0119b01:	0f b6 c0             	movzbl %al,%eax
f0119b04:	8a 15 60 6d 85 f0    	mov    0xf0856d60,%dl
f0119b0a:	0f b6 d2             	movzbl %dl,%edx
f0119b0d:	4a                   	dec    %edx
f0119b0e:	39 d0                	cmp    %edx,%eax
f0119b10:	7d 08                	jge    f0119b1a <schenv+0x116>
f0119b12:	a0 01 e7 83 f0       	mov    0xf083e701,%al
f0119b17:	40                   	inc    %eax
f0119b18:	eb 05                	jmp    f0119b1f <schenv+0x11b>
f0119b1a:	a0 01 e7 83 f0       	mov    0xf083e701,%al
f0119b1f:	a2 dc 6d 85 f0       	mov    %al,0xf0856ddc
		}
	}
}
f0119b24:	90                   	nop
f0119b25:	c9                   	leave  
f0119b26:	c3                   	ret    

f0119b27 <chksch>:

void chksch(uint8 onoff)
{
f0119b27:	55                   	push   %ebp
f0119b28:	89 e5                	mov    %esp,%ebp
f0119b2a:	83 ec 18             	sub    $0x18,%esp
f0119b2d:	8b 45 08             	mov    0x8(%ebp),%eax
f0119b30:	88 45 f4             	mov    %al,-0xc(%ebp)
	//		__pl = 0 ;
	//		__nl = 0 ;
	//	}

	/*TEST BSD*/
	if (isSchedMethodBSD())
f0119b33:	e8 85 db fe ff       	call   f01076bd <isSchedMethodBSD>
f0119b38:	85 c0                	test   %eax,%eax
f0119b3a:	74 48                	je     f0119b84 <chksch+0x5d>
	{
		__histla = __pla = get_load_average();
f0119b3c:	e8 00 db fe ff       	call   f0107641 <get_load_average>
f0119b41:	a3 7c 6d 85 f0       	mov    %eax,0xf0856d7c
f0119b46:	a1 7c 6d 85 f0       	mov    0xf0856d7c,%eax
f0119b4b:	a3 bc e9 83 f0       	mov    %eax,0xf083e9bc
		acquire_kspinlock(&ProcessQueues.qlock);
f0119b50:	83 ec 0c             	sub    $0xc,%esp
f0119b53:	68 20 e7 83 f0       	push   $0xf083e720
f0119b58:	e8 1e 62 ff ff       	call   f010fd7b <acquire_kspinlock>
f0119b5d:	83 c4 10             	add    $0x10,%esp
		{
			__pnexit = LIST_SIZE(&ProcessQueues.env_exit_queue) ;
f0119b60:	a1 ac e7 83 f0       	mov    0xf083e7ac,%eax
f0119b65:	a3 50 e8 83 f0       	mov    %eax,0xf083e850
		}
		release_kspinlock(&ProcessQueues.qlock);
f0119b6a:	83 ec 0c             	sub    $0xc,%esp
f0119b6d:	68 20 e7 83 f0       	push   $0xf083e720
f0119b72:	e8 a9 62 ff ff       	call   f010fe20 <release_kspinlock>
f0119b77:	83 c4 10             	add    $0x10,%esp
		__firsttime = 1;
f0119b7a:	c7 05 04 6b 85 f0 01 	movl   $0x1,0xf0856b04
f0119b81:	00 00 00 
	}
	__chkstatus = onoff;
f0119b84:	8a 45 f4             	mov    -0xc(%ebp),%al
f0119b87:	a2 ec 6a 85 f0       	mov    %al,0xf0856aec
}
f0119b8c:	90                   	nop
f0119b8d:	c9                   	leave  
f0119b8e:	c3                   	ret    

f0119b8f <chk1>:
void chk1()
{
f0119b8f:	55                   	push   %ebp
f0119b90:	89 e5                	mov    %esp,%ebp
	//			__pl = 0;
	//		}
	//		//cprintf("chk1: current = %s @ level %d\n", __pe == NULL? "NULL" : __pe->prog_name, __pl);
	//		schenv();
	//	}
}
f0119b92:	90                   	nop
f0119b93:	5d                   	pop    %ebp
f0119b94:	c3                   	ret    

f0119b95 <chk2>:
void chk2(struct Env* __se)
{
f0119b95:	55                   	push   %ebp
f0119b96:	89 e5                	mov    %esp,%ebp
f0119b98:	83 ec 28             	sub    $0x28,%esp
	if (__chkstatus == 0)
f0119b9b:	a0 ec 6a 85 f0       	mov    0xf0856aec,%al
f0119ba0:	84 c0                	test   %al,%al
f0119ba2:	0f 84 59 03 00 00    	je     f0119f01 <chk2+0x36c>
		return ;

	/*TEST BSD*/
	if (isSchedMethodBSD())
f0119ba8:	e8 10 db fe ff       	call   f01076bd <isSchedMethodBSD>
f0119bad:	85 c0                	test   %eax,%eax
f0119baf:	0f 84 4d 03 00 00    	je     f0119f02 <chk2+0x36d>
	{
		__nla = get_load_average();
f0119bb5:	e8 87 da fe ff       	call   f0107641 <get_load_average>
f0119bba:	a3 f4 e8 83 f0       	mov    %eax,0xf083e8f4
		acquire_kspinlock(&ProcessQueues.qlock);
f0119bbf:	83 ec 0c             	sub    $0xc,%esp
f0119bc2:	68 20 e7 83 f0       	push   $0xf083e720
f0119bc7:	e8 af 61 ff ff       	call   f010fd7b <acquire_kspinlock>
f0119bcc:	83 c4 10             	add    $0x10,%esp
		{
			__nnexit = LIST_SIZE(&ProcessQueues.env_exit_queue);
f0119bcf:	a1 ac e7 83 f0       	mov    0xf083e7ac,%eax
f0119bd4:	a3 f8 6a 85 f0       	mov    %eax,0xf0856af8
		}
		release_kspinlock(&ProcessQueues.qlock);
f0119bd9:	83 ec 0c             	sub    $0xc,%esp
f0119bdc:	68 20 e7 83 f0       	push   $0xf083e720
f0119be1:	e8 3a 62 ff ff       	call   f010fe20 <release_kspinlock>
f0119be6:	83 c4 10             	add    $0x10,%esp

		if (__firsttime)
f0119be9:	a1 04 6b 85 f0       	mov    0xf0856b04,%eax
f0119bee:	85 c0                	test   %eax,%eax
f0119bf0:	74 72                	je     f0119c64 <chk2+0xcf>
		{
			acquire_kspinlock(&ProcessQueues.qlock);
f0119bf2:	83 ec 0c             	sub    $0xc,%esp
f0119bf5:	68 20 e7 83 f0       	push   $0xf083e720
f0119bfa:	e8 7c 61 ff ff       	call   f010fd7b <acquire_kspinlock>
f0119bff:	83 c4 10             	add    $0x10,%esp
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
f0119c02:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0119c06:	0f 95 c0             	setne  %al
f0119c09:	0f b6 c0             	movzbl %al,%eax
f0119c0c:	a3 34 6c 85 f0       	mov    %eax,0xf0856c34
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f0119c11:	a0 60 6d 85 f0       	mov    0xf0856d60,%al
f0119c16:	0f b6 c0             	movzbl %al,%eax
f0119c19:	48                   	dec    %eax
f0119c1a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0119c1d:	eb 20                	jmp    f0119c3f <chk2+0xaa>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f0119c1f:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0119c24:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119c27:	c1 e2 04             	shl    $0x4,%edx
f0119c2a:	01 d0                	add    %edx,%eax
f0119c2c:	8b 40 0c             	mov    0xc(%eax),%eax
f0119c2f:	8b 15 34 6c 85 f0    	mov    0xf0856c34,%edx
f0119c35:	01 d0                	add    %edx,%eax
f0119c37:	a3 34 6c 85 f0       	mov    %eax,0xf0856c34
		{
			acquire_kspinlock(&ProcessQueues.qlock);
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f0119c3c:	ff 4d f4             	decl   -0xc(%ebp)
f0119c3f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0119c43:	79 da                	jns    f0119c1f <chk2+0x8a>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
				}
				__firsttime = 0;
f0119c45:	c7 05 04 6b 85 f0 00 	movl   $0x0,0xf0856b04
f0119c4c:	00 00 00 
			}
			release_kspinlock(&ProcessQueues.qlock);
f0119c4f:	83 ec 0c             	sub    $0xc,%esp
f0119c52:	68 20 e7 83 f0       	push   $0xf083e720
f0119c57:	e8 c4 61 ff ff       	call   f010fe20 <release_kspinlock>
f0119c5c:	83 c4 10             	add    $0x10,%esp
f0119c5f:	e9 91 02 00 00       	jmp    f0119ef5 <chk2+0x360>
		}
		else
		{
			if (__pnexit != __nnexit)
f0119c64:	8b 15 50 e8 83 f0    	mov    0xf083e850,%edx
f0119c6a:	a1 f8 6a 85 f0       	mov    0xf0856af8,%eax
f0119c6f:	39 c2                	cmp    %eax,%edx
f0119c71:	74 63                	je     f0119cd6 <chk2+0x141>
			{
				acquire_kspinlock(&ProcessQueues.qlock);
f0119c73:	83 ec 0c             	sub    $0xc,%esp
f0119c76:	68 20 e7 83 f0       	push   $0xf083e720
f0119c7b:	e8 fb 60 ff ff       	call   f010fd7b <acquire_kspinlock>
f0119c80:	83 c4 10             	add    $0x10,%esp
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
f0119c83:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0119c87:	0f 95 c0             	setne  %al
f0119c8a:	0f b6 c0             	movzbl %al,%eax
f0119c8d:	a3 34 6c 85 f0       	mov    %eax,0xf0856c34
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f0119c92:	a0 60 6d 85 f0       	mov    0xf0856d60,%al
f0119c97:	0f b6 c0             	movzbl %al,%eax
f0119c9a:	48                   	dec    %eax
f0119c9b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0119c9e:	eb 20                	jmp    f0119cc0 <chk2+0x12b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f0119ca0:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0119ca5:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0119ca8:	c1 e2 04             	shl    $0x4,%edx
f0119cab:	01 d0                	add    %edx,%eax
f0119cad:	8b 40 0c             	mov    0xc(%eax),%eax
f0119cb0:	8b 15 34 6c 85 f0    	mov    0xf0856c34,%edx
f0119cb6:	01 d0                	add    %edx,%eax
f0119cb8:	a3 34 6c 85 f0       	mov    %eax,0xf0856c34
			{
				acquire_kspinlock(&ProcessQueues.qlock);
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f0119cbd:	ff 4d f0             	decl   -0x10(%ebp)
f0119cc0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0119cc4:	79 da                	jns    f0119ca0 <chk2+0x10b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
					}
				}
				release_kspinlock(&ProcessQueues.qlock);
f0119cc6:	83 ec 0c             	sub    $0xc,%esp
f0119cc9:	68 20 e7 83 f0       	push   $0xf083e720
f0119cce:	e8 4d 61 ff ff       	call   f010fe20 <release_kspinlock>
f0119cd3:	83 c4 10             	add    $0x10,%esp
			}

			//Make sure that the la is changed over long period of time
			if (timer_ticks() % 1000 == 0)
f0119cd6:	e8 ff d8 fe ff       	call   f01075da <timer_ticks>
f0119cdb:	6a 00                	push   $0x0
f0119cdd:	68 e8 03 00 00       	push   $0x3e8
f0119ce2:	52                   	push   %edx
f0119ce3:	50                   	push   %eax
f0119ce4:	e8 33 1a 00 00       	call   f011b71c <__moddi3>
f0119ce9:	83 c4 10             	add    $0x10,%esp
f0119cec:	09 d0                	or     %edx,%eax
f0119cee:	85 c0                	test   %eax,%eax
f0119cf0:	75 32                	jne    f0119d24 <chk2+0x18f>
			{
				assert_endall(__histla != __nla) ;
f0119cf2:	8b 15 bc e9 83 f0    	mov    0xf083e9bc,%edx
f0119cf8:	a1 f4 e8 83 f0       	mov    0xf083e8f4,%eax
f0119cfd:	39 c2                	cmp    %eax,%edx
f0119cff:	75 19                	jne    f0119d1a <chk2+0x185>
f0119d01:	68 2d 58 13 f0       	push   $0xf013582d
f0119d06:	68 67 50 13 f0       	push   $0xf0135067
f0119d0b:	68 b9 02 00 00       	push   $0x2b9
f0119d10:	68 af 50 13 f0       	push   $0xf01350af
f0119d15:	e8 24 72 fe ff       	call   f0100f3e <_panic_all>
				__histla = __nla;
f0119d1a:	a1 f4 e8 83 f0       	mov    0xf083e8f4,%eax
f0119d1f:	a3 bc e9 83 f0       	mov    %eax,0xf083e9bc
			}

			//check every 1 sec, assuming quantum >= 10
			if (timer_ticks() % 100 == 0)
f0119d24:	e8 b1 d8 fe ff       	call   f01075da <timer_ticks>
f0119d29:	6a 00                	push   $0x0
f0119d2b:	6a 64                	push   $0x64
f0119d2d:	52                   	push   %edx
f0119d2e:	50                   	push   %eax
f0119d2f:	e8 e8 19 00 00       	call   f011b71c <__moddi3>
f0119d34:	83 c4 10             	add    $0x10,%esp
f0119d37:	09 d0                	or     %edx,%eax
f0119d39:	85 c0                	test   %eax,%eax
f0119d3b:	0f 85 b4 01 00 00    	jne    f0119ef5 <chk2+0x360>
			{
				int plaint = __pla / 100 ;
f0119d41:	8b 0d 7c 6d 85 f0    	mov    0xf0856d7c,%ecx
f0119d47:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0119d4c:	f7 e9                	imul   %ecx
f0119d4e:	c1 fa 05             	sar    $0x5,%edx
f0119d51:	89 c8                	mov    %ecx,%eax
f0119d53:	c1 f8 1f             	sar    $0x1f,%eax
f0119d56:	29 c2                	sub    %eax,%edx
f0119d58:	89 d0                	mov    %edx,%eax
f0119d5a:	89 45 ec             	mov    %eax,-0x14(%ebp)
				int plafrc = __pla % 100 ;
f0119d5d:	8b 0d 7c 6d 85 f0    	mov    0xf0856d7c,%ecx
f0119d63:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0119d68:	f7 e9                	imul   %ecx
f0119d6a:	c1 fa 05             	sar    $0x5,%edx
f0119d6d:	89 c8                	mov    %ecx,%eax
f0119d6f:	c1 f8 1f             	sar    $0x1f,%eax
f0119d72:	29 c2                	sub    %eax,%edx
f0119d74:	89 d0                	mov    %edx,%eax
f0119d76:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0119d79:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0119d7c:	89 d0                	mov    %edx,%eax
f0119d7e:	c1 e0 02             	shl    $0x2,%eax
f0119d81:	01 d0                	add    %edx,%eax
f0119d83:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0119d8a:	01 d0                	add    %edx,%eax
f0119d8c:	c1 e0 02             	shl    $0x2,%eax
f0119d8f:	29 c1                	sub    %eax,%ecx
f0119d91:	89 c8                	mov    %ecx,%eax
f0119d93:	89 45 e8             	mov    %eax,-0x18(%ebp)

				int nlaint = __nla / 100 ;
f0119d96:	8b 0d f4 e8 83 f0    	mov    0xf083e8f4,%ecx
f0119d9c:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0119da1:	f7 e9                	imul   %ecx
f0119da3:	c1 fa 05             	sar    $0x5,%edx
f0119da6:	89 c8                	mov    %ecx,%eax
f0119da8:	c1 f8 1f             	sar    $0x1f,%eax
f0119dab:	29 c2                	sub    %eax,%edx
f0119dad:	89 d0                	mov    %edx,%eax
f0119daf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				int nlafrc = __nla % 100 ;
f0119db2:	8b 0d f4 e8 83 f0    	mov    0xf083e8f4,%ecx
f0119db8:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0119dbd:	f7 e9                	imul   %ecx
f0119dbf:	c1 fa 05             	sar    $0x5,%edx
f0119dc2:	89 c8                	mov    %ecx,%eax
f0119dc4:	c1 f8 1f             	sar    $0x1f,%eax
f0119dc7:	29 c2                	sub    %eax,%edx
f0119dc9:	89 d0                	mov    %edx,%eax
f0119dcb:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0119dce:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0119dd1:	89 d0                	mov    %edx,%eax
f0119dd3:	c1 e0 02             	shl    $0x2,%eax
f0119dd6:	01 d0                	add    %edx,%eax
f0119dd8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0119ddf:	01 d0                	add    %edx,%eax
f0119de1:	c1 e0 02             	shl    $0x2,%eax
f0119de4:	29 c1                	sub    %eax,%ecx
f0119de6:	89 c8                	mov    %ecx,%eax
f0119de8:	89 45 e0             	mov    %eax,-0x20(%ebp)

				//Check at steady state of nproc (include equality)
				if (__nnexit == __pnexit)
f0119deb:	8b 15 f8 6a 85 f0    	mov    0xf0856af8,%edx
f0119df1:	a1 50 e8 83 f0       	mov    0xf083e850,%eax
f0119df6:	39 c2                	cmp    %eax,%edx
f0119df8:	0f 85 ed 00 00 00    	jne    f0119eeb <chk2+0x356>
				{
					//cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
					if (__nproc > plaint)
f0119dfe:	a1 34 6c 85 f0       	mov    0xf0856c34,%eax
f0119e03:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0119e06:	7e 5b                	jle    f0119e63 <chk2+0x2ce>
					{
						cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f0119e08:	a1 34 6c 85 f0       	mov    0xf0856c34,%eax
f0119e0d:	83 ec 08             	sub    $0x8,%esp
f0119e10:	ff 75 e0             	pushl  -0x20(%ebp)
f0119e13:	ff 75 e4             	pushl  -0x1c(%ebp)
f0119e16:	ff 75 e8             	pushl  -0x18(%ebp)
f0119e19:	ff 75 ec             	pushl  -0x14(%ebp)
f0119e1c:	50                   	push   %eax
f0119e1d:	68 40 58 13 f0       	push   $0xf0135840
f0119e22:	e8 35 7d fe ff       	call   f0101b5c <cprintf>
f0119e27:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla > __pla);
						assert_endall((nlaint > plaint) || ((nlaint == plaint) && (nlafrc >= plafrc)));
f0119e2a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119e2d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0119e30:	0f 8f b5 00 00 00    	jg     f0119eeb <chk2+0x356>
f0119e36:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119e39:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0119e3c:	75 0c                	jne    f0119e4a <chk2+0x2b5>
f0119e3e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0119e41:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119e44:	0f 8d a1 00 00 00    	jge    f0119eeb <chk2+0x356>
f0119e4a:	68 88 58 13 f0       	push   $0xf0135888
f0119e4f:	68 67 50 13 f0       	push   $0xf0135067
f0119e54:	68 ce 02 00 00       	push   $0x2ce
f0119e59:	68 af 50 13 f0       	push   $0xf01350af
f0119e5e:	e8 db 70 fe ff       	call   f0100f3e <_panic_all>
					}
					else if (__nproc < plaint)
f0119e63:	a1 34 6c 85 f0       	mov    0xf0856c34,%eax
f0119e68:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0119e6b:	7d 53                	jge    f0119ec0 <chk2+0x32b>
					{
						cprintf("------------------# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f0119e6d:	a1 34 6c 85 f0       	mov    0xf0856c34,%eax
f0119e72:	83 ec 08             	sub    $0x8,%esp
f0119e75:	ff 75 e0             	pushl  -0x20(%ebp)
f0119e78:	ff 75 e4             	pushl  -0x1c(%ebp)
f0119e7b:	ff 75 e8             	pushl  -0x18(%ebp)
f0119e7e:	ff 75 ec             	pushl  -0x14(%ebp)
f0119e81:	50                   	push   %eax
f0119e82:	68 c8 58 13 f0       	push   $0xf01358c8
f0119e87:	e8 d0 7c fe ff       	call   f0101b5c <cprintf>
f0119e8c:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla < __pla);
						assert_endall((nlaint < plaint) || ((nlaint == plaint) && (nlafrc <= plafrc)));
f0119e8f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119e92:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0119e95:	7c 54                	jl     f0119eeb <chk2+0x356>
f0119e97:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119e9a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0119e9d:	75 08                	jne    f0119ea7 <chk2+0x312>
f0119e9f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0119ea2:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119ea5:	7e 44                	jle    f0119eeb <chk2+0x356>
f0119ea7:	68 10 59 13 f0       	push   $0xf0135910
f0119eac:	68 67 50 13 f0       	push   $0xf0135067
f0119eb1:	68 d4 02 00 00       	push   $0x2d4
f0119eb6:	68 af 50 13 f0       	push   $0xf01350af
f0119ebb:	e8 7e 70 fe ff       	call   f0100f3e <_panic_all>
					}
					else if (__nproc == plaint)
f0119ec0:	a1 34 6c 85 f0       	mov    0xf0856c34,%eax
f0119ec5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0119ec8:	75 21                	jne    f0119eeb <chk2+0x356>
					{
						assert_endall((nlaint == plaint));
f0119eca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119ecd:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0119ed0:	74 19                	je     f0119eeb <chk2+0x356>
f0119ed2:	68 50 59 13 f0       	push   $0xf0135950
f0119ed7:	68 67 50 13 f0       	push   $0xf0135067
f0119edc:	68 d8 02 00 00       	push   $0x2d8
f0119ee1:	68 af 50 13 f0       	push   $0xf01350af
f0119ee6:	e8 53 70 fe ff       	call   f0100f3e <_panic_all>
					}
				}
				__pla = __nla;
f0119eeb:	a1 f4 e8 83 f0       	mov    0xf083e8f4,%eax
f0119ef0:	a3 7c 6d 85 f0       	mov    %eax,0xf0856d7c
			}
		}
		__pnexit = __nnexit;
f0119ef5:	a1 f8 6a 85 f0       	mov    0xf0856af8,%eax
f0119efa:	a3 50 e8 83 f0       	mov    %eax,0xf083e850
f0119eff:	eb 01                	jmp    f0119f02 <chk2+0x36d>
	//	}
}
void chk2(struct Env* __se)
{
	if (__chkstatus == 0)
		return ;
f0119f01:	90                   	nop
	//				if (i == __tl) continue;
	//				assert_endall(find_env_in_queue(&(env_ready_queues[i]), __pe->env_id) == NULL) ;
	//			}
	//		}
	//	}
}
f0119f02:	c9                   	leave  
f0119f03:	c3                   	ret    

f0119f04 <check_boot_pgdir>:
// but it is a pretty good check.
//
uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va);

void check_boot_pgdir()
{
f0119f04:	55                   	push   %ebp
f0119f05:	89 e5                	mov    %esp,%ebp
f0119f07:	83 ec 18             	sub    $0x18,%esp

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f0119f0a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119f11:	eb 40                	jmp    f0119f53 <check_boot_pgdir+0x4f>
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
f0119f13:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119f16:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f0119f1c:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0119f21:	83 ec 08             	sub    $0x8,%esp
f0119f24:	52                   	push   %edx
f0119f25:	50                   	push   %eax
f0119f26:	e8 af 01 00 00       	call   f011a0da <check_va2pa>
f0119f2b:	83 c4 10             	add    $0x10,%esp
f0119f2e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119f31:	74 19                	je     f0119f4c <check_boot_pgdir+0x48>
f0119f33:	68 64 59 13 f0       	push   $0xf0135964
f0119f38:	68 67 50 13 f0       	push   $0xf0135067
f0119f3d:	68 1f 03 00 00       	push   $0x31f
f0119f42:	68 af 50 13 f0       	push   $0xf01350af
f0119f47:	e8 63 6f fe ff       	call   f0100eaf <_panic>

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f0119f4c:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0119f53:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119f56:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f0119f5c:	a1 d0 6c 85 f0       	mov    0xf0856cd0,%eax
f0119f61:	39 c2                	cmp    %eax,%edx
f0119f63:	72 ae                	jb     f0119f13 <check_boot_pgdir+0xf>
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f0119f65:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119f6c:	e9 81 00 00 00       	jmp    f0119ff2 <check_boot_pgdir+0xee>
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
f0119f71:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119f74:	25 ff 7f 00 00       	and    $0x7fff,%eax
f0119f79:	85 c0                	test   %eax,%eax
f0119f7b:	74 6d                	je     f0119fea <check_boot_pgdir+0xe6>
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
f0119f7d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119f80:	8d 90 00 80 bf ef    	lea    -0x10408000(%eax),%edx
f0119f86:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0119f8b:	83 ec 08             	sub    $0x8,%esp
f0119f8e:	52                   	push   %edx
f0119f8f:	50                   	push   %eax
f0119f90:	e8 45 01 00 00       	call   f011a0da <check_va2pa>
f0119f95:	83 c4 10             	add    $0x10,%esp
f0119f98:	c7 45 f0 00 70 17 f0 	movl   $0xf0177000,-0x10(%ebp)
f0119f9f:	81 7d f0 ff ff ff ef 	cmpl   $0xefffffff,-0x10(%ebp)
f0119fa6:	77 17                	ja     f0119fbf <check_boot_pgdir+0xbb>
f0119fa8:	ff 75 f0             	pushl  -0x10(%ebp)
f0119fab:	68 9c 59 13 f0       	push   $0xf013599c
f0119fb0:	68 2d 03 00 00       	push   $0x32d
f0119fb5:	68 af 50 13 f0       	push   $0xf01350af
f0119fba:	e8 f0 6e fe ff       	call   f0100eaf <_panic>
f0119fbf:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0119fc2:	8d 8a 00 00 00 10    	lea    0x10000000(%edx),%ecx
f0119fc8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119fcb:	01 ca                	add    %ecx,%edx
f0119fcd:	39 d0                	cmp    %edx,%eax
f0119fcf:	74 1a                	je     f0119feb <check_boot_pgdir+0xe7>
f0119fd1:	68 d0 59 13 f0       	push   $0xf01359d0
f0119fd6:	68 67 50 13 f0       	push   $0xf0135067
f0119fdb:	68 2d 03 00 00       	push   $0x32d
f0119fe0:	68 af 50 13 f0       	push   $0xf01350af
f0119fe5:	e8 c5 6e fe ff       	call   f0100eaf <_panic>
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
f0119fea:	90                   	nop
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f0119feb:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0119ff2:	81 7d f4 ff 7f 00 00 	cmpl   $0x7fff,-0xc(%ebp)
f0119ff9:	0f 86 72 ff ff ff    	jbe    f0119f71 <check_boot_pgdir+0x6d>
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f0119fff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a006:	e9 af 00 00 00       	jmp    f011a0ba <check_boot_pgdir+0x1b6>
		switch (i) {
f011a00b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a00e:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011a013:	74 11                	je     f011a026 <check_boot_pgdir+0x122>
f011a015:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011a01a:	72 36                	jb     f011a052 <check_boot_pgdir+0x14e>
f011a01c:	2d bd 03 00 00       	sub    $0x3bd,%eax
f011a021:	83 f8 02             	cmp    $0x2,%eax
f011a024:	77 2c                	ja     f011a052 <check_boot_pgdir+0x14e>
		case PDX(UVPT):
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
f011a026:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f011a02b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a02e:	c1 e2 02             	shl    $0x2,%edx
f011a031:	01 d0                	add    %edx,%eax
f011a033:	8b 00                	mov    (%eax),%eax
f011a035:	85 c0                	test   %eax,%eax
f011a037:	75 7a                	jne    f011a0b3 <check_boot_pgdir+0x1af>
f011a039:	68 56 5a 13 f0       	push   $0xf0135a56
f011a03e:	68 67 50 13 f0       	push   $0xf0135067
f011a043:	68 38 03 00 00       	push   $0x338
f011a048:	68 af 50 13 f0       	push   $0xf01350af
f011a04d:	e8 5d 6e fe ff       	call   f0100eaf <_panic>
		break;
		default:
			if (i >= PDX(KERNEL_BASE))
f011a052:	81 7d f4 bf 03 00 00 	cmpl   $0x3bf,-0xc(%ebp)
f011a059:	76 2c                	jbe    f011a087 <check_boot_pgdir+0x183>
				assert(ptr_page_directory[i]);
f011a05b:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f011a060:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a063:	c1 e2 02             	shl    $0x2,%edx
f011a066:	01 d0                	add    %edx,%eax
f011a068:	8b 00                	mov    (%eax),%eax
f011a06a:	85 c0                	test   %eax,%eax
f011a06c:	75 48                	jne    f011a0b6 <check_boot_pgdir+0x1b2>
f011a06e:	68 56 5a 13 f0       	push   $0xf0135a56
f011a073:	68 67 50 13 f0       	push   $0xf0135067
f011a078:	68 3c 03 00 00       	push   $0x33c
f011a07d:	68 af 50 13 f0       	push   $0xf01350af
f011a082:	e8 28 6e fe ff       	call   f0100eaf <_panic>
			else
				assert(ptr_page_directory[i] == 0);
f011a087:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f011a08c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a08f:	c1 e2 02             	shl    $0x2,%edx
f011a092:	01 d0                	add    %edx,%eax
f011a094:	8b 00                	mov    (%eax),%eax
f011a096:	85 c0                	test   %eax,%eax
f011a098:	74 1c                	je     f011a0b6 <check_boot_pgdir+0x1b2>
f011a09a:	68 6c 5a 13 f0       	push   $0xf0135a6c
f011a09f:	68 67 50 13 f0       	push   $0xf0135067
f011a0a4:	68 3e 03 00 00       	push   $0x33e
f011a0a9:	68 af 50 13 f0       	push   $0xf01350af
f011a0ae:	e8 fc 6d fe ff       	call   f0100eaf <_panic>
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
		break;
f011a0b3:	90                   	nop
f011a0b4:	eb 01                	jmp    f011a0b7 <check_boot_pgdir+0x1b3>
		default:
			if (i >= PDX(KERNEL_BASE))
				assert(ptr_page_directory[i]);
			else
				assert(ptr_page_directory[i] == 0);
			break;
f011a0b6:	90                   	nop
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011a0b7:	ff 45 f4             	incl   -0xc(%ebp)
f011a0ba:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f011a0c1:	0f 86 44 ff ff ff    	jbe    f011a00b <check_boot_pgdir+0x107>
			else
				assert(ptr_page_directory[i] == 0);
			break;
		}
	}
	cprintf("*	check_boot_pgdir() succeeded!\n");
f011a0c7:	83 ec 0c             	sub    $0xc,%esp
f011a0ca:	68 88 5a 13 f0       	push   $0xf0135a88
f011a0cf:	e8 88 7a fe ff       	call   f0101b5c <cprintf>
f011a0d4:	83 c4 10             	add    $0x10,%esp
}
f011a0d7:	90                   	nop
f011a0d8:	c9                   	leave  
f011a0d9:	c3                   	ret    

f011a0da <check_va2pa>:
// defined by the page directory 'ptr_page_directory'.  The hardware normally performs
// this functionality for us!  We define our own version to help check
// the check_boot_pgdir() function; it shouldn't be used elsewhere.

uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va)
{
f011a0da:	55                   	push   %ebp
f011a0db:	89 e5                	mov    %esp,%ebp
f011a0dd:	83 ec 18             	sub    $0x18,%esp
	uint32 *p;

	uint32* dirEntry = &(ptr_page_directory[PDX(va)]);
f011a0e0:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a0e3:	c1 e8 16             	shr    $0x16,%eax
f011a0e6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011a0ed:	8b 45 08             	mov    0x8(%ebp),%eax
f011a0f0:	01 d0                	add    %edx,%eax
f011a0f2:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_VARS("dir table entry %x", *dirEntry);

	if (!(*dirEntry & PERM_PRESENT))
f011a0f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a0f8:	8b 00                	mov    (%eax),%eax
f011a0fa:	83 e0 01             	and    $0x1,%eax
f011a0fd:	85 c0                	test   %eax,%eax
f011a0ff:	75 0a                	jne    f011a10b <check_va2pa+0x31>
		return ~0;
f011a101:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011a106:	e9 87 00 00 00       	jmp    f011a192 <check_va2pa+0xb8>
	p = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(*dirEntry));
f011a10b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a10e:	8b 00                	mov    (%eax),%eax
f011a110:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011a115:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011a118:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011a11b:	c1 e8 0c             	shr    $0xc,%eax
f011a11e:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011a121:	a1 b8 e9 83 f0       	mov    0xf083e9b8,%eax
f011a126:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f011a129:	72 17                	jb     f011a142 <check_va2pa+0x68>
f011a12b:	ff 75 f0             	pushl  -0x10(%ebp)
f011a12e:	68 ac 5a 13 f0       	push   $0xf0135aac
f011a133:	68 54 03 00 00       	push   $0x354
f011a138:	68 af 50 13 f0       	push   $0xf01350af
f011a13d:	e8 6d 6d fe ff       	call   f0100eaf <_panic>
f011a142:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011a145:	2d 00 00 00 10       	sub    $0x10000000,%eax
f011a14a:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//LOG_VARS("ptr to page table  = %x", p);

	if (!(p[PTX(va)] & PERM_PRESENT))
f011a14d:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a150:	c1 e8 0c             	shr    $0xc,%eax
f011a153:	25 ff 03 00 00       	and    $0x3ff,%eax
f011a158:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011a15f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011a162:	01 d0                	add    %edx,%eax
f011a164:	8b 00                	mov    (%eax),%eax
f011a166:	83 e0 01             	and    $0x1,%eax
f011a169:	85 c0                	test   %eax,%eax
f011a16b:	75 07                	jne    f011a174 <check_va2pa+0x9a>
		return ~0;
f011a16d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011a172:	eb 1e                	jmp    f011a192 <check_va2pa+0xb8>

	//LOG_VARS("page phys addres = %x",EXTRACT_ADDRESS(p[PTX(va)]));
	return EXTRACT_ADDRESS(p[PTX(va)]);
f011a174:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a177:	c1 e8 0c             	shr    $0xc,%eax
f011a17a:	25 ff 03 00 00       	and    $0x3ff,%eax
f011a17f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011a186:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011a189:	01 d0                	add    %edx,%eax
f011a18b:	8b 00                	mov    (%eax),%eax
f011a18d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
f011a192:	c9                   	leave  
f011a193:	c3                   	ret    

f011a194 <clone_kern_dir>:
}
 */

//

uint32* clone_kern_dir() {
f011a194:	55                   	push   %ebp
f011a195:	89 e5                	mov    %esp,%ebp
f011a197:	83 ec 28             	sub    $0x28,%esp
	struct FrameInfo* ptr_fi;
	allocate_frame(&ptr_fi);
f011a19a:	83 ec 0c             	sub    $0xc,%esp
f011a19d:	8d 45 dc             	lea    -0x24(%ebp),%eax
f011a1a0:	50                   	push   %eax
f011a1a1:	e8 9c ee fe ff       	call   f0109042 <allocate_frame>
f011a1a6:	83 c4 10             	add    $0x10,%esp
	uint32 dir_pa = to_physical_address(ptr_fi);
f011a1a9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011a1ac:	83 ec 0c             	sub    $0xc,%esp
f011a1af:	50                   	push   %eax
f011a1b0:	e8 6b e7 ff ff       	call   f0118920 <to_physical_address>
f011a1b5:	83 c4 10             	add    $0x10,%esp
f011a1b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32* dir_ptr = STATIC_KERNEL_VIRTUAL_ADDRESS(dir_pa);
f011a1bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011a1be:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011a1c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011a1c4:	c1 e8 0c             	shr    $0xc,%eax
f011a1c7:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011a1ca:	a1 b8 e9 83 f0       	mov    0xf083e9b8,%eax
f011a1cf:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f011a1d2:	72 17                	jb     f011a1eb <clone_kern_dir+0x57>
f011a1d4:	ff 75 ec             	pushl  -0x14(%ebp)
f011a1d7:	68 ac 5a 13 f0       	push   $0xf0135aac
f011a1dc:	68 d4 03 00 00       	push   $0x3d4
f011a1e1:	68 af 50 13 f0       	push   $0xf01350af
f011a1e6:	e8 c4 6c fe ff       	call   f0100eaf <_panic>
f011a1eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011a1ee:	2d 00 00 00 10       	sub    $0x10000000,%eax
f011a1f3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for (int i = 0; i < 1024; ++i) {
f011a1f6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a1fd:	eb 23                	jmp    f011a222 <clone_kern_dir+0x8e>
		dir_ptr[i] = ptr_page_directory[i];
f011a1ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a202:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011a209:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011a20c:	01 c2                	add    %eax,%edx
f011a20e:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f011a213:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a216:	c1 e1 02             	shl    $0x2,%ecx
f011a219:	01 c8                	add    %ecx,%eax
f011a21b:	8b 00                	mov    (%eax),%eax
f011a21d:	89 02                	mov    %eax,(%edx)
uint32* clone_kern_dir() {
	struct FrameInfo* ptr_fi;
	allocate_frame(&ptr_fi);
	uint32 dir_pa = to_physical_address(ptr_fi);
	uint32* dir_ptr = STATIC_KERNEL_VIRTUAL_ADDRESS(dir_pa);
	for (int i = 0; i < 1024; ++i) {
f011a21f:	ff 45 f4             	incl   -0xc(%ebp)
f011a222:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f011a229:	7e d4                	jle    f011a1ff <clone_kern_dir+0x6b>
f011a22b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011a22e:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f011a231:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011a234:	0f 22 d8             	mov    %eax,%cr3
		dir_ptr[i] = ptr_page_directory[i];
	}
	lcr3(dir_pa);
	return dir_ptr;
f011a237:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f011a23a:	c9                   	leave  
f011a23b:	c3                   	ret    

f011a23c <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
f011a23c:	55                   	push   %ebp
f011a23d:	89 e5                	mov    %esp,%ebp
f011a23f:	53                   	push   %ebx
f011a240:	83 ec 14             	sub    $0x14,%esp
f011a243:	8b 45 10             	mov    0x10(%ebp),%eax
f011a246:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011a249:	8b 45 14             	mov    0x14(%ebp),%eax
f011a24c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
f011a24f:	8b 45 18             	mov    0x18(%ebp),%eax
f011a252:	ba 00 00 00 00       	mov    $0x0,%edx
f011a257:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011a25a:	77 55                	ja     f011a2b1 <printnum+0x75>
f011a25c:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011a25f:	72 05                	jb     f011a266 <printnum+0x2a>
f011a261:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011a264:	77 4b                	ja     f011a2b1 <printnum+0x75>
		printnum(putch, putdat, num / base, base, width - 1, padc);
f011a266:	8b 45 1c             	mov    0x1c(%ebp),%eax
f011a269:	8d 58 ff             	lea    -0x1(%eax),%ebx
f011a26c:	8b 45 18             	mov    0x18(%ebp),%eax
f011a26f:	ba 00 00 00 00       	mov    $0x0,%edx
f011a274:	52                   	push   %edx
f011a275:	50                   	push   %eax
f011a276:	ff 75 f4             	pushl  -0xc(%ebp)
f011a279:	ff 75 f0             	pushl  -0x10(%ebp)
f011a27c:	e8 33 16 00 00       	call   f011b8b4 <__udivdi3>
f011a281:	83 c4 10             	add    $0x10,%esp
f011a284:	83 ec 04             	sub    $0x4,%esp
f011a287:	ff 75 20             	pushl  0x20(%ebp)
f011a28a:	53                   	push   %ebx
f011a28b:	ff 75 18             	pushl  0x18(%ebp)
f011a28e:	52                   	push   %edx
f011a28f:	50                   	push   %eax
f011a290:	ff 75 0c             	pushl  0xc(%ebp)
f011a293:	ff 75 08             	pushl  0x8(%ebp)
f011a296:	e8 a1 ff ff ff       	call   f011a23c <printnum>
f011a29b:	83 c4 20             	add    $0x20,%esp
f011a29e:	eb 1a                	jmp    f011a2ba <printnum+0x7e>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
f011a2a0:	83 ec 08             	sub    $0x8,%esp
f011a2a3:	ff 75 0c             	pushl  0xc(%ebp)
f011a2a6:	ff 75 20             	pushl  0x20(%ebp)
f011a2a9:	8b 45 08             	mov    0x8(%ebp),%eax
f011a2ac:	ff d0                	call   *%eax
f011a2ae:	83 c4 10             	add    $0x10,%esp
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
f011a2b1:	ff 4d 1c             	decl   0x1c(%ebp)
f011a2b4:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
f011a2b8:	7f e6                	jg     f011a2a0 <printnum+0x64>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
f011a2ba:	8b 4d 18             	mov    0x18(%ebp),%ecx
f011a2bd:	bb 00 00 00 00       	mov    $0x0,%ebx
f011a2c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011a2c5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a2c8:	53                   	push   %ebx
f011a2c9:	51                   	push   %ecx
f011a2ca:	52                   	push   %edx
f011a2cb:	50                   	push   %eax
f011a2cc:	e8 f3 16 00 00       	call   f011b9c4 <__umoddi3>
f011a2d1:	83 c4 10             	add    $0x10,%esp
f011a2d4:	05 f4 5c 13 f0       	add    $0xf0135cf4,%eax
f011a2d9:	8a 00                	mov    (%eax),%al
f011a2db:	0f be c0             	movsbl %al,%eax
f011a2de:	83 ec 08             	sub    $0x8,%esp
f011a2e1:	ff 75 0c             	pushl  0xc(%ebp)
f011a2e4:	50                   	push   %eax
f011a2e5:	8b 45 08             	mov    0x8(%ebp),%eax
f011a2e8:	ff d0                	call   *%eax
f011a2ea:	83 c4 10             	add    $0x10,%esp
}
f011a2ed:	90                   	nop
f011a2ee:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f011a2f1:	c9                   	leave  
f011a2f2:	c3                   	ret    

f011a2f3 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
f011a2f3:	55                   	push   %ebp
f011a2f4:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011a2f6:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011a2fa:	7e 1c                	jle    f011a318 <getuint+0x25>
		return va_arg(*ap, unsigned long long);
f011a2fc:	8b 45 08             	mov    0x8(%ebp),%eax
f011a2ff:	8b 00                	mov    (%eax),%eax
f011a301:	8d 50 08             	lea    0x8(%eax),%edx
f011a304:	8b 45 08             	mov    0x8(%ebp),%eax
f011a307:	89 10                	mov    %edx,(%eax)
f011a309:	8b 45 08             	mov    0x8(%ebp),%eax
f011a30c:	8b 00                	mov    (%eax),%eax
f011a30e:	83 e8 08             	sub    $0x8,%eax
f011a311:	8b 50 04             	mov    0x4(%eax),%edx
f011a314:	8b 00                	mov    (%eax),%eax
f011a316:	eb 40                	jmp    f011a358 <getuint+0x65>
	else if (lflag)
f011a318:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011a31c:	74 1e                	je     f011a33c <getuint+0x49>
		return va_arg(*ap, unsigned long);
f011a31e:	8b 45 08             	mov    0x8(%ebp),%eax
f011a321:	8b 00                	mov    (%eax),%eax
f011a323:	8d 50 04             	lea    0x4(%eax),%edx
f011a326:	8b 45 08             	mov    0x8(%ebp),%eax
f011a329:	89 10                	mov    %edx,(%eax)
f011a32b:	8b 45 08             	mov    0x8(%ebp),%eax
f011a32e:	8b 00                	mov    (%eax),%eax
f011a330:	83 e8 04             	sub    $0x4,%eax
f011a333:	8b 00                	mov    (%eax),%eax
f011a335:	ba 00 00 00 00       	mov    $0x0,%edx
f011a33a:	eb 1c                	jmp    f011a358 <getuint+0x65>
	else
		return va_arg(*ap, unsigned int);
f011a33c:	8b 45 08             	mov    0x8(%ebp),%eax
f011a33f:	8b 00                	mov    (%eax),%eax
f011a341:	8d 50 04             	lea    0x4(%eax),%edx
f011a344:	8b 45 08             	mov    0x8(%ebp),%eax
f011a347:	89 10                	mov    %edx,(%eax)
f011a349:	8b 45 08             	mov    0x8(%ebp),%eax
f011a34c:	8b 00                	mov    (%eax),%eax
f011a34e:	83 e8 04             	sub    $0x4,%eax
f011a351:	8b 00                	mov    (%eax),%eax
f011a353:	ba 00 00 00 00       	mov    $0x0,%edx
}
f011a358:	5d                   	pop    %ebp
f011a359:	c3                   	ret    

f011a35a <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
f011a35a:	55                   	push   %ebp
f011a35b:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011a35d:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011a361:	7e 1c                	jle    f011a37f <getint+0x25>
		return va_arg(*ap, long long);
f011a363:	8b 45 08             	mov    0x8(%ebp),%eax
f011a366:	8b 00                	mov    (%eax),%eax
f011a368:	8d 50 08             	lea    0x8(%eax),%edx
f011a36b:	8b 45 08             	mov    0x8(%ebp),%eax
f011a36e:	89 10                	mov    %edx,(%eax)
f011a370:	8b 45 08             	mov    0x8(%ebp),%eax
f011a373:	8b 00                	mov    (%eax),%eax
f011a375:	83 e8 08             	sub    $0x8,%eax
f011a378:	8b 50 04             	mov    0x4(%eax),%edx
f011a37b:	8b 00                	mov    (%eax),%eax
f011a37d:	eb 38                	jmp    f011a3b7 <getint+0x5d>
	else if (lflag)
f011a37f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011a383:	74 1a                	je     f011a39f <getint+0x45>
		return va_arg(*ap, long);
f011a385:	8b 45 08             	mov    0x8(%ebp),%eax
f011a388:	8b 00                	mov    (%eax),%eax
f011a38a:	8d 50 04             	lea    0x4(%eax),%edx
f011a38d:	8b 45 08             	mov    0x8(%ebp),%eax
f011a390:	89 10                	mov    %edx,(%eax)
f011a392:	8b 45 08             	mov    0x8(%ebp),%eax
f011a395:	8b 00                	mov    (%eax),%eax
f011a397:	83 e8 04             	sub    $0x4,%eax
f011a39a:	8b 00                	mov    (%eax),%eax
f011a39c:	99                   	cltd   
f011a39d:	eb 18                	jmp    f011a3b7 <getint+0x5d>
	else
		return va_arg(*ap, int);
f011a39f:	8b 45 08             	mov    0x8(%ebp),%eax
f011a3a2:	8b 00                	mov    (%eax),%eax
f011a3a4:	8d 50 04             	lea    0x4(%eax),%edx
f011a3a7:	8b 45 08             	mov    0x8(%ebp),%eax
f011a3aa:	89 10                	mov    %edx,(%eax)
f011a3ac:	8b 45 08             	mov    0x8(%ebp),%eax
f011a3af:	8b 00                	mov    (%eax),%eax
f011a3b1:	83 e8 04             	sub    $0x4,%eax
f011a3b4:	8b 00                	mov    (%eax),%eax
f011a3b6:	99                   	cltd   
}
f011a3b7:	5d                   	pop    %ebp
f011a3b8:	c3                   	ret    

f011a3b9 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
f011a3b9:	55                   	push   %ebp
f011a3ba:	89 e5                	mov    %esp,%ebp
f011a3bc:	56                   	push   %esi
f011a3bd:	53                   	push   %ebx
f011a3be:	83 ec 20             	sub    $0x20,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011a3c1:	eb 17                	jmp    f011a3da <vprintfmt+0x21>
			if (ch == '\0')
f011a3c3:	85 db                	test   %ebx,%ebx
f011a3c5:	0f 84 c1 03 00 00    	je     f011a78c <vprintfmt+0x3d3>
				return;
			putch(ch, putdat);
f011a3cb:	83 ec 08             	sub    $0x8,%esp
f011a3ce:	ff 75 0c             	pushl  0xc(%ebp)
f011a3d1:	53                   	push   %ebx
f011a3d2:	8b 45 08             	mov    0x8(%ebp),%eax
f011a3d5:	ff d0                	call   *%eax
f011a3d7:	83 c4 10             	add    $0x10,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011a3da:	8b 45 10             	mov    0x10(%ebp),%eax
f011a3dd:	8d 50 01             	lea    0x1(%eax),%edx
f011a3e0:	89 55 10             	mov    %edx,0x10(%ebp)
f011a3e3:	8a 00                	mov    (%eax),%al
f011a3e5:	0f b6 d8             	movzbl %al,%ebx
f011a3e8:	83 fb 25             	cmp    $0x25,%ebx
f011a3eb:	75 d6                	jne    f011a3c3 <vprintfmt+0xa>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
f011a3ed:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
		width = -1;
f011a3f1:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
		precision = -1;
f011a3f8:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
f011a3ff:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		altflag = 0;
f011a406:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
f011a40d:	8b 45 10             	mov    0x10(%ebp),%eax
f011a410:	8d 50 01             	lea    0x1(%eax),%edx
f011a413:	89 55 10             	mov    %edx,0x10(%ebp)
f011a416:	8a 00                	mov    (%eax),%al
f011a418:	0f b6 d8             	movzbl %al,%ebx
f011a41b:	8d 43 dd             	lea    -0x23(%ebx),%eax
f011a41e:	83 f8 5b             	cmp    $0x5b,%eax
f011a421:	0f 87 3d 03 00 00    	ja     f011a764 <vprintfmt+0x3ab>
f011a427:	8b 04 85 18 5d 13 f0 	mov    -0xfeca2e8(,%eax,4),%eax
f011a42e:	ff e0                	jmp    *%eax

		// flag to pad on the right
		case '-':
			padc = '-';
f011a430:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
			goto reswitch;
f011a434:	eb d7                	jmp    f011a40d <vprintfmt+0x54>

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
f011a436:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
			goto reswitch;
f011a43a:	eb d1                	jmp    f011a40d <vprintfmt+0x54>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011a43c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				precision = precision * 10 + ch - '0';
f011a443:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011a446:	89 d0                	mov    %edx,%eax
f011a448:	c1 e0 02             	shl    $0x2,%eax
f011a44b:	01 d0                	add    %edx,%eax
f011a44d:	01 c0                	add    %eax,%eax
f011a44f:	01 d8                	add    %ebx,%eax
f011a451:	83 e8 30             	sub    $0x30,%eax
f011a454:	89 45 e0             	mov    %eax,-0x20(%ebp)
				ch = *fmt;
f011a457:	8b 45 10             	mov    0x10(%ebp),%eax
f011a45a:	8a 00                	mov    (%eax),%al
f011a45c:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
f011a45f:	83 fb 2f             	cmp    $0x2f,%ebx
f011a462:	7e 3e                	jle    f011a4a2 <vprintfmt+0xe9>
f011a464:	83 fb 39             	cmp    $0x39,%ebx
f011a467:	7f 39                	jg     f011a4a2 <vprintfmt+0xe9>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011a469:	ff 45 10             	incl   0x10(%ebp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
f011a46c:	eb d5                	jmp    f011a443 <vprintfmt+0x8a>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
f011a46e:	8b 45 14             	mov    0x14(%ebp),%eax
f011a471:	83 c0 04             	add    $0x4,%eax
f011a474:	89 45 14             	mov    %eax,0x14(%ebp)
f011a477:	8b 45 14             	mov    0x14(%ebp),%eax
f011a47a:	83 e8 04             	sub    $0x4,%eax
f011a47d:	8b 00                	mov    (%eax),%eax
f011a47f:	89 45 e0             	mov    %eax,-0x20(%ebp)
			goto process_precision;
f011a482:	eb 1f                	jmp    f011a4a3 <vprintfmt+0xea>

		case '.':
			if (width < 0)
f011a484:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011a488:	79 83                	jns    f011a40d <vprintfmt+0x54>
				width = 0;
f011a48a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
			goto reswitch;
f011a491:	e9 77 ff ff ff       	jmp    f011a40d <vprintfmt+0x54>

		case '#':
			altflag = 1;
f011a496:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
			goto reswitch;
f011a49d:	e9 6b ff ff ff       	jmp    f011a40d <vprintfmt+0x54>
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
			goto process_precision;
f011a4a2:	90                   	nop
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
f011a4a3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011a4a7:	0f 89 60 ff ff ff    	jns    f011a40d <vprintfmt+0x54>
				width = precision, precision = -1;
f011a4ad:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011a4b0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011a4b3:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
			goto reswitch;
f011a4ba:	e9 4e ff ff ff       	jmp    f011a40d <vprintfmt+0x54>

		// long flag (doubled for long long)
		case 'l':
			lflag++;
f011a4bf:	ff 45 e8             	incl   -0x18(%ebp)
			goto reswitch;
f011a4c2:	e9 46 ff ff ff       	jmp    f011a40d <vprintfmt+0x54>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
f011a4c7:	8b 45 14             	mov    0x14(%ebp),%eax
f011a4ca:	83 c0 04             	add    $0x4,%eax
f011a4cd:	89 45 14             	mov    %eax,0x14(%ebp)
f011a4d0:	8b 45 14             	mov    0x14(%ebp),%eax
f011a4d3:	83 e8 04             	sub    $0x4,%eax
f011a4d6:	8b 00                	mov    (%eax),%eax
f011a4d8:	83 ec 08             	sub    $0x8,%esp
f011a4db:	ff 75 0c             	pushl  0xc(%ebp)
f011a4de:	50                   	push   %eax
f011a4df:	8b 45 08             	mov    0x8(%ebp),%eax
f011a4e2:	ff d0                	call   *%eax
f011a4e4:	83 c4 10             	add    $0x10,%esp
			break;
f011a4e7:	e9 9b 02 00 00       	jmp    f011a787 <vprintfmt+0x3ce>

		// error message
		case 'e':
			err = va_arg(ap, int);
f011a4ec:	8b 45 14             	mov    0x14(%ebp),%eax
f011a4ef:	83 c0 04             	add    $0x4,%eax
f011a4f2:	89 45 14             	mov    %eax,0x14(%ebp)
f011a4f5:	8b 45 14             	mov    0x14(%ebp),%eax
f011a4f8:	83 e8 04             	sub    $0x4,%eax
f011a4fb:	8b 18                	mov    (%eax),%ebx
			if (err < 0)
f011a4fd:	85 db                	test   %ebx,%ebx
f011a4ff:	79 02                	jns    f011a503 <vprintfmt+0x14a>
				err = -err;
f011a501:	f7 db                	neg    %ebx
			if (err > MAXERROR || (p = error_string[err]) == NULL)
f011a503:	83 fb 64             	cmp    $0x64,%ebx
f011a506:	7f 0b                	jg     f011a513 <vprintfmt+0x15a>
f011a508:	8b 34 9d 60 5b 13 f0 	mov    -0xfeca4a0(,%ebx,4),%esi
f011a50f:	85 f6                	test   %esi,%esi
f011a511:	75 19                	jne    f011a52c <vprintfmt+0x173>
				printfmt(putch, putdat, "error %d", err);
f011a513:	53                   	push   %ebx
f011a514:	68 05 5d 13 f0       	push   $0xf0135d05
f011a519:	ff 75 0c             	pushl  0xc(%ebp)
f011a51c:	ff 75 08             	pushl  0x8(%ebp)
f011a51f:	e8 70 02 00 00       	call   f011a794 <printfmt>
f011a524:	83 c4 10             	add    $0x10,%esp
			else
				printfmt(putch, putdat, "%s", p);
			break;
f011a527:	e9 5b 02 00 00       	jmp    f011a787 <vprintfmt+0x3ce>
			if (err < 0)
				err = -err;
			if (err > MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
f011a52c:	56                   	push   %esi
f011a52d:	68 0e 5d 13 f0       	push   $0xf0135d0e
f011a532:	ff 75 0c             	pushl  0xc(%ebp)
f011a535:	ff 75 08             	pushl  0x8(%ebp)
f011a538:	e8 57 02 00 00       	call   f011a794 <printfmt>
f011a53d:	83 c4 10             	add    $0x10,%esp
			break;
f011a540:	e9 42 02 00 00       	jmp    f011a787 <vprintfmt+0x3ce>

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
f011a545:	8b 45 14             	mov    0x14(%ebp),%eax
f011a548:	83 c0 04             	add    $0x4,%eax
f011a54b:	89 45 14             	mov    %eax,0x14(%ebp)
f011a54e:	8b 45 14             	mov    0x14(%ebp),%eax
f011a551:	83 e8 04             	sub    $0x4,%eax
f011a554:	8b 30                	mov    (%eax),%esi
f011a556:	85 f6                	test   %esi,%esi
f011a558:	75 05                	jne    f011a55f <vprintfmt+0x1a6>
				p = "(null)";
f011a55a:	be 11 5d 13 f0       	mov    $0xf0135d11,%esi
			if (width > 0 && padc != '-')
f011a55f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011a563:	7e 6d                	jle    f011a5d2 <vprintfmt+0x219>
f011a565:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
f011a569:	74 67                	je     f011a5d2 <vprintfmt+0x219>
				for (width -= strnlen(p, precision); width > 0; width--)
f011a56b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011a56e:	83 ec 08             	sub    $0x8,%esp
f011a571:	50                   	push   %eax
f011a572:	56                   	push   %esi
f011a573:	e8 26 05 00 00       	call   f011aa9e <strnlen>
f011a578:	83 c4 10             	add    $0x10,%esp
f011a57b:	29 45 e4             	sub    %eax,-0x1c(%ebp)
f011a57e:	eb 16                	jmp    f011a596 <vprintfmt+0x1dd>
					putch(padc, putdat);
f011a580:	0f be 45 db          	movsbl -0x25(%ebp),%eax
f011a584:	83 ec 08             	sub    $0x8,%esp
f011a587:	ff 75 0c             	pushl  0xc(%ebp)
f011a58a:	50                   	push   %eax
f011a58b:	8b 45 08             	mov    0x8(%ebp),%eax
f011a58e:	ff d0                	call   *%eax
f011a590:	83 c4 10             	add    $0x10,%esp
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
f011a593:	ff 4d e4             	decl   -0x1c(%ebp)
f011a596:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011a59a:	7f e4                	jg     f011a580 <vprintfmt+0x1c7>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f011a59c:	eb 34                	jmp    f011a5d2 <vprintfmt+0x219>
				if (altflag && (ch < ' ' || ch > '~'))
f011a59e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011a5a2:	74 1c                	je     f011a5c0 <vprintfmt+0x207>
f011a5a4:	83 fb 1f             	cmp    $0x1f,%ebx
f011a5a7:	7e 05                	jle    f011a5ae <vprintfmt+0x1f5>
f011a5a9:	83 fb 7e             	cmp    $0x7e,%ebx
f011a5ac:	7e 12                	jle    f011a5c0 <vprintfmt+0x207>
					putch('?', putdat);
f011a5ae:	83 ec 08             	sub    $0x8,%esp
f011a5b1:	ff 75 0c             	pushl  0xc(%ebp)
f011a5b4:	6a 3f                	push   $0x3f
f011a5b6:	8b 45 08             	mov    0x8(%ebp),%eax
f011a5b9:	ff d0                	call   *%eax
f011a5bb:	83 c4 10             	add    $0x10,%esp
f011a5be:	eb 0f                	jmp    f011a5cf <vprintfmt+0x216>
				else
					putch(ch, putdat);
f011a5c0:	83 ec 08             	sub    $0x8,%esp
f011a5c3:	ff 75 0c             	pushl  0xc(%ebp)
f011a5c6:	53                   	push   %ebx
f011a5c7:	8b 45 08             	mov    0x8(%ebp),%eax
f011a5ca:	ff d0                	call   *%eax
f011a5cc:	83 c4 10             	add    $0x10,%esp
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f011a5cf:	ff 4d e4             	decl   -0x1c(%ebp)
f011a5d2:	89 f0                	mov    %esi,%eax
f011a5d4:	8d 70 01             	lea    0x1(%eax),%esi
f011a5d7:	8a 00                	mov    (%eax),%al
f011a5d9:	0f be d8             	movsbl %al,%ebx
f011a5dc:	85 db                	test   %ebx,%ebx
f011a5de:	74 24                	je     f011a604 <vprintfmt+0x24b>
f011a5e0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011a5e4:	78 b8                	js     f011a59e <vprintfmt+0x1e5>
f011a5e6:	ff 4d e0             	decl   -0x20(%ebp)
f011a5e9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011a5ed:	79 af                	jns    f011a59e <vprintfmt+0x1e5>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f011a5ef:	eb 13                	jmp    f011a604 <vprintfmt+0x24b>
				putch(' ', putdat);
f011a5f1:	83 ec 08             	sub    $0x8,%esp
f011a5f4:	ff 75 0c             	pushl  0xc(%ebp)
f011a5f7:	6a 20                	push   $0x20
f011a5f9:	8b 45 08             	mov    0x8(%ebp),%eax
f011a5fc:	ff d0                	call   *%eax
f011a5fe:	83 c4 10             	add    $0x10,%esp
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f011a601:	ff 4d e4             	decl   -0x1c(%ebp)
f011a604:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011a608:	7f e7                	jg     f011a5f1 <vprintfmt+0x238>
				putch(' ', putdat);
			break;
f011a60a:	e9 78 01 00 00       	jmp    f011a787 <vprintfmt+0x3ce>

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
f011a60f:	83 ec 08             	sub    $0x8,%esp
f011a612:	ff 75 e8             	pushl  -0x18(%ebp)
f011a615:	8d 45 14             	lea    0x14(%ebp),%eax
f011a618:	50                   	push   %eax
f011a619:	e8 3c fd ff ff       	call   f011a35a <getint>
f011a61e:	83 c4 10             	add    $0x10,%esp
f011a621:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011a624:	89 55 f4             	mov    %edx,-0xc(%ebp)
			if ((long long) num < 0) {
f011a627:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011a62a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a62d:	85 d2                	test   %edx,%edx
f011a62f:	79 23                	jns    f011a654 <vprintfmt+0x29b>
				putch('-', putdat);
f011a631:	83 ec 08             	sub    $0x8,%esp
f011a634:	ff 75 0c             	pushl  0xc(%ebp)
f011a637:	6a 2d                	push   $0x2d
f011a639:	8b 45 08             	mov    0x8(%ebp),%eax
f011a63c:	ff d0                	call   *%eax
f011a63e:	83 c4 10             	add    $0x10,%esp
				num = -(long long) num;
f011a641:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011a644:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a647:	f7 d8                	neg    %eax
f011a649:	83 d2 00             	adc    $0x0,%edx
f011a64c:	f7 da                	neg    %edx
f011a64e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011a651:	89 55 f4             	mov    %edx,-0xc(%ebp)
			}
			base = 10;
f011a654:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f011a65b:	e9 bc 00 00 00       	jmp    f011a71c <vprintfmt+0x363>

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
f011a660:	83 ec 08             	sub    $0x8,%esp
f011a663:	ff 75 e8             	pushl  -0x18(%ebp)
f011a666:	8d 45 14             	lea    0x14(%ebp),%eax
f011a669:	50                   	push   %eax
f011a66a:	e8 84 fc ff ff       	call   f011a2f3 <getuint>
f011a66f:	83 c4 10             	add    $0x10,%esp
f011a672:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011a675:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 10;
f011a678:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f011a67f:	e9 98 00 00 00       	jmp    f011a71c <vprintfmt+0x363>

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
f011a684:	83 ec 08             	sub    $0x8,%esp
f011a687:	ff 75 0c             	pushl  0xc(%ebp)
f011a68a:	6a 58                	push   $0x58
f011a68c:	8b 45 08             	mov    0x8(%ebp),%eax
f011a68f:	ff d0                	call   *%eax
f011a691:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f011a694:	83 ec 08             	sub    $0x8,%esp
f011a697:	ff 75 0c             	pushl  0xc(%ebp)
f011a69a:	6a 58                	push   $0x58
f011a69c:	8b 45 08             	mov    0x8(%ebp),%eax
f011a69f:	ff d0                	call   *%eax
f011a6a1:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f011a6a4:	83 ec 08             	sub    $0x8,%esp
f011a6a7:	ff 75 0c             	pushl  0xc(%ebp)
f011a6aa:	6a 58                	push   $0x58
f011a6ac:	8b 45 08             	mov    0x8(%ebp),%eax
f011a6af:	ff d0                	call   *%eax
f011a6b1:	83 c4 10             	add    $0x10,%esp
			break;
f011a6b4:	e9 ce 00 00 00       	jmp    f011a787 <vprintfmt+0x3ce>

		// pointer
		case 'p':
			putch('0', putdat);
f011a6b9:	83 ec 08             	sub    $0x8,%esp
f011a6bc:	ff 75 0c             	pushl  0xc(%ebp)
f011a6bf:	6a 30                	push   $0x30
f011a6c1:	8b 45 08             	mov    0x8(%ebp),%eax
f011a6c4:	ff d0                	call   *%eax
f011a6c6:	83 c4 10             	add    $0x10,%esp
			putch('x', putdat);
f011a6c9:	83 ec 08             	sub    $0x8,%esp
f011a6cc:	ff 75 0c             	pushl  0xc(%ebp)
f011a6cf:	6a 78                	push   $0x78
f011a6d1:	8b 45 08             	mov    0x8(%ebp),%eax
f011a6d4:	ff d0                	call   *%eax
f011a6d6:	83 c4 10             	add    $0x10,%esp
			num = (unsigned long long)
				(uint32) va_arg(ap, void *);
f011a6d9:	8b 45 14             	mov    0x14(%ebp),%eax
f011a6dc:	83 c0 04             	add    $0x4,%eax
f011a6df:	89 45 14             	mov    %eax,0x14(%ebp)
f011a6e2:	8b 45 14             	mov    0x14(%ebp),%eax
f011a6e5:	83 e8 04             	sub    $0x4,%eax
f011a6e8:	8b 00                	mov    (%eax),%eax

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
f011a6ea:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011a6ed:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				(uint32) va_arg(ap, void *);
			base = 16;
f011a6f4:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
			goto number;
f011a6fb:	eb 1f                	jmp    f011a71c <vprintfmt+0x363>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
f011a6fd:	83 ec 08             	sub    $0x8,%esp
f011a700:	ff 75 e8             	pushl  -0x18(%ebp)
f011a703:	8d 45 14             	lea    0x14(%ebp),%eax
f011a706:	50                   	push   %eax
f011a707:	e8 e7 fb ff ff       	call   f011a2f3 <getuint>
f011a70c:	83 c4 10             	add    $0x10,%esp
f011a70f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011a712:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 16;
f011a715:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
		number:
			printnum(putch, putdat, num, base, width, padc);
f011a71c:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f011a720:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011a723:	83 ec 04             	sub    $0x4,%esp
f011a726:	52                   	push   %edx
f011a727:	ff 75 e4             	pushl  -0x1c(%ebp)
f011a72a:	50                   	push   %eax
f011a72b:	ff 75 f4             	pushl  -0xc(%ebp)
f011a72e:	ff 75 f0             	pushl  -0x10(%ebp)
f011a731:	ff 75 0c             	pushl  0xc(%ebp)
f011a734:	ff 75 08             	pushl  0x8(%ebp)
f011a737:	e8 00 fb ff ff       	call   f011a23c <printnum>
f011a73c:	83 c4 20             	add    $0x20,%esp
			break;
f011a73f:	eb 46                	jmp    f011a787 <vprintfmt+0x3ce>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
f011a741:	83 ec 08             	sub    $0x8,%esp
f011a744:	ff 75 0c             	pushl  0xc(%ebp)
f011a747:	53                   	push   %ebx
f011a748:	8b 45 08             	mov    0x8(%ebp),%eax
f011a74b:	ff d0                	call   *%eax
f011a74d:	83 c4 10             	add    $0x10,%esp
			break;
f011a750:	eb 35                	jmp    f011a787 <vprintfmt+0x3ce>

		/**********************************/
		/*2023*/
		// DON'T Print Program Name & UD
		case '~':
			printProgName = 0;
f011a752:	c6 05 00 e7 83 f0 00 	movb   $0x0,0xf083e700
			break;
f011a759:	eb 2c                	jmp    f011a787 <vprintfmt+0x3ce>
		// Print Program Name & UD
		case '@':
			printProgName = 1;
f011a75b:	c6 05 00 e7 83 f0 01 	movb   $0x1,0xf083e700
			break;
f011a762:	eb 23                	jmp    f011a787 <vprintfmt+0x3ce>
		/**********************************/

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
f011a764:	83 ec 08             	sub    $0x8,%esp
f011a767:	ff 75 0c             	pushl  0xc(%ebp)
f011a76a:	6a 25                	push   $0x25
f011a76c:	8b 45 08             	mov    0x8(%ebp),%eax
f011a76f:	ff d0                	call   *%eax
f011a771:	83 c4 10             	add    $0x10,%esp
			for (fmt--; fmt[-1] != '%'; fmt--)
f011a774:	ff 4d 10             	decl   0x10(%ebp)
f011a777:	eb 03                	jmp    f011a77c <vprintfmt+0x3c3>
f011a779:	ff 4d 10             	decl   0x10(%ebp)
f011a77c:	8b 45 10             	mov    0x10(%ebp),%eax
f011a77f:	48                   	dec    %eax
f011a780:	8a 00                	mov    (%eax),%al
f011a782:	3c 25                	cmp    $0x25,%al
f011a784:	75 f3                	jne    f011a779 <vprintfmt+0x3c0>
				/* do nothing */;
			break;
f011a786:	90                   	nop
		}
	}
f011a787:	e9 35 fc ff ff       	jmp    f011a3c1 <vprintfmt+0x8>
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
				return;
f011a78c:	90                   	nop
			for (fmt--; fmt[-1] != '%'; fmt--)
				/* do nothing */;
			break;
		}
	}
}
f011a78d:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011a790:	5b                   	pop    %ebx
f011a791:	5e                   	pop    %esi
f011a792:	5d                   	pop    %ebp
f011a793:	c3                   	ret    

f011a794 <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
f011a794:	55                   	push   %ebp
f011a795:	89 e5                	mov    %esp,%ebp
f011a797:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f011a79a:	8d 45 10             	lea    0x10(%ebp),%eax
f011a79d:	83 c0 04             	add    $0x4,%eax
f011a7a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vprintfmt(putch, putdat, fmt, ap);
f011a7a3:	8b 45 10             	mov    0x10(%ebp),%eax
f011a7a6:	ff 75 f4             	pushl  -0xc(%ebp)
f011a7a9:	50                   	push   %eax
f011a7aa:	ff 75 0c             	pushl  0xc(%ebp)
f011a7ad:	ff 75 08             	pushl  0x8(%ebp)
f011a7b0:	e8 04 fc ff ff       	call   f011a3b9 <vprintfmt>
f011a7b5:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f011a7b8:	90                   	nop
f011a7b9:	c9                   	leave  
f011a7ba:	c3                   	ret    

f011a7bb <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
f011a7bb:	55                   	push   %ebp
f011a7bc:	89 e5                	mov    %esp,%ebp
	b->cnt++;
f011a7be:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a7c1:	8b 40 08             	mov    0x8(%eax),%eax
f011a7c4:	8d 50 01             	lea    0x1(%eax),%edx
f011a7c7:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a7ca:	89 50 08             	mov    %edx,0x8(%eax)
	if (b->buf < b->ebuf)
f011a7cd:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a7d0:	8b 10                	mov    (%eax),%edx
f011a7d2:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a7d5:	8b 40 04             	mov    0x4(%eax),%eax
f011a7d8:	39 c2                	cmp    %eax,%edx
f011a7da:	73 12                	jae    f011a7ee <sprintputch+0x33>
		*b->buf++ = ch;
f011a7dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a7df:	8b 00                	mov    (%eax),%eax
f011a7e1:	8d 48 01             	lea    0x1(%eax),%ecx
f011a7e4:	8b 55 0c             	mov    0xc(%ebp),%edx
f011a7e7:	89 0a                	mov    %ecx,(%edx)
f011a7e9:	8b 55 08             	mov    0x8(%ebp),%edx
f011a7ec:	88 10                	mov    %dl,(%eax)
}
f011a7ee:	90                   	nop
f011a7ef:	5d                   	pop    %ebp
f011a7f0:	c3                   	ret    

f011a7f1 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
f011a7f1:	55                   	push   %ebp
f011a7f2:	89 e5                	mov    %esp,%ebp
f011a7f4:	83 ec 18             	sub    $0x18,%esp
	struct sprintbuf b = {buf, buf+n-1, 0};
f011a7f7:	8b 45 08             	mov    0x8(%ebp),%eax
f011a7fa:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011a7fd:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a800:	8d 50 ff             	lea    -0x1(%eax),%edx
f011a803:	8b 45 08             	mov    0x8(%ebp),%eax
f011a806:	01 d0                	add    %edx,%eax
f011a808:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011a80b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
f011a812:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011a816:	74 06                	je     f011a81e <vsnprintf+0x2d>
f011a818:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011a81c:	7f 07                	jg     f011a825 <vsnprintf+0x34>
		return -E_INVAL;
f011a81e:	b8 03 00 00 00       	mov    $0x3,%eax
f011a823:	eb 20                	jmp    f011a845 <vsnprintf+0x54>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
f011a825:	ff 75 14             	pushl  0x14(%ebp)
f011a828:	ff 75 10             	pushl  0x10(%ebp)
f011a82b:	8d 45 ec             	lea    -0x14(%ebp),%eax
f011a82e:	50                   	push   %eax
f011a82f:	68 bb a7 11 f0       	push   $0xf011a7bb
f011a834:	e8 80 fb ff ff       	call   f011a3b9 <vprintfmt>
f011a839:	83 c4 10             	add    $0x10,%esp

	// null terminate the buffer
	*b.buf = '\0';
f011a83c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011a83f:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
f011a842:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011a845:	c9                   	leave  
f011a846:	c3                   	ret    

f011a847 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
f011a847:	55                   	push   %ebp
f011a848:	89 e5                	mov    %esp,%ebp
f011a84a:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
f011a84d:	8d 45 10             	lea    0x10(%ebp),%eax
f011a850:	83 c0 04             	add    $0x4,%eax
f011a853:	89 45 f4             	mov    %eax,-0xc(%ebp)
	rc = vsnprintf(buf, n, fmt, ap);
f011a856:	8b 45 10             	mov    0x10(%ebp),%eax
f011a859:	ff 75 f4             	pushl  -0xc(%ebp)
f011a85c:	50                   	push   %eax
f011a85d:	ff 75 0c             	pushl  0xc(%ebp)
f011a860:	ff 75 08             	pushl  0x8(%ebp)
f011a863:	e8 89 ff ff ff       	call   f011a7f1 <vsnprintf>
f011a868:	83 c4 10             	add    $0x10,%esp
f011a86b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	va_end(ap);

	return rc;
f011a86e:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f011a871:	c9                   	leave  
f011a872:	c3                   	ret    

f011a873 <readline>:
#include <inc/lib.h>

//static char buf[BUFLEN];

void readline(const char *prompt, char* buf)
{
f011a873:	55                   	push   %ebp
f011a874:	89 e5                	mov    %esp,%ebp
f011a876:	83 ec 18             	sub    $0x18,%esp
	int i, c, echoing;

	if (prompt != NULL)
f011a879:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011a87d:	74 13                	je     f011a892 <readline+0x1f>
		cprintf("%s", prompt);
f011a87f:	83 ec 08             	sub    $0x8,%esp
f011a882:	ff 75 08             	pushl  0x8(%ebp)
f011a885:	68 88 5e 13 f0       	push   $0xf0135e88
f011a88a:	e8 cd 72 fe ff       	call   f0101b5c <cprintf>
f011a88f:	83 c4 10             	add    $0x10,%esp

	i = 0;
f011a892:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	echoing = iscons(0);
f011a899:	83 ec 0c             	sub    $0xc,%esp
f011a89c:	6a 00                	push   $0x0
f011a89e:	e8 83 71 fe ff       	call   f0101a26 <iscons>
f011a8a3:	83 c4 10             	add    $0x10,%esp
f011a8a6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (1) {
		c = getchar();
f011a8a9:	e8 5f 71 fe ff       	call   f0101a0d <getchar>
f011a8ae:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (c < 0) {
f011a8b1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a8b5:	79 22                	jns    f011a8d9 <readline+0x66>
			if (c != -E_EOF)
f011a8b7:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011a8bb:	0f 84 ad 00 00 00    	je     f011a96e <readline+0xfb>
				cprintf("read error: %e\n", c);
f011a8c1:	83 ec 08             	sub    $0x8,%esp
f011a8c4:	ff 75 ec             	pushl  -0x14(%ebp)
f011a8c7:	68 8b 5e 13 f0       	push   $0xf0135e8b
f011a8cc:	e8 8b 72 fe ff       	call   f0101b5c <cprintf>
f011a8d1:	83 c4 10             	add    $0x10,%esp
			break;
f011a8d4:	e9 95 00 00 00       	jmp    f011a96e <readline+0xfb>
		} else if (c >= ' ' && i < BUFLEN-1) {
f011a8d9:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f011a8dd:	7e 34                	jle    f011a913 <readline+0xa0>
f011a8df:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f011a8e6:	7f 2b                	jg     f011a913 <readline+0xa0>
			if (echoing)
f011a8e8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011a8ec:	74 0e                	je     f011a8fc <readline+0x89>
				cputchar(c);
f011a8ee:	83 ec 0c             	sub    $0xc,%esp
f011a8f1:	ff 75 ec             	pushl  -0x14(%ebp)
f011a8f4:	e8 fd 70 fe ff       	call   f01019f6 <cputchar>
f011a8f9:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f011a8fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a8ff:	8d 50 01             	lea    0x1(%eax),%edx
f011a902:	89 55 f4             	mov    %edx,-0xc(%ebp)
f011a905:	89 c2                	mov    %eax,%edx
f011a907:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a90a:	01 d0                	add    %edx,%eax
f011a90c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011a90f:	88 10                	mov    %dl,(%eax)
f011a911:	eb 56                	jmp    f011a969 <readline+0xf6>
		} else if (c == '\b' && i > 0) {
f011a913:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011a917:	75 1f                	jne    f011a938 <readline+0xc5>
f011a919:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011a91d:	7e 19                	jle    f011a938 <readline+0xc5>
			if (echoing)
f011a91f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011a923:	74 0e                	je     f011a933 <readline+0xc0>
				cputchar(c);
f011a925:	83 ec 0c             	sub    $0xc,%esp
f011a928:	ff 75 ec             	pushl  -0x14(%ebp)
f011a92b:	e8 c6 70 fe ff       	call   f01019f6 <cputchar>
f011a930:	83 c4 10             	add    $0x10,%esp

			i--;
f011a933:	ff 4d f4             	decl   -0xc(%ebp)
f011a936:	eb 31                	jmp    f011a969 <readline+0xf6>
		} else if (c == '\n' || c == '\r') {
f011a938:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f011a93c:	74 0a                	je     f011a948 <readline+0xd5>
f011a93e:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f011a942:	0f 85 61 ff ff ff    	jne    f011a8a9 <readline+0x36>
			if (echoing)
f011a948:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011a94c:	74 0e                	je     f011a95c <readline+0xe9>
				cputchar(c);
f011a94e:	83 ec 0c             	sub    $0xc,%esp
f011a951:	ff 75 ec             	pushl  -0x14(%ebp)
f011a954:	e8 9d 70 fe ff       	call   f01019f6 <cputchar>
f011a959:	83 c4 10             	add    $0x10,%esp

			buf[i] = 0;
f011a95c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a95f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a962:	01 d0                	add    %edx,%eax
f011a964:	c6 00 00             	movb   $0x0,(%eax)
			break;
f011a967:	eb 06                	jmp    f011a96f <readline+0xfc>
		}
	}
f011a969:	e9 3b ff ff ff       	jmp    f011a8a9 <readline+0x36>
	while (1) {
		c = getchar();
		if (c < 0) {
			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			break;
f011a96e:	90                   	nop

			buf[i] = 0;
			break;
		}
	}
}
f011a96f:	90                   	nop
f011a970:	c9                   	leave  
f011a971:	c3                   	ret    

f011a972 <atomic_readline>:

void atomic_readline(const char *prompt, char* buf)
{
f011a972:	55                   	push   %ebp
f011a973:	89 e5                	mov    %esp,%ebp
f011a975:	83 ec 18             	sub    $0x18,%esp
	sys_lock_cons();
f011a978:	e8 de 3d ff ff       	call   f010e75b <sys_lock_cons>
	{
		int i, c, echoing;

		if (prompt != NULL)
f011a97d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011a981:	74 13                	je     f011a996 <atomic_readline+0x24>
			cprintf("%s", prompt);
f011a983:	83 ec 08             	sub    $0x8,%esp
f011a986:	ff 75 08             	pushl  0x8(%ebp)
f011a989:	68 88 5e 13 f0       	push   $0xf0135e88
f011a98e:	e8 c9 71 fe ff       	call   f0101b5c <cprintf>
f011a993:	83 c4 10             	add    $0x10,%esp

		i = 0;
f011a996:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		echoing = iscons(0);
f011a99d:	83 ec 0c             	sub    $0xc,%esp
f011a9a0:	6a 00                	push   $0x0
f011a9a2:	e8 7f 70 fe ff       	call   f0101a26 <iscons>
f011a9a7:	83 c4 10             	add    $0x10,%esp
f011a9aa:	89 45 f0             	mov    %eax,-0x10(%ebp)
		while (1) {
			c = getchar();
f011a9ad:	e8 5b 70 fe ff       	call   f0101a0d <getchar>
f011a9b2:	89 45 ec             	mov    %eax,-0x14(%ebp)
			if (c < 0) {
f011a9b5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a9b9:	79 22                	jns    f011a9dd <atomic_readline+0x6b>
				if (c != -E_EOF)
f011a9bb:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011a9bf:	0f 84 ad 00 00 00    	je     f011aa72 <atomic_readline+0x100>
					cprintf("read error: %e\n", c);
f011a9c5:	83 ec 08             	sub    $0x8,%esp
f011a9c8:	ff 75 ec             	pushl  -0x14(%ebp)
f011a9cb:	68 8b 5e 13 f0       	push   $0xf0135e8b
f011a9d0:	e8 87 71 fe ff       	call   f0101b5c <cprintf>
f011a9d5:	83 c4 10             	add    $0x10,%esp
				break;
f011a9d8:	e9 95 00 00 00       	jmp    f011aa72 <atomic_readline+0x100>
			} else if (c >= ' ' && i < BUFLEN-1) {
f011a9dd:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f011a9e1:	7e 34                	jle    f011aa17 <atomic_readline+0xa5>
f011a9e3:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f011a9ea:	7f 2b                	jg     f011aa17 <atomic_readline+0xa5>
				if (echoing)
f011a9ec:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011a9f0:	74 0e                	je     f011aa00 <atomic_readline+0x8e>
					cputchar(c);
f011a9f2:	83 ec 0c             	sub    $0xc,%esp
f011a9f5:	ff 75 ec             	pushl  -0x14(%ebp)
f011a9f8:	e8 f9 6f fe ff       	call   f01019f6 <cputchar>
f011a9fd:	83 c4 10             	add    $0x10,%esp
				buf[i++] = c;
f011aa00:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011aa03:	8d 50 01             	lea    0x1(%eax),%edx
f011aa06:	89 55 f4             	mov    %edx,-0xc(%ebp)
f011aa09:	89 c2                	mov    %eax,%edx
f011aa0b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011aa0e:	01 d0                	add    %edx,%eax
f011aa10:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011aa13:	88 10                	mov    %dl,(%eax)
f011aa15:	eb 56                	jmp    f011aa6d <atomic_readline+0xfb>
			} else if (c == '\b' && i > 0) {
f011aa17:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011aa1b:	75 1f                	jne    f011aa3c <atomic_readline+0xca>
f011aa1d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011aa21:	7e 19                	jle    f011aa3c <atomic_readline+0xca>
				if (echoing)
f011aa23:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011aa27:	74 0e                	je     f011aa37 <atomic_readline+0xc5>
					cputchar(c);
f011aa29:	83 ec 0c             	sub    $0xc,%esp
f011aa2c:	ff 75 ec             	pushl  -0x14(%ebp)
f011aa2f:	e8 c2 6f fe ff       	call   f01019f6 <cputchar>
f011aa34:	83 c4 10             	add    $0x10,%esp
				i--;
f011aa37:	ff 4d f4             	decl   -0xc(%ebp)
f011aa3a:	eb 31                	jmp    f011aa6d <atomic_readline+0xfb>
			} else if (c == '\n' || c == '\r') {
f011aa3c:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f011aa40:	74 0a                	je     f011aa4c <atomic_readline+0xda>
f011aa42:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f011aa46:	0f 85 61 ff ff ff    	jne    f011a9ad <atomic_readline+0x3b>
				if (echoing)
f011aa4c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011aa50:	74 0e                	je     f011aa60 <atomic_readline+0xee>
					cputchar(c);
f011aa52:	83 ec 0c             	sub    $0xc,%esp
f011aa55:	ff 75 ec             	pushl  -0x14(%ebp)
f011aa58:	e8 99 6f fe ff       	call   f01019f6 <cputchar>
f011aa5d:	83 c4 10             	add    $0x10,%esp
				buf[i] = 0;
f011aa60:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011aa63:	8b 45 0c             	mov    0xc(%ebp),%eax
f011aa66:	01 d0                	add    %edx,%eax
f011aa68:	c6 00 00             	movb   $0x0,(%eax)
				break;
f011aa6b:	eb 06                	jmp    f011aa73 <atomic_readline+0x101>
			}
		}
f011aa6d:	e9 3b ff ff ff       	jmp    f011a9ad <atomic_readline+0x3b>
		while (1) {
			c = getchar();
			if (c < 0) {
				if (c != -E_EOF)
					cprintf("read error: %e\n", c);
				break;
f011aa72:	90                   	nop
				buf[i] = 0;
				break;
			}
		}
	}
	sys_unlock_cons();
f011aa73:	e8 f1 3c ff ff       	call   f010e769 <sys_unlock_cons>
}
f011aa78:	90                   	nop
f011aa79:	c9                   	leave  
f011aa7a:	c3                   	ret    

f011aa7b <strlen>:

#include <inc/string.h>

int
strlen(const char *s)
{
f011aa7b:	55                   	push   %ebp
f011aa7c:	89 e5                	mov    %esp,%ebp
f011aa7e:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; *s != '\0'; s++)
f011aa81:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011aa88:	eb 06                	jmp    f011aa90 <strlen+0x15>
		n++;
f011aa8a:	ff 45 fc             	incl   -0x4(%ebp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
f011aa8d:	ff 45 08             	incl   0x8(%ebp)
f011aa90:	8b 45 08             	mov    0x8(%ebp),%eax
f011aa93:	8a 00                	mov    (%eax),%al
f011aa95:	84 c0                	test   %al,%al
f011aa97:	75 f1                	jne    f011aa8a <strlen+0xf>
		n++;
	return n;
f011aa99:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011aa9c:	c9                   	leave  
f011aa9d:	c3                   	ret    

f011aa9e <strnlen>:

int
strnlen(const char *s, uint32 size)
{
f011aa9e:	55                   	push   %ebp
f011aa9f:	89 e5                	mov    %esp,%ebp
f011aaa1:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f011aaa4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011aaab:	eb 09                	jmp    f011aab6 <strnlen+0x18>
		n++;
f011aaad:	ff 45 fc             	incl   -0x4(%ebp)
int
strnlen(const char *s, uint32 size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f011aab0:	ff 45 08             	incl   0x8(%ebp)
f011aab3:	ff 4d 0c             	decl   0xc(%ebp)
f011aab6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011aaba:	74 09                	je     f011aac5 <strnlen+0x27>
f011aabc:	8b 45 08             	mov    0x8(%ebp),%eax
f011aabf:	8a 00                	mov    (%eax),%al
f011aac1:	84 c0                	test   %al,%al
f011aac3:	75 e8                	jne    f011aaad <strnlen+0xf>
		n++;
	return n;
f011aac5:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011aac8:	c9                   	leave  
f011aac9:	c3                   	ret    

f011aaca <strcpy>:

char *
strcpy(char *dst, const char *src)
{
f011aaca:	55                   	push   %ebp
f011aacb:	89 e5                	mov    %esp,%ebp
f011aacd:	83 ec 10             	sub    $0x10,%esp
	char *ret;

	ret = dst;
f011aad0:	8b 45 08             	mov    0x8(%ebp),%eax
f011aad3:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while ((*dst++ = *src++) != '\0')
f011aad6:	90                   	nop
f011aad7:	8b 45 08             	mov    0x8(%ebp),%eax
f011aada:	8d 50 01             	lea    0x1(%eax),%edx
f011aadd:	89 55 08             	mov    %edx,0x8(%ebp)
f011aae0:	8b 55 0c             	mov    0xc(%ebp),%edx
f011aae3:	8d 4a 01             	lea    0x1(%edx),%ecx
f011aae6:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f011aae9:	8a 12                	mov    (%edx),%dl
f011aaeb:	88 10                	mov    %dl,(%eax)
f011aaed:	8a 00                	mov    (%eax),%al
f011aaef:	84 c0                	test   %al,%al
f011aaf1:	75 e4                	jne    f011aad7 <strcpy+0xd>
		/* do nothing */;
	return ret;
f011aaf3:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011aaf6:	c9                   	leave  
f011aaf7:	c3                   	ret    

f011aaf8 <strncpy>:

char *
strncpy(char *dst, const char *src, uint32 size) {
f011aaf8:	55                   	push   %ebp
f011aaf9:	89 e5                	mov    %esp,%ebp
f011aafb:	83 ec 10             	sub    $0x10,%esp
	uint32 i;
	char *ret;

	ret = dst;
f011aafe:	8b 45 08             	mov    0x8(%ebp),%eax
f011ab01:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for (i = 0; i < size; i++) {
f011ab04:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011ab0b:	eb 1f                	jmp    f011ab2c <strncpy+0x34>
		*dst++ = *src;
f011ab0d:	8b 45 08             	mov    0x8(%ebp),%eax
f011ab10:	8d 50 01             	lea    0x1(%eax),%edx
f011ab13:	89 55 08             	mov    %edx,0x8(%ebp)
f011ab16:	8b 55 0c             	mov    0xc(%ebp),%edx
f011ab19:	8a 12                	mov    (%edx),%dl
f011ab1b:	88 10                	mov    %dl,(%eax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
f011ab1d:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ab20:	8a 00                	mov    (%eax),%al
f011ab22:	84 c0                	test   %al,%al
f011ab24:	74 03                	je     f011ab29 <strncpy+0x31>
			src++;
f011ab26:	ff 45 0c             	incl   0xc(%ebp)
strncpy(char *dst, const char *src, uint32 size) {
	uint32 i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
f011ab29:	ff 45 fc             	incl   -0x4(%ebp)
f011ab2c:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ab2f:	3b 45 10             	cmp    0x10(%ebp),%eax
f011ab32:	72 d9                	jb     f011ab0d <strncpy+0x15>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
f011ab34:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f011ab37:	c9                   	leave  
f011ab38:	c3                   	ret    

f011ab39 <strlcpy>:

uint32
strlcpy(char *dst, const char *src, uint32 size)
{
f011ab39:	55                   	push   %ebp
f011ab3a:	89 e5                	mov    %esp,%ebp
f011ab3c:	83 ec 10             	sub    $0x10,%esp
	char *dst_in;

	dst_in = dst;
f011ab3f:	8b 45 08             	mov    0x8(%ebp),%eax
f011ab42:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (size > 0) {
f011ab45:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ab49:	74 30                	je     f011ab7b <strlcpy+0x42>
		while (--size > 0 && *src != '\0')
f011ab4b:	eb 16                	jmp    f011ab63 <strlcpy+0x2a>
			*dst++ = *src++;
f011ab4d:	8b 45 08             	mov    0x8(%ebp),%eax
f011ab50:	8d 50 01             	lea    0x1(%eax),%edx
f011ab53:	89 55 08             	mov    %edx,0x8(%ebp)
f011ab56:	8b 55 0c             	mov    0xc(%ebp),%edx
f011ab59:	8d 4a 01             	lea    0x1(%edx),%ecx
f011ab5c:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f011ab5f:	8a 12                	mov    (%edx),%dl
f011ab61:	88 10                	mov    %dl,(%eax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
f011ab63:	ff 4d 10             	decl   0x10(%ebp)
f011ab66:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ab6a:	74 09                	je     f011ab75 <strlcpy+0x3c>
f011ab6c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ab6f:	8a 00                	mov    (%eax),%al
f011ab71:	84 c0                	test   %al,%al
f011ab73:	75 d8                	jne    f011ab4d <strlcpy+0x14>
			*dst++ = *src++;
		*dst = '\0';
f011ab75:	8b 45 08             	mov    0x8(%ebp),%eax
f011ab78:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
f011ab7b:	8b 55 08             	mov    0x8(%ebp),%edx
f011ab7e:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ab81:	29 c2                	sub    %eax,%edx
f011ab83:	89 d0                	mov    %edx,%eax
}
f011ab85:	c9                   	leave  
f011ab86:	c3                   	ret    

f011ab87 <strcmp>:

int
strcmp(const char *p, const char *q)
{
f011ab87:	55                   	push   %ebp
f011ab88:	89 e5                	mov    %esp,%ebp
	while (*p && *p == *q)
f011ab8a:	eb 06                	jmp    f011ab92 <strcmp+0xb>
		p++, q++;
f011ab8c:	ff 45 08             	incl   0x8(%ebp)
f011ab8f:	ff 45 0c             	incl   0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
f011ab92:	8b 45 08             	mov    0x8(%ebp),%eax
f011ab95:	8a 00                	mov    (%eax),%al
f011ab97:	84 c0                	test   %al,%al
f011ab99:	74 0e                	je     f011aba9 <strcmp+0x22>
f011ab9b:	8b 45 08             	mov    0x8(%ebp),%eax
f011ab9e:	8a 10                	mov    (%eax),%dl
f011aba0:	8b 45 0c             	mov    0xc(%ebp),%eax
f011aba3:	8a 00                	mov    (%eax),%al
f011aba5:	38 c2                	cmp    %al,%dl
f011aba7:	74 e3                	je     f011ab8c <strcmp+0x5>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
f011aba9:	8b 45 08             	mov    0x8(%ebp),%eax
f011abac:	8a 00                	mov    (%eax),%al
f011abae:	0f b6 d0             	movzbl %al,%edx
f011abb1:	8b 45 0c             	mov    0xc(%ebp),%eax
f011abb4:	8a 00                	mov    (%eax),%al
f011abb6:	0f b6 c0             	movzbl %al,%eax
f011abb9:	29 c2                	sub    %eax,%edx
f011abbb:	89 d0                	mov    %edx,%eax
}
f011abbd:	5d                   	pop    %ebp
f011abbe:	c3                   	ret    

f011abbf <strncmp>:

int
strncmp(const char *p, const char *q, uint32 n)
{
f011abbf:	55                   	push   %ebp
f011abc0:	89 e5                	mov    %esp,%ebp
	while (n > 0 && *p && *p == *q)
f011abc2:	eb 09                	jmp    f011abcd <strncmp+0xe>
		n--, p++, q++;
f011abc4:	ff 4d 10             	decl   0x10(%ebp)
f011abc7:	ff 45 08             	incl   0x8(%ebp)
f011abca:	ff 45 0c             	incl   0xc(%ebp)
}

int
strncmp(const char *p, const char *q, uint32 n)
{
	while (n > 0 && *p && *p == *q)
f011abcd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011abd1:	74 17                	je     f011abea <strncmp+0x2b>
f011abd3:	8b 45 08             	mov    0x8(%ebp),%eax
f011abd6:	8a 00                	mov    (%eax),%al
f011abd8:	84 c0                	test   %al,%al
f011abda:	74 0e                	je     f011abea <strncmp+0x2b>
f011abdc:	8b 45 08             	mov    0x8(%ebp),%eax
f011abdf:	8a 10                	mov    (%eax),%dl
f011abe1:	8b 45 0c             	mov    0xc(%ebp),%eax
f011abe4:	8a 00                	mov    (%eax),%al
f011abe6:	38 c2                	cmp    %al,%dl
f011abe8:	74 da                	je     f011abc4 <strncmp+0x5>
		n--, p++, q++;
	if (n == 0)
f011abea:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011abee:	75 07                	jne    f011abf7 <strncmp+0x38>
		return 0;
f011abf0:	b8 00 00 00 00       	mov    $0x0,%eax
f011abf5:	eb 14                	jmp    f011ac0b <strncmp+0x4c>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
f011abf7:	8b 45 08             	mov    0x8(%ebp),%eax
f011abfa:	8a 00                	mov    (%eax),%al
f011abfc:	0f b6 d0             	movzbl %al,%edx
f011abff:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ac02:	8a 00                	mov    (%eax),%al
f011ac04:	0f b6 c0             	movzbl %al,%eax
f011ac07:	29 c2                	sub    %eax,%edx
f011ac09:	89 d0                	mov    %edx,%eax
}
f011ac0b:	5d                   	pop    %ebp
f011ac0c:	c3                   	ret    

f011ac0d <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
f011ac0d:	55                   	push   %ebp
f011ac0e:	89 e5                	mov    %esp,%ebp
f011ac10:	83 ec 04             	sub    $0x4,%esp
f011ac13:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ac16:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f011ac19:	eb 12                	jmp    f011ac2d <strchr+0x20>
		if (*s == c)
f011ac1b:	8b 45 08             	mov    0x8(%ebp),%eax
f011ac1e:	8a 00                	mov    (%eax),%al
f011ac20:	3a 45 fc             	cmp    -0x4(%ebp),%al
f011ac23:	75 05                	jne    f011ac2a <strchr+0x1d>
			return (char *) s;
f011ac25:	8b 45 08             	mov    0x8(%ebp),%eax
f011ac28:	eb 11                	jmp    f011ac3b <strchr+0x2e>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
f011ac2a:	ff 45 08             	incl   0x8(%ebp)
f011ac2d:	8b 45 08             	mov    0x8(%ebp),%eax
f011ac30:	8a 00                	mov    (%eax),%al
f011ac32:	84 c0                	test   %al,%al
f011ac34:	75 e5                	jne    f011ac1b <strchr+0xe>
		if (*s == c)
			return (char *) s;
	return 0;
f011ac36:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011ac3b:	c9                   	leave  
f011ac3c:	c3                   	ret    

f011ac3d <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
f011ac3d:	55                   	push   %ebp
f011ac3e:	89 e5                	mov    %esp,%ebp
f011ac40:	83 ec 04             	sub    $0x4,%esp
f011ac43:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ac46:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f011ac49:	eb 0d                	jmp    f011ac58 <strfind+0x1b>
		if (*s == c)
f011ac4b:	8b 45 08             	mov    0x8(%ebp),%eax
f011ac4e:	8a 00                	mov    (%eax),%al
f011ac50:	3a 45 fc             	cmp    -0x4(%ebp),%al
f011ac53:	74 0e                	je     f011ac63 <strfind+0x26>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
f011ac55:	ff 45 08             	incl   0x8(%ebp)
f011ac58:	8b 45 08             	mov    0x8(%ebp),%eax
f011ac5b:	8a 00                	mov    (%eax),%al
f011ac5d:	84 c0                	test   %al,%al
f011ac5f:	75 ea                	jne    f011ac4b <strfind+0xe>
f011ac61:	eb 01                	jmp    f011ac64 <strfind+0x27>
		if (*s == c)
			break;
f011ac63:	90                   	nop
	return (char *) s;
f011ac64:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011ac67:	c9                   	leave  
f011ac68:	c3                   	ret    

f011ac69 <memset>:

// *************** The faster implementation of memset & memcpy is implemented by *************
// ****************** Team80 (Yahia Khaled, Malek Ahmed et al) - FCIS'24-25 *******************
void *
memset(void *v, int c, uint32 n)
{
f011ac69:	55                   	push   %ebp
f011ac6a:	89 e5                	mov    %esp,%ebp
f011ac6c:	83 ec 10             	sub    $0x10,%esp
//	m = n;
//	while (--m >= 0)
//		*p++ = c;

	/*Faster Implementation*/
	uint64* p64 = (uint64*)v;
f011ac6f:	8b 45 08             	mov    0x8(%ebp),%eax
f011ac72:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if(n >= 8){
f011ac75:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
f011ac79:	76 63                	jbe    f011acde <memset+0x75>
		uint64 data_block = c;
f011ac7b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ac7e:	99                   	cltd   
f011ac7f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011ac82:	89 55 f4             	mov    %edx,-0xc(%ebp)
		data_block |= data_block << 8;
f011ac85:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ac88:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ac8b:	0f a4 c2 08          	shld   $0x8,%eax,%edx
f011ac8f:	c1 e0 08             	shl    $0x8,%eax
f011ac92:	09 45 f0             	or     %eax,-0x10(%ebp)
f011ac95:	09 55 f4             	or     %edx,-0xc(%ebp)
		data_block |= data_block << 16;
f011ac98:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ac9b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ac9e:	0f a4 c2 10          	shld   $0x10,%eax,%edx
f011aca2:	c1 e0 10             	shl    $0x10,%eax
f011aca5:	09 45 f0             	or     %eax,-0x10(%ebp)
f011aca8:	09 55 f4             	or     %edx,-0xc(%ebp)
		data_block |= data_block << 32;
f011acab:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011acae:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011acb1:	89 c2                	mov    %eax,%edx
f011acb3:	b8 00 00 00 00       	mov    $0x0,%eax
f011acb8:	09 45 f0             	or     %eax,-0x10(%ebp)
f011acbb:	09 55 f4             	or     %edx,-0xc(%ebp)

		while(n >= 8)
f011acbe:	eb 18                	jmp    f011acd8 <memset+0x6f>
			*p64++ = data_block, n -= 8;
f011acc0:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f011acc3:	8d 41 08             	lea    0x8(%ecx),%eax
f011acc6:	89 45 fc             	mov    %eax,-0x4(%ebp)
f011acc9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011accc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011accf:	89 01                	mov    %eax,(%ecx)
f011acd1:	89 51 04             	mov    %edx,0x4(%ecx)
f011acd4:	83 6d 10 08          	subl   $0x8,0x10(%ebp)
		uint64 data_block = c;
		data_block |= data_block << 8;
		data_block |= data_block << 16;
		data_block |= data_block << 32;

		while(n >= 8)
f011acd8:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
f011acdc:	77 e2                	ja     f011acc0 <memset+0x57>
			*p64++ = data_block, n -= 8;
	}

	if(n){
f011acde:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ace2:	74 23                	je     f011ad07 <memset+0x9e>
		uint8* p8 = (uint8*)p64;
f011ace4:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ace7:	89 45 f8             	mov    %eax,-0x8(%ebp)
		while (n-- > 0)
f011acea:	eb 0e                	jmp    f011acfa <memset+0x91>
			*p8++ = (uint8)c;
f011acec:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011acef:	8d 50 01             	lea    0x1(%eax),%edx
f011acf2:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011acf5:	8b 55 0c             	mov    0xc(%ebp),%edx
f011acf8:	88 10                	mov    %dl,(%eax)
			*p64++ = data_block, n -= 8;
	}

	if(n){
		uint8* p8 = (uint8*)p64;
		while (n-- > 0)
f011acfa:	8b 45 10             	mov    0x10(%ebp),%eax
f011acfd:	8d 50 ff             	lea    -0x1(%eax),%edx
f011ad00:	89 55 10             	mov    %edx,0x10(%ebp)
f011ad03:	85 c0                	test   %eax,%eax
f011ad05:	75 e5                	jne    f011acec <memset+0x83>
			*p8++ = (uint8)c;
	}

	return v;
f011ad07:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011ad0a:	c9                   	leave  
f011ad0b:	c3                   	ret    

f011ad0c <memcpy>:

void *
memcpy(void *dst, const void *src, uint32 n)
{
f011ad0c:	55                   	push   %ebp
f011ad0d:	89 e5                	mov    %esp,%ebp
f011ad0f:	83 ec 10             	sub    $0x10,%esp
	//	s = src;
	//	d = dst;
	//	while (n-- > 0)
	//		*d++ = *s++;
	/*Faster Implementation*/
	uint64* s64 = (uint64*)src;
f011ad12:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ad15:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint64* d64 = (uint64*)dst;
f011ad18:	8b 45 08             	mov    0x8(%ebp),%eax
f011ad1b:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if(n >= 8){
f011ad1e:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
f011ad22:	76 24                	jbe    f011ad48 <memcpy+0x3c>
		while(n >= 8){
f011ad24:	eb 1c                	jmp    f011ad42 <memcpy+0x36>
			*d64 = *s64;
f011ad26:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ad29:	8b 50 04             	mov    0x4(%eax),%edx
f011ad2c:	8b 00                	mov    (%eax),%eax
f011ad2e:	8b 4d f8             	mov    -0x8(%ebp),%ecx
f011ad31:	89 01                	mov    %eax,(%ecx)
f011ad33:	89 51 04             	mov    %edx,0x4(%ecx)
			n -= 8;
f011ad36:	83 6d 10 08          	subl   $0x8,0x10(%ebp)
			++s64;
f011ad3a:	83 45 fc 08          	addl   $0x8,-0x4(%ebp)
			++d64;
f011ad3e:	83 45 f8 08          	addl   $0x8,-0x8(%ebp)
	//		*d++ = *s++;
	/*Faster Implementation*/
	uint64* s64 = (uint64*)src;
	uint64* d64 = (uint64*)dst;
	if(n >= 8){
		while(n >= 8){
f011ad42:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
f011ad46:	77 de                	ja     f011ad26 <memcpy+0x1a>
			++s64;
			++d64;
		}
	}

	if(n){
f011ad48:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ad4c:	74 31                	je     f011ad7f <memcpy+0x73>
		uint8* s8 = (uint8*)s64;
f011ad4e:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ad51:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint8* d8 = (uint8*)d64;
f011ad54:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011ad57:	89 45 f0             	mov    %eax,-0x10(%ebp)
		while (n-- > 0)
f011ad5a:	eb 16                	jmp    f011ad72 <memcpy+0x66>
			*d8++ = *s8++;
f011ad5c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ad5f:	8d 50 01             	lea    0x1(%eax),%edx
f011ad62:	89 55 f0             	mov    %edx,-0x10(%ebp)
f011ad65:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ad68:	8d 4a 01             	lea    0x1(%edx),%ecx
f011ad6b:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f011ad6e:	8a 12                	mov    (%edx),%dl
f011ad70:	88 10                	mov    %dl,(%eax)
	}

	if(n){
		uint8* s8 = (uint8*)s64;
		uint8* d8 = (uint8*)d64;
		while (n-- > 0)
f011ad72:	8b 45 10             	mov    0x10(%ebp),%eax
f011ad75:	8d 50 ff             	lea    -0x1(%eax),%edx
f011ad78:	89 55 10             	mov    %edx,0x10(%ebp)
f011ad7b:	85 c0                	test   %eax,%eax
f011ad7d:	75 dd                	jne    f011ad5c <memcpy+0x50>
			*d8++ = *s8++;
	}
	return dst;
f011ad7f:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011ad82:	c9                   	leave  
f011ad83:	c3                   	ret    

f011ad84 <memmove>:

void *
memmove(void *dst, const void *src, uint32 n)
{
f011ad84:	55                   	push   %ebp
f011ad85:	89 e5                	mov    %esp,%ebp
f011ad87:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f011ad8a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ad8d:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f011ad90:	8b 45 08             	mov    0x8(%ebp),%eax
f011ad93:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if (s < d && s + n > d) {
f011ad96:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ad99:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f011ad9c:	73 50                	jae    f011adee <memmove+0x6a>
f011ad9e:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011ada1:	8b 45 10             	mov    0x10(%ebp),%eax
f011ada4:	01 d0                	add    %edx,%eax
f011ada6:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f011ada9:	76 43                	jbe    f011adee <memmove+0x6a>
		s += n;
f011adab:	8b 45 10             	mov    0x10(%ebp),%eax
f011adae:	01 45 fc             	add    %eax,-0x4(%ebp)
		d += n;
f011adb1:	8b 45 10             	mov    0x10(%ebp),%eax
f011adb4:	01 45 f8             	add    %eax,-0x8(%ebp)
		while (n-- > 0)
f011adb7:	eb 10                	jmp    f011adc9 <memmove+0x45>
			*--d = *--s;
f011adb9:	ff 4d f8             	decl   -0x8(%ebp)
f011adbc:	ff 4d fc             	decl   -0x4(%ebp)
f011adbf:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011adc2:	8a 10                	mov    (%eax),%dl
f011adc4:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011adc7:	88 10                	mov    %dl,(%eax)
	s = src;
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		while (n-- > 0)
f011adc9:	8b 45 10             	mov    0x10(%ebp),%eax
f011adcc:	8d 50 ff             	lea    -0x1(%eax),%edx
f011adcf:	89 55 10             	mov    %edx,0x10(%ebp)
f011add2:	85 c0                	test   %eax,%eax
f011add4:	75 e3                	jne    f011adb9 <memmove+0x35>
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
f011add6:	eb 23                	jmp    f011adfb <memmove+0x77>
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
			*d++ = *s++;
f011add8:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011addb:	8d 50 01             	lea    0x1(%eax),%edx
f011adde:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011ade1:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011ade4:	8d 4a 01             	lea    0x1(%edx),%ecx
f011ade7:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f011adea:	8a 12                	mov    (%edx),%dl
f011adec:	88 10                	mov    %dl,(%eax)
		s += n;
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
f011adee:	8b 45 10             	mov    0x10(%ebp),%eax
f011adf1:	8d 50 ff             	lea    -0x1(%eax),%edx
f011adf4:	89 55 10             	mov    %edx,0x10(%ebp)
f011adf7:	85 c0                	test   %eax,%eax
f011adf9:	75 dd                	jne    f011add8 <memmove+0x54>
			*d++ = *s++;

	return dst;
f011adfb:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011adfe:	c9                   	leave  
f011adff:	c3                   	ret    

f011ae00 <memcmp>:

int
memcmp(const void *v1, const void *v2, uint32 n)
{
f011ae00:	55                   	push   %ebp
f011ae01:	89 e5                	mov    %esp,%ebp
f011ae03:	83 ec 10             	sub    $0x10,%esp
	const uint8 *s1 = (const uint8 *) v1;
f011ae06:	8b 45 08             	mov    0x8(%ebp),%eax
f011ae09:	89 45 fc             	mov    %eax,-0x4(%ebp)
	const uint8 *s2 = (const uint8 *) v2;
f011ae0c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ae0f:	89 45 f8             	mov    %eax,-0x8(%ebp)

	while (n-- > 0) {
f011ae12:	eb 2a                	jmp    f011ae3e <memcmp+0x3e>
		if (*s1 != *s2)
f011ae14:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ae17:	8a 10                	mov    (%eax),%dl
f011ae19:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011ae1c:	8a 00                	mov    (%eax),%al
f011ae1e:	38 c2                	cmp    %al,%dl
f011ae20:	74 16                	je     f011ae38 <memcmp+0x38>
			return (int) *s1 - (int) *s2;
f011ae22:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ae25:	8a 00                	mov    (%eax),%al
f011ae27:	0f b6 d0             	movzbl %al,%edx
f011ae2a:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011ae2d:	8a 00                	mov    (%eax),%al
f011ae2f:	0f b6 c0             	movzbl %al,%eax
f011ae32:	29 c2                	sub    %eax,%edx
f011ae34:	89 d0                	mov    %edx,%eax
f011ae36:	eb 18                	jmp    f011ae50 <memcmp+0x50>
		s1++, s2++;
f011ae38:	ff 45 fc             	incl   -0x4(%ebp)
f011ae3b:	ff 45 f8             	incl   -0x8(%ebp)
memcmp(const void *v1, const void *v2, uint32 n)
{
	const uint8 *s1 = (const uint8 *) v1;
	const uint8 *s2 = (const uint8 *) v2;

	while (n-- > 0) {
f011ae3e:	8b 45 10             	mov    0x10(%ebp),%eax
f011ae41:	8d 50 ff             	lea    -0x1(%eax),%edx
f011ae44:	89 55 10             	mov    %edx,0x10(%ebp)
f011ae47:	85 c0                	test   %eax,%eax
f011ae49:	75 c9                	jne    f011ae14 <memcmp+0x14>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
f011ae4b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011ae50:	c9                   	leave  
f011ae51:	c3                   	ret    

f011ae52 <memfind>:

void *
memfind(const void *s, int c, uint32 n)
{
f011ae52:	55                   	push   %ebp
f011ae53:	89 e5                	mov    %esp,%ebp
f011ae55:	83 ec 10             	sub    $0x10,%esp
	const void *ends = (const char *) s + n;
f011ae58:	8b 55 08             	mov    0x8(%ebp),%edx
f011ae5b:	8b 45 10             	mov    0x10(%ebp),%eax
f011ae5e:	01 d0                	add    %edx,%eax
f011ae60:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for (; s < ends; s++)
f011ae63:	eb 15                	jmp    f011ae7a <memfind+0x28>
		if (*(const unsigned char *) s == (unsigned char) c)
f011ae65:	8b 45 08             	mov    0x8(%ebp),%eax
f011ae68:	8a 00                	mov    (%eax),%al
f011ae6a:	0f b6 d0             	movzbl %al,%edx
f011ae6d:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ae70:	0f b6 c0             	movzbl %al,%eax
f011ae73:	39 c2                	cmp    %eax,%edx
f011ae75:	74 0d                	je     f011ae84 <memfind+0x32>

void *
memfind(const void *s, int c, uint32 n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
f011ae77:	ff 45 08             	incl   0x8(%ebp)
f011ae7a:	8b 45 08             	mov    0x8(%ebp),%eax
f011ae7d:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f011ae80:	72 e3                	jb     f011ae65 <memfind+0x13>
f011ae82:	eb 01                	jmp    f011ae85 <memfind+0x33>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
f011ae84:	90                   	nop
	return (void *) s;
f011ae85:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011ae88:	c9                   	leave  
f011ae89:	c3                   	ret    

f011ae8a <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
f011ae8a:	55                   	push   %ebp
f011ae8b:	89 e5                	mov    %esp,%ebp
f011ae8d:	83 ec 10             	sub    $0x10,%esp
	int neg = 0;
f011ae90:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	long val = 0;
f011ae97:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f011ae9e:	eb 03                	jmp    f011aea3 <strtol+0x19>
		s++;
f011aea0:	ff 45 08             	incl   0x8(%ebp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f011aea3:	8b 45 08             	mov    0x8(%ebp),%eax
f011aea6:	8a 00                	mov    (%eax),%al
f011aea8:	3c 20                	cmp    $0x20,%al
f011aeaa:	74 f4                	je     f011aea0 <strtol+0x16>
f011aeac:	8b 45 08             	mov    0x8(%ebp),%eax
f011aeaf:	8a 00                	mov    (%eax),%al
f011aeb1:	3c 09                	cmp    $0x9,%al
f011aeb3:	74 eb                	je     f011aea0 <strtol+0x16>
		s++;

	// plus/minus sign
	if (*s == '+')
f011aeb5:	8b 45 08             	mov    0x8(%ebp),%eax
f011aeb8:	8a 00                	mov    (%eax),%al
f011aeba:	3c 2b                	cmp    $0x2b,%al
f011aebc:	75 05                	jne    f011aec3 <strtol+0x39>
		s++;
f011aebe:	ff 45 08             	incl   0x8(%ebp)
f011aec1:	eb 13                	jmp    f011aed6 <strtol+0x4c>
	else if (*s == '-')
f011aec3:	8b 45 08             	mov    0x8(%ebp),%eax
f011aec6:	8a 00                	mov    (%eax),%al
f011aec8:	3c 2d                	cmp    $0x2d,%al
f011aeca:	75 0a                	jne    f011aed6 <strtol+0x4c>
		s++, neg = 1;
f011aecc:	ff 45 08             	incl   0x8(%ebp)
f011aecf:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
f011aed6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011aeda:	74 06                	je     f011aee2 <strtol+0x58>
f011aedc:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
f011aee0:	75 20                	jne    f011af02 <strtol+0x78>
f011aee2:	8b 45 08             	mov    0x8(%ebp),%eax
f011aee5:	8a 00                	mov    (%eax),%al
f011aee7:	3c 30                	cmp    $0x30,%al
f011aee9:	75 17                	jne    f011af02 <strtol+0x78>
f011aeeb:	8b 45 08             	mov    0x8(%ebp),%eax
f011aeee:	40                   	inc    %eax
f011aeef:	8a 00                	mov    (%eax),%al
f011aef1:	3c 78                	cmp    $0x78,%al
f011aef3:	75 0d                	jne    f011af02 <strtol+0x78>
		s += 2, base = 16;
f011aef5:	83 45 08 02          	addl   $0x2,0x8(%ebp)
f011aef9:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
f011af00:	eb 28                	jmp    f011af2a <strtol+0xa0>
	else if (base == 0 && s[0] == '0')
f011af02:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011af06:	75 15                	jne    f011af1d <strtol+0x93>
f011af08:	8b 45 08             	mov    0x8(%ebp),%eax
f011af0b:	8a 00                	mov    (%eax),%al
f011af0d:	3c 30                	cmp    $0x30,%al
f011af0f:	75 0c                	jne    f011af1d <strtol+0x93>
		s++, base = 8;
f011af11:	ff 45 08             	incl   0x8(%ebp)
f011af14:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
f011af1b:	eb 0d                	jmp    f011af2a <strtol+0xa0>
	else if (base == 0)
f011af1d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011af21:	75 07                	jne    f011af2a <strtol+0xa0>
		base = 10;
f011af23:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
f011af2a:	8b 45 08             	mov    0x8(%ebp),%eax
f011af2d:	8a 00                	mov    (%eax),%al
f011af2f:	3c 2f                	cmp    $0x2f,%al
f011af31:	7e 19                	jle    f011af4c <strtol+0xc2>
f011af33:	8b 45 08             	mov    0x8(%ebp),%eax
f011af36:	8a 00                	mov    (%eax),%al
f011af38:	3c 39                	cmp    $0x39,%al
f011af3a:	7f 10                	jg     f011af4c <strtol+0xc2>
			dig = *s - '0';
f011af3c:	8b 45 08             	mov    0x8(%ebp),%eax
f011af3f:	8a 00                	mov    (%eax),%al
f011af41:	0f be c0             	movsbl %al,%eax
f011af44:	83 e8 30             	sub    $0x30,%eax
f011af47:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011af4a:	eb 42                	jmp    f011af8e <strtol+0x104>
		else if (*s >= 'a' && *s <= 'z')
f011af4c:	8b 45 08             	mov    0x8(%ebp),%eax
f011af4f:	8a 00                	mov    (%eax),%al
f011af51:	3c 60                	cmp    $0x60,%al
f011af53:	7e 19                	jle    f011af6e <strtol+0xe4>
f011af55:	8b 45 08             	mov    0x8(%ebp),%eax
f011af58:	8a 00                	mov    (%eax),%al
f011af5a:	3c 7a                	cmp    $0x7a,%al
f011af5c:	7f 10                	jg     f011af6e <strtol+0xe4>
			dig = *s - 'a' + 10;
f011af5e:	8b 45 08             	mov    0x8(%ebp),%eax
f011af61:	8a 00                	mov    (%eax),%al
f011af63:	0f be c0             	movsbl %al,%eax
f011af66:	83 e8 57             	sub    $0x57,%eax
f011af69:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011af6c:	eb 20                	jmp    f011af8e <strtol+0x104>
		else if (*s >= 'A' && *s <= 'Z')
f011af6e:	8b 45 08             	mov    0x8(%ebp),%eax
f011af71:	8a 00                	mov    (%eax),%al
f011af73:	3c 40                	cmp    $0x40,%al
f011af75:	7e 39                	jle    f011afb0 <strtol+0x126>
f011af77:	8b 45 08             	mov    0x8(%ebp),%eax
f011af7a:	8a 00                	mov    (%eax),%al
f011af7c:	3c 5a                	cmp    $0x5a,%al
f011af7e:	7f 30                	jg     f011afb0 <strtol+0x126>
			dig = *s - 'A' + 10;
f011af80:	8b 45 08             	mov    0x8(%ebp),%eax
f011af83:	8a 00                	mov    (%eax),%al
f011af85:	0f be c0             	movsbl %al,%eax
f011af88:	83 e8 37             	sub    $0x37,%eax
f011af8b:	89 45 f4             	mov    %eax,-0xc(%ebp)
		else
			break;
		if (dig >= base)
f011af8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011af91:	3b 45 10             	cmp    0x10(%ebp),%eax
f011af94:	7d 19                	jge    f011afaf <strtol+0x125>
			break;
		s++, val = (val * base) + dig;
f011af96:	ff 45 08             	incl   0x8(%ebp)
f011af99:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011af9c:	0f af 45 10          	imul   0x10(%ebp),%eax
f011afa0:	89 c2                	mov    %eax,%edx
f011afa2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011afa5:	01 d0                	add    %edx,%eax
f011afa7:	89 45 f8             	mov    %eax,-0x8(%ebp)
		// we don't properly detect overflow!
	}
f011afaa:	e9 7b ff ff ff       	jmp    f011af2a <strtol+0xa0>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
f011afaf:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
f011afb0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011afb4:	74 08                	je     f011afbe <strtol+0x134>
		*endptr = (char *) s;
f011afb6:	8b 45 0c             	mov    0xc(%ebp),%eax
f011afb9:	8b 55 08             	mov    0x8(%ebp),%edx
f011afbc:	89 10                	mov    %edx,(%eax)
	return (neg ? -val : val);
f011afbe:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f011afc2:	74 07                	je     f011afcb <strtol+0x141>
f011afc4:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011afc7:	f7 d8                	neg    %eax
f011afc9:	eb 03                	jmp    f011afce <strtol+0x144>
f011afcb:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f011afce:	c9                   	leave  
f011afcf:	c3                   	ret    

f011afd0 <ltostr>:

void
ltostr(long value, char *str)
{
f011afd0:	55                   	push   %ebp
f011afd1:	89 e5                	mov    %esp,%ebp
f011afd3:	83 ec 20             	sub    $0x20,%esp
	int neg = 0;
f011afd6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int s = 0 ;
f011afdd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// plus/minus sign
	if (value < 0)
f011afe4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011afe8:	79 13                	jns    f011affd <ltostr+0x2d>
	{
		neg = 1;
f011afea:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
		str[0] = '-';
f011aff1:	8b 45 0c             	mov    0xc(%ebp),%eax
f011aff4:	c6 00 2d             	movb   $0x2d,(%eax)
		value = value * -1 ;
f011aff7:	f7 5d 08             	negl   0x8(%ebp)
		s++ ;
f011affa:	ff 45 f8             	incl   -0x8(%ebp)
	}
	do
	{
		int mod = value % 10 ;
f011affd:	8b 45 08             	mov    0x8(%ebp),%eax
f011b000:	b9 0a 00 00 00       	mov    $0xa,%ecx
f011b005:	99                   	cltd   
f011b006:	f7 f9                	idiv   %ecx
f011b008:	89 55 ec             	mov    %edx,-0x14(%ebp)
		str[s++] = mod + '0' ;
f011b00b:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011b00e:	8d 50 01             	lea    0x1(%eax),%edx
f011b011:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011b014:	89 c2                	mov    %eax,%edx
f011b016:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b019:	01 d0                	add    %edx,%eax
f011b01b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011b01e:	83 c2 30             	add    $0x30,%edx
f011b021:	88 10                	mov    %dl,(%eax)
		value = value / 10 ;
f011b023:	8b 4d 08             	mov    0x8(%ebp),%ecx
f011b026:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011b02b:	f7 e9                	imul   %ecx
f011b02d:	c1 fa 02             	sar    $0x2,%edx
f011b030:	89 c8                	mov    %ecx,%eax
f011b032:	c1 f8 1f             	sar    $0x1f,%eax
f011b035:	29 c2                	sub    %eax,%edx
f011b037:	89 d0                	mov    %edx,%eax
f011b039:	89 45 08             	mov    %eax,0x8(%ebp)
	/*2023 FIX el7 :)*/
	//} while (value % 10 != 0);
	} while (value != 0);
f011b03c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011b040:	75 bb                	jne    f011affd <ltostr+0x2d>

	//reverse the string
	int start = 0 ;
f011b042:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int end = s-1 ;
f011b049:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011b04c:	48                   	dec    %eax
f011b04d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (neg)
f011b050:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f011b054:	74 3d                	je     f011b093 <ltostr+0xc3>
		start = 1 ;
f011b056:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	while(start<end)
f011b05d:	eb 34                	jmp    f011b093 <ltostr+0xc3>
	{
		char tmp = str[start] ;
f011b05f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011b062:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b065:	01 d0                	add    %edx,%eax
f011b067:	8a 00                	mov    (%eax),%al
f011b069:	88 45 eb             	mov    %al,-0x15(%ebp)
		str[start] = str[end] ;
f011b06c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011b06f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b072:	01 c2                	add    %eax,%edx
f011b074:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f011b077:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b07a:	01 c8                	add    %ecx,%eax
f011b07c:	8a 00                	mov    (%eax),%al
f011b07e:	88 02                	mov    %al,(%edx)
		str[end] = tmp;
f011b080:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011b083:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b086:	01 c2                	add    %eax,%edx
f011b088:	8a 45 eb             	mov    -0x15(%ebp),%al
f011b08b:	88 02                	mov    %al,(%edx)
		start++ ;
f011b08d:	ff 45 f4             	incl   -0xc(%ebp)
		end-- ;
f011b090:	ff 4d f0             	decl   -0x10(%ebp)
	//reverse the string
	int start = 0 ;
	int end = s-1 ;
	if (neg)
		start = 1 ;
	while(start<end)
f011b093:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b096:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011b099:	7c c4                	jl     f011b05f <ltostr+0x8f>
		str[end] = tmp;
		start++ ;
		end-- ;
	}

	str[s] = 0 ;
f011b09b:	8b 55 f8             	mov    -0x8(%ebp),%edx
f011b09e:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b0a1:	01 d0                	add    %edx,%eax
f011b0a3:	c6 00 00             	movb   $0x0,(%eax)
	// we don't properly detect overflow!

}
f011b0a6:	90                   	nop
f011b0a7:	c9                   	leave  
f011b0a8:	c3                   	ret    

f011b0a9 <strcconcat>:

void
strcconcat(const char *str1, const char *str2, char *final)
{
f011b0a9:	55                   	push   %ebp
f011b0aa:	89 e5                	mov    %esp,%ebp
f011b0ac:	83 ec 10             	sub    $0x10,%esp
	int len1 = strlen(str1);
f011b0af:	ff 75 08             	pushl  0x8(%ebp)
f011b0b2:	e8 c4 f9 ff ff       	call   f011aa7b <strlen>
f011b0b7:	83 c4 04             	add    $0x4,%esp
f011b0ba:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int len2 = strlen(str2);
f011b0bd:	ff 75 0c             	pushl  0xc(%ebp)
f011b0c0:	e8 b6 f9 ff ff       	call   f011aa7b <strlen>
f011b0c5:	83 c4 04             	add    $0x4,%esp
f011b0c8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int s = 0 ;
f011b0cb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	for (s=0 ; s < len1 ; s++)
f011b0d2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011b0d9:	eb 17                	jmp    f011b0f2 <strcconcat+0x49>
		final[s] = str1[s] ;
f011b0db:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011b0de:	8b 45 10             	mov    0x10(%ebp),%eax
f011b0e1:	01 c2                	add    %eax,%edx
f011b0e3:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f011b0e6:	8b 45 08             	mov    0x8(%ebp),%eax
f011b0e9:	01 c8                	add    %ecx,%eax
f011b0eb:	8a 00                	mov    (%eax),%al
f011b0ed:	88 02                	mov    %al,(%edx)
strcconcat(const char *str1, const char *str2, char *final)
{
	int len1 = strlen(str1);
	int len2 = strlen(str2);
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
f011b0ef:	ff 45 fc             	incl   -0x4(%ebp)
f011b0f2:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011b0f5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011b0f8:	7c e1                	jl     f011b0db <strcconcat+0x32>
		final[s] = str1[s] ;

	int i = 0 ;
f011b0fa:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for (i=0 ; i < len2 ; i++)
f011b101:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
f011b108:	eb 1f                	jmp    f011b129 <strcconcat+0x80>
		final[s++] = str2[i] ;
f011b10a:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011b10d:	8d 50 01             	lea    0x1(%eax),%edx
f011b110:	89 55 fc             	mov    %edx,-0x4(%ebp)
f011b113:	89 c2                	mov    %eax,%edx
f011b115:	8b 45 10             	mov    0x10(%ebp),%eax
f011b118:	01 c2                	add    %eax,%edx
f011b11a:	8b 4d f8             	mov    -0x8(%ebp),%ecx
f011b11d:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b120:	01 c8                	add    %ecx,%eax
f011b122:	8a 00                	mov    (%eax),%al
f011b124:	88 02                	mov    %al,(%edx)
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
		final[s] = str1[s] ;

	int i = 0 ;
	for (i=0 ; i < len2 ; i++)
f011b126:	ff 45 f8             	incl   -0x8(%ebp)
f011b129:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011b12c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011b12f:	7c d9                	jl     f011b10a <strcconcat+0x61>
		final[s++] = str2[i] ;

	final[s] = 0;
f011b131:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011b134:	8b 45 10             	mov    0x10(%ebp),%eax
f011b137:	01 d0                	add    %edx,%eax
f011b139:	c6 00 00             	movb   $0x0,(%eax)
}
f011b13c:	90                   	nop
f011b13d:	c9                   	leave  
f011b13e:	c3                   	ret    

f011b13f <strsplit>:
int strsplit(char *string, char *SPLIT_CHARS, char **argv, int * argc)
{
f011b13f:	55                   	push   %ebp
f011b140:	89 e5                	mov    %esp,%ebp
	// Parse the command string into splitchars-separated arguments
	*argc = 0;
f011b142:	8b 45 14             	mov    0x14(%ebp),%eax
f011b145:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	(argv)[*argc] = 0;
f011b14b:	8b 45 14             	mov    0x14(%ebp),%eax
f011b14e:	8b 00                	mov    (%eax),%eax
f011b150:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011b157:	8b 45 10             	mov    0x10(%ebp),%eax
f011b15a:	01 d0                	add    %edx,%eax
f011b15c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f011b162:	eb 0c                	jmp    f011b170 <strsplit+0x31>
			*string++ = 0;
f011b164:	8b 45 08             	mov    0x8(%ebp),%eax
f011b167:	8d 50 01             	lea    0x1(%eax),%edx
f011b16a:	89 55 08             	mov    %edx,0x8(%ebp)
f011b16d:	c6 00 00             	movb   $0x0,(%eax)
	*argc = 0;
	(argv)[*argc] = 0;
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f011b170:	8b 45 08             	mov    0x8(%ebp),%eax
f011b173:	8a 00                	mov    (%eax),%al
f011b175:	84 c0                	test   %al,%al
f011b177:	74 18                	je     f011b191 <strsplit+0x52>
f011b179:	8b 45 08             	mov    0x8(%ebp),%eax
f011b17c:	8a 00                	mov    (%eax),%al
f011b17e:	0f be c0             	movsbl %al,%eax
f011b181:	50                   	push   %eax
f011b182:	ff 75 0c             	pushl  0xc(%ebp)
f011b185:	e8 83 fa ff ff       	call   f011ac0d <strchr>
f011b18a:	83 c4 08             	add    $0x8,%esp
f011b18d:	85 c0                	test   %eax,%eax
f011b18f:	75 d3                	jne    f011b164 <strsplit+0x25>
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
f011b191:	8b 45 08             	mov    0x8(%ebp),%eax
f011b194:	8a 00                	mov    (%eax),%al
f011b196:	84 c0                	test   %al,%al
f011b198:	74 5a                	je     f011b1f4 <strsplit+0xb5>
			break;

		//check current number of arguments
		if (*argc == MAX_ARGUMENTS-1)
f011b19a:	8b 45 14             	mov    0x14(%ebp),%eax
f011b19d:	8b 00                	mov    (%eax),%eax
f011b19f:	83 f8 0f             	cmp    $0xf,%eax
f011b1a2:	75 07                	jne    f011b1ab <strsplit+0x6c>
		{
			return 0;
f011b1a4:	b8 00 00 00 00       	mov    $0x0,%eax
f011b1a9:	eb 66                	jmp    f011b211 <strsplit+0xd2>
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
f011b1ab:	8b 45 14             	mov    0x14(%ebp),%eax
f011b1ae:	8b 00                	mov    (%eax),%eax
f011b1b0:	8d 48 01             	lea    0x1(%eax),%ecx
f011b1b3:	8b 55 14             	mov    0x14(%ebp),%edx
f011b1b6:	89 0a                	mov    %ecx,(%edx)
f011b1b8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011b1bf:	8b 45 10             	mov    0x10(%ebp),%eax
f011b1c2:	01 c2                	add    %eax,%edx
f011b1c4:	8b 45 08             	mov    0x8(%ebp),%eax
f011b1c7:	89 02                	mov    %eax,(%edx)
		while (*string && !strchr(SPLIT_CHARS, *string))
f011b1c9:	eb 03                	jmp    f011b1ce <strsplit+0x8f>
			string++;
f011b1cb:	ff 45 08             	incl   0x8(%ebp)
			return 0;
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
f011b1ce:	8b 45 08             	mov    0x8(%ebp),%eax
f011b1d1:	8a 00                	mov    (%eax),%al
f011b1d3:	84 c0                	test   %al,%al
f011b1d5:	74 8b                	je     f011b162 <strsplit+0x23>
f011b1d7:	8b 45 08             	mov    0x8(%ebp),%eax
f011b1da:	8a 00                	mov    (%eax),%al
f011b1dc:	0f be c0             	movsbl %al,%eax
f011b1df:	50                   	push   %eax
f011b1e0:	ff 75 0c             	pushl  0xc(%ebp)
f011b1e3:	e8 25 fa ff ff       	call   f011ac0d <strchr>
f011b1e8:	83 c4 08             	add    $0x8,%esp
f011b1eb:	85 c0                	test   %eax,%eax
f011b1ed:	74 dc                	je     f011b1cb <strsplit+0x8c>
			string++;
	}
f011b1ef:	e9 6e ff ff ff       	jmp    f011b162 <strsplit+0x23>
		while (*string && strchr(SPLIT_CHARS, *string))
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
			break;
f011b1f4:	90                   	nop
		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
			string++;
	}
	(argv)[*argc] = 0;
f011b1f5:	8b 45 14             	mov    0x14(%ebp),%eax
f011b1f8:	8b 00                	mov    (%eax),%eax
f011b1fa:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011b201:	8b 45 10             	mov    0x10(%ebp),%eax
f011b204:	01 d0                	add    %edx,%eax
f011b206:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return 1 ;
f011b20c:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011b211:	c9                   	leave  
f011b212:	c3                   	ret    

f011b213 <str2lower>:


char* str2lower(char *dst, const char *src)
{
f011b213:	55                   	push   %ebp
f011b214:	89 e5                	mov    %esp,%ebp
f011b216:	83 ec 10             	sub    $0x10,%esp
	char* ret = dst;
f011b219:	8b 45 08             	mov    0x8(%ebp),%eax
f011b21c:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for (int i = 0; i < strlen(src); ++i)
f011b21f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011b226:	eb 4a                	jmp    f011b272 <str2lower+0x5f>
	{
		dst[i] = src[i] ;
f011b228:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011b22b:	8b 45 08             	mov    0x8(%ebp),%eax
f011b22e:	01 c2                	add    %eax,%edx
f011b230:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f011b233:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b236:	01 c8                	add    %ecx,%eax
f011b238:	8a 00                	mov    (%eax),%al
f011b23a:	88 02                	mov    %al,(%edx)
		if (src[i] >= 'A' && src[i] <= 'Z')
f011b23c:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011b23f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b242:	01 d0                	add    %edx,%eax
f011b244:	8a 00                	mov    (%eax),%al
f011b246:	3c 40                	cmp    $0x40,%al
f011b248:	7e 25                	jle    f011b26f <str2lower+0x5c>
f011b24a:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011b24d:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b250:	01 d0                	add    %edx,%eax
f011b252:	8a 00                	mov    (%eax),%al
f011b254:	3c 5a                	cmp    $0x5a,%al
f011b256:	7f 17                	jg     f011b26f <str2lower+0x5c>
		{
			dst[i] += 32 ;
f011b258:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011b25b:	8b 45 08             	mov    0x8(%ebp),%eax
f011b25e:	01 d0                	add    %edx,%eax
f011b260:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f011b263:	8b 55 08             	mov    0x8(%ebp),%edx
f011b266:	01 ca                	add    %ecx,%edx
f011b268:	8a 12                	mov    (%edx),%dl
f011b26a:	83 c2 20             	add    $0x20,%edx
f011b26d:	88 10                	mov    %dl,(%eax)


char* str2lower(char *dst, const char *src)
{
	char* ret = dst;
	for (int i = 0; i < strlen(src); ++i)
f011b26f:	ff 45 fc             	incl   -0x4(%ebp)
f011b272:	ff 75 0c             	pushl  0xc(%ebp)
f011b275:	e8 01 f8 ff ff       	call   f011aa7b <strlen>
f011b27a:	83 c4 04             	add    $0x4,%esp
f011b27d:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f011b280:	7f a6                	jg     f011b228 <str2lower+0x15>
		if (src[i] >= 'A' && src[i] <= 'Z')
		{
			dst[i] += 32 ;
		}
	}
	return ret;
f011b282:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f011b285:	c9                   	leave  
f011b286:	c3                   	ret    

f011b287 <disk_interrupt_handler>:
#define IDE_ERR		0x01

static int diskno = 0;

void disk_interrupt_handler(struct Trapframe *tf)
{
f011b287:	55                   	push   %ebp
f011b288:	89 e5                	mov    %esp,%ebp
f011b28a:	83 ec 18             	sub    $0x18,%esp
	int r;
	cprintf("\n>>>>>>>> DISK INTERRUPT <<<<<<<<<\n");
f011b28d:	83 ec 0c             	sub    $0xc,%esp
f011b290:	68 9c 5e 13 f0       	push   $0xf0135e9c
f011b295:	e8 c2 68 fe ff       	call   f0101b5c <cprintf>
f011b29a:	83 c4 10             	add    $0x10,%esp
f011b29d:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f011b2a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011b2a7:	89 c2                	mov    %eax,%edx
f011b2a9:	ec                   	in     (%dx),%al
f011b2aa:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f011b2ad:	8a 45 ef             	mov    -0x11(%ebp),%al
	if (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f011b2b0:	0f b6 c0             	movzbl %al,%eax
f011b2b3:	89 45 f4             	mov    %eax,-0xc(%ebp)
#elif DISK_IO_METHOD == INT_SEMAPHORE
		signal_ksemaphore(&DISKsem);
#endif
	}

}
f011b2b6:	90                   	nop
f011b2b7:	c9                   	leave  
f011b2b8:	c3                   	ret    

f011b2b9 <ide_init>:

void ide_init()
{
f011b2b9:	55                   	push   %ebp
f011b2ba:	89 e5                	mov    %esp,%ebp
		irq_install_handler(14, &disk_interrupt_handler);
		init_ksemaphore(&DISKsem, 0, "DISK semaphore");
		init_ksemaphore(&DISKmutex, 1, "DISK mutex");
	}
#endif
}
f011b2bc:	90                   	nop
f011b2bd:	5d                   	pop    %ebp
f011b2be:	c3                   	ret    

f011b2bf <ide_wait_ready>:


static int ide_wait_ready(bool check_error)
{
f011b2bf:	55                   	push   %ebp
f011b2c0:	89 e5                	mov    %esp,%ebp
f011b2c2:	83 ec 18             	sub    $0x18,%esp
	int r;

#if DISK_IO_METHOD == PROGRAMMED_IO
	while (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f011b2c5:	90                   	nop
f011b2c6:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f011b2cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011b2d0:	89 c2                	mov    %eax,%edx
f011b2d2:	ec                   	in     (%dx),%al
f011b2d3:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f011b2d6:	8a 45 ef             	mov    -0x11(%ebp),%al
f011b2d9:	0f b6 c0             	movzbl %al,%eax
f011b2dc:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011b2df:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b2e2:	25 c0 00 00 00       	and    $0xc0,%eax
f011b2e7:	83 f8 40             	cmp    $0x40,%eax
f011b2ea:	75 da                	jne    f011b2c6 <ide_wait_ready+0x7>
#elif DISK_IO_METHOD == INT_SEMAPHORE
		wait_ksemaphore(&DISKsem);
	}
#endif
#endif
	if (check_error && (r & (IDE_DF|IDE_ERR)) != 0)
f011b2ec:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011b2f0:	74 24                	je     f011b316 <ide_wait_ready+0x57>
f011b2f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b2f5:	83 e0 21             	and    $0x21,%eax
f011b2f8:	85 c0                	test   %eax,%eax
f011b2fa:	74 1a                	je     f011b316 <ide_wait_ready+0x57>
	{
		panic("ERROR @ ide_wait_ready() = %x(%d)\n",r,r);
f011b2fc:	83 ec 0c             	sub    $0xc,%esp
f011b2ff:	ff 75 f4             	pushl  -0xc(%ebp)
f011b302:	ff 75 f4             	pushl  -0xc(%ebp)
f011b305:	68 c0 5e 13 f0       	push   $0xf0135ec0
f011b30a:	6a 54                	push   $0x54
f011b30c:	68 e3 5e 13 f0       	push   $0xf0135ee3
f011b311:	e8 99 5b fe ff       	call   f0100eaf <_panic>
		LOG_STATMENT(cprintf("ERROR @ ide_wait_ready() = %x(%d)\n",r,r););
		return -1;
	}
	return 0;
f011b316:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011b31b:	c9                   	leave  
f011b31c:	c3                   	ret    

f011b31d <ide_read>:

int	ide_read(uint32 secno, void *dst, uint32 nsecs)
{
f011b31d:	55                   	push   %ebp
f011b31e:	89 e5                	mov    %esp,%ebp
f011b320:	57                   	push   %edi
f011b321:	53                   	push   %ebx
f011b322:	83 ec 40             	sub    $0x40,%esp
	int r;

	assert(nsecs <= 256);
f011b325:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f011b32c:	76 16                	jbe    f011b344 <ide_read+0x27>
f011b32e:	68 ee 5e 13 f0       	push   $0xf0135eee
f011b333:	68 fb 5e 13 f0       	push   $0xf0135efb
f011b338:	6a 5f                	push   $0x5f
f011b33a:	68 e3 5e 13 f0       	push   $0xf0135ee3
f011b33f:	e8 6b 5b fe ff       	call   f0100eaf <_panic>

	struct Env* e = get_cpu_proc();
f011b344:	e8 cf 06 ff ff       	call   f010ba18 <get_cpu_proc>
f011b349:	89 45 f4             	mov    %eax,-0xc(%ebp)
#elif DISK_IO_METHOD == INT_SEMAPHORE
	wait_ksemaphore(&DISKmutex);
#endif
	{
		if (e) LOG_STATMENT(cprintf("ide_read: %d inside CS\n", e->env_id););
		ide_wait_ready(0);
f011b34c:	83 ec 0c             	sub    $0xc,%esp
f011b34f:	6a 00                	push   $0x0
f011b351:	e8 69 ff ff ff       	call   f011b2bf <ide_wait_ready>
f011b356:	83 c4 10             	add    $0x10,%esp

		outb(0x1F2, nsecs);
f011b359:	8b 45 10             	mov    0x10(%ebp),%eax
f011b35c:	0f b6 c0             	movzbl %al,%eax
f011b35f:	c7 45 ec f2 01 00 00 	movl   $0x1f2,-0x14(%ebp)
f011b366:	88 45 ce             	mov    %al,-0x32(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f011b369:	8a 45 ce             	mov    -0x32(%ebp),%al
f011b36c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011b36f:	ee                   	out    %al,(%dx)
		outb(0x1F3, secno & 0xFF);
f011b370:	8b 45 08             	mov    0x8(%ebp),%eax
f011b373:	0f b6 c0             	movzbl %al,%eax
f011b376:	c7 45 e8 f3 01 00 00 	movl   $0x1f3,-0x18(%ebp)
f011b37d:	88 45 cf             	mov    %al,-0x31(%ebp)
f011b380:	8a 45 cf             	mov    -0x31(%ebp),%al
f011b383:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011b386:	ee                   	out    %al,(%dx)
		outb(0x1F4, (secno >> 8) & 0xFF);
f011b387:	8b 45 08             	mov    0x8(%ebp),%eax
f011b38a:	c1 e8 08             	shr    $0x8,%eax
f011b38d:	0f b6 c0             	movzbl %al,%eax
f011b390:	c7 45 e4 f4 01 00 00 	movl   $0x1f4,-0x1c(%ebp)
f011b397:	88 45 d0             	mov    %al,-0x30(%ebp)
f011b39a:	8a 45 d0             	mov    -0x30(%ebp),%al
f011b39d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011b3a0:	ee                   	out    %al,(%dx)
		outb(0x1F5, (secno >> 16) & 0xFF);
f011b3a1:	8b 45 08             	mov    0x8(%ebp),%eax
f011b3a4:	c1 e8 10             	shr    $0x10,%eax
f011b3a7:	0f b6 c0             	movzbl %al,%eax
f011b3aa:	c7 45 e0 f5 01 00 00 	movl   $0x1f5,-0x20(%ebp)
f011b3b1:	88 45 d1             	mov    %al,-0x2f(%ebp)
f011b3b4:	8a 45 d1             	mov    -0x2f(%ebp),%al
f011b3b7:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011b3ba:	ee                   	out    %al,(%dx)
		outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f011b3bb:	a1 24 e5 83 f0       	mov    0xf083e524,%eax
f011b3c0:	83 e0 01             	and    $0x1,%eax
f011b3c3:	c1 e0 04             	shl    $0x4,%eax
f011b3c6:	88 c2                	mov    %al,%dl
f011b3c8:	8b 45 08             	mov    0x8(%ebp),%eax
f011b3cb:	c1 e8 18             	shr    $0x18,%eax
f011b3ce:	83 e0 0f             	and    $0xf,%eax
f011b3d1:	09 d0                	or     %edx,%eax
f011b3d3:	83 c8 e0             	or     $0xffffffe0,%eax
f011b3d6:	0f b6 c0             	movzbl %al,%eax
f011b3d9:	c7 45 dc f6 01 00 00 	movl   $0x1f6,-0x24(%ebp)
f011b3e0:	88 45 d2             	mov    %al,-0x2e(%ebp)
f011b3e3:	8a 45 d2             	mov    -0x2e(%ebp),%al
f011b3e6:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011b3e9:	ee                   	out    %al,(%dx)
f011b3ea:	c7 45 d4 f7 01 00 00 	movl   $0x1f7,-0x2c(%ebp)
f011b3f1:	c6 45 d3 20          	movb   $0x20,-0x2d(%ebp)
f011b3f5:	8a 45 d3             	mov    -0x2d(%ebp),%al
f011b3f8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011b3fb:	ee                   	out    %al,(%dx)
		outb(0x1F7, 0x20);	// CMD 0x20 means read sector

		for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f011b3fc:	eb 64                	jmp    f011b462 <ide_read+0x145>
			if ((r = ide_wait_ready(1)) < 0)
f011b3fe:	83 ec 0c             	sub    $0xc,%esp
f011b401:	6a 01                	push   $0x1
f011b403:	e8 b7 fe ff ff       	call   f011b2bf <ide_wait_ready>
f011b408:	83 c4 10             	add    $0x10,%esp
f011b40b:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011b40e:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f011b412:	79 14                	jns    f011b428 <ide_read+0x10b>
			{
				panic("FAILURE to read %d sectors to disk\n",nsecs);
f011b414:	ff 75 10             	pushl  0x10(%ebp)
f011b417:	68 10 5f 13 f0       	push   $0xf0135f10
f011b41c:	6a 79                	push   $0x79
f011b41e:	68 e3 5e 13 f0       	push   $0xf0135ee3
f011b423:	e8 87 5a fe ff       	call   f0100eaf <_panic>
f011b428:	c7 45 f0 f0 01 00 00 	movl   $0x1f0,-0x10(%ebp)
f011b42f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b432:	89 45 c8             	mov    %eax,-0x38(%ebp)
f011b435:	c7 45 c4 80 00 00 00 	movl   $0x80,-0x3c(%ebp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
f011b43c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011b43f:	8b 4d c8             	mov    -0x38(%ebp),%ecx
f011b442:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011b445:	89 cb                	mov    %ecx,%ebx
f011b447:	89 df                	mov    %ebx,%edi
f011b449:	89 c1                	mov    %eax,%ecx
f011b44b:	fc                   	cld    
f011b44c:	f2 6d                	repnz insl (%dx),%es:(%edi)
f011b44e:	89 c8                	mov    %ecx,%eax
f011b450:	89 fb                	mov    %edi,%ebx
f011b452:	89 5d c8             	mov    %ebx,-0x38(%ebp)
f011b455:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		outb(0x1F4, (secno >> 8) & 0xFF);
		outb(0x1F5, (secno >> 16) & 0xFF);
		outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
		outb(0x1F7, 0x20);	// CMD 0x20 means read sector

		for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f011b458:	ff 4d 10             	decl   0x10(%ebp)
f011b45b:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f011b462:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011b466:	75 96                	jne    f011b3fe <ide_read+0xe1>
	signal_ksemaphore(&DISKmutex);
#endif

	if (e) LOG_STATMENT(cprintf("ide_read: %d Left CS\n", e->env_id););

	return 0;
f011b468:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011b46d:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011b470:	5b                   	pop    %ebx
f011b471:	5f                   	pop    %edi
f011b472:	5d                   	pop    %ebp
f011b473:	c3                   	ret    

f011b474 <ide_write>:

int ide_write(uint32 secno, const void *src, uint32 nsecs)
{
f011b474:	55                   	push   %ebp
f011b475:	89 e5                	mov    %esp,%ebp
f011b477:	56                   	push   %esi
f011b478:	53                   	push   %ebx
f011b479:	83 ec 40             	sub    $0x40,%esp
	int r;

	//LOG_STATMENT(cprintf("1 ==> nsecs = %d\n",nsecs);)
	assert(nsecs <= 256);
f011b47c:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f011b483:	76 19                	jbe    f011b49e <ide_write+0x2a>
f011b485:	68 ee 5e 13 f0       	push   $0xf0135eee
f011b48a:	68 fb 5e 13 f0       	push   $0xf0135efb
f011b48f:	68 8f 00 00 00       	push   $0x8f
f011b494:	68 e3 5e 13 f0       	push   $0xf0135ee3
f011b499:	e8 11 5a fe ff       	call   f0100eaf <_panic>

	struct Env* e = get_cpu_proc();
f011b49e:	e8 75 05 ff ff       	call   f010ba18 <get_cpu_proc>
f011b4a3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	wait_ksemaphore(&DISKmutex);
#endif
	{
		if (e) LOG_STATMENT(cprintf("ide_write: %d inside CS\n", e->env_id););

		ide_wait_ready(0);
f011b4a6:	83 ec 0c             	sub    $0xc,%esp
f011b4a9:	6a 00                	push   $0x0
f011b4ab:	e8 0f fe ff ff       	call   f011b2bf <ide_wait_ready>
f011b4b0:	83 c4 10             	add    $0x10,%esp

		//LOG_STATMENT(cprintf("3 ==> nsecs = %d\n",nsecs);)
		outb(0x1F2, nsecs);
f011b4b3:	8b 45 10             	mov    0x10(%ebp),%eax
f011b4b6:	0f b6 c0             	movzbl %al,%eax
f011b4b9:	c7 45 ec f2 01 00 00 	movl   $0x1f2,-0x14(%ebp)
f011b4c0:	88 45 ce             	mov    %al,-0x32(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f011b4c3:	8a 45 ce             	mov    -0x32(%ebp),%al
f011b4c6:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011b4c9:	ee                   	out    %al,(%dx)
		outb(0x1F3, secno & 0xFF);
f011b4ca:	8b 45 08             	mov    0x8(%ebp),%eax
f011b4cd:	0f b6 c0             	movzbl %al,%eax
f011b4d0:	c7 45 e8 f3 01 00 00 	movl   $0x1f3,-0x18(%ebp)
f011b4d7:	88 45 cf             	mov    %al,-0x31(%ebp)
f011b4da:	8a 45 cf             	mov    -0x31(%ebp),%al
f011b4dd:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011b4e0:	ee                   	out    %al,(%dx)
		outb(0x1F4, (secno >> 8) & 0xFF);
f011b4e1:	8b 45 08             	mov    0x8(%ebp),%eax
f011b4e4:	c1 e8 08             	shr    $0x8,%eax
f011b4e7:	0f b6 c0             	movzbl %al,%eax
f011b4ea:	c7 45 e4 f4 01 00 00 	movl   $0x1f4,-0x1c(%ebp)
f011b4f1:	88 45 d0             	mov    %al,-0x30(%ebp)
f011b4f4:	8a 45 d0             	mov    -0x30(%ebp),%al
f011b4f7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011b4fa:	ee                   	out    %al,(%dx)
		outb(0x1F5, (secno >> 16) & 0xFF);
f011b4fb:	8b 45 08             	mov    0x8(%ebp),%eax
f011b4fe:	c1 e8 10             	shr    $0x10,%eax
f011b501:	0f b6 c0             	movzbl %al,%eax
f011b504:	c7 45 e0 f5 01 00 00 	movl   $0x1f5,-0x20(%ebp)
f011b50b:	88 45 d1             	mov    %al,-0x2f(%ebp)
f011b50e:	8a 45 d1             	mov    -0x2f(%ebp),%al
f011b511:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011b514:	ee                   	out    %al,(%dx)
		outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f011b515:	a1 24 e5 83 f0       	mov    0xf083e524,%eax
f011b51a:	83 e0 01             	and    $0x1,%eax
f011b51d:	c1 e0 04             	shl    $0x4,%eax
f011b520:	88 c2                	mov    %al,%dl
f011b522:	8b 45 08             	mov    0x8(%ebp),%eax
f011b525:	c1 e8 18             	shr    $0x18,%eax
f011b528:	83 e0 0f             	and    $0xf,%eax
f011b52b:	09 d0                	or     %edx,%eax
f011b52d:	83 c8 e0             	or     $0xffffffe0,%eax
f011b530:	0f b6 c0             	movzbl %al,%eax
f011b533:	c7 45 dc f6 01 00 00 	movl   $0x1f6,-0x24(%ebp)
f011b53a:	88 45 d2             	mov    %al,-0x2e(%ebp)
f011b53d:	8a 45 d2             	mov    -0x2e(%ebp),%al
f011b540:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011b543:	ee                   	out    %al,(%dx)
f011b544:	c7 45 d4 f7 01 00 00 	movl   $0x1f7,-0x2c(%ebp)
f011b54b:	c6 45 d3 30          	movb   $0x30,-0x2d(%ebp)
f011b54f:	8a 45 d3             	mov    -0x2d(%ebp),%al
f011b552:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011b555:	ee                   	out    %al,(%dx)
		outb(0x1F7, 0x30);	// CMD 0x30 means write sector


		for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f011b556:	eb 67                	jmp    f011b5bf <ide_write+0x14b>
			if ((r = ide_wait_ready(1)) < 0)
f011b558:	83 ec 0c             	sub    $0xc,%esp
f011b55b:	6a 01                	push   $0x1
f011b55d:	e8 5d fd ff ff       	call   f011b2bf <ide_wait_ready>
f011b562:	83 c4 10             	add    $0x10,%esp
f011b565:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011b568:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f011b56c:	79 17                	jns    f011b585 <ide_write+0x111>
			{
				panic("FAILURE to write %d sectors to disk\n",nsecs);
f011b56e:	ff 75 10             	pushl  0x10(%ebp)
f011b571:	68 34 5f 13 f0       	push   $0xf0135f34
f011b576:	68 ab 00 00 00       	push   $0xab
f011b57b:	68 e3 5e 13 f0       	push   $0xf0135ee3
f011b580:	e8 2a 59 fe ff       	call   f0100eaf <_panic>
f011b585:	c7 45 f0 f0 01 00 00 	movl   $0x1f0,-0x10(%ebp)
f011b58c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b58f:	89 45 c8             	mov    %eax,-0x38(%ebp)
f011b592:	c7 45 c4 80 00 00 00 	movl   $0x80,-0x3c(%ebp)
}

static __inline void
outsl(int port, const void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\toutsl"		:
f011b599:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011b59c:	8b 4d c8             	mov    -0x38(%ebp),%ecx
f011b59f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011b5a2:	89 cb                	mov    %ecx,%ebx
f011b5a4:	89 de                	mov    %ebx,%esi
f011b5a6:	89 c1                	mov    %eax,%ecx
f011b5a8:	fc                   	cld    
f011b5a9:	f2 6f                	repnz outsl %ds:(%esi),(%dx)
f011b5ab:	89 c8                	mov    %ecx,%eax
f011b5ad:	89 f3                	mov    %esi,%ebx
f011b5af:	89 5d c8             	mov    %ebx,-0x38(%ebp)
f011b5b2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		outb(0x1F5, (secno >> 16) & 0xFF);
		outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
		outb(0x1F7, 0x30);	// CMD 0x30 means write sector


		for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f011b5b5:	ff 4d 10             	decl   0x10(%ebp)
f011b5b8:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f011b5bf:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011b5c3:	75 93                	jne    f011b558 <ide_write+0xe4>
	if (e) LOG_STATMENT(cprintf("ide_write: %d Left CS\n", e->env_id););

	//LOG_STATMENT(cprintf("5\n");)
	//cprintf("returning from ide_write \n");

	return 0;
f011b5c5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011b5ca:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011b5cd:	5b                   	pop    %ebx
f011b5ce:	5e                   	pop    %esi
f011b5cf:	5d                   	pop    %ebp
f011b5d0:	c3                   	ret    

f011b5d1 <to_page_va>:
//==================================================================================//
//==================================
// [1] GET PAGE VA:
//==================================
__inline__ uint32 to_page_va(struct PageInfoElement *ptrPageInfo)
{
f011b5d1:	55                   	push   %ebp
f011b5d2:	89 e5                	mov    %esp,%ebp
f011b5d4:	83 ec 10             	sub    $0x10,%esp
	//Get start VA of the page from the corresponding Page Info pointer
	int idxInPageInfoArr = (ptrPageInfo - pageBlockInfoArr);
f011b5d7:	8b 45 08             	mov    0x8(%ebp),%eax
f011b5da:	ba c0 e9 83 f0       	mov    $0xf083e9c0,%edx
f011b5df:	29 d0                	sub    %edx,%eax
f011b5e1:	c1 f8 02             	sar    $0x2,%eax
f011b5e4:	89 c2                	mov    %eax,%edx
f011b5e6:	89 d0                	mov    %edx,%eax
f011b5e8:	c1 e0 02             	shl    $0x2,%eax
f011b5eb:	01 d0                	add    %edx,%eax
f011b5ed:	c1 e0 02             	shl    $0x2,%eax
f011b5f0:	01 d0                	add    %edx,%eax
f011b5f2:	c1 e0 02             	shl    $0x2,%eax
f011b5f5:	01 d0                	add    %edx,%eax
f011b5f7:	89 c1                	mov    %eax,%ecx
f011b5f9:	c1 e1 08             	shl    $0x8,%ecx
f011b5fc:	01 c8                	add    %ecx,%eax
f011b5fe:	89 c1                	mov    %eax,%ecx
f011b600:	c1 e1 10             	shl    $0x10,%ecx
f011b603:	01 c8                	add    %ecx,%eax
f011b605:	01 c0                	add    %eax,%eax
f011b607:	01 d0                	add    %edx,%eax
f011b609:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return dynAllocStart + (idxInPageInfoArr << PGSHIFT);
f011b60c:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011b60f:	c1 e0 0c             	shl    $0xc,%eax
f011b612:	89 c2                	mov    %eax,%edx
f011b614:	a1 1c 6b 85 f0       	mov    0xf0856b1c,%eax
f011b619:	01 d0                	add    %edx,%eax
}
f011b61b:	c9                   	leave  
f011b61c:	c3                   	ret    

f011b61d <initialize_dynamic_allocator>:
//==================================
// [1] INITIALIZE DYNAMIC ALLOCATOR:
//==================================
bool is_initialized = 0;
void initialize_dynamic_allocator(uint32 daStart, uint32 daEnd)
{
f011b61d:	55                   	push   %ebp
f011b61e:	89 e5                	mov    %esp,%ebp
f011b620:	83 ec 08             	sub    $0x8,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		assert(daEnd <= daStart + DYN_ALLOC_MAX_SIZE);
f011b623:	8b 45 08             	mov    0x8(%ebp),%eax
f011b626:	05 00 00 00 02       	add    $0x2000000,%eax
f011b62b:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011b62e:	73 16                	jae    f011b646 <initialize_dynamic_allocator+0x29>
f011b630:	68 5c 5f 13 f0       	push   $0xf0135f5c
f011b635:	68 82 5f 13 f0       	push   $0xf0135f82
f011b63a:	6a 26                	push   $0x26
f011b63c:	68 97 5f 13 f0       	push   $0xf0135f97
f011b641:	e8 69 58 fe ff       	call   f0100eaf <_panic>
		is_initialized = 1;
f011b646:	c7 05 28 e5 83 f0 01 	movl   $0x1,0xf083e528
f011b64d:	00 00 00 
	//==================================================================================
	//==================================================================================
	//TODO: [PROJECT'25.GM#1] DYNAMIC ALLOCATOR - #1 initialize_dynamic_allocator
	//Your code is here
	//Comment the following line
	panic("initialize_dynamic_allocator() Not implemented yet");
f011b650:	83 ec 04             	sub    $0x4,%esp
f011b653:	68 b0 5f 13 f0       	push   $0xf0135fb0
f011b658:	6a 2e                	push   $0x2e
f011b65a:	68 97 5f 13 f0       	push   $0xf0135f97
f011b65f:	e8 4b 58 fe ff       	call   f0100eaf <_panic>

f011b664 <get_block_size>:

//===========================
// [2] GET BLOCK SIZE:
//===========================
__inline__ uint32 get_block_size(void *va)
{
f011b664:	55                   	push   %ebp
f011b665:	89 e5                	mov    %esp,%ebp
f011b667:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.GM#1] DYNAMIC ALLOCATOR - #2 get_block_size
	//Your code is here
	//Comment the following line
	panic("get_block_size() Not implemented yet");
f011b66a:	83 ec 04             	sub    $0x4,%esp
f011b66d:	68 e4 5f 13 f0       	push   $0xf0135fe4
f011b672:	6a 3a                	push   $0x3a
f011b674:	68 97 5f 13 f0       	push   $0xf0135f97
f011b679:	e8 31 58 fe ff       	call   f0100eaf <_panic>

f011b67e <alloc_block>:

//===========================
// 3) ALLOCATE BLOCK:
//===========================
void *alloc_block(uint32 size)
{
f011b67e:	55                   	push   %ebp
f011b67f:	89 e5                	mov    %esp,%ebp
f011b681:	83 ec 08             	sub    $0x8,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		assert(size <= DYN_ALLOC_MAX_BLOCK_SIZE);
f011b684:	81 7d 08 00 08 00 00 	cmpl   $0x800,0x8(%ebp)
f011b68b:	76 16                	jbe    f011b6a3 <alloc_block+0x25>
f011b68d:	68 0c 60 13 f0       	push   $0xf013600c
f011b692:	68 82 5f 13 f0       	push   $0xf0135f82
f011b697:	6a 46                	push   $0x46
f011b699:	68 97 5f 13 f0       	push   $0xf0135f97
f011b69e:	e8 0c 58 fe ff       	call   f0100eaf <_panic>
	//==================================================================================
	//==================================================================================
	//TODO: [PROJECT'25.GM#1] DYNAMIC ALLOCATOR - #3 alloc_block
	//Your code is here
	//Comment the following line
	panic("alloc_block() Not implemented yet");
f011b6a3:	83 ec 04             	sub    $0x4,%esp
f011b6a6:	68 30 60 13 f0       	push   $0xf0136030
f011b6ab:	6a 4d                	push   $0x4d
f011b6ad:	68 97 5f 13 f0       	push   $0xf0135f97
f011b6b2:	e8 f8 57 fe ff       	call   f0100eaf <_panic>

f011b6b7 <free_block>:

//===========================
// [4] FREE BLOCK:
//===========================
void free_block(void *va)
{
f011b6b7:	55                   	push   %ebp
f011b6b8:	89 e5                	mov    %esp,%ebp
f011b6ba:	83 ec 08             	sub    $0x8,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		assert((uint32)va >= dynAllocStart && (uint32)va < dynAllocEnd);
f011b6bd:	8b 55 08             	mov    0x8(%ebp),%edx
f011b6c0:	a1 1c 6b 85 f0       	mov    0xf0856b1c,%eax
f011b6c5:	39 c2                	cmp    %eax,%edx
f011b6c7:	72 0c                	jb     f011b6d5 <free_block+0x1e>
f011b6c9:	8b 55 08             	mov    0x8(%ebp),%edx
f011b6cc:	a1 40 e5 83 f0       	mov    0xf083e540,%eax
f011b6d1:	39 c2                	cmp    %eax,%edx
f011b6d3:	72 16                	jb     f011b6eb <free_block+0x34>
f011b6d5:	68 54 60 13 f0       	push   $0xf0136054
f011b6da:	68 82 5f 13 f0       	push   $0xf0135f82
f011b6df:	6a 5b                	push   $0x5b
f011b6e1:	68 97 5f 13 f0       	push   $0xf0135f97
f011b6e6:	e8 c4 57 fe ff       	call   f0100eaf <_panic>
	//==================================================================================

	//TODO: [PROJECT'25.GM#1] DYNAMIC ALLOCATOR - #4 free_block
	//Your code is here
	//Comment the following line
	panic("free_block() Not implemented yet");
f011b6eb:	83 ec 04             	sub    $0x4,%esp
f011b6ee:	68 8c 60 13 f0       	push   $0xf013608c
f011b6f3:	6a 63                	push   $0x63
f011b6f5:	68 97 5f 13 f0       	push   $0xf0135f97
f011b6fa:	e8 b0 57 fe ff       	call   f0100eaf <_panic>

f011b6ff <realloc_block>:

//===========================
// [1] REALLOCATE BLOCK:
//===========================
void *realloc_block(void* va, uint32 new_size)
{
f011b6ff:	55                   	push   %ebp
f011b700:	89 e5                	mov    %esp,%ebp
f011b702:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.BONUS#2] KERNEL REALLOC - realloc_block
	//Your code is here
	//Comment the following line
	panic("realloc_block() Not implemented yet");
f011b705:	83 ec 04             	sub    $0x4,%esp
f011b708:	68 b0 60 13 f0       	push   $0xf01360b0
f011b70d:	6a 72                	push   $0x72
f011b70f:	68 97 5f 13 f0       	push   $0xf0135f97
f011b714:	e8 96 57 fe ff       	call   f0100eaf <_panic>
f011b719:	66 90                	xchg   %ax,%ax
f011b71b:	90                   	nop

f011b71c <__moddi3>:
f011b71c:	55                   	push   %ebp
f011b71d:	57                   	push   %edi
f011b71e:	56                   	push   %esi
f011b71f:	53                   	push   %ebx
f011b720:	83 ec 2c             	sub    $0x2c,%esp
f011b723:	8b 74 24 40          	mov    0x40(%esp),%esi
f011b727:	8b 7c 24 44          	mov    0x44(%esp),%edi
f011b72b:	8b 4c 24 48          	mov    0x48(%esp),%ecx
f011b72f:	8b 5c 24 4c          	mov    0x4c(%esp),%ebx
f011b733:	89 d8                	mov    %ebx,%eax
f011b735:	85 ff                	test   %edi,%edi
f011b737:	0f 88 d3 00 00 00    	js     f011b810 <__moddi3+0xf4>
f011b73d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
f011b744:	00 
f011b745:	85 c0                	test   %eax,%eax
f011b747:	0f 88 ab 00 00 00    	js     f011b7f8 <__moddi3+0xdc>
f011b74d:	89 0c 24             	mov    %ecx,(%esp)
f011b750:	89 5c 24 04          	mov    %ebx,0x4(%esp)
f011b754:	89 74 24 10          	mov    %esi,0x10(%esp)
f011b758:	89 fb                	mov    %edi,%ebx
f011b75a:	8b 14 24             	mov    (%esp),%edx
f011b75d:	8b 4c 24 04          	mov    0x4(%esp),%ecx
f011b761:	89 d0                	mov    %edx,%eax
f011b763:	89 54 24 18          	mov    %edx,0x18(%esp)
f011b767:	89 ca                	mov    %ecx,%edx
f011b769:	8b 0c 24             	mov    (%esp),%ecx
f011b76c:	89 34 24             	mov    %esi,(%esp)
f011b76f:	89 7c 24 14          	mov    %edi,0x14(%esp)
f011b773:	85 d2                	test   %edx,%edx
f011b775:	75 15                	jne    f011b78c <__moddi3+0x70>
f011b777:	89 c7                	mov    %eax,%edi
f011b779:	39 d8                	cmp    %ebx,%eax
f011b77b:	76 5b                	jbe    f011b7d8 <__moddi3+0xbc>
f011b77d:	89 f0                	mov    %esi,%eax
f011b77f:	89 da                	mov    %ebx,%edx
f011b781:	f7 f7                	div    %edi
f011b783:	89 d3                	mov    %edx,%ebx
f011b785:	89 d8                	mov    %ebx,%eax
f011b787:	31 d2                	xor    %edx,%edx
f011b789:	eb 09                	jmp    f011b794 <__moddi3+0x78>
f011b78b:	90                   	nop
f011b78c:	39 fa                	cmp    %edi,%edx
f011b78e:	76 1c                	jbe    f011b7ac <__moddi3+0x90>
f011b790:	89 f0                	mov    %esi,%eax
f011b792:	89 fa                	mov    %edi,%edx
f011b794:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
f011b798:	85 c9                	test   %ecx,%ecx
f011b79a:	74 07                	je     f011b7a3 <__moddi3+0x87>
f011b79c:	f7 d8                	neg    %eax
f011b79e:	83 d2 00             	adc    $0x0,%edx
f011b7a1:	f7 da                	neg    %edx
f011b7a3:	83 c4 2c             	add    $0x2c,%esp
f011b7a6:	5b                   	pop    %ebx
f011b7a7:	5e                   	pop    %esi
f011b7a8:	5f                   	pop    %edi
f011b7a9:	5d                   	pop    %ebp
f011b7aa:	c3                   	ret    
f011b7ab:	90                   	nop
f011b7ac:	0f bd c2             	bsr    %edx,%eax
f011b7af:	83 f0 1f             	xor    $0x1f,%eax
f011b7b2:	89 44 24 1c          	mov    %eax,0x1c(%esp)
f011b7b6:	75 6c                	jne    f011b824 <__moddi3+0x108>
f011b7b8:	39 fa                	cmp    %edi,%edx
f011b7ba:	72 05                	jb     f011b7c1 <__moddi3+0xa5>
f011b7bc:	3b 0c 24             	cmp    (%esp),%ecx
f011b7bf:	77 0e                	ja     f011b7cf <__moddi3+0xb3>
f011b7c1:	8b 34 24             	mov    (%esp),%esi
f011b7c4:	29 ce                	sub    %ecx,%esi
f011b7c6:	19 d3                	sbb    %edx,%ebx
f011b7c8:	89 5c 24 14          	mov    %ebx,0x14(%esp)
f011b7cc:	89 34 24             	mov    %esi,(%esp)
f011b7cf:	8b 04 24             	mov    (%esp),%eax
f011b7d2:	8b 54 24 14          	mov    0x14(%esp),%edx
f011b7d6:	eb bc                	jmp    f011b794 <__moddi3+0x78>
f011b7d8:	85 c9                	test   %ecx,%ecx
f011b7da:	75 0b                	jne    f011b7e7 <__moddi3+0xcb>
f011b7dc:	b8 01 00 00 00       	mov    $0x1,%eax
f011b7e1:	31 d2                	xor    %edx,%edx
f011b7e3:	f7 f1                	div    %ecx
f011b7e5:	89 c1                	mov    %eax,%ecx
f011b7e7:	89 d8                	mov    %ebx,%eax
f011b7e9:	31 d2                	xor    %edx,%edx
f011b7eb:	f7 f1                	div    %ecx
f011b7ed:	8b 04 24             	mov    (%esp),%eax
f011b7f0:	f7 f1                	div    %ecx
f011b7f2:	89 d3                	mov    %edx,%ebx
f011b7f4:	eb 8f                	jmp    f011b785 <__moddi3+0x69>
f011b7f6:	66 90                	xchg   %ax,%ax
f011b7f8:	89 c8                	mov    %ecx,%eax
f011b7fa:	89 da                	mov    %ebx,%edx
f011b7fc:	f7 d8                	neg    %eax
f011b7fe:	83 d2 00             	adc    $0x0,%edx
f011b801:	f7 da                	neg    %edx
f011b803:	89 04 24             	mov    %eax,(%esp)
f011b806:	89 54 24 04          	mov    %edx,0x4(%esp)
f011b80a:	e9 45 ff ff ff       	jmp    f011b754 <__moddi3+0x38>
f011b80f:	90                   	nop
f011b810:	f7 de                	neg    %esi
f011b812:	83 d7 00             	adc    $0x0,%edi
f011b815:	f7 df                	neg    %edi
f011b817:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
f011b81e:	ff 
f011b81f:	e9 21 ff ff ff       	jmp    f011b745 <__moddi3+0x29>
f011b824:	b8 20 00 00 00       	mov    $0x20,%eax
f011b829:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f011b82d:	29 f8                	sub    %edi,%eax
f011b82f:	89 c6                	mov    %eax,%esi
f011b831:	89 44 24 14          	mov    %eax,0x14(%esp)
f011b835:	89 f9                	mov    %edi,%ecx
f011b837:	d3 e2                	shl    %cl,%edx
f011b839:	8b 6c 24 18          	mov    0x18(%esp),%ebp
f011b83d:	89 e8                	mov    %ebp,%eax
f011b83f:	89 f1                	mov    %esi,%ecx
f011b841:	d3 e8                	shr    %cl,%eax
f011b843:	09 d0                	or     %edx,%eax
f011b845:	89 04 24             	mov    %eax,(%esp)
f011b848:	89 ea                	mov    %ebp,%edx
f011b84a:	89 f9                	mov    %edi,%ecx
f011b84c:	d3 e2                	shl    %cl,%edx
f011b84e:	89 d7                	mov    %edx,%edi
f011b850:	89 da                	mov    %ebx,%edx
f011b852:	d3 e2                	shl    %cl,%edx
f011b854:	8b 6c 24 10          	mov    0x10(%esp),%ebp
f011b858:	d3 e5                	shl    %cl,%ebp
f011b85a:	8b 44 24 10          	mov    0x10(%esp),%eax
f011b85e:	89 f1                	mov    %esi,%ecx
f011b860:	d3 e8                	shr    %cl,%eax
f011b862:	09 d0                	or     %edx,%eax
f011b864:	d3 eb                	shr    %cl,%ebx
f011b866:	89 da                	mov    %ebx,%edx
f011b868:	f7 34 24             	divl   (%esp)
f011b86b:	89 d3                	mov    %edx,%ebx
f011b86d:	f7 e7                	mul    %edi
f011b86f:	89 c6                	mov    %eax,%esi
f011b871:	89 d1                	mov    %edx,%ecx
f011b873:	39 d3                	cmp    %edx,%ebx
f011b875:	72 29                	jb     f011b8a0 <__moddi3+0x184>
f011b877:	74 33                	je     f011b8ac <__moddi3+0x190>
f011b879:	89 e8                	mov    %ebp,%eax
f011b87b:	29 f0                	sub    %esi,%eax
f011b87d:	19 cb                	sbb    %ecx,%ebx
f011b87f:	89 de                	mov    %ebx,%esi
f011b881:	8a 4c 24 14          	mov    0x14(%esp),%cl
f011b885:	d3 e6                	shl    %cl,%esi
f011b887:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f011b88b:	89 f9                	mov    %edi,%ecx
f011b88d:	d3 e8                	shr    %cl,%eax
f011b88f:	09 c6                	or     %eax,%esi
f011b891:	89 f0                	mov    %esi,%eax
f011b893:	89 f9                	mov    %edi,%ecx
f011b895:	d3 eb                	shr    %cl,%ebx
f011b897:	89 da                	mov    %ebx,%edx
f011b899:	e9 f6 fe ff ff       	jmp    f011b794 <__moddi3+0x78>
f011b89e:	66 90                	xchg   %ax,%ax
f011b8a0:	29 f8                	sub    %edi,%eax
f011b8a2:	1b 14 24             	sbb    (%esp),%edx
f011b8a5:	89 d1                	mov    %edx,%ecx
f011b8a7:	89 c6                	mov    %eax,%esi
f011b8a9:	eb ce                	jmp    f011b879 <__moddi3+0x15d>
f011b8ab:	90                   	nop
f011b8ac:	39 c5                	cmp    %eax,%ebp
f011b8ae:	72 f0                	jb     f011b8a0 <__moddi3+0x184>
f011b8b0:	89 d9                	mov    %ebx,%ecx
f011b8b2:	eb c5                	jmp    f011b879 <__moddi3+0x15d>

f011b8b4 <__udivdi3>:
f011b8b4:	55                   	push   %ebp
f011b8b5:	57                   	push   %edi
f011b8b6:	56                   	push   %esi
f011b8b7:	53                   	push   %ebx
f011b8b8:	83 ec 1c             	sub    $0x1c,%esp
f011b8bb:	8b 5c 24 30          	mov    0x30(%esp),%ebx
f011b8bf:	8b 4c 24 34          	mov    0x34(%esp),%ecx
f011b8c3:	8b 7c 24 38          	mov    0x38(%esp),%edi
f011b8c7:	89 5c 24 08          	mov    %ebx,0x8(%esp)
f011b8cb:	89 ca                	mov    %ecx,%edx
f011b8cd:	89 f8                	mov    %edi,%eax
f011b8cf:	8b 74 24 3c          	mov    0x3c(%esp),%esi
f011b8d3:	85 f6                	test   %esi,%esi
f011b8d5:	75 2d                	jne    f011b904 <__udivdi3+0x50>
f011b8d7:	39 cf                	cmp    %ecx,%edi
f011b8d9:	77 65                	ja     f011b940 <__udivdi3+0x8c>
f011b8db:	89 fd                	mov    %edi,%ebp
f011b8dd:	85 ff                	test   %edi,%edi
f011b8df:	75 0b                	jne    f011b8ec <__udivdi3+0x38>
f011b8e1:	b8 01 00 00 00       	mov    $0x1,%eax
f011b8e6:	31 d2                	xor    %edx,%edx
f011b8e8:	f7 f7                	div    %edi
f011b8ea:	89 c5                	mov    %eax,%ebp
f011b8ec:	31 d2                	xor    %edx,%edx
f011b8ee:	89 c8                	mov    %ecx,%eax
f011b8f0:	f7 f5                	div    %ebp
f011b8f2:	89 c1                	mov    %eax,%ecx
f011b8f4:	89 d8                	mov    %ebx,%eax
f011b8f6:	f7 f5                	div    %ebp
f011b8f8:	89 cf                	mov    %ecx,%edi
f011b8fa:	89 fa                	mov    %edi,%edx
f011b8fc:	83 c4 1c             	add    $0x1c,%esp
f011b8ff:	5b                   	pop    %ebx
f011b900:	5e                   	pop    %esi
f011b901:	5f                   	pop    %edi
f011b902:	5d                   	pop    %ebp
f011b903:	c3                   	ret    
f011b904:	39 ce                	cmp    %ecx,%esi
f011b906:	77 28                	ja     f011b930 <__udivdi3+0x7c>
f011b908:	0f bd fe             	bsr    %esi,%edi
f011b90b:	83 f7 1f             	xor    $0x1f,%edi
f011b90e:	75 40                	jne    f011b950 <__udivdi3+0x9c>
f011b910:	39 ce                	cmp    %ecx,%esi
f011b912:	72 0a                	jb     f011b91e <__udivdi3+0x6a>
f011b914:	3b 44 24 08          	cmp    0x8(%esp),%eax
f011b918:	0f 87 9e 00 00 00    	ja     f011b9bc <__udivdi3+0x108>
f011b91e:	b8 01 00 00 00       	mov    $0x1,%eax
f011b923:	89 fa                	mov    %edi,%edx
f011b925:	83 c4 1c             	add    $0x1c,%esp
f011b928:	5b                   	pop    %ebx
f011b929:	5e                   	pop    %esi
f011b92a:	5f                   	pop    %edi
f011b92b:	5d                   	pop    %ebp
f011b92c:	c3                   	ret    
f011b92d:	8d 76 00             	lea    0x0(%esi),%esi
f011b930:	31 ff                	xor    %edi,%edi
f011b932:	31 c0                	xor    %eax,%eax
f011b934:	89 fa                	mov    %edi,%edx
f011b936:	83 c4 1c             	add    $0x1c,%esp
f011b939:	5b                   	pop    %ebx
f011b93a:	5e                   	pop    %esi
f011b93b:	5f                   	pop    %edi
f011b93c:	5d                   	pop    %ebp
f011b93d:	c3                   	ret    
f011b93e:	66 90                	xchg   %ax,%ax
f011b940:	89 d8                	mov    %ebx,%eax
f011b942:	f7 f7                	div    %edi
f011b944:	31 ff                	xor    %edi,%edi
f011b946:	89 fa                	mov    %edi,%edx
f011b948:	83 c4 1c             	add    $0x1c,%esp
f011b94b:	5b                   	pop    %ebx
f011b94c:	5e                   	pop    %esi
f011b94d:	5f                   	pop    %edi
f011b94e:	5d                   	pop    %ebp
f011b94f:	c3                   	ret    
f011b950:	bd 20 00 00 00       	mov    $0x20,%ebp
f011b955:	89 eb                	mov    %ebp,%ebx
f011b957:	29 fb                	sub    %edi,%ebx
f011b959:	89 f9                	mov    %edi,%ecx
f011b95b:	d3 e6                	shl    %cl,%esi
f011b95d:	89 c5                	mov    %eax,%ebp
f011b95f:	88 d9                	mov    %bl,%cl
f011b961:	d3 ed                	shr    %cl,%ebp
f011b963:	89 e9                	mov    %ebp,%ecx
f011b965:	09 f1                	or     %esi,%ecx
f011b967:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
f011b96b:	89 f9                	mov    %edi,%ecx
f011b96d:	d3 e0                	shl    %cl,%eax
f011b96f:	89 c5                	mov    %eax,%ebp
f011b971:	89 d6                	mov    %edx,%esi
f011b973:	88 d9                	mov    %bl,%cl
f011b975:	d3 ee                	shr    %cl,%esi
f011b977:	89 f9                	mov    %edi,%ecx
f011b979:	d3 e2                	shl    %cl,%edx
f011b97b:	8b 44 24 08          	mov    0x8(%esp),%eax
f011b97f:	88 d9                	mov    %bl,%cl
f011b981:	d3 e8                	shr    %cl,%eax
f011b983:	09 c2                	or     %eax,%edx
f011b985:	89 d0                	mov    %edx,%eax
f011b987:	89 f2                	mov    %esi,%edx
f011b989:	f7 74 24 0c          	divl   0xc(%esp)
f011b98d:	89 d6                	mov    %edx,%esi
f011b98f:	89 c3                	mov    %eax,%ebx
f011b991:	f7 e5                	mul    %ebp
f011b993:	39 d6                	cmp    %edx,%esi
f011b995:	72 19                	jb     f011b9b0 <__udivdi3+0xfc>
f011b997:	74 0b                	je     f011b9a4 <__udivdi3+0xf0>
f011b999:	89 d8                	mov    %ebx,%eax
f011b99b:	31 ff                	xor    %edi,%edi
f011b99d:	e9 58 ff ff ff       	jmp    f011b8fa <__udivdi3+0x46>
f011b9a2:	66 90                	xchg   %ax,%ax
f011b9a4:	8b 54 24 08          	mov    0x8(%esp),%edx
f011b9a8:	89 f9                	mov    %edi,%ecx
f011b9aa:	d3 e2                	shl    %cl,%edx
f011b9ac:	39 c2                	cmp    %eax,%edx
f011b9ae:	73 e9                	jae    f011b999 <__udivdi3+0xe5>
f011b9b0:	8d 43 ff             	lea    -0x1(%ebx),%eax
f011b9b3:	31 ff                	xor    %edi,%edi
f011b9b5:	e9 40 ff ff ff       	jmp    f011b8fa <__udivdi3+0x46>
f011b9ba:	66 90                	xchg   %ax,%ax
f011b9bc:	31 c0                	xor    %eax,%eax
f011b9be:	e9 37 ff ff ff       	jmp    f011b8fa <__udivdi3+0x46>
f011b9c3:	90                   	nop

f011b9c4 <__umoddi3>:
f011b9c4:	55                   	push   %ebp
f011b9c5:	57                   	push   %edi
f011b9c6:	56                   	push   %esi
f011b9c7:	53                   	push   %ebx
f011b9c8:	83 ec 1c             	sub    $0x1c,%esp
f011b9cb:	8b 4c 24 30          	mov    0x30(%esp),%ecx
f011b9cf:	8b 74 24 34          	mov    0x34(%esp),%esi
f011b9d3:	8b 7c 24 38          	mov    0x38(%esp),%edi
f011b9d7:	8b 44 24 3c          	mov    0x3c(%esp),%eax
f011b9db:	89 44 24 0c          	mov    %eax,0xc(%esp)
f011b9df:	89 4c 24 08          	mov    %ecx,0x8(%esp)
f011b9e3:	89 f3                	mov    %esi,%ebx
f011b9e5:	89 fa                	mov    %edi,%edx
f011b9e7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f011b9eb:	89 34 24             	mov    %esi,(%esp)
f011b9ee:	85 c0                	test   %eax,%eax
f011b9f0:	75 1a                	jne    f011ba0c <__umoddi3+0x48>
f011b9f2:	39 f7                	cmp    %esi,%edi
f011b9f4:	0f 86 a2 00 00 00    	jbe    f011ba9c <__umoddi3+0xd8>
f011b9fa:	89 c8                	mov    %ecx,%eax
f011b9fc:	89 f2                	mov    %esi,%edx
f011b9fe:	f7 f7                	div    %edi
f011ba00:	89 d0                	mov    %edx,%eax
f011ba02:	31 d2                	xor    %edx,%edx
f011ba04:	83 c4 1c             	add    $0x1c,%esp
f011ba07:	5b                   	pop    %ebx
f011ba08:	5e                   	pop    %esi
f011ba09:	5f                   	pop    %edi
f011ba0a:	5d                   	pop    %ebp
f011ba0b:	c3                   	ret    
f011ba0c:	39 f0                	cmp    %esi,%eax
f011ba0e:	0f 87 ac 00 00 00    	ja     f011bac0 <__umoddi3+0xfc>
f011ba14:	0f bd e8             	bsr    %eax,%ebp
f011ba17:	83 f5 1f             	xor    $0x1f,%ebp
f011ba1a:	0f 84 ac 00 00 00    	je     f011bacc <__umoddi3+0x108>
f011ba20:	bf 20 00 00 00       	mov    $0x20,%edi
f011ba25:	29 ef                	sub    %ebp,%edi
f011ba27:	89 fe                	mov    %edi,%esi
f011ba29:	89 7c 24 0c          	mov    %edi,0xc(%esp)
f011ba2d:	89 e9                	mov    %ebp,%ecx
f011ba2f:	d3 e0                	shl    %cl,%eax
f011ba31:	89 d7                	mov    %edx,%edi
f011ba33:	89 f1                	mov    %esi,%ecx
f011ba35:	d3 ef                	shr    %cl,%edi
f011ba37:	09 c7                	or     %eax,%edi
f011ba39:	89 e9                	mov    %ebp,%ecx
f011ba3b:	d3 e2                	shl    %cl,%edx
f011ba3d:	89 14 24             	mov    %edx,(%esp)
f011ba40:	89 d8                	mov    %ebx,%eax
f011ba42:	d3 e0                	shl    %cl,%eax
f011ba44:	89 c2                	mov    %eax,%edx
f011ba46:	8b 44 24 08          	mov    0x8(%esp),%eax
f011ba4a:	d3 e0                	shl    %cl,%eax
f011ba4c:	89 44 24 04          	mov    %eax,0x4(%esp)
f011ba50:	8b 44 24 08          	mov    0x8(%esp),%eax
f011ba54:	89 f1                	mov    %esi,%ecx
f011ba56:	d3 e8                	shr    %cl,%eax
f011ba58:	09 d0                	or     %edx,%eax
f011ba5a:	d3 eb                	shr    %cl,%ebx
f011ba5c:	89 da                	mov    %ebx,%edx
f011ba5e:	f7 f7                	div    %edi
f011ba60:	89 d3                	mov    %edx,%ebx
f011ba62:	f7 24 24             	mull   (%esp)
f011ba65:	89 c6                	mov    %eax,%esi
f011ba67:	89 d1                	mov    %edx,%ecx
f011ba69:	39 d3                	cmp    %edx,%ebx
f011ba6b:	0f 82 87 00 00 00    	jb     f011baf8 <__umoddi3+0x134>
f011ba71:	0f 84 91 00 00 00    	je     f011bb08 <__umoddi3+0x144>
f011ba77:	8b 54 24 04          	mov    0x4(%esp),%edx
f011ba7b:	29 f2                	sub    %esi,%edx
f011ba7d:	19 cb                	sbb    %ecx,%ebx
f011ba7f:	89 d8                	mov    %ebx,%eax
f011ba81:	8a 4c 24 0c          	mov    0xc(%esp),%cl
f011ba85:	d3 e0                	shl    %cl,%eax
f011ba87:	89 e9                	mov    %ebp,%ecx
f011ba89:	d3 ea                	shr    %cl,%edx
f011ba8b:	09 d0                	or     %edx,%eax
f011ba8d:	89 e9                	mov    %ebp,%ecx
f011ba8f:	d3 eb                	shr    %cl,%ebx
f011ba91:	89 da                	mov    %ebx,%edx
f011ba93:	83 c4 1c             	add    $0x1c,%esp
f011ba96:	5b                   	pop    %ebx
f011ba97:	5e                   	pop    %esi
f011ba98:	5f                   	pop    %edi
f011ba99:	5d                   	pop    %ebp
f011ba9a:	c3                   	ret    
f011ba9b:	90                   	nop
f011ba9c:	89 fd                	mov    %edi,%ebp
f011ba9e:	85 ff                	test   %edi,%edi
f011baa0:	75 0b                	jne    f011baad <__umoddi3+0xe9>
f011baa2:	b8 01 00 00 00       	mov    $0x1,%eax
f011baa7:	31 d2                	xor    %edx,%edx
f011baa9:	f7 f7                	div    %edi
f011baab:	89 c5                	mov    %eax,%ebp
f011baad:	89 f0                	mov    %esi,%eax
f011baaf:	31 d2                	xor    %edx,%edx
f011bab1:	f7 f5                	div    %ebp
f011bab3:	89 c8                	mov    %ecx,%eax
f011bab5:	f7 f5                	div    %ebp
f011bab7:	89 d0                	mov    %edx,%eax
f011bab9:	e9 44 ff ff ff       	jmp    f011ba02 <__umoddi3+0x3e>
f011babe:	66 90                	xchg   %ax,%ax
f011bac0:	89 c8                	mov    %ecx,%eax
f011bac2:	89 f2                	mov    %esi,%edx
f011bac4:	83 c4 1c             	add    $0x1c,%esp
f011bac7:	5b                   	pop    %ebx
f011bac8:	5e                   	pop    %esi
f011bac9:	5f                   	pop    %edi
f011baca:	5d                   	pop    %ebp
f011bacb:	c3                   	ret    
f011bacc:	3b 04 24             	cmp    (%esp),%eax
f011bacf:	72 06                	jb     f011bad7 <__umoddi3+0x113>
f011bad1:	3b 7c 24 04          	cmp    0x4(%esp),%edi
f011bad5:	77 0f                	ja     f011bae6 <__umoddi3+0x122>
f011bad7:	89 f2                	mov    %esi,%edx
f011bad9:	29 f9                	sub    %edi,%ecx
f011badb:	1b 54 24 0c          	sbb    0xc(%esp),%edx
f011badf:	89 14 24             	mov    %edx,(%esp)
f011bae2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f011bae6:	8b 44 24 04          	mov    0x4(%esp),%eax
f011baea:	8b 14 24             	mov    (%esp),%edx
f011baed:	83 c4 1c             	add    $0x1c,%esp
f011baf0:	5b                   	pop    %ebx
f011baf1:	5e                   	pop    %esi
f011baf2:	5f                   	pop    %edi
f011baf3:	5d                   	pop    %ebp
f011baf4:	c3                   	ret    
f011baf5:	8d 76 00             	lea    0x0(%esi),%esi
f011baf8:	2b 04 24             	sub    (%esp),%eax
f011bafb:	19 fa                	sbb    %edi,%edx
f011bafd:	89 d1                	mov    %edx,%ecx
f011baff:	89 c6                	mov    %eax,%esi
f011bb01:	e9 71 ff ff ff       	jmp    f011ba77 <__umoddi3+0xb3>
f011bb06:	66 90                	xchg   %ax,%ax
f011bb08:	39 44 24 04          	cmp    %eax,0x4(%esp)
f011bb0c:	72 ea                	jb     f011baf8 <__umoddi3+0x134>
f011bb0e:	89 d9                	mov    %ebx,%ecx
f011bb10:	e9 62 ff ff ff       	jmp    f011ba77 <__umoddi3+0xb3>
